///|
pub struct Env {
  id : Int
  parent : Env?
  bindings : @hashmap.HashMap[String, Value]
  readonly_bindings : @hashmap.HashMap[String, Bool]
  deletable_bindings : @hashmap.HashMap[String, Bool]
  private_bindings : @hashmap.HashMap[String, String]
  mut strict : Bool
  mut with_object : Value?
  mut var_object : Value?
  mut new_target : Value
  mut allow_new_target : Bool
  mut allow_super : Bool
  mut allow_super_call : Bool
  mut this_uninitialized : Bool
  mut is_param_env : Bool
  mut is_catch_env : Bool
  param_binding_names : @hashmap.HashMap[String, Bool]
  uninitialized_bindings : @hashmap.HashMap[String, Bool]
  mut var_env : Env?
}

///|
pub impl Show for Env with output(self, logger) {
  let _ = self
  logger.write_string("Env")
}

///|
pub struct Vm {
  env : Env
  runtime : RuntimeState
} derive(Show)

///|
priv suberror ReturnSignal {
  ReturnSignal(Value)
}

///|
priv suberror BreakSignal {
  BreakSignal((String?, Value?))
}

///|
priv suberror ContinueSignal {
  ContinueSignal((String?, Value?))
}

///|
priv suberror ThrowSignal {
  ThrowSignal(Value)
}

///|
let id_ref : Ref[Int] = Ref::new(1)

///|
let symbol_registry_ref : Ref[Map[String, SymbolValue]] = Ref::new(Map::new())

///|
let symbol_table_ref : Ref[Map[Int, SymbolValue]] = Ref::new(Map::new())

///|
let symbol_iterator_ref : Ref[SymbolValue?] = Ref::new(None)

///|
let symbol_to_string_tag_ref : Ref[SymbolValue?] = Ref::new(None)

///|
let symbol_async_iterator_ref : Ref[SymbolValue?] = Ref::new(None)

///|
let symbol_has_instance_ref : Ref[SymbolValue?] = Ref::new(None)

///|
let symbol_is_concat_spreadable_ref : Ref[SymbolValue?] = Ref::new(None)

///|
let symbol_match_ref : Ref[SymbolValue?] = Ref::new(None)

///|
let symbol_match_all_ref : Ref[SymbolValue?] = Ref::new(None)

///|
let symbol_replace_ref : Ref[SymbolValue?] = Ref::new(None)

///|
let symbol_search_ref : Ref[SymbolValue?] = Ref::new(None)

///|
let symbol_species_ref : Ref[SymbolValue?] = Ref::new(None)

///|
let symbol_split_ref : Ref[SymbolValue?] = Ref::new(None)

///|
let symbol_to_primitive_ref : Ref[SymbolValue?] = Ref::new(None)

///|
let symbol_unscopables_ref : Ref[SymbolValue?] = Ref::new(None)

///|
let throw_type_error_ref : Ref[Map[Int, Value]] = Ref::new(Map::new())

///|
let template_registry_ref : Ref[Map[Int, Map[Int, Value]]] = Ref::new(
  Map::new(),
)

///|
let annex_b_var_func_decls_ref : Ref[Array[@hashmap.HashMap[Int, Bool]]] = Ref::new([],
)

///|
let top_level_func_decls_ref : Ref[Array[@hashmap.HashMap[Int, Bool]]] = Ref::new([],
)

///|
let js_string_len_max : Int = (1 << 30) - 1

///|
let object_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let function_proto_ref : Ref[Value?] = Ref::new(None)

///|
let array_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let array_buffer_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let shared_array_buffer_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let dataview_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let typed_array_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let uint8_array_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let int8_array_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let uint8_clamped_array_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let uint16_array_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let int16_array_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let uint32_array_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let int32_array_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let bigint64_array_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let biguint64_array_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let float16_array_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let float32_array_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let float64_array_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let string_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let bool_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let number_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let bigint_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let symbol_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let regexp_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let date_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let generator_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let generator_function_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let async_function_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let generator_function_ctor_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let async_generator_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let async_generator_function_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let async_generator_function_ctor_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let iterator_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let async_iterator_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let async_from_sync_iterator_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let generator_proto_env_ref : Ref[Map[Int, ObjectValue]] = Ref::new(Map::new())

///|
let async_generator_proto_env_ref : Ref[Map[Int, ObjectValue]] = Ref::new(
  Map::new(),
)

///|
let generator_function_ctor_env_ref : Ref[Map[Int, BuiltinValue]] = Ref::new(
  Map::new(),
)

///|
let async_generator_function_ctor_env_ref : Ref[Map[Int, BuiltinValue]] = Ref::new(
  Map::new(),
)

///|
let async_function_ctor_env_ref : Ref[Map[Int, BuiltinValue]] = Ref::new(
  Map::new(),
)

///|
let promise_ctor_env_ref : Ref[Map[Int, BuiltinValue]] = Ref::new(Map::new())

///|
let async_iterator_proto_env_ref : Ref[Map[Int, ObjectValue]] = Ref::new(
  Map::new(),
)

///|
let iterator_concat_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let iterator_helper_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let iterator_wrap_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let array_iterator_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let string_iterator_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let regexp_string_iterator_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let map_iterator_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let set_iterator_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let map_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let set_proto_ref_cell : Ref[ObjectValue?] = Ref::new(None)

///|
let weakmap_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let weakset_proto_ref_cell : Ref[ObjectValue?] = Ref::new(None)

///|
let weakref_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let finreg_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let promise_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let error_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let aggregate_error_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let eval_error_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let syntax_error_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let range_error_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let type_error_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let reference_error_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let uri_error_proto_ref : Ref[ObjectValue?] = Ref::new(None)

///|
let max_array_index : Int64 = 4294967294

///|
let max_array_length : Int64 = max_array_index + 1L

///|
let symbol_prop_prefix : String = "@@sym:"

///|
let private_prop_prefix : String = "@@priv:"

///|
let root_env_ref : Ref[Env?] = Ref::new(None)

///|
let env_stack_ref : Ref[Array[Env]] = Ref::new([])

///|
let source_stack_ref : Ref[Array[String]] = Ref::new([])

///|
let expr_pos_stack_ref : Ref[Array[Int]] = Ref::new([])

///|
let source_path_stack_ref : Ref[Array[String]] = Ref::new([])

///|
let math_rand_state_ref : Ref[UInt64] = Ref::new(0x6a09e667f3bcc909UL)

///|
let current_function_stack_ref : Ref[Array[FunctionValue]] = Ref::new([])

///|
let current_generator_data_ref : Ref[GeneratorData?] = Ref::new(None)

///|
let max_call_depth : Int = 1000

///|
priv struct TimerEntry {
  id : Int
  callback : Value
  delay_ms : Int64
}

///|
priv enum PromiseState {
  Pending
  Fulfilled
  Rejected
}

///|
priv struct PromiseReaction {
  resolve : Value
  reject : Value
  handler : Value
}

///|
priv struct PromiseData {
  mut state : PromiseState
  mut value : Value
  mut fulfill_reactions : Array[PromiseReaction]
  mut reject_reactions : Array[PromiseReaction]
  mut is_handled : Bool
}

///|
let promise_table_ref : Ref[Map[Int, PromiseData]] = Ref::new(Map::new())

///|
priv struct PromiseResolveShared {
  mut already_resolved : Bool
}

///|
priv struct PromiseResolveFunctionData {
  promise : Value
  shared : PromiseResolveShared
  is_reject : Bool
}

///|
let promise_resolve_func_data_ref : Ref[Map[Int, PromiseResolveFunctionData]] = Ref::new(
  Map::new(),
)

///|
priv struct PromiseExecutorData {
  mut resolve : Value?
  mut reject : Value?
}

///|
let promise_executor_data_ref : Ref[Map[Int, PromiseExecutorData]] = Ref::new(
  Map::new(),
)

///|
priv struct PromiseAllRemaining {
  mut count : Int
}

///|
priv struct PromiseAllElementShared {
  mut already_called : Bool
}

///|
priv struct PromiseAllElementData {
  shared : PromiseAllElementShared
  index : Int
  values : Value
  result_resolve : Value
  remaining : PromiseAllRemaining
  mode : Int
  is_reject : Bool
}

///|
let promise_all_element_data_ref : Ref[Map[Int, PromiseAllElementData]] = Ref::new(
  Map::new(),
)

///|
priv struct PromiseThenFinallyData {
  ctor : Value
  on_finally : Value
  is_reject : Bool
}

///|
let promise_then_finally_data_ref : Ref[Map[Int, PromiseThenFinallyData]] = Ref::new(
  Map::new(),
)

///|
priv struct AsyncFromSyncIteratorUnwrapData {
  done : Bool
}

///|
let async_from_sync_unwrap_data_ref : Ref[
  Map[Int, AsyncFromSyncIteratorUnwrapData],
] = Ref::new(Map::new())

///|
priv struct AsyncFromSyncIteratorCloseWrapData {
  sync_iter : Value
}

///|
let async_from_sync_close_wrap_data_ref : Ref[
  Map[Int, AsyncFromSyncIteratorCloseWrapData],
] = Ref::new(Map::new())

///|
priv struct AsyncGeneratorResolveFunctionData {
  generator : Value
  resume_next : Bool
  is_reject : Bool
}

///|
let async_generator_resolve_func_data_ref : Ref[
  Map[Int, AsyncGeneratorResolveFunctionData],
] = Ref::new(Map::new())

///|
priv struct AsyncFunctionResolveFunctionData {
  generator : Value
  is_reject : Bool
}

///|
let async_function_resolve_func_data_ref : Ref[
  Map[Int, AsyncFunctionResolveFunctionData],
] = Ref::new(Map::new())

///|
priv struct AsyncFunctionData {
  resolve : Value
  reject : Value
}

///|
let async_function_data_ref : Ref[Map[Int, AsyncFunctionData]] = Ref::new(
  Map::new(),
)

///|
let promise_finally_value_data_ref : Ref[Map[Int, Value]] = Ref::new(Map::new())

///|
priv struct JobEntry {
  func : Value
  args : Array[Value]
  env : Env?
}

///|
let job_queue_ref : Ref[Array[JobEntry]] = Ref::new([])

///|
let timer_queue_ref : Ref[Array[TimerEntry]] = Ref::new([])

///|
let next_timer_id_ref : Ref[Int] = Ref::new(1)

///|
priv struct WorkerState {
  id : Int
  env : Env
  worker_obj : ObjectValue
  parent_obj : ObjectValue
  mut queue_to_main : Array[Value]
  mut queue_to_worker : Array[Value]
}

///|
priv struct Test262AgentState {
  id : Int
  env : Env
  mut broadcast_callback : Value?
}

///|
priv struct AgentLockEntry {
  buffer_id : Int
  byte_index : Int
  is_bigint : Bool
}

///|
enum AtomicsWaitStatus {
  Waiting
  Ok
  TimedOut
} derive(Eq)

///|
priv struct AtomicsWaiter {
  id : Int
  buffer_id : Int
  byte_index : Int
  status : AtomicsWaitStatus
  start_time : Int64
  deadline : Int64?
}

///|
priv struct AgentReportEntry {
  message : String
  waiter_ids : Array[Int]
}

///|
priv enum ModuleState {
  Loading
  Loaded
}

///|
priv enum ModuleEvalStatus {
  NotEvaluated
  Evaluating
  EvaluatingAsync
  Evaluated
}

///|
priv struct ModuleRecord {
  exports : ObjectValue
  state : ModuleState
  module_ns : ObjectValue?
  meta_obj : ObjectValue?
  eval_promise : Value?
}

///|
priv struct ModuleEvalInfo {
  script : @engine.Script
  env_id : Int
  deps : Array[String]
  has_tla : Bool
  mut status : ModuleEvalStatus
  mut dfs_index : Int
  mut dfs_ancestor_index : Int
  mut pending_async_deps : Int
  async_parents : Array[String]
  mut async_timestamp : Int64
  mut async_evaluation : Bool
  mut cycle_root : String?
  mut eval_has_exception : Bool
  mut eval_exception : Value?
  mut resolve : Value?
  mut reject : Value?
}

///|
priv struct ModuleExportInfo {
  local_exports : Map[String, String]
  indirect_exports : Map[String, (String, String)]
  star_exports : Array[String]
}

///|
priv struct ModuleResolveExportResult {
  status : Int
  path : String?
  local_name : String?
}

///|
priv struct ModuleImportDynamicJobData {
  resolve : Value
  reject : Value
  specifier : String
  attributes : Value
  base_path : String?
}

///|
let worker_table_ref : Ref[Map[Int, WorkerState]] = Ref::new(Map::new())

///|
let next_worker_id_ref : Ref[Int] = Ref::new(1)

///|
let agent_table_ref : Ref[Map[Int, Test262AgentState]] = Ref::new(Map::new())

///|
let agent_report_queue_ref : Ref[Array[AgentReportEntry]] = Ref::new([])

///|
let agent_lock_queue_ref : Ref[Array[AgentLockEntry]] = Ref::new([])

///|
let agent_spin_load_ref : Ref[Map[String, Int]] = Ref::new(Map::new())

///|
let next_agent_id_ref : Ref[Int] = Ref::new(1)

///|
let current_agent_id_ref : Ref[Int?] = Ref::new(None)

///|
let agent_clock_ref : Ref[Int64] = Ref::new(0)

///|
let atomics_waiter_table_ref : Ref[Map[Int, AtomicsWaiter]] = Ref::new(
  Map::new(),
)

///|
let atomics_waiter_list_ref : Ref[Array[Int]] = Ref::new([])

///|
let atomics_waiter_next_id_ref : Ref[Int] = Ref::new(1)

///|
let atomics_waiter_stack_ref : Ref[Map[Int, Array[Int]]] = Ref::new(Map::new())

///|
let atomics_notify_time_ref : Ref[Map[Int, Int64]] = Ref::new(Map::new())

///|
let atomics_waiter_token_prefix = "\u{00}atomics_waiter:"

///|
let module_table_ref : Ref[Map[String, ModuleRecord]] = Ref::new(Map::new())

///|
let module_exports_stack_ref : Ref[Array[ObjectValue]] = Ref::new([])

///|
let yield_star_raw_ref : Ref[Bool] = Ref::new(false)

///|
let module_export_info_ref : Ref[Map[String, ModuleExportInfo]] = Ref::new(
  Map::new(),
)

///|
let module_eval_info_ref : Ref[Map[String, ModuleEvalInfo]] = Ref::new(
  Map::new(),
)

///|
let module_async_eval_timestamp_ref : Ref[Int64] = Ref::new(1)

///|
let module_async_callback_data_ref : Ref[Map[Int, String]] = Ref::new(
  Map::new(),
)

///|
let module_import_dynamic_job_data_ref : Ref[
  Map[Int, ModuleImportDynamicJobData],
] = Ref::new(Map::new())

///|
let module_builtin_namespace_ref : Ref[Map[Int, Map[String, ObjectValue]]] = Ref::new(
  Map::new(),
)

///|
let module_env_stack_ref : Ref[Array[Int]] = Ref::new([])

///|
let module_import_stack_ref : Ref[Array[Array[String]]] = Ref::new([])

///|
let module_env_exports_ref : Ref[Map[Int, ObjectValue]] = Ref::new(Map::new())

///|
let module_env_exports_by_obj_ref : Ref[Map[Int, Int]] = Ref::new(Map::new())

///|
let module_env_export_names_ref : Ref[Map[Int, Map[String, Array[String]]]] = Ref::new(
  Map::new(),
)

///|
let module_env_export_uninitialized_ref : Ref[Map[Int, Map[String, Bool]]] = Ref::new(
  Map::new(),
)

///|
let module_env_ref : Ref[Map[Int, Env]] = Ref::new(Map::new())

///|
fn alloc_id() -> Int {
  let mut id = 0
  id_ref.update(fn(current) {
    id = current
    current + 1
  })
  id
}

///|
fn alloc_symbol_id() -> Int {
  alloc_id()
}

///|
fn symbol_registry_get(key : String) -> SymbolValue? {
  let mut result : SymbolValue? = None
  symbol_registry_ref.update(fn(current) {
    result = current.get(key)
    current
  })
  result
}

///|
fn symbol_registry_set(key : String, symbol : SymbolValue) -> Unit {
  symbol_registry_ref.update(fn(current) {
    current.set(key, symbol)
    current
  })
}

///|
fn register_symbol(symbol : SymbolValue) -> Unit {
  symbol_table_ref.update(fn(current) {
    current.set(symbol.id, symbol)
    current
  })
  register_value(Symbol(symbol))
}

///|
fn symbol_prop_key(symbol : SymbolValue) -> String {
  symbol_prop_prefix + Int::to_string(symbol.id)
}

///|
fn is_symbol_prop_key(name : String) -> Bool {
  name.has_prefix(symbol_prop_prefix)
}

///|
fn private_prop_key(id : Int) -> String {
  private_prop_prefix + Int::to_string(id)
}

///|
fn is_private_prop_key(name : String) -> Bool {
  name.has_prefix(private_prop_prefix)
}

///|
fn symbol_from_prop_key(name : String) -> SymbolValue? {
  if !is_symbol_prop_key(name) {
    return None
  }
  let id_text = name.unsafe_substring(
    start=symbol_prop_prefix.length(),
    end=name.length(),
  )
  try {
    let id = @strconv.parse_int(id_text, base=10)
    let mut value : SymbolValue? = None
    symbol_table_ref.update(fn(current) {
      value = current.get(id)
      current
    })
    value
  } catch {
    _ => None
  }
}

///|
fn symbol_key_from_ref(cell : Ref[SymbolValue?]) -> String? {
  let mut value : SymbolValue? = None
  cell.update(fn(current) {
    value = current
    current
  })
  match value {
    Some(symbol) => Some(symbol_prop_key(symbol))
    None => None
  }
}

///|
fn symbol_iterator_key() -> String? {
  symbol_key_from_ref(symbol_iterator_ref)
}

///|
fn symbol_to_string_tag_key() -> String? {
  symbol_key_from_ref(symbol_to_string_tag_ref)
}

///|
fn symbol_async_iterator_key() -> String? {
  symbol_key_from_ref(symbol_async_iterator_ref)
}

///|
fn symbol_has_instance_key() -> String? {
  symbol_key_from_ref(symbol_has_instance_ref)
}

///|
fn symbol_is_concat_spreadable_key() -> String? {
  symbol_key_from_ref(symbol_is_concat_spreadable_ref)
}

///|
fn symbol_match_key() -> String? {
  symbol_key_from_ref(symbol_match_ref)
}

///|
fn symbol_match_all_key() -> String? {
  symbol_key_from_ref(symbol_match_all_ref)
}

///|
fn symbol_replace_key() -> String? {
  symbol_key_from_ref(symbol_replace_ref)
}

///|
fn symbol_search_key() -> String? {
  symbol_key_from_ref(symbol_search_ref)
}

///|
fn symbol_species_key() -> String? {
  symbol_key_from_ref(symbol_species_ref)
}

///|
fn symbol_split_key() -> String? {
  symbol_key_from_ref(symbol_split_ref)
}

///|
fn symbol_to_primitive_key() -> String? {
  symbol_key_from_ref(symbol_to_primitive_ref)
}

///|
fn symbol_unscopables_key() -> String? {
  symbol_key_from_ref(symbol_unscopables_ref)
}

///|
fn symbol_to_string(symbol : SymbolValue) -> String {
  match symbol.description {
    Some(desc) => "Symbol(" + desc + ")"
    None => "Symbol()"
  }
}

///|
fn symbol_from_value(value : Value) -> SymbolValue? {
  match value {
    Symbol(symbol) => Some(symbol)
    Object(obj) => obj.symbol_data
    _ => None
  }
}

///|
fn is_symbol_like(value : Value) -> Bool {
  symbol_from_value(value) is Some(_)
}

///|
fn set_proto_ref(cell : Ref[ObjectValue?], value : ObjectValue?) -> Unit {
  cell.update(fn(_) { value })
}

///|
fn get_proto_ref(cell : Ref[ObjectValue?]) -> ObjectValue? {
  let mut value : ObjectValue? = None
  cell.update(fn(current) {
    value = current
    current
  })
  value
}

///|
fn set_value_ref(cell : Ref[Value?], value : Value?) -> Unit {
  cell.update(fn(_) { value })
}

///|
fn get_value_ref(cell : Ref[Value?]) -> Value? {
  let mut value : Value? = None
  cell.update(fn(current) {
    value = current
    current
  })
  value
}

///|
fn realm_env_from_env(env : Env) -> Env {
  match env.parent {
    Some(parent) => realm_env_from_env(parent)
    None => env
  }
}

///|
fn new_throw_type_error_value_for_env(env : Env) -> Value {
  let props = Map::new()
  props.set("length", property_data_const(Number(Double::from_int(0))))
  props.set("name", property_data_const(String("")))
  let proto = match function_proto_for_env(env) {
    Some(value) => Some(value)
    None => function_proto()
  }
  let builtin = register_builtin_value(BuiltinValue::{
    kind: BuiltinFunction::ThrowTypeError,
    id: alloc_id(),
    props,
    this_value: None,
    proto,
    extensible: false,
    is_html_dda: false,
    realm_env: Some(env),
  })
  Builtin(builtin)
}

///|
fn throw_type_error_value_for_env(env : Env) -> Value {
  let realm_env = realm_env_from_env(env)
  let mut value : Value? = None
  throw_type_error_ref.update(fn(table) {
    value = table.get(realm_env.id)
    table
  })
  match value {
    Some(existing) => existing
    None => {
      let created = new_throw_type_error_value_for_env(realm_env)
      throw_type_error_ref.update(fn(table) {
        table.set(realm_env.id, created)
        table
      })
      created
    }
  }
}

///|
fn template_registry_for_env(env : Env) -> Map[Int, Value] {
  let realm_env = realm_env_from_env(env)
  let mut registry : Map[Int, Value]? = None
  template_registry_ref.update(fn(table) {
    registry = table.get(realm_env.id)
    table
  })
  match registry {
    Some(existing) => existing
    None => {
      let created = Map::new()
      template_registry_ref.update(fn(table) {
        table.set(realm_env.id, created)
        table
      })
      created
    }
  }
}

///|
fn value_from_object(obj : ObjectValue?) -> Value? {
  match obj {
    Some(value) => Some(Object(value))
    None => None
  }
}

///|
fn set_root_env(env : Env) -> Unit {
  root_env_ref.update(fn(_) { Some(env) })
}

///|
fn root_env() -> Env? {
  let mut value : Env? = None
  root_env_ref.update(fn(current) {
    value = current
    current
  })
  value
}

///|
fn with_root_env(env : Env, f : () -> Value raise) -> Value raise {
  let prev = root_env()
  set_root_env(env)
  try f() catch {
    err => {
      match prev {
        Some(prev_env) => set_root_env(prev_env)
        None => ()
      }
      raise err
    }
  } noraise {
    result => {
      match prev {
        Some(prev_env) => set_root_env(prev_env)
        None => ()
      }
      result
    }
  }
}

///|
fn clone_root_env() -> Env {
  match root_env() {
    Some(env) => {
      let cloned = Env::{
        id: alloc_id(),
        parent: None,
        bindings: env.bindings.copy(),
        readonly_bindings: env.readonly_bindings.copy(),
        deletable_bindings: env.deletable_bindings.copy(),
        private_bindings: env.private_bindings.copy(),
        strict: env.strict,
        with_object: None,
        var_object: None,
        new_target: Undefined,
        allow_new_target: false,
        allow_super: false,
        allow_super_call: false,
        this_uninitialized: false,
        is_param_env: false,
        is_catch_env: false,
        param_binding_names: @hashmap.new(),
        uninitialized_bindings: @hashmap.new(),
        var_env: None,
      }
      register_env(cloned)
      cloned
    }
    None => Env::new(None)
  }
}

///|
fn record_print_line(line : String) -> Unit {
  print_log_ref().update(fn(log) {
    log.push(line)
    log
  })
  async_done_ref().update(fn(current) {
    if line == "Test262:AsyncTestComplete" {
      current + 1
    } else if line.has_prefix("Test262:AsyncTestFailure") {
      2
    } else {
      current
    }
  })
}

///|
pub fn take_print_log() -> Array[String] {
  let mut out : Array[String] = []
  print_log_ref().update(fn(log) {
    out = log
    []
  })
  out
}

///|
pub fn async_done_count() -> Int {
  let mut value = 0
  async_done_ref().update(fn(current) {
    value = current
    current
  })
  value
}

///|
fn current_agent_id() -> Int? {
  let mut value : Int? = None
  current_agent_id_ref.update(fn(current) {
    value = current
    current
  })
  value
}

///|
fn with_agent_id(id : Int?, f : () -> Value raise) -> Value raise {
  let prev = current_agent_id()
  current_agent_id_ref.update(fn(_) { id })
  try f() catch {
    err => {
      current_agent_id_ref.update(fn(_) { prev })
      raise err
    }
  } noraise {
    result => {
      current_agent_id_ref.update(fn(_) { prev })
      result
    }
  }
}

///|
fn next_agent_id() -> Int {
  let mut value : Int = 0
  next_agent_id_ref.update(fn(current) {
    value = current
    current + 1
  })
  value
}

///|
fn agent_table_snapshot() -> Array[Test262AgentState] {
  let items : Array[Test262AgentState] = []
  agent_table_ref.update(fn(table) {
    for _, state in table {
      items.push(state)
    }
    table
  })
  items
}

///|
fn agent_state_get(id : Int) -> Test262AgentState? {
  let mut value : Test262AgentState? = None
  agent_table_ref.update(fn(table) {
    value = table.get(id)
    table
  })
  value
}

///|
fn agent_state_set(state : Test262AgentState) -> Unit {
  agent_table_ref.update(fn(table) {
    table.set(state.id, state)
    table
  })
}

///|
fn agent_lock_enqueue(
  buffer_id : Int,
  byte_index : Int,
  is_bigint : Bool,
) -> Unit {
  // Track agent spin-lock acquisitions for test262's single-threaded harness.
  let entry = AgentLockEntry::{ buffer_id, byte_index, is_bigint }
  agent_lock_queue_ref.update(fn(queue) {
    queue.push(entry)
    queue
  })
}

///|
fn agent_lock_has_pending(
  buffer_id : Int,
  byte_index : Int,
  is_bigint : Bool,
) -> Bool {
  let mut found = false
  agent_lock_queue_ref.update(fn(queue) {
    for entry in queue {
      if entry.buffer_id == buffer_id &&
        entry.byte_index == byte_index &&
        entry.is_bigint == is_bigint {
        found = true
        break
      }
    }
    queue
  })
  found
}

///|
fn agent_lock_pop(buffer_id : Int, byte_index : Int, is_bigint : Bool) -> Unit {
  agent_lock_queue_ref.update(fn(queue) {
    let next : Array[AgentLockEntry] = []
    let mut removed = false
    for entry in queue {
      if !removed &&
        entry.buffer_id == buffer_id &&
        entry.byte_index == byte_index &&
        entry.is_bigint == is_bigint {
        removed = true
      } else {
        next.push(entry)
      }
    }
    next
  })
}

///|
fn agent_spin_key(agent_id : Int, buffer_id : Int, byte_index : Int) -> String {
  Int::to_string(agent_id) +
  ":" +
  Int::to_string(buffer_id) +
  ":" +
  Int::to_string(byte_index)
}

///|
fn agent_spin_should_release(
  agent_id : Int,
  buffer_id : Int,
  byte_index : Int,
) -> Bool {
  // Let agent spin loops on Atomics.load exit without real concurrency.
  let key = agent_spin_key(agent_id, buffer_id, byte_index)
  let mut release = false
  agent_spin_load_ref.update(fn(table) {
    let count = match table.get(key) {
      Some(value) => value
      None => 0
    }
    if count >= 1 {
      release = true
      let _ = table.remove(key)

    } else {
      table.set(key, count + 1)
    }
    table
  })
  release
}

///|
fn agent_spin_clear(agent_id : Int, buffer_id : Int, byte_index : Int) -> Unit {
  let key = agent_spin_key(agent_id, buffer_id, byte_index)
  agent_spin_load_ref.update(fn(table) {
    let _ = table.remove(key)
    table
  })
}

///|
fn atomics_next_waiter_id() -> Int {
  let mut id = 0
  atomics_waiter_next_id_ref.update(fn(current) {
    id = current
    current + 1
  })
  id
}

///|
fn atomics_waiter_set(waiter : AtomicsWaiter) -> Unit {
  atomics_waiter_table_ref.update(fn(table) {
    table.set(waiter.id, waiter)
    table
  })
}

///|
fn atomics_waiter_get(id : Int) -> AtomicsWaiter? {
  let mut value : AtomicsWaiter? = None
  atomics_waiter_table_ref.update(fn(table) {
    value = table.get(id)
    table
  })
  value
}

///|
fn atomics_waiter_add(waiter : AtomicsWaiter) -> Unit {
  atomics_waiter_table_ref.update(fn(table) {
    table.set(waiter.id, waiter)
    table
  })
  atomics_waiter_list_ref.update(fn(list) {
    list.push(waiter.id)
    list
  })
}

///|
fn atomics_waiter_update_status(id : Int, status : AtomicsWaitStatus) -> Unit {
  match atomics_waiter_get(id) {
    Some(waiter) => {
      let updated = AtomicsWaiter::{
        id: waiter.id,
        buffer_id: waiter.buffer_id,
        byte_index: waiter.byte_index,
        status,
        start_time: waiter.start_time,
        deadline: waiter.deadline,
      }
      atomics_waiter_set(updated)
    }
    None => ()
  }
}

///|
fn atomics_update_waiter_timeouts(now : Int64) -> Unit {
  atomics_waiter_table_ref.update(fn(table) {
    for id, waiter in table {
      match waiter.status {
        AtomicsWaitStatus::Waiting =>
          match waiter.deadline {
            Some(deadline) =>
              if now >= deadline {
                table.set(id, AtomicsWaiter::{
                  id: waiter.id,
                  buffer_id: waiter.buffer_id,
                  byte_index: waiter.byte_index,
                  status: AtomicsWaitStatus::TimedOut,
                  start_time: waiter.start_time,
                  deadline: waiter.deadline,
                })
              }
            None => ()
          }
        _ => ()
      }
    }
    table
  })
}

///|
fn atomics_record_notify_time(buffer_id : Int, now : Int64) -> Unit {
  atomics_notify_time_ref.update(fn(table) {
    table.set(buffer_id, now)
    table
  })
}

///|
fn atomics_agent_push_waiter(agent_id : Int, waiter_id : Int) -> Unit {
  atomics_waiter_stack_ref.update(fn(table) {
    let stack = match table.get(agent_id) {
      Some(existing) => existing
      None => []
    }
    let next = stack
    next.push(waiter_id)
    table.set(agent_id, next)
    table
  })
}

///|
fn atomics_agent_last_waiter(agent_id : Int) -> Int? {
  let mut value : Int? = None
  atomics_waiter_stack_ref.update(fn(table) {
    match table.get(agent_id) {
      Some(stack) =>
        if !stack.is_empty() {
          value = Some(stack[stack.length() - 1])
        }
      None => ()
    }
    table
  })
  value
}

///|
fn atomics_waiter_status_string(id : Int, now : Int64) -> String {
  atomics_update_waiter_timeouts(now)
  match atomics_waiter_get(id) {
    Some(waiter) =>
      match waiter.status {
        AtomicsWaitStatus::Ok => "ok"
        AtomicsWaitStatus::TimedOut => "timed-out"
        AtomicsWaitStatus::Waiting => "timed-out"
      }
    None => "timed-out"
  }
}

///|
fn atomics_collect_waiter_ids(message : String) -> Array[Int] {
  let ids : Array[Int] = []
  let prefix = atomics_waiter_token_prefix
  let prefix_len = prefix.length()
  let len = message.length()
  let mut i = 0
  let zero = Char::to_int('0')
  let nine = Char::to_int('9')
  while i + prefix_len <= len {
    let slice = message.unsafe_substring(start=i, end=i + prefix_len)
    if slice == prefix {
      let mut j = i + prefix_len
      let mut id = 0
      let mut has_digit = false
      while j < len {
        let code = UInt16::to_int(message.code_unit_at(j))
        if code >= zero && code <= nine {
          id = id * 10 + (code - zero)
          has_digit = true
          j = j + 1
        } else {
          break
        }
      }
      if has_digit {
        ids.push(id)
      }
      i = j
    } else {
      i = i + 1
    }
  }
  ids
}

///|
fn replace_once(text : String, from : String, to : String) -> String {
  match text.find(from) {
    Some(idx) => {
      let before = text.unsafe_substring(start=0, end=idx)
      let after = text.unsafe_substring(
        start=idx + from.length(),
        end=text.length(),
      )
      before + to + after
    }
    None => text
  }
}

///|
fn atomics_should_report_timeout_after(waiter_id : Int) -> Bool {
  match atomics_waiter_get(waiter_id) {
    Some(waiter) => {
      let mut notify_time : Int64? = None
      atomics_notify_time_ref.update(fn(table) {
        notify_time = table.get(waiter.buffer_id)
        table
      })
      match notify_time {
        Some(time) =>
          match waiter.deadline {
            Some(deadline) => time >= waiter.start_time && time <= deadline
            None => time >= waiter.start_time
          }
        None => false
      }
    }
    None => false
  }
}

///|
fn atomics_resolve_message(
  message : String,
  waiter_ids : Array[Int],
  now : Int64,
) -> String {
  let prefix = atomics_waiter_token_prefix
  let prefix_len = prefix.length()
  let len = message.length()
  let sb = StringBuilder::new()
  let mut i = 0
  let zero = Char::to_int('0')
  let nine = Char::to_int('9')
  while i < len {
    if i + prefix_len <= len &&
      message.unsafe_substring(start=i, end=i + prefix_len) == prefix {
      let mut j = i + prefix_len
      let mut id = 0
      let mut has_digit = false
      while j < len {
        let code = UInt16::to_int(message.code_unit_at(j))
        if code >= zero && code <= nine {
          id = id * 10 + (code - zero)
          has_digit = true
          j = j + 1
        } else {
          break
        }
      }
      if has_digit {
        sb.write_string(atomics_waiter_status_string(id, now))
        i = j
      } else {
        sb.write_string(prefix)
        i = i + prefix_len
      }
    } else {
      sb.write_string(message.unsafe_substring(start=i, end=i + 1))
      i = i + 1
    }
  }
  let mut resolved = sb.to_string()
  if !waiter_ids.is_empty() {
    let wants_after = atomics_should_report_timeout_after(waiter_ids[0])
    if wants_after {
      resolved = replace_once(
        resolved, "timeout before Atomics.notify", "timeout after Atomics.notify",
      )
    } else {
      resolved = replace_once(
        resolved, "timeout after Atomics.notify", "timeout before Atomics.notify",
      )
    }
  }
  resolved
}

///|
fn agent_report_push(message : String, waiter_ids : Array[Int]) -> Unit {
  let entry = AgentReportEntry::{ message, waiter_ids }
  agent_report_queue_ref.update(fn(queue) {
    queue.push(entry)
    queue
  })
}

///|
fn agent_report_pop() -> String? {
  let mut result : String? = None
  agent_report_queue_ref.update(fn(queue) {
    let now = agent_clock_now()
    atomics_update_waiter_timeouts(now)
    let mut ready_index = -1
    let mut resolved : String? = None
    let mut i = 0
    while i < queue.length() {
      let entry = queue[i]
      let mut waiting = false
      for id in entry.waiter_ids {
        match atomics_waiter_get(id) {
          Some(waiter) =>
            if waiter.status == AtomicsWaitStatus::Waiting {
              waiting = true
            }
          None => ()
        }
        if waiting {
          break
        }
      }
      if !waiting {
        ready_index = i
        resolved = Some(
          atomics_resolve_message(entry.message, entry.waiter_ids, now),
        )
        break
      }
      i = i + 1
    }
    if ready_index >= 0 {
      result = resolved
      let rest : Array[AgentReportEntry] = []
      let mut j = 0
      while j < queue.length() {
        if j != ready_index {
          rest.push(queue[j])
        }
        j = j + 1
      }
      return rest
    }
    queue
  })
  result
}

///|
fn agent_clock_now() -> Int64 {
  let mut value : Int64 = 0
  agent_clock_ref.update(fn(current) {
    value = current
    current
  })
  value
}

///|
fn agent_clock_advance(delta_ms : Int64) -> Int64 {
  let mut value : Int64 = 0
  agent_clock_ref.update(fn(current) {
    let next = current + delta_ms
    value = next
    next
  })
  atomics_update_waiter_timeouts(value)
  value
}

///|
fn push_env(env : Env) -> Unit {
  env_stack_ref.update(fn(stack) {
    stack.push(env)
    stack
  })
}

///|
fn pop_env() -> Unit {
  env_stack_ref.update(fn(stack) {
    let _ = stack.pop()
    stack
  })
}

///|
fn env_stack() -> Array[Env] {
  let mut value : Array[Env] = []
  env_stack_ref.update(fn(current) {
    value = current
    current
  })
  value
}

///|
fn current_env() -> Env? {
  let stack = env_stack()
  if stack.is_empty() {
    root_env()
  } else {
    Some(stack[stack.length() - 1])
  }
}

///|
fn push_source(source : String) -> Unit {
  source_stack_ref.update(fn(current) {
    current.push(source)
    current
  })
}

///|
fn pop_source() -> Unit {
  source_stack_ref.update(fn(current) {
    if !current.is_empty() {
      let _ = current.pop()

    }
    current
  })
}

///|
fn current_source() -> String? {
  let mut value : String? = None
  source_stack_ref.update(fn(current) {
    if !current.is_empty() {
      value = Some(current[current.length() - 1])
    }
    current
  })
  value
}

///|
fn push_source_path(path : String) -> Unit {
  source_path_stack_ref.update(fn(current) {
    current.push(path)
    current
  })
}

///|
fn pop_source_path() -> Unit {
  source_path_stack_ref.update(fn(current) {
    if !current.is_empty() {
      let _ = current.pop()

    }
    current
  })
}

///|
fn current_source_path() -> String? {
  let mut value : String? = None
  source_path_stack_ref.update(fn(current) {
    if !current.is_empty() {
      value = Some(current[current.length() - 1])
    }
    current
  })
  value
}

///|
fn with_source_value(source : String, f : () -> Value raise) -> Value raise {
  push_source(source)
  try {
    let result = f()
    pop_source()
    result
  } catch {
    err => {
      pop_source()
      raise err
    }
  }
}

///|
fn with_source_value_step(
  source : String,
  f : () -> GenStep raise,
) -> GenStep raise {
  push_source(source)
  try {
    let result = f()
    pop_source()
    result
  } catch {
    err => {
      pop_source()
      raise err
    }
  }
}

///|
fn with_function_source(
  func : FunctionValue,
  f : () -> Value raise,
) -> Value raise {
  match func.source_root {
    Some(source) => with_source_value(source, f)
    None => f()
  }
}

///|
fn with_function_source_step(
  func : FunctionValue,
  f : () -> GenStep raise,
) -> GenStep raise {
  match func.source_root {
    Some(source) => with_source_value_step(source, f)
    None => f()
  }
}

///|
fn with_source_path(path : String, f : () -> Value raise) -> Value raise {
  push_source_path(path)
  try {
    let result = f()
    pop_source_path()
    result
  } catch {
    err => {
      pop_source_path()
      raise err
    }
  }
}

///|
fn with_source_path_string_option(
  path : String,
  f : () -> String? raise,
) -> String? raise {
  push_source_path(path)
  try {
    let result = f()
    pop_source_path()
    result
  } catch {
    err => {
      pop_source_path()
      raise err
    }
  }
}

///|
fn with_source_path_step(
  path : String,
  f : () -> GenStep raise,
) -> GenStep raise {
  push_source_path(path)
  try {
    let result = f()
    pop_source_path()
    result
  } catch {
    err => {
      pop_source_path()
      raise err
    }
  }
}

///|
fn push_module_exports(exports : ObjectValue) -> Unit {
  module_exports_stack_ref.update(fn(current) {
    current.push(exports)
    current
  })
}

///|
fn pop_module_exports() -> Unit {
  module_exports_stack_ref.update(fn(current) {
    if !current.is_empty() {
      let _ = current.pop()

    }
    current
  })
}

///|
fn current_module_exports() -> ObjectValue? {
  let mut value : ObjectValue? = None
  module_exports_stack_ref.update(fn(current) {
    if !current.is_empty() {
      value = Some(current[current.length() - 1])
    }
    current
  })
  value
}

///|
fn set_yield_star_raw(value : Bool) -> Unit {
  let _ = yield_star_raw_ref.update(fn(_) { value })

}

///|
fn take_yield_star_raw() -> Bool {
  let mut value = false
  let _ = yield_star_raw_ref.update(fn(current) {
    value = current
    false
  })
  value
}

///|
fn with_module_exports(
  exports : ObjectValue,
  f : () -> Value raise,
) -> Value raise {
  push_module_exports(exports)
  try {
    let result = f()
    pop_module_exports()
    result
  } catch {
    err => {
      pop_module_exports()
      raise err
    }
  }
}

///|
fn with_module_exports_step(
  exports : ObjectValue,
  f : () -> GenStep raise,
) -> GenStep raise {
  push_module_exports(exports)
  try {
    let result = f()
    pop_module_exports()
    result
  } catch {
    err => {
      pop_module_exports()
      raise err
    }
  }
}

///|
fn push_module_env_id(id : Int) -> Unit {
  module_env_stack_ref.update(fn(current) {
    current.push(id)
    current
  })
}

///|
fn pop_module_env_id() -> Unit {
  module_env_stack_ref.update(fn(current) {
    if !current.is_empty() {
      let _ = current.pop()

    }
    current
  })
}

///|
fn current_module_env_id() -> Int? {
  let mut value : Int? = None
  module_env_stack_ref.update(fn(current) {
    if !current.is_empty() {
      value = Some(current[current.length() - 1])
    }
    current
  })
  value
}

///|
fn push_module_imports() -> Unit {
  module_import_stack_ref.update(fn(current) {
    current.push([])
    current
  })
}

///|
fn pop_module_imports() -> Array[String] {
  let mut value : Array[String] = []
  module_import_stack_ref.update(fn(current) {
    if !current.is_empty() {
      value = current.pop().unwrap_or([])
    }
    current
  })
  value
}

///|
fn record_module_import(cache_key : String) -> Unit {
  module_import_stack_ref.update(fn(current) {
    if !current.is_empty() {
      current[current.length() - 1].push(cache_key)
    }
    current
  })
}

///|
fn with_module_env_id(env_id : Int, f : () -> Value raise) -> Value raise {
  push_module_env_id(env_id)
  try {
    let result = f()
    pop_module_env_id()
    result
  } catch {
    err => {
      pop_module_env_id()
      raise err
    }
  }
}

///|
fn with_module_env_id_step(
  env_id : Int,
  f : () -> GenStep raise,
) -> GenStep raise {
  push_module_env_id(env_id)
  try {
    let result = f()
    pop_module_env_id()
    result
  } catch {
    err => {
      pop_module_env_id()
      raise err
    }
  }
}

///|
fn module_env_exports_set(env_id : Int, exports : ObjectValue) -> Unit {
  module_env_exports_ref.update(fn(table) {
    table.set(env_id, exports)
    table
  })
  module_env_exports_by_obj_ref.update(fn(table) {
    table.set(exports.id, env_id)
    table
  })
}

///|
fn module_env_exports_remove(env_id : Int) -> Unit {
  let mut exports_id : Int? = None
  module_env_exports_ref.update(fn(table) {
    match table.get(env_id) {
      Some(exports) => exports_id = Some(exports.id)
      None => ()
    }
    table.remove(env_id)
    table
  })
  module_env_exports_by_obj_ref.update(fn(table) {
    match exports_id {
      Some(id) => table.remove(id)
      None => ()
    }
    table
  })
}

///|
fn module_env_exports_get(env_id : Int) -> ObjectValue? {
  let mut value : ObjectValue? = None
  module_env_exports_ref.update(fn(table) {
    value = table.get(env_id)
    table
  })
  value
}

///|
fn module_env_id_for_exports_obj(exports : ObjectValue) -> Int? {
  let mut value : Int? = None
  module_env_exports_by_obj_ref.update(fn(table) {
    value = table.get(exports.id)
    table
  })
  value
}

///|
fn module_env_set(env : Env) -> Unit {
  module_env_ref.update(fn(table) {
    table.set(env.id, env)
    table
  })
}

///|
fn module_env_get(env_id : Int) -> Env? {
  let mut value : Env? = None
  module_env_ref.update(fn(table) {
    value = table.get(env_id)
    table
  })
  value
}

///|
fn module_env_remove(env_id : Int) -> Unit {
  module_env_ref.update(fn(table) {
    table.remove(env_id)
    table
  })
}

///|
fn sync_module_env(env : Env) -> Unit {
  let mut should_sync = false
  module_env_ref.update(fn(table) {
    should_sync = table.contains(env.id)
    table
  })
  if should_sync {
    module_env_set(env)
  }
}

///|
fn module_env_export_names_add(
  env_id : Int,
  binding : String,
  export_name : String,
) -> Unit {
  module_env_export_names_ref.update(fn(table) {
    let names = match table.get(env_id) {
      Some(existing) => existing
      None => Map::new()
    }
    let exports = match names.get(binding) {
      Some(existing) => existing
      None => []
    }
    if !exports.contains(export_name) {
      exports.push(export_name)
    }
    names.set(binding, exports)
    table.set(env_id, names)
    table
  })
}

///|
fn module_env_export_uninitialized_add(
  env_id : Int,
  export_name : String,
) -> Unit {
  module_env_export_uninitialized_ref.update(fn(table) {
    let names = match table.get(env_id) {
      Some(existing) => existing
      None => Map::new()
    }
    names.set(export_name, true)
    table.set(env_id, names)
    table
  })
}

///|
fn module_env_export_uninitialized_has(
  env_id : Int,
  export_name : String,
) -> Bool {
  let mut result = false
  module_env_export_uninitialized_ref.update(fn(table) {
    match table.get(env_id) {
      Some(names) => result = names.contains(export_name)
      None => ()
    }
    table
  })
  result
}

///|
fn module_env_export_uninitialized_remove(
  env_id : Int,
  export_name : String,
) -> Unit {
  module_env_export_uninitialized_ref.update(fn(table) {
    match table.get(env_id) {
      Some(names) => {
        names.remove(export_name)
        if names.is_empty() {
          table.remove(env_id)
        } else {
          table.set(env_id, names)
        }
      }
      None => ()
    }
    table
  })
}

///|
fn module_env_export_names_get(
  env_id : Int,
  binding : String,
) -> Array[String]? {
  let mut result : Array[String]? = None
  module_env_export_names_ref.update(fn(table) {
    match table.get(env_id) {
      Some(names) => result = names.get(binding)
      None => ()
    }
    table
  })
  result
}

///|
fn module_env_export_binding_for_name(
  env_id : Int,
  export_name : String,
) -> String? {
  let mut result : String? = None
  module_env_export_names_ref.update(fn(table) {
    match table.get(env_id) {
      Some(names) =>
        for binding, exports in names {
          if exports.contains(export_name) {
            result = Some(binding)
            break
          }
        }
      None => ()
    }
    table
  })
  result
}

///|
fn module_env_export_names_all(env_id : Int) -> Map[String, Array[String]]? {
  let mut result : Map[String, Array[String]]? = None
  module_env_export_names_ref.update(fn(table) {
    result = table.get(env_id)
    table
  })
  result
}

///|
fn module_env_export_names_remove(env_id : Int) -> Unit {
  module_env_export_names_ref.update(fn(table) {
    table.remove(env_id)
    table
  })
  module_env_export_uninitialized_ref.update(fn(table) {
    table.remove(env_id)
    table
  })
}

///|
fn update_module_export_binding(
  env : Env,
  binding : String,
  value : Value,
) -> Unit {
  match module_env_exports_get(env.id) {
    Some(exports) =>
      match module_env_export_names_get(env.id, binding) {
        Some(names) =>
          for export_name in names {
            match exports.props.get(export_name) {
              Some(prop) =>
                exports.props.set(export_name, Property::{
                  value,
                  writable: prop.writable,
                  configurable: prop.configurable,
                  enumerable: prop.enumerable,
                  getter: prop.getter,
                  setter: prop.setter,
                })
              None => ()
            }
          }
        None => ()
      }
    None => ()
  }
}

///|
fn push_expr_pos(offset : Int) -> Unit {
  expr_pos_stack_ref.update(fn(current) {
    current.push(offset)
    current
  })
}

///|
fn pop_expr_pos() -> Unit {
  expr_pos_stack_ref.update(fn(current) {
    if !current.is_empty() {
      let _ = current.pop()

    }
    current
  })
}

///|
fn expr_pos_stack() -> Array[Int] {
  let mut value : Array[Int] = []
  expr_pos_stack_ref.update(fn(current) {
    value = current
    current
  })
  value
}

///|
fn with_expr_pos(offset : Int, f : () -> Value raise) -> Value raise {
  push_expr_pos(offset)
  try {
    let result = f()
    pop_expr_pos()
    result
  } catch {
    err => {
      pop_expr_pos()
      raise err
    }
  }
}

///|
fn with_expr_pos_call_ref(
  offset : Int,
  f : () -> (Value, Value) raise,
) -> (Value, Value) raise {
  push_expr_pos(offset)
  try {
    let result = f()
    pop_expr_pos()
    result
  } catch {
    err => {
      pop_expr_pos()
      raise err
    }
  }
}

///|
fn current_function() -> FunctionValue? {
  let mut value : FunctionValue? = None
  current_function_stack_ref.update(fn(current) {
    if !current.is_empty() {
      value = Some(current[current.length() - 1])
    }
    current
  })
  value
}

///|
fn current_function_stack() -> Array[FunctionValue] {
  let mut value : Array[FunctionValue] = []
  current_function_stack_ref.update(fn(current) {
    value = current
    current
  })
  value
}

///|
fn current_function_is_async_generator() -> Bool {
  match current_function() {
    Some(func) => func.is_async && func.is_generator
    None => false
  }
}

///|
fn current_function_is_generator() -> Bool {
  match current_function() {
    Some(func) => func.is_generator
    None => false
  }
}

///|
fn in_class_field_init_context() -> Bool {
  match current_function() {
    Some(func) => func.in_class_field_init
    None => false
  }
}

///|
fn current_super_function() -> FunctionValue? {
  let mut value : FunctionValue? = None
  current_function_stack_ref.update(fn(current) {
    let mut i = current.length()
    while i > 0 {
      i = i - 1
      let func = current[i]
      if !func.is_arrow ||
        func.home_object is Some(_) ||
        func.super_constructor is Some(_) {
        value = Some(func)
        break
      }
    }
    current
  })
  value
}

///|
fn with_current_function(
  func : FunctionValue,
  f : () -> Value raise,
) -> Value raise {
  let mut depth = 0
  current_function_stack_ref.update(fn(current) {
    depth = current.length()
    current
  })
  if depth >= max_call_depth {
    let _ = throw_range_error("stack overflow")

  }
  current_function_stack_ref.update(fn(current) {
    current.push(func)
    current
  })
  try {
    let result = f()
    current_function_stack_ref.update(fn(current) {
      let _ = current.pop()
      current
    })
    result
  } catch {
    err => {
      current_function_stack_ref.update(fn(current) {
        let _ = current.pop()
        current
      })
      raise err
    }
  }
}

///|
fn with_current_function_step(
  func : FunctionValue,
  f : () -> GenStep raise,
) -> GenStep raise {
  let mut depth = 0
  current_function_stack_ref.update(fn(current) {
    depth = current.length()
    current
  })
  if depth >= max_call_depth {
    let _ = throw_range_error("stack overflow")

  }
  current_function_stack_ref.update(fn(current) {
    current.push(func)
    current
  })
  try {
    let result = f()
    current_function_stack_ref.update(fn(current) {
      let _ = current.pop()
      current
    })
    result
  } catch {
    err => {
      current_function_stack_ref.update(fn(current) {
        let _ = current.pop()
        current
      })
      raise err
    }
  }
}

///|
fn with_current_generator_data_step(
  data : GeneratorData,
  f : () -> GenStep raise,
) -> GenStep raise {
  let mut saved : GeneratorData? = None
  current_generator_data_ref.update(fn(current) {
    saved = current
    Some(data)
  })
  try {
    let result = f()
    current_generator_data_ref.update(fn(_) { saved })
    result
  } catch {
    err => {
      current_generator_data_ref.update(fn(_) { saved })
      raise err
    }
  }
}

///|
fn gen_root_depth() -> Int {
  let mut depth = 0
  current_generator_data_ref.update(fn(current) {
    match current {
      Some(data) => depth = data.roots.length()
      None => depth = 0
    }
    current
  })
  depth
}

///|
fn gen_root_push(value : Value) -> Int {
  let mut depth = 0
  current_generator_data_ref.update(fn(current) {
    match current {
      Some(data) => {
        data.roots.push(value)
        depth = data.roots.length()
      }
      None => depth = 0
    }
    current
  })
  depth
}

///|
fn gen_root_pop_to(depth : Int) -> Unit {
  current_generator_data_ref.update(fn(current) {
    match current {
      Some(data) =>
        while data.roots.length() > depth {
          let _ = data.roots.pop()

        }
      None => ()
    }
    current
  })
}

///|
fn gen_wrap_step_with_root(base : Int, step : GenStep) -> GenStep {
  match step {
    Yield(value, next_step) =>
      Yield(value, fn(resume_state) raise {
        gen_wrap_step_with_root(base, next_step(resume_state))
      })
    Await(value, next_step) =>
      Await(value, fn(resume_state) raise {
        gen_wrap_step_with_root(base, next_step(resume_state))
      })
    Done(control) => {
      gen_root_pop_to(base)
      Done(control)
    }
  }
}

///|
fn gen_with_root_frame(f : () -> GenStep raise) -> GenStep raise {
  let base = gen_root_depth()
  try {
    let step = f()
    gen_wrap_step_with_root(base, step)
  } catch {
    err => {
      gen_root_pop_to(base)
      raise err
    }
  }
}

///|
fn with_env_value(env : Env, f : () -> Value raise) -> Value raise {
  push_env(env)
  try {
    let result = f()
    pop_env()
    result
  } catch {
    err => {
      pop_env()
      raise err
    }
  }
}

///|
fn with_env_step(env : Env, f : () -> GenStep raise) -> GenStep raise {
  push_env(env)
  try {
    let result = f()
    pop_env()
    result
  } catch {
    err => {
      pop_env()
      raise err
    }
  }
}

///|
fn annex_b_var_func_decl_contains(func : @engine.FunctionDef) -> Bool {
  let mut result = false
  annex_b_var_func_decls_ref.update(fn(stack) {
    if !stack.is_empty() {
      let current = stack[stack.length() - 1]
      result = current.contains(func.offset)
    }
    stack
  })
  result
}

///|
fn[T] with_annex_b_var_func_decls(
  decls : @hashmap.HashMap[Int, Bool],
  f : () -> T raise,
) -> T raise {
  annex_b_var_func_decls_ref.update(fn(stack) {
    stack.push(decls)
    stack
  })
  try {
    let result = f()
    annex_b_var_func_decls_ref.update(fn(stack) {
      ignore(stack.pop())
      stack
    })
    result
  } catch {
    err => {
      annex_b_var_func_decls_ref.update(fn(stack) {
        ignore(stack.pop())
        stack
      })
      raise err
    }
  }
}

///|
fn top_level_function_decl_contains(func : @engine.FunctionDef) -> Bool {
  let mut result = false
  top_level_func_decls_ref.update(fn(stack) {
    if !stack.is_empty() {
      let current = stack[stack.length() - 1]
      result = current.contains(func.offset)
    }
    stack
  })
  result
}

///|
fn[T] with_top_level_function_decls(
  decls : @hashmap.HashMap[Int, Bool],
  f : () -> T raise,
) -> T raise {
  top_level_func_decls_ref.update(fn(stack) {
    stack.push(decls)
    stack
  })
  try {
    let result = f()
    top_level_func_decls_ref.update(fn(stack) {
      ignore(stack.pop())
      stack
    })
    result
  } catch {
    err => {
      top_level_func_decls_ref.update(fn(stack) {
        ignore(stack.pop())
        stack
      })
      raise err
    }
  }
}

///|
fn with_top_level_function_decls_step(
  decls : @hashmap.HashMap[Int, Bool],
  f : () -> GenStep raise,
) -> GenStep raise {
  top_level_func_decls_ref.update(fn(stack) {
    stack.push(decls)
    stack
  })
  try {
    let result = f()
    top_level_func_decls_ref.update(fn(stack) {
      ignore(stack.pop())
      stack
    })
    result
  } catch {
    err => {
      top_level_func_decls_ref.update(fn(stack) {
        ignore(stack.pop())
        stack
      })
      raise err
    }
  }
}

///|
fn top_level_function_decls_wrap_next_step(
  next_step : (GenResume) -> GenStep raise,
  decls : @hashmap.HashMap[Int, Bool],
) -> (GenResume) -> GenStep raise {
  fn(resume_) raise {
    let step = with_top_level_function_decls_step(decls, fn() raise {
      next_step(resume_)
    })
    top_level_function_decls_wrap_step(step, decls)
  }
}

///|
fn top_level_function_decls_wrap_step(
  step : GenStep,
  decls : @hashmap.HashMap[Int, Bool],
) -> GenStep {
  match step {
    Yield(value, next_step) =>
      Yield(value, top_level_function_decls_wrap_next_step(next_step, decls))
    Await(value, next_step) =>
      Await(value, top_level_function_decls_wrap_next_step(next_step, decls))
    Done(control) => Done(control)
  }
}

///|
fn enqueue_job(func : Value, args : Array[Value]) -> Unit {
  enqueue_job_with_env(current_env(), func, args)
}

///|
fn enqueue_job_with_env(env : Env?, func : Value, args : Array[Value]) -> Unit {
  let job_env = match env {
    Some(inner) => Some(realm_env_from_env(inner))
    None =>
      match root_env() {
        Some(root) => Some(root)
        None => None
      }
  }
  job_queue_ref.update(fn(queue) {
    queue.push(JobEntry::{ func, args, env: job_env })
    queue
  })
}

///|
fn has_pending_jobs() -> Bool {
  let mut value = false
  job_queue_ref.update(fn(queue) {
    if !queue.is_empty() {
      value = true
    }
    queue
  })
  value
}

///|
fn run_pending_jobs() -> Unit raise {
  while true {
    let mut pending : Array[JobEntry] = []
    job_queue_ref.update(fn(queue) {
      if !queue.is_empty() {
        pending = queue
        []
      } else {
        queue
      }
    })
    if pending.is_empty() {
      break
    }
    for entry in pending {
      match entry.env {
        Some(env) => {
          let result = with_env_value(env, fn() raise {
            call_value_with_this(entry.func, entry.args, Undefined)
          })
          gc_maybe_collect_with_root(result)
        }
        None => {
          let result = call_value_with_this(entry.func, entry.args, Undefined)
          gc_maybe_collect_with_root(result)
        }
      }
    }
  }
}

///|
fn next_timer_id() -> Int {
  let mut value : Int = 0
  next_timer_id_ref.update(fn(current) {
    value = current
    current + 1
  })
  value
}

///|
fn enqueue_timer(callback : Value, delay_ms : Int64) -> Int {
  let id = next_timer_id()
  timer_queue_ref.update(fn(queue) {
    queue.push(TimerEntry::{ id, callback, delay_ms })
    queue
  })
  id
}

///|
fn clear_timer(id : Int) -> Unit {
  timer_queue_ref.update(fn(queue) {
    let keep : Array[TimerEntry] = []
    for entry in queue {
      if entry.id != id {
        keep.push(entry)
      }
    }
    keep
  })
}

///|
fn next_worker_id() -> Int {
  let mut value : Int = 0
  next_worker_id_ref.update(fn(current) {
    value = current
    current + 1
  })
  value
}

///|
fn worker_table_snapshot() -> Array[WorkerState] {
  let items : Array[WorkerState] = []
  worker_table_ref.update(fn(table) {
    for _, state in table {
      items.push(state)
    }
    table
  })
  items
}

///|
fn worker_state_get(id : Int) -> WorkerState? {
  let mut value : WorkerState? = None
  worker_table_ref.update(fn(table) {
    value = table.get(id)
    table
  })
  value
}

///|
fn worker_state_set(state : WorkerState) -> Unit {
  worker_table_ref.update(fn(table) {
    table.set(state.id, state)
    table
  })
}

///|
fn module_record_get(path : String) -> ModuleRecord? {
  let mut value : ModuleRecord? = None
  module_table_ref.update(fn(table) {
    value = table.get(path)
    table
  })
  value
}

///|
fn module_record_set(path : String, record : ModuleRecord) -> Unit {
  module_table_ref.update(fn(table) {
    table.set(path, record)
    table
  })
}

///|
fn module_eval_promise_get(path : String) -> Value? {
  match module_record_get(path) {
    Some(record) => record.eval_promise
    None => None
  }
}

///|
fn module_eval_promise_set(path : String, promise : Value?) -> Unit {
  match module_record_get(path) {
    Some(record) =>
      module_record_set(path, ModuleRecord::{
        exports: record.exports,
        state: record.state,
        module_ns: record.module_ns,
        meta_obj: record.meta_obj,
        eval_promise: promise,
      })
    None => ()
  }
}

///|
fn module_eval_info_get(path : String) -> ModuleEvalInfo? {
  let mut value : ModuleEvalInfo? = None
  module_eval_info_ref.update(fn(table) {
    value = table.get(path)
    table
  })
  value
}

///|
fn module_eval_info_set(path : String, info : ModuleEvalInfo) -> Unit {
  module_eval_info_ref.update(fn(table) {
    table.set(path, info)
    table
  })
}

///|
fn module_eval_info_remove(path : String) -> Unit {
  module_eval_info_ref.update(fn(table) {
    table.remove(path)
    table
  })
}

///|
fn module_export_info_get(path : String) -> ModuleExportInfo? {
  let mut value : ModuleExportInfo? = None
  module_export_info_ref.update(fn(table) {
    value = table.get(path)
    table
  })
  value
}

///|
fn module_export_info_set(path : String, info : ModuleExportInfo) -> Unit {
  module_export_info_ref.update(fn(table) {
    table.set(path, info)
    table
  })
}

///|
fn module_export_info_remove(path : String) -> Unit {
  module_export_info_ref.update(fn(table) {
    table.remove(path)
    table
  })
}

///|
fn module_record_remove(path : String) -> Unit {
  module_table_ref.update(fn(table) {
    table.remove(path)
    table
  })
  module_export_info_remove(path)
}

///|
fn module_builtin_namespace_get(env_id : Int, name : String) -> ObjectValue? {
  let mut value : ObjectValue? = None
  module_builtin_namespace_ref.update(fn(table) {
    match table.get(env_id) {
      Some(namespaces) => value = namespaces.get(name)
      None => ()
    }
    table
  })
  value
}

///|
fn module_builtin_namespace_set(
  env_id : Int,
  name : String,
  value : ObjectValue,
) -> Unit {
  module_builtin_namespace_ref.update(fn(table) {
    let namespaces = match table.get(env_id) {
      Some(existing) => existing
      None => Map::new()
    }
    namespaces.set(name, value)
    table.set(env_id, namespaces)
    table
  })
}

///|
fn worker_enqueue(id : Int, to_main : Bool, message : Value) -> Unit {
  match worker_state_get(id) {
    Some(state) =>
      if to_main {
        state.queue_to_main.push(message)
      } else {
        state.queue_to_worker.push(message)
      }
    None => ()
  }
}

///|
fn run_pending_timers() -> Unit raise {
  let mut pending : Array[TimerEntry] = []
  timer_queue_ref.update(fn(queue) {
    pending = queue
    []
  })
  while !pending.is_empty() {
    let current = pending
    pending = []
    for entry in current {
      let _ = entry.delay_ms
      let result = call_value(entry.callback, [])
      gc_maybe_collect_with_root(result)
    }
    timer_queue_ref.update(fn(queue) {
      if !queue.is_empty() {
        pending = queue
        []
      } else {
        queue
      }
    })
  }
}

///|
fn has_pending_timers() -> Bool {
  let mut value = false
  timer_queue_ref.update(fn(queue) {
    if !queue.is_empty() {
      value = true
    }
    queue
  })
  value
}

///|
fn run_pending_workers() -> Unit raise {
  let mut did_work = true
  while did_work {
    did_work = false
    let states = worker_table_snapshot()
    for state in states {
      if !state.queue_to_main.is_empty() {
        let pending = state.queue_to_main
        state.queue_to_main = []
        did_work = true
        for message in pending {
          deliver_worker_message_main(state, message)
        }
      }
      if !state.queue_to_worker.is_empty() {
        let pending = state.queue_to_worker
        state.queue_to_worker = []
        did_work = true
        for message in pending {
          deliver_worker_message_worker(state, message)
        }
      }
    }
  }
}

///|
fn has_pending_workers() -> Bool {
  let states = worker_table_snapshot()
  for state in states {
    if !state.queue_to_main.is_empty() || !state.queue_to_worker.is_empty() {
      return true
    }
  }
  false
}

///|
fn new_message_event(data : Value) -> Value {
  let obj = new_object_value()
  match obj {
    Object(event) => event.props.set("data", property_data(data))
    _ => ()
  }
  obj
}

///|
fn worker_port_info(this_value : Value?) -> (Int, Bool) raise {
  match this_value {
    Some(Object(obj)) => {
      let id_value = property_get(Object(obj), "__worker_id")
      let port_value = property_get(Object(obj), "__worker_port")
      match (id_value, port_value) {
        (Number(id_num), Number(port_num)) => {
          let worker_id = to_int32(id_num)
          let to_main = Double::trunc(port_num) != 0.0
          (worker_id, to_main)
        }
        _ => {
          let _ = throw_type_error("invalid worker")
          (0, false)
        }
      }
    }
    _ => {
      let _ = throw_type_error("invalid worker")
      (0, false)
    }
  }
}

///|
fn new_worker_port_value(worker_id : Int, to_main : Bool) -> Value {
  let obj = new_object_value()
  match obj {
    Object(port) => {
      port.props.set(
        "__worker_id",
        property_data_non_enum(Number(Double::from_int(worker_id))),
      )
      let port_kind = if to_main { 1.0 } else { 0.0 }
      port.props.set("__worker_port", property_data_non_enum(Number(port_kind)))
      port.props.set(
        "postMessage",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::WorkerPostMessage),
        ),
      )
      port.props.set("onmessage", property_data_non_enum(Null))
    }
    _ => ()
  }
  obj
}

///|
fn deliver_worker_message_main(
  state : WorkerState,
  message : Value,
) -> Unit raise {
  let handler = property_get(Object(state.worker_obj), "onmessage")
  if is_callable(handler) {
    let event = new_message_event(message)
    let result = call_value_with_this(
      handler,
      [event],
      Object(state.worker_obj),
    )
    gc_maybe_collect_with_root(result)
  }
}

///|
fn deliver_worker_message_worker(
  state : WorkerState,
  message : Value,
) -> Unit raise {
  let handler = property_get(Object(state.parent_obj), "onmessage")
  if is_callable(handler) {
    let event = new_message_event(message)
    let result = with_root_env(state.env, fn() raise {
      call_value_with_this(handler, [event], Object(state.parent_obj))
    })
    gc_maybe_collect_with_root(result)
  }
}

///|
fn clone_worker_value(value : Value) -> Value raise {
  let seen : Map[Int, Value] = Map::new()
  clone_worker_value_inner(value, seen)
}

///|
fn clone_array_buffer_object(
  obj : ObjectValue,
  data : ArrayBufferData,
  seen : Map[Int, Value],
) -> ObjectValue {
  match seen.get(obj.id) {
    Some(Object(existing)) => return existing
    Some(_) => return obj
    None => ()
  }
  if data.shared {
    let value = Object(obj)
    seen.set(obj.id, value)
    return obj
  }
  let clone_value = new_array_buffer_value_with_options(
    data.bytes.length(),
    data.max_byte_length,
    data.resizable,
  )
  seen.set(obj.id, clone_value)
  match clone_value {
    Object(new_obj) =>
      match new_obj.array_buffer_data {
        Some(new_data) => {
          let mut i = 0
          while i < data.bytes.length() {
            new_data.bytes[i] = data.bytes[i]
            i = i + 1
          }
          new_obj
        }
        None => new_obj
      }
    _ => new_object_struct(None)
  }
}

///|
fn clone_worker_value_inner(
  value : Value,
  seen : Map[Int, Value],
) -> Value raise {
  match value {
    Undefined | Null | Bool(_) | Number(_) | String(_) | BigInt(_) => value
    Symbol(_) => {
      let _ = throw_type_error("unsupported type")
      Undefined
    }
    Function(_) | Builtin(_) | BoundFunction(_) | Arguments(_) => {
      let _ = throw_type_error("unsupported type")
      Undefined
    }
    Array(arr) =>
      match seen.get(arr.id) {
        Some(existing) => existing
        None =>
          match arr.typed_array_data {
            Some(data) => {
              let buffer_obj = match data.buffer.array_buffer_data {
                Some(buf) => clone_array_buffer_object(data.buffer, buf, seen)
                None => data.buffer
              }
              let clone_value = new_typed_array_view(
                data.kind,
                buffer_obj,
                data.byte_offset,
                data.length,
                data.length_tracking,
              )
              seen.set(arr.id, clone_value)
              clone_value
            }
            None => {
              let len = arr.elements.length()
              let elements : Array[Value?] = []
              let mut i = 0
              while i < len {
                elements.push(None)
                i = i + 1
              }
              let clone_value = new_array_value(elements)
              seen.set(arr.id, clone_value)
              match clone_value {
                Array(target) => {
                  let mut j = 0
                  while j < len {
                    match arr.elements[j] {
                      Some(entry) =>
                        target.elements[j] = Some(
                          clone_worker_value_inner(entry, seen),
                        )
                      None => ()
                    }
                    j = j + 1
                  }
                }
                _ => ()
              }
              clone_value
            }
          }
      }
    Object(obj) =>
      match obj.array_buffer_data {
        Some(data) => {
          let clone_obj = clone_array_buffer_object(obj, data, seen)
          Object(clone_obj)
        }
        None =>
          match obj.date_data {
            Some(value) => new_date_value(value)
            None =>
              match obj.string_data {
                Some(text) => new_string_object(text)
                None =>
                  match obj.number_data {
                    Some(num) => new_number_object(num)
                    None =>
                      match obj.bool_data {
                        Some(flag) => new_bool_object(flag)
                        None =>
                          match obj.bigint_data {
                            Some(num) => new_bigint_object(num)
                            None =>
                              match obj.symbol_data {
                                Some(sym) => new_symbol_object(sym)
                                None =>
                                  match
                                    (
                                      obj.regexp_data,
                                      obj.generator_data,
                                      obj.async_generator_data,
                                      obj.proxy_data,
                                      obj.map_data,
                                      obj.set_data,
                                      obj.map_iter_data,
                                      obj.set_iter_data,
                                      obj.weakmap_data,
                                      obj.weakset_data,
                                      obj.weakref_data,
                                      obj.finreg_data,
                                    ) {
                                    (Some(_), _, _, _, _, _, _, _, _, _, _, _) => {
                                      let _ = throw_type_error(
                                        "unsupported type",
                                      )
                                      Undefined
                                    }
                                    (_, Some(_), _, _, _, _, _, _, _, _, _, _) => {
                                      let _ = throw_type_error(
                                        "unsupported type",
                                      )
                                      Undefined
                                    }
                                    (_, _, Some(_), _, _, _, _, _, _, _, _, _) => {
                                      let _ = throw_type_error(
                                        "unsupported type",
                                      )
                                      Undefined
                                    }
                                    (_, _, _, Some(_), _, _, _, _, _, _, _, _) => {
                                      let _ = throw_type_error(
                                        "unsupported type",
                                      )
                                      Undefined
                                    }
                                    (_, _, _, _, Some(_), _, _, _, _, _, _, _) => {
                                      let _ = throw_type_error(
                                        "unsupported type",
                                      )
                                      Undefined
                                    }
                                    (_, _, _, _, _, Some(_), _, _, _, _, _, _) => {
                                      let _ = throw_type_error(
                                        "unsupported type",
                                      )
                                      Undefined
                                    }
                                    (_, _, _, _, _, _, Some(_), _, _, _, _, _) => {
                                      let _ = throw_type_error(
                                        "unsupported type",
                                      )
                                      Undefined
                                    }
                                    (_, _, _, _, _, _, _, Some(_), _, _, _, _) => {
                                      let _ = throw_type_error(
                                        "unsupported type",
                                      )
                                      Undefined
                                    }
                                    (_, _, _, _, _, _, _, _, Some(_), _, _, _) => {
                                      let _ = throw_type_error(
                                        "unsupported type",
                                      )
                                      Undefined
                                    }
                                    (_, _, _, _, _, _, _, _, _, Some(_), _, _) => {
                                      let _ = throw_type_error(
                                        "unsupported type",
                                      )
                                      Undefined
                                    }
                                    (_, _, _, _, _, _, _, _, _, _, Some(_), _) => {
                                      let _ = throw_type_error(
                                        "unsupported type",
                                      )
                                      Undefined
                                    }
                                    (_, _, _, _, _, _, _, _, _, _, _, Some(_)) => {
                                      let _ = throw_type_error(
                                        "unsupported type",
                                      )
                                      Undefined
                                    }
                                    _ =>
                                      match seen.get(obj.id) {
                                        Some(existing) => existing
                                        None => {
                                          let clone_value = new_object_value_with_proto(
                                            obj.proto,
                                          )
                                          seen.set(obj.id, clone_value)
                                          match clone_value {
                                            Object(target) =>
                                              for key, prop in obj.props {
                                                if is_symbol_prop_key(key) ||
                                                  is_private_prop_key(key) ||
                                                  !prop.enumerable {
                                                  continue
                                                }
                                                let cloned = clone_worker_value_inner(
                                                  prop.value,
                                                  seen,
                                                )
                                                target.props.set(
                                                  key,
                                                  property_data(cloned),
                                                )
                                              }
                                            _ => ()
                                          }
                                          clone_value
                                        }
                                      }
                                  }
                              }
                          }
                      }
                  }
              }
          }
      }
  }
}

///|
fn set_worker_parent(env : Env, parent_value : Value) -> Unit raise {
  let os_value = env_get(env, "os")
  match os_value {
    Object(os_obj) => {
      let worker_ctor = property_get(Object(os_obj), "Worker")
      let _ = property_set(worker_ctor, "parent", parent_value, env.strict)

    }
    _ => ()
  }
}

///|
fn create_worker_from_args(args : Array[Value]) -> Value raise {
  if args.is_empty() {
    return throw_type_error("missing filename")
  }
  let path = to_string_value(args[0])
  let full_path = resolve_path_from_source(path)
  let source = @fs.read_file_to_string(full_path) catch {
    _ => {
      let _ = throw_reference_error("could not load '\{path}'")
      ""
    }
  }
  let script = parse_script_with_pos(source)
  let worker_id = next_worker_id()
  let worker_value = new_worker_port_value(worker_id, false)
  let parent_value = new_worker_port_value(worker_id, true)
  let worker_env = clone_root_env()
  let worker_obj = match worker_value {
    Object(obj) => obj
    _ => new_object_struct(None)
  }
  let parent_obj = match parent_value {
    Object(obj) => obj
    _ => new_object_struct(None)
  }
  let state = WorkerState::{
    id: worker_id,
    env: worker_env,
    worker_obj,
    parent_obj,
    queue_to_main: [],
    queue_to_worker: [],
  }
  worker_state_set(state)
  let _ = set_worker_parent(worker_env, parent_value)
  let _ = with_root_env(worker_env, fn() raise {
    if script.is_module {
      let _ = eval_module_script(script, full_path)
      Undefined
    } else {
      with_source_path(full_path, fn() raise { eval_script(worker_env, script) })
    }
  })
  worker_value
}

///|
priv struct GcMeta {
  mut ref_count : Int
  mut mark : Bool
  mut in_tmp : Bool
}

///|
priv struct GcState {
  meta : Map[Int, GcMeta]
  weakrefs : Array[ObjectValue]
  weakmaps : Array[ObjectValue]
  weaksets : Array[ObjectValue]
  finregs : Array[ObjectValue]
}

///|
pub struct GcRegistry {
  envs : Map[Int, Env]
  values : Map[Int, Value]
}

///|
let gc_default_threshold : Int = 256 * 1024

///|
pub struct RuntimeState {
  gc_registry_ref : Ref[GcRegistry]
  gc_alloc_count_ref : Ref[Int]
  gc_threshold_ref : Ref[Int]
  gc_debug_ref : Ref[Bool]
  gc_value_root_ref : Ref[Array[Value]]
  gc_pending_ref : Ref[Bool]
  print_log_ref : Ref[Array[String]]
  async_done_ref : Ref[Int]
  can_block_ref : Ref[Bool]
}

///|
pub impl Show for RuntimeState with output(self, logger) {
  let _ = self
  logger.write_string("RuntimeState")
}

///|
fn RuntimeState::new() -> RuntimeState {
  RuntimeState::{
    gc_registry_ref: Ref::new(GcRegistry::{
      envs: Map::new(),
      values: Map::new(),
    }),
    gc_alloc_count_ref: Ref::new(0),
    gc_threshold_ref: Ref::new(gc_default_threshold),
    gc_debug_ref: Ref::new(false),
    gc_value_root_ref: Ref::new([]),
    gc_pending_ref: Ref::new(false),
    print_log_ref: Ref::new([]),
    async_done_ref: Ref::new(0),
    can_block_ref: Ref::new(true),
  }
}

///|
let current_runtime_ref : Ref[RuntimeState?] = Ref::new(None)

///|
let fallback_runtime_state : RuntimeState = RuntimeState::new()

///|
fn current_runtime_state() -> RuntimeState {
  let mut value : RuntimeState? = None
  current_runtime_ref.update(fn(current) {
    value = current
    current
  })
  match value {
    Some(runtime) => runtime
    None => fallback_runtime_state
  }
}

///|
fn set_current_runtime_state(runtime : RuntimeState) -> RuntimeState? {
  let mut prev : RuntimeState? = None
  current_runtime_ref.update(fn(current) {
    prev = current
    Some(runtime)
  })
  prev
}

///|
fn restore_runtime_state(prev : RuntimeState?) -> Unit {
  current_runtime_ref.update(fn(_) { prev })
}

///|
fn gc_registry_ref() -> Ref[GcRegistry] {
  current_runtime_state().gc_registry_ref
}

///|
fn gc_alloc_count_ref() -> Ref[Int] {
  current_runtime_state().gc_alloc_count_ref
}

///|
fn gc_threshold_ref() -> Ref[Int] {
  current_runtime_state().gc_threshold_ref
}

///|
fn gc_debug_ref() -> Ref[Bool] {
  current_runtime_state().gc_debug_ref
}

///|
fn gc_value_root_ref() -> Ref[Array[Value]] {
  current_runtime_state().gc_value_root_ref
}

///|
fn gc_pending_ref() -> Ref[Bool] {
  current_runtime_state().gc_pending_ref
}

///|
fn print_log_ref() -> Ref[Array[String]] {
  current_runtime_state().print_log_ref
}

///|
fn async_done_ref() -> Ref[Int] {
  current_runtime_state().async_done_ref
}

///|
fn can_block_ref() -> Ref[Bool] {
  current_runtime_state().can_block_ref
}

///|
fn new_gc_state() -> GcState {
  GcState::{
    meta: Map::new(),
    weakrefs: [],
    weakmaps: [],
    weaksets: [],
    finregs: [],
  }
}

///|
fn value_id(value : Value) -> Int? {
  match value {
    Object(obj) => Some(obj.id)
    Function(func) => Some(func.id)
    BoundFunction(bound) => Some(bound.id)
    Builtin(builtin) => Some(builtin.id)
    Array(arr) => Some(arr.id)
    Arguments(args) => Some(args.id)
    Symbol(symbol) => Some(symbol.id)
    _ => None
  }
}

///|
fn register_env(env : Env) -> Unit {
  gc_registry_ref().update(fn(registry) {
    if !registry.envs.contains(env.id) {
      registry.envs.set(env.id, env)
      gc_alloc_count_ref().update(fn(count) { count + 1 })
    }
    registry
  })
  gc_request()
}

///|
fn register_value(value : Value) -> Unit {
  match value_id(value) {
    Some(id) =>
      gc_registry_ref().update(fn(registry) {
        if !registry.values.contains(id) {
          registry.values.set(id, value)
          gc_alloc_count_ref().update(fn(count) { count + 1 })
        }
        registry
      })
    None => ()
  }
  gc_request()
}

///|
fn register_object_value(obj : ObjectValue) -> ObjectValue {
  register_value(Object(obj))
  obj
}

///|
fn register_array_value(arr : ArrayValue) -> ArrayValue {
  register_value(Array(arr))
  arr
}

///|
fn register_function_value(func : FunctionValue) -> FunctionValue {
  register_value(Function(func))
  func
}

///|
fn register_bound_function_value(
  bound : BoundFunctionValue,
) -> BoundFunctionValue {
  register_value(BoundFunction(bound))
  bound
}

///|
fn register_builtin_value(builtin : BuiltinValue) -> BuiltinValue {
  register_value(Builtin(builtin))
  builtin
}

///|
fn register_arguments_value(args : ArgumentsValue) -> ArgumentsValue {
  register_value(Arguments(args))
  args
}

///|
fn gc_prepare_meta(state : GcState) -> Unit {
  gc_registry_ref().update(fn(registry) {
    registry.values.each(fn(id, _) {
      state.meta.set(id, GcMeta::{ ref_count: 0, mark: false, in_tmp: false })
    })
    registry.envs.each(fn(id, _) {
      state.meta.set(id, GcMeta::{ ref_count: 0, mark: false, in_tmp: false })
    })
    registry
  })
}

///|
fn gc_meta_incref(state : GcState, id : Int) -> Unit {
  match state.meta.get(id) {
    Some(meta) => meta.ref_count = meta.ref_count + 1
    None => ()
  }
}

///|
fn gc_meta_decref(state : GcState, id : Int) -> Unit {
  match state.meta.get(id) {
    Some(meta) =>
      if meta.ref_count > 0 {
        meta.ref_count = meta.ref_count - 1
        if meta.ref_count == 0 && meta.mark && !meta.in_tmp {
          meta.in_tmp = true
        }
      }
    None => ()
  }
}

///|
fn gc_incref_value(state : GcState, value : Value) -> Unit {
  match value_id(value) {
    Some(id) => gc_meta_incref(state, id)
    None => ()
  }
}

///|
fn gc_decref_value(state : GcState, value : Value) -> Unit {
  match value_id(value) {
    Some(id) => gc_meta_decref(state, id)
    None => ()
  }
}

///|
fn gc_incref_env(state : GcState, env : Env) -> Unit {
  gc_meta_incref(state, env.id)
}

///|
fn gc_decref_env(state : GcState, env : Env) -> Unit {
  gc_meta_decref(state, env.id)
}

///|
fn gc_incref_optional_value(state : GcState, value : Value?) -> Unit {
  match value {
    Some(inner) => gc_incref_value(state, inner)
    None => ()
  }
}

///|

///|
fn gc_incref_optional_object(state : GcState, obj : ObjectValue?) -> Unit {
  match obj {
    Some(inner) => gc_incref_value(state, Object(inner))
    None => ()
  }
}

///|
fn gc_incref_symbol(state : GcState, symbol : SymbolValue) -> Unit {
  gc_meta_incref(state, symbol.id)
}

///|
fn gc_incref_value_ref(state : GcState, cell : Ref[Value?]) -> Unit {
  cell.update(fn(current) {
    gc_incref_optional_value(state, current)
    current
  })
}

///|
fn gc_incref_object_ref(state : GcState, cell : Ref[ObjectValue?]) -> Unit {
  cell.update(fn(current) {
    gc_incref_optional_object(state, current)
    current
  })
}

///|
fn gc_incref_symbol_ref(state : GcState, cell : Ref[SymbolValue?]) -> Unit {
  cell.update(fn(current) {
    match current {
      Some(symbol) => gc_incref_symbol(state, symbol)
      None => ()
    }
    current
  })
}

///|
fn is_live_value(state : GcState, value : Value) -> Bool {
  match value {
    Undefined => true
    _ =>
      match value_id(value) {
        Some(id) =>
          match state.meta.get(id) {
            Some(meta) => meta.ref_count > 0
            None => false
          }
        None => false
      }
  }
}

///|
fn is_live_value_now(value : Value) -> Bool {
  let state = new_gc_state()
  gc_prepare_meta(state)
  gc_count_roots(state)
  gc_count_internal_refs(state)
  is_live_value(state, value)
}

///|
fn gc_visit_props(
  props : Map[String, Property],
  visit_value : (Value) -> Unit,
) -> Unit {
  for key, prop in props {
    if is_symbol_prop_key(key) {
      match symbol_from_prop_key(key) {
        Some(symbol) => visit_value(Symbol(symbol))
        None => ()
      }
    }
    visit_value(prop.value)
    match prop.getter {
      Some(getter) => visit_value(getter)
      None => ()
    }
    match prop.setter {
      Some(setter) => visit_value(setter)
      None => ()
    }
  }
}

///|
fn gc_visit_proto(proto : Value?, visit_value : (Value) -> Unit) -> Unit {
  match proto {
    Some(value) => visit_value(value)
    None => ()
  }
}

///|
fn gc_visit_env_children(
  env : Env,
  visit_value : (Value) -> Unit,
  visit_env : (Env) -> Unit,
) -> Unit {
  for _, value in env.bindings {
    visit_value(value)
  }
  match env.with_object {
    Some(value) => visit_value(value)
    None => ()
  }
  match env.var_object {
    Some(value) => visit_value(value)
    None => ()
  }
  visit_value(env.new_target)
  match env.var_env {
    Some(var_env) => visit_env(var_env)
    None => ()
  }
  match env.parent {
    Some(parent) => visit_env(parent)
    None => ()
  }
}

///|
fn gc_visit_promise_data(obj_id : Int, visit_value : (Value) -> Unit) -> Unit {
  match promise_table_get(obj_id) {
    Some(data) => {
      visit_value(data.value)
      for reaction in data.fulfill_reactions {
        visit_value(reaction.resolve)
        visit_value(reaction.reject)
        visit_value(reaction.handler)
      }
      for reaction in data.reject_reactions {
        visit_value(reaction.resolve)
        visit_value(reaction.reject)
        visit_value(reaction.handler)
      }
    }
    None => ()
  }
}

///|
fn gc_visit_async_function_data(
  obj_id : Int,
  visit_value : (Value) -> Unit,
) -> Unit {
  match async_function_data_get(obj_id) {
    Some(data) => {
      visit_value(data.resolve)
      visit_value(data.reject)
    }
    None => ()
  }
}

///|
fn gc_visit_object_children(
  state : GcState,
  obj : ObjectValue,
  visit_value : (Value) -> Unit,
  visit_env : (Env) -> Unit,
  collect_weak : Bool,
) -> Unit {
  gc_visit_proto(obj.proto, visit_value)
  gc_visit_props(obj.props, visit_value)
  match obj.symbol_data {
    Some(symbol) => visit_value(Symbol(symbol))
    None => ()
  }
  match obj.realm_env {
    Some(env) => visit_env(env)
    None => ()
  }
  match obj.generator_data {
    Some(data) => {
      visit_env(data.env)
      visit_value(Function(data.func))
      for value in data.roots {
        visit_value(value)
      }
    }
    None => ()
  }
  match obj.async_generator_data {
    Some(data) =>
      for request in data.queue {
        match request.resume_state {
          GenResume::Next(value) => visit_value(value)
          GenResume::Return(value) => visit_value(value)
          GenResume::Throw(value) => visit_value(value)
        }
        visit_value(request.promise)
        visit_value(request.resolve)
        visit_value(request.reject)
      }
    None => ()
  }
  match obj.proxy_data {
    Some(data) => {
      visit_value(data.target)
      visit_value(data.handler)
    }
    None => ()
  }
  match obj.map_data {
    Some(data) =>
      for entry in data.entries {
        match entry {
          Some((key, value)) => {
            visit_value(key)
            visit_value(value)
          }
          None => ()
        }
      }
    None => ()
  }
  match obj.set_data {
    Some(data) =>
      for value in data.entries {
        match value {
          Some(entry) => visit_value(entry)
          None => ()
        }
      }
    None => ()
  }
  match obj.map_iter_data {
    Some(data) =>
      for entry in data.entries {
        match entry {
          Some((key, value)) => {
            visit_value(key)
            visit_value(value)
          }
          None => ()
        }
      }
    None => ()
  }
  match obj.set_iter_data {
    Some(data) =>
      for value in data.entries {
        match value {
          Some(entry) => visit_value(entry)
          None => ()
        }
      }
    None => ()
  }
  match obj.iterator_wrap_data {
    Some(data) => {
      visit_value(data.wrapped_iter)
      visit_value(data.wrapped_next)
    }
    None => ()
  }
  match obj.iterator_concat_data {
    Some(data) => {
      visit_value(data.iter)
      visit_value(data.next)
      for pair in data.values {
        let (value, next_value) = pair
        visit_value(value)
        visit_value(next_value)
      }
    }
    None => ()
  }
  match obj.iterator_helper_data {
    Some(data) => {
      visit_value(data.obj)
      visit_value(data.next)
      visit_value(data.func)
      visit_value(data.inner)
      visit_value(data.inner_next)
    }
    None => ()
  }
  match obj.weakref_data {
    Some(_) => if collect_weak { state.weakrefs.push(obj) }
    None => ()
  }
  match obj.weakmap_data {
    Some(data) => {
      if collect_weak {
        state.weakmaps.push(obj)
      }
      for entry in data.entries {
        let (_, value) = entry
        visit_value(value)
      }
    }
    None => ()
  }
  match obj.weakset_data {
    Some(_) => if collect_weak { state.weaksets.push(obj) }
    None => ()
  }
  match obj.finreg_data {
    Some(data) => {
      visit_env(data.realm_env)
      visit_value(data.callback)
      for entry in data.entries {
        visit_value(entry.held_value)
      }
      if collect_weak {
        state.finregs.push(obj)
      }
    }
    None => ()
  }
  match obj.dataview_data {
    Some(data) => visit_value(Object(data.buffer))
    None => ()
  }
  gc_visit_promise_data(obj.id, visit_value)
  gc_visit_async_function_data(obj.id, visit_value)
}

///|
fn gc_visit_function_children(
  func : FunctionValue,
  visit_value : (Value) -> Unit,
  visit_env : (Env) -> Unit,
) -> Unit {
  gc_visit_proto(func.proto, visit_value)
  match func.home_object {
    Some(value) => visit_value(value)
    None => ()
  }
  gc_visit_props(func.props, visit_value)
  gc_visit_props(func.private_instance_props, visit_value)
  visit_env(func.env)
  match func.super_constructor {
    Some(value) => visit_value(value)
    None => ()
  }
}

///|
fn gc_visit_bound_function_children(
  bound : BoundFunctionValue,
  visit_value : (Value) -> Unit,
) -> Unit {
  gc_visit_proto(bound.proto, visit_value)
  gc_visit_props(bound.props, visit_value)
  visit_value(bound.target)
  visit_value(bound.bound_this)
  for value in bound.bound_args {
    visit_value(value)
  }
}

///|
fn gc_visit_builtin_extra_children(
  builtin : BuiltinValue,
  visit_value : (Value) -> Unit,
) -> Unit {
  match builtin.kind {
    BuiltinFunction::PromiseResolveFunction
    | BuiltinFunction::PromiseRejectFunction =>
      match promise_resolve_func_data_get(builtin.id) {
        Some(data) => visit_value(data.promise)
        None => ()
      }
    BuiltinFunction::PromiseCapabilityExecutor =>
      match promise_executor_data_get(builtin.id) {
        Some(data) => {
          match data.resolve {
            Some(value) => visit_value(value)
            None => ()
          }
          match data.reject {
            Some(value) => visit_value(value)
            None => ()
          }
        }
        None => ()
      }
    BuiltinFunction::PromiseAllResolveElement =>
      match promise_all_element_data_get(builtin.id) {
        Some(data) => {
          visit_value(data.values)
          visit_value(data.result_resolve)
        }
        None => ()
      }
    BuiltinFunction::PromiseThenFinally =>
      match promise_then_finally_data_get(builtin.id) {
        Some(data) => {
          visit_value(data.ctor)
          visit_value(data.on_finally)
        }
        None => ()
      }
    BuiltinFunction::PromiseFinallyValueThunk
    | BuiltinFunction::PromiseFinallyThrower =>
      match promise_finally_value_data_get(builtin.id) {
        Some(value) => visit_value(value)
        None => ()
      }
    BuiltinFunction::AsyncFromSyncIteratorCloseWrap =>
      match async_from_sync_close_wrap_data_get(builtin.id) {
        Some(data) => visit_value(data.sync_iter)
        None => ()
      }
    BuiltinFunction::AsyncGeneratorResolveFunction =>
      match async_generator_resolve_func_data_get(builtin.id) {
        Some(data) => visit_value(data.generator)
        None => ()
      }
    BuiltinFunction::AsyncFunctionResolveFunction =>
      match async_function_resolve_func_data_get(builtin.id) {
        Some(data) => visit_value(data.generator)
        None => ()
      }
    _ => ()
  }
}

///|
fn gc_visit_builtin_children(
  builtin : BuiltinValue,
  visit_value : (Value) -> Unit,
  visit_env : (Env) -> Unit,
) -> Unit {
  gc_visit_proto(builtin.proto, visit_value)
  gc_visit_props(builtin.props, visit_value)
  match builtin.this_value {
    Some(value) => visit_value(value)
    None => ()
  }
  match builtin.realm_env {
    Some(env) => visit_env(env)
    None => ()
  }
  gc_visit_builtin_extra_children(builtin, visit_value)
}

///|
fn gc_visit_array_children(
  arr : ArrayValue,
  visit_value : (Value) -> Unit,
) -> Unit {
  gc_visit_proto(arr.proto, visit_value)
  gc_visit_props(arr.props, visit_value)
  for entry in arr.elements {
    match entry {
      Some(value) => visit_value(value)
      None => ()
    }
  }
  match arr.typed_array_data {
    Some(data) => visit_value(Object(data.buffer))
    None => ()
  }
}

///|
fn gc_visit_arguments_children(
  args : ArgumentsValue,
  visit_value : (Value) -> Unit,
  visit_env : (Env) -> Unit,
) -> Unit {
  gc_visit_proto(args.proto, visit_value)
  gc_visit_props(args.props, visit_value)
  visit_env(args.env)
  for entry in args.elements {
    match entry {
      Some(value) => visit_value(value)
      None => ()
    }
  }
}

///|
fn gc_visit_value_children(
  state : GcState,
  value : Value,
  visit_value : (Value) -> Unit,
  visit_env : (Env) -> Unit,
  collect_weak : Bool,
) -> Unit {
  match value {
    Object(obj) =>
      gc_visit_object_children(state, obj, visit_value, visit_env, collect_weak)
    Function(func) => gc_visit_function_children(func, visit_value, visit_env)
    BoundFunction(bound) => gc_visit_bound_function_children(bound, visit_value)
    Builtin(builtin) =>
      gc_visit_builtin_children(builtin, visit_value, visit_env)
    Array(arr) => gc_visit_array_children(arr, visit_value)
    Arguments(args) => gc_visit_arguments_children(args, visit_value, visit_env)
    _ => ()
  }
}

///|
fn gc_count_roots(state : GcState) -> Unit {
  match root_env() {
    Some(env) => gc_incref_env(state, env)
    None => ()
  }
  for env in env_stack() {
    gc_incref_env(state, env)
  }
  for func in current_function_stack() {
    gc_incref_value(state, Function(func))
  }
  gc_value_root_ref().update(fn(stack) {
    for value in stack {
      gc_incref_value(state, value)
    }
    stack
  })
  gc_incref_object_ref(state, object_proto_ref)
  gc_incref_value_ref(state, function_proto_ref)
  gc_incref_object_ref(state, array_proto_ref)
  gc_incref_object_ref(state, array_buffer_proto_ref)
  gc_incref_object_ref(state, shared_array_buffer_proto_ref)
  gc_incref_object_ref(state, dataview_proto_ref)
  gc_incref_object_ref(state, typed_array_proto_ref)
  gc_incref_object_ref(state, uint8_array_proto_ref)
  gc_incref_object_ref(state, int8_array_proto_ref)
  gc_incref_object_ref(state, uint8_clamped_array_proto_ref)
  gc_incref_object_ref(state, uint16_array_proto_ref)
  gc_incref_object_ref(state, int16_array_proto_ref)
  gc_incref_object_ref(state, uint32_array_proto_ref)
  gc_incref_object_ref(state, int32_array_proto_ref)
  gc_incref_object_ref(state, bigint64_array_proto_ref)
  gc_incref_object_ref(state, biguint64_array_proto_ref)
  gc_incref_object_ref(state, float16_array_proto_ref)
  gc_incref_object_ref(state, float32_array_proto_ref)
  gc_incref_object_ref(state, float64_array_proto_ref)
  gc_incref_object_ref(state, string_proto_ref)
  gc_incref_object_ref(state, bool_proto_ref)
  gc_incref_object_ref(state, number_proto_ref)
  gc_incref_object_ref(state, bigint_proto_ref)
  gc_incref_object_ref(state, symbol_proto_ref)
  gc_incref_object_ref(state, regexp_proto_ref)
  gc_incref_object_ref(state, date_proto_ref)
  gc_incref_object_ref(state, generator_proto_ref)
  gc_incref_object_ref(state, generator_function_proto_ref)
  gc_incref_object_ref(state, async_function_proto_ref)
  gc_incref_object_ref(state, generator_function_ctor_ref)
  gc_incref_object_ref(state, async_generator_proto_ref)
  gc_incref_object_ref(state, async_generator_function_proto_ref)
  gc_incref_object_ref(state, async_generator_function_ctor_ref)
  gc_incref_object_ref(state, iterator_proto_ref)
  gc_incref_object_ref(state, async_iterator_proto_ref)
  gc_incref_object_ref(state, async_from_sync_iterator_proto_ref)
  gc_incref_object_ref(state, iterator_concat_proto_ref)
  gc_incref_object_ref(state, iterator_helper_proto_ref)
  gc_incref_object_ref(state, iterator_wrap_proto_ref)
  gc_incref_object_ref(state, array_iterator_proto_ref)
  gc_incref_object_ref(state, string_iterator_proto_ref)
  gc_incref_object_ref(state, regexp_string_iterator_proto_ref)
  gc_incref_object_ref(state, map_iterator_proto_ref)
  gc_incref_object_ref(state, set_iterator_proto_ref)
  gc_incref_object_ref(state, map_proto_ref)
  gc_incref_object_ref(state, set_proto_ref_cell)
  gc_incref_object_ref(state, weakmap_proto_ref)
  gc_incref_object_ref(state, weakset_proto_ref_cell)
  gc_incref_object_ref(state, weakref_proto_ref)
  gc_incref_object_ref(state, finreg_proto_ref)
  gc_incref_object_ref(state, promise_proto_ref)
  gc_incref_object_ref(state, error_proto_ref)
  gc_incref_object_ref(state, aggregate_error_proto_ref)
  gc_incref_object_ref(state, eval_error_proto_ref)
  gc_incref_object_ref(state, syntax_error_proto_ref)
  gc_incref_object_ref(state, range_error_proto_ref)
  gc_incref_object_ref(state, type_error_proto_ref)
  gc_incref_object_ref(state, reference_error_proto_ref)
  gc_incref_object_ref(state, uri_error_proto_ref)
  gc_incref_symbol_ref(state, symbol_iterator_ref)
  gc_incref_symbol_ref(state, symbol_to_string_tag_ref)
  gc_incref_symbol_ref(state, symbol_async_iterator_ref)
  gc_incref_symbol_ref(state, symbol_has_instance_ref)
  gc_incref_symbol_ref(state, symbol_is_concat_spreadable_ref)
  gc_incref_symbol_ref(state, symbol_match_ref)
  gc_incref_symbol_ref(state, symbol_match_all_ref)
  gc_incref_symbol_ref(state, symbol_replace_ref)
  gc_incref_symbol_ref(state, symbol_search_ref)
  gc_incref_symbol_ref(state, symbol_species_ref)
  gc_incref_symbol_ref(state, symbol_split_ref)
  gc_incref_symbol_ref(state, symbol_to_primitive_ref)
  gc_incref_symbol_ref(state, symbol_unscopables_ref)
  symbol_registry_ref.update(fn(current) {
    for _, symbol in current {
      gc_incref_symbol(state, symbol)
    }
    current
  })
  throw_type_error_ref.update(fn(table) {
    for _, value in table {
      gc_incref_value(state, value)
    }
    table
  })
  template_registry_ref.update(fn(table) {
    for _, registry in table {
      for _, value in registry {
        gc_incref_value(state, value)
      }
    }
    table
  })
  generator_proto_env_ref.update(fn(table) {
    for _, obj in table {
      gc_incref_value(state, Object(obj))
    }
    table
  })
  async_generator_proto_env_ref.update(fn(table) {
    for _, obj in table {
      gc_incref_value(state, Object(obj))
    }
    table
  })
  generator_function_ctor_env_ref.update(fn(table) {
    for _, builtin in table {
      gc_incref_value(state, Builtin(builtin))
    }
    table
  })
  async_generator_function_ctor_env_ref.update(fn(table) {
    for _, builtin in table {
      gc_incref_value(state, Builtin(builtin))
    }
    table
  })
  async_function_ctor_env_ref.update(fn(table) {
    for _, builtin in table {
      gc_incref_value(state, Builtin(builtin))
    }
    table
  })
  async_iterator_proto_env_ref.update(fn(table) {
    for _, obj in table {
      gc_incref_value(state, Object(obj))
    }
    table
  })
  job_queue_ref.update(fn(queue) {
    for job in queue {
      gc_incref_value(state, job.func)
      for value in job.args {
        gc_incref_value(state, value)
      }
      match job.env {
        Some(env) => gc_incref_env(state, env)
        None => ()
      }
    }
    queue
  })
  timer_queue_ref.update(fn(queue) {
    for entry in queue {
      gc_incref_value(state, entry.callback)
    }
    queue
  })
  worker_table_ref.update(fn(table) {
    for _, worker in table {
      gc_incref_env(state, worker.env)
      gc_incref_value(state, Object(worker.worker_obj))
      gc_incref_value(state, Object(worker.parent_obj))
      for value in worker.queue_to_main {
        gc_incref_value(state, value)
      }
      for value in worker.queue_to_worker {
        gc_incref_value(state, value)
      }
    }
    table
  })
  agent_table_ref.update(fn(table) {
    for _, agent in table {
      gc_incref_env(state, agent.env)
      match agent.broadcast_callback {
        Some(callback) => gc_incref_value(state, callback)
        None => ()
      }
    }
    table
  })
  module_table_ref.update(fn(table) {
    for _, record in table {
      gc_incref_value(state, Object(record.exports))
      match record.module_ns {
        Some(obj) => gc_incref_value(state, Object(obj))
        None => ()
      }
      match record.meta_obj {
        Some(obj) => gc_incref_value(state, Object(obj))
        None => ()
      }
      match record.eval_promise {
        Some(value) => gc_incref_value(state, value)
        None => ()
      }
    }
    table
  })
  module_exports_stack_ref.update(fn(stack) {
    for obj in stack {
      gc_incref_value(state, Object(obj))
    }
    stack
  })
  module_eval_info_ref.update(fn(table) {
    for _, info in table {
      match info.eval_exception {
        Some(value) => gc_incref_value(state, value)
        None => ()
      }
      match info.resolve {
        Some(value) => gc_incref_value(state, value)
        None => ()
      }
      match info.reject {
        Some(value) => gc_incref_value(state, value)
        None => ()
      }
    }
    table
  })
  module_import_dynamic_job_data_ref.update(fn(table) {
    for _, data in table {
      gc_incref_value(state, data.resolve)
      gc_incref_value(state, data.reject)
      gc_incref_value(state, data.attributes)
    }
    table
  })
  module_builtin_namespace_ref.update(fn(table) {
    for _, ns_map in table {
      for _, obj in ns_map {
        gc_incref_value(state, Object(obj))
      }
    }
    table
  })
  module_env_exports_ref.update(fn(table) {
    for _, obj in table {
      gc_incref_value(state, Object(obj))
    }
    table
  })
  module_env_ref.update(fn(table) {
    for _, env in table {
      gc_incref_env(state, env)
    }
    table
  })
}

///|
fn gc_count_internal_refs(state : GcState) -> Unit {
  gc_registry_ref().update(fn(registry) {
    registry.values.each(fn(_, value) {
      gc_visit_value_children(
        state,
        value,
        fn(child) { gc_incref_value(state, child) },
        fn(env) { gc_incref_env(state, env) },
        true,
      )
    })
    registry.envs.each(fn(_, env) {
      gc_visit_env_children(env, fn(child) { gc_incref_value(state, child) }, fn(
        child_env,
      ) {
        gc_incref_env(state, child_env)
      })
    })
    registry
  })
}

///|
fn gc_remove_weak_objects(state : GcState) -> Unit {
  let mut index = 0
  while index < state.weakmaps.length() {
    let obj = state.weakmaps[index]
    match obj.weakmap_data {
      Some(data) => {
        let mut i = 0
        while i < data.entries.length() {
          let (key, value) = data.entries[i]
          if is_live_value(state, key) {
            i = i + 1
          } else {
            gc_decref_value(state, value)
            let _ = data.entries.remove(i)

          }
        }
      }
      None => ()
    }
    index = index + 1
  }
  index = 0
  while index < state.weaksets.length() {
    let obj = state.weaksets[index]
    match obj.weakset_data {
      Some(data) => {
        let mut i = 0
        while i < data.entries.length() {
          let key = data.entries[i]
          if is_live_value(state, key) {
            i = i + 1
          } else {
            let _ = data.entries.remove(i)

          }
        }
      }
      None => ()
    }
    index = index + 1
  }
  for obj in state.weakrefs {
    match obj.weakref_data {
      Some(data) =>
        if !is_live_value(state, data.target) {
          obj.weakref_data = Some(WeakRefData::{ target: Undefined })
        }
      None => ()
    }
  }
  for obj in state.finregs {
    match obj.finreg_data {
      Some(data) => {
        let mut i = 0
        while i < data.entries.length() {
          let entry = data.entries[i]
          match entry.token {
            Undefined => ()
            _ =>
              if !is_live_value(state, entry.token) {
                entry.token = Undefined
              }
          }
          if !is_live_value(state, entry.target) {
            let realm_env = realm_env_from_env(data.realm_env)
            enqueue_job_with_env(Some(realm_env), data.callback, [
              entry.held_value,
            ])
            gc_incref_value(state, data.callback)
            gc_incref_value(state, entry.held_value)
            gc_incref_env(state, realm_env)
            let _ = data.entries.remove(i)
            gc_decref_value(state, entry.held_value)
          } else {
            i = i + 1
          }
        }
      }
      None => ()
    }
  }
}

///|
fn gc_decref(state : GcState) -> Unit {
  gc_registry_ref().update(fn(registry) {
    registry.values.each(fn(id, value) {
      gc_visit_value_children(
        state,
        value,
        fn(child) { gc_decref_value(state, child) },
        fn(env) { gc_decref_env(state, env) },
        false,
      )
      match state.meta.get(id) {
        Some(meta) => {
          meta.mark = true
          if meta.ref_count == 0 && !meta.in_tmp {
            meta.in_tmp = true
          }
        }
        None => ()
      }
    })
    registry.envs.each(fn(id, env) {
      gc_visit_env_children(env, fn(child) { gc_decref_value(state, child) }, fn(
        child_env,
      ) {
        gc_decref_env(state, child_env)
      })
      match state.meta.get(id) {
        Some(meta) => {
          meta.mark = true
          if meta.ref_count == 0 && !meta.in_tmp {
            meta.in_tmp = true
          }
        }
        None => ()
      }
    })
    registry
  })
}

///|
fn gc_scan_incref_value(state : GcState, value : Value) -> Bool {
  match value_id(value) {
    Some(id) =>
      match state.meta.get(id) {
        Some(meta) => {
          let was_zero = meta.ref_count == 0
          if was_zero && meta.in_tmp {
            meta.in_tmp = false
          }
          meta.ref_count = meta.ref_count + 1
          was_zero
        }
        None => false
      }
    None => false
  }
}

///|
fn gc_scan_incref_env(state : GcState, env : Env) -> Bool {
  match state.meta.get(env.id) {
    Some(meta) => {
      let was_zero = meta.ref_count == 0
      if was_zero && meta.in_tmp {
        meta.in_tmp = false
      }
      meta.ref_count = meta.ref_count + 1
      was_zero
    }
    None => false
  }
}

///|
fn gc_scan_incref_value_keep_tmp(state : GcState, value : Value) -> Unit {
  match value_id(value) {
    Some(id) =>
      match state.meta.get(id) {
        Some(meta) => meta.ref_count = meta.ref_count + 1
        None => ()
      }
    None => ()
  }
}

///|
fn gc_scan_incref_env_keep_tmp(state : GcState, env : Env) -> Unit {
  match state.meta.get(env.id) {
    Some(meta) => meta.ref_count = meta.ref_count + 1
    None => ()
  }
}

///|
fn gc_scan(state : GcState) -> Unit {
  let mut changed = true
  while changed {
    changed = false
    gc_registry_ref().update(fn(registry) {
      registry.envs.each(fn(id, env) {
        match state.meta.get(id) {
          Some(meta) =>
            if meta.ref_count > 0 {
              gc_visit_env_children(
                env,
                fn(child) {
                  if gc_scan_incref_value(state, child) {
                    changed = true
                  }
                },
                fn(child_env) {
                  if gc_scan_incref_env(state, child_env) {
                    changed = true
                  }
                },
              )
            }
          None => ()
        }
      })
      registry.values.each(fn(id, value) {
        match state.meta.get(id) {
          Some(meta) =>
            if meta.ref_count > 0 {
              gc_visit_value_children(
                state,
                value,
                fn(child) {
                  if gc_scan_incref_value(state, child) {
                    changed = true
                  }
                },
                fn(env) { if gc_scan_incref_env(state, env) { changed = true } },
                false,
              )
            }
          None => ()
        }
      })
      registry
    })
  }
  gc_registry_ref().update(fn(registry) {
    registry.values.each(fn(id, value) {
      match state.meta.get(id) {
        Some(meta) =>
          if meta.in_tmp {
            gc_visit_value_children(
              state,
              value,
              fn(child) { gc_scan_incref_value_keep_tmp(state, child) },
              fn(env) { gc_scan_incref_env_keep_tmp(state, env) },
              false,
            )
          }
        None => ()
      }
    })
    registry.envs.each(fn(id, env) {
      match state.meta.get(id) {
        Some(meta) =>
          if meta.in_tmp {
            gc_visit_env_children(
              env,
              fn(child) { gc_scan_incref_value_keep_tmp(state, child) },
              fn(child_env) { gc_scan_incref_env_keep_tmp(state, child_env) },
            )
          }
        None => ()
      }
    })
    registry
  })
}

///|
fn gc_free_cycles(state : GcState) -> Unit {
  gc_registry_ref().update(fn(registry) {
    let before = registry.values.length() + registry.envs.length()
    registry.values.retain(fn(id, value) {
      match state.meta.get(id) {
        Some(meta) =>
          if meta.in_tmp {
            gc_release_value(value)
            false
          } else {
            true
          }
        None => true
      }
    })
    registry.envs.retain(fn(id, env) {
      match state.meta.get(id) {
        Some(meta) =>
          if meta.in_tmp {
            gc_release_env(env)
            false
          } else {
            true
          }
        None => true
      }
    })
    let after = registry.values.length() + registry.envs.length()
    if after < before {
      let removed = before - after
      gc_alloc_count_ref().update(fn(count) {
        if count > removed {
          count - removed
        } else {
          0
        }
      })
    }
    registry
  })
}

///|
fn gc_release_env(env : Env) -> Unit {
  env.bindings.clear()
  env.readonly_bindings.clear()
  env.deletable_bindings.clear()
  env.private_bindings.clear()
  env.param_binding_names.clear()
  env.uninitialized_bindings.clear()
  env.with_object = None
  env.var_object = None
  env.new_target = Undefined
  env.var_env = None
}

///|
fn gc_release_props(props : Map[String, Property]) -> Unit {
  props.clear()
}

///|
fn gc_release_object_tables(obj_id : Int) -> Unit {
  promise_table_ref.update(fn(table) {
    let _ = table.remove(obj_id)
    table
  })
  async_function_data_ref.update(fn(table) {
    let _ = table.remove(obj_id)
    table
  })
}

///|
fn gc_release_builtin_tables(builtin_id : Int) -> Unit {
  promise_resolve_func_data_ref.update(fn(table) {
    let _ = table.remove(builtin_id)
    table
  })
  promise_executor_data_ref.update(fn(table) {
    let _ = table.remove(builtin_id)
    table
  })
  promise_all_element_data_ref.update(fn(table) {
    let _ = table.remove(builtin_id)
    table
  })
  promise_then_finally_data_ref.update(fn(table) {
    let _ = table.remove(builtin_id)
    table
  })
  async_from_sync_unwrap_data_ref.update(fn(table) {
    let _ = table.remove(builtin_id)
    table
  })
  async_from_sync_close_wrap_data_ref.update(fn(table) {
    let _ = table.remove(builtin_id)
    table
  })
  async_generator_resolve_func_data_ref.update(fn(table) {
    let _ = table.remove(builtin_id)
    table
  })
  async_function_resolve_func_data_ref.update(fn(table) {
    let _ = table.remove(builtin_id)
    table
  })
  promise_finally_value_data_ref.update(fn(table) {
    let _ = table.remove(builtin_id)
    table
  })
}

///|
fn gc_release_object(obj : ObjectValue) -> Unit {
  gc_release_object_tables(obj.id)
  gc_release_props(obj.props)
  obj.proto = None
  obj.realm_env = None
  match obj.generator_data {
    Some(data) => data.roots.clear()
    None => ()
  }
  obj.generator_data = None
  obj.async_generator_data = None
  obj.map_iter_data = None
  obj.set_iter_data = None
  obj.iterator_wrap_data = None
  obj.iterator_concat_data = None
  obj.iterator_helper_data = None
  obj.weakref_data = None
  obj.date_data = None
  obj.array_buffer_data = None
  obj.dataview_data = None
  obj.regexp_data = None
  match obj.proxy_data {
    Some(data) => {
      data.target = Undefined
      data.handler = Undefined
    }
    None => ()
  }
  obj.proxy_data = None
  match obj.map_data {
    Some(data) => data.entries.clear()
    None => ()
  }
  obj.map_data = None
  match obj.set_data {
    Some(data) => data.entries.clear()
    None => ()
  }
  obj.set_data = None
  match obj.weakmap_data {
    Some(data) => data.entries.clear()
    None => ()
  }
  match obj.weakset_data {
    Some(data) => data.entries.clear()
    None => ()
  }
  match obj.finreg_data {
    Some(data) => data.entries.clear()
    None => ()
  }
  obj.weakmap_data = None
  obj.weakset_data = None
  obj.finreg_data = None
}

///|
fn gc_release_function(func : FunctionValue) -> Unit {
  gc_release_props(func.props)
  gc_release_props(func.private_instance_props)
  // Avoid clearing shared AST-backed arrays (params/body/fields) since they are
  // reused across FunctionValue instances and clones.
  func.proto = None
  func.home_object = None
  func.super_constructor = None
  func.source = None
}

///|
fn gc_release_bound_function(bound : BoundFunctionValue) -> Unit {
  gc_release_props(bound.props)
  bound.target = Undefined
  bound.bound_this = Undefined
  bound.bound_args.clear()
  bound.proto = None
}

///|
fn gc_release_builtin(builtin : BuiltinValue) -> Unit {
  gc_release_builtin_tables(builtin.id)
  gc_release_props(builtin.props)
  builtin.this_value = None
  builtin.proto = None
  builtin.realm_env = None
}

///|
fn gc_release_array(arr : ArrayValue) -> Unit {
  gc_release_props(arr.props)
  arr.elements.clear()
  arr.proto = None
  arr.typed_array_data = None
}

///|
fn gc_release_arguments(args : ArgumentsValue) -> Unit {
  gc_release_props(args.props)
  args.elements.clear()
  args.mapped.clear()
  args.params.clear()
  args.proto = None
}

///|
fn gc_release_value(value : Value) -> Unit {
  match value {
    Object(obj) => gc_release_object(obj)
    Function(func) => gc_release_function(func)
    BoundFunction(bound) => gc_release_bound_function(bound)
    Builtin(builtin) => gc_release_builtin(builtin)
    Array(arr) => gc_release_array(arr)
    Arguments(args) => gc_release_arguments(args)
    Symbol(symbol) =>
      symbol_table_ref.update(fn(current) {
        let _ = current.remove(symbol.id)
        current
      })
    _ => ()
  }
}

///|

///|
fn gc_release_all() -> Unit {
  gc_registry_ref().update(fn(registry) {
    registry.values.each(fn(_, value) { gc_release_value(value) })
    registry.envs.each(fn(_, env) { gc_release_env(env) })
    GcRegistry::{ envs: Map::new(), values: Map::new() }
  })
  gc_alloc_count_ref().update(fn(_) { 0 })
}

///|
fn run_gc_internal(remove_weak : Bool) -> Unit {
  gc_debug_dump_roots("begin")
  let state = new_gc_state()
  gc_prepare_meta(state)
  gc_count_roots(state)
  gc_count_internal_refs(state)
  gc_debug_dump_assert_meta(state, "pre")
  if remove_weak {
    gc_remove_weak_objects(state)
  }
  gc_decref(state)
  gc_scan(state)
  gc_debug_dump_assert_meta(state, "post")
  gc_free_cycles(state)
}

///|
pub fn run_gc() -> Unit {
  run_gc_internal(true)
}

///|
fn run_gc_without_weak() -> Unit {
  run_gc_internal(false)
}

///|
fn gc_request() -> Unit {
  let mut threshold = 0
  let mut count = 0
  gc_threshold_ref().update(fn(current) {
    threshold = current
    current
  })
  if threshold < 0 {
    return ()
  }
  gc_alloc_count_ref().update(fn(current) {
    count = current
    current
  })
  if count > threshold {
    gc_pending_ref().update(fn(_) { true })
  }
}

///|
fn gc_root_depth() -> Int {
  let mut depth = 0
  gc_value_root_ref().update(fn(stack) {
    depth = stack.length()
    stack
  })
  depth
}

///|
fn gc_root_push(value : Value) -> Int {
  let mut depth = 0
  gc_value_root_ref().update(fn(stack) {
    stack.push(value)
    depth = stack.length()
    stack
  })
  depth
}

///|
fn gc_root_pop_to(depth : Int) -> Unit {
  gc_value_root_ref().update(fn(stack) {
    while stack.length() > depth {
      let _ = stack.pop()

    }
    stack
  })
}

///|
fn with_gc_frame(f : () -> Value raise) -> Value raise {
  let base = gc_root_depth()
  try f() catch {
    err => {
      gc_root_pop_to(base)
      raise err
    }
  } noraise {
    result => {
      gc_root_pop_to(base)
      result
    }
  }
}

///|
fn with_gc_frame_values(f : () -> Array[Value] raise) -> Array[Value] raise {
  let base = gc_root_depth()
  try f() catch {
    err => {
      gc_root_pop_to(base)
      raise err
    }
  } noraise {
    result => {
      gc_root_pop_to(base)
      result
    }
  }
}

///|
fn with_gc_frame_pair(f : () -> (Value, Value?) raise) -> (Value, Value?) raise {
  let base = gc_root_depth()
  try f() catch {
    err => {
      gc_root_pop_to(base)
      raise err
    }
  } noraise {
    result => {
      gc_root_pop_to(base)
      result
    }
  }
}

///|
fn gc_maybe_collect() -> Unit {
  gc_request()
  let mut pending = false
  let mut count = 0
  let mut threshold = 0
  gc_pending_ref().update(fn(current) {
    pending = current
    current
  })
  if !pending {
    return ()
  }
  gc_threshold_ref().update(fn(current) {
    threshold = current
    current
  })
  if threshold < 0 {
    gc_pending_ref().update(fn(_) { false })
    return ()
  }
  run_gc()
  gc_pending_ref().update(fn(_) { false })
  gc_alloc_count_ref().update(fn(current) {
    count = current
    current
  })
  let next_threshold = count + count / 2
  gc_threshold_ref().update(fn(_) { next_threshold })
}

///|
fn gc_maybe_collect_with_root(value : Value) -> Unit {
  let base = gc_root_depth()
  match current_env() {
    Some(env) => {
      let _ = gc_root_push(global_object_value(env))

    }
    None => ()
  }
  let _ = gc_root_push(value)
  gc_maybe_collect()
  gc_root_pop_to(base)
}

///|
fn gc_maybe_collect_with_global(env : Env, value : Value) -> Unit {
  let base = gc_root_depth()
  let _ = gc_root_push(global_object_value(env))
  let _ = gc_root_push(value)
  gc_maybe_collect()
  gc_root_pop_to(base)
}

///|
#warnings("-unused_error_type")
fn loop_gc_maybe(env : Env, value : Value, tick : Int) -> Int raise {
  let next = tick + 1
  if Int::land(next, 255) == 0 {
    let _ = with_env_value(env, fn() raise {
      gc_maybe_collect_with_global(env, value)
      Undefined
    })

  }
  next
}

///|
pub fn set_gc_threshold(threshold : Int) -> Unit {
  gc_threshold_ref().update(fn(_) { threshold })
}

///|
pub fn set_gc_debug(enabled : Bool) -> Unit {
  gc_debug_ref().update(fn(_) { enabled })
}

///|
fn gc_debug_enabled() -> Bool {
  let mut enabled = false
  gc_debug_ref().update(fn(current) {
    enabled = current
    current
  })
  enabled
}

///|
fn gc_debug_value_has_prop(value : Value, name : String) -> Bool {
  match value {
    Object(obj) => obj.props.get(name) is Some(_)
    Function(func) => func.props.get(name) is Some(_)
    BoundFunction(bound) => bound.props.get(name) is Some(_)
    Builtin(builtin) => builtin.props.get(name) is Some(_)
    _ => false
  }
}

///|
fn gc_debug_prop_value(value : Value, name : String) -> Value? {
  match value {
    Object(obj) =>
      match obj.props.get(name) {
        Some(prop) => Some(prop.value)
        None => None
      }
    Function(func) =>
      match func.props.get(name) {
        Some(prop) => Some(prop.value)
        None => None
      }
    BoundFunction(bound) =>
      match bound.props.get(name) {
        Some(prop) => Some(prop.value)
        None => None
      }
    Builtin(builtin) =>
      match builtin.props.get(name) {
        Some(prop) => Some(prop.value)
        None => None
      }
    _ => None
  }
}

///|
fn gc_debug_dump_roots(phase : String) -> Unit {
  if !gc_debug_enabled() {
    return ()
  }
  let env_len = env_stack().length()
  let func_len = current_function_stack().length()
  let root_len = gc_root_depth()
  let mut root_env_present = false
  let mut current_env_present = false
  let mut global_present = false
  let mut assert_present = false
  let mut deep_equal_present = false
  let mut root_global_present = false
  let mut root_assert_present = false
  let mut root_deep_equal_present = false
  let mut root_binding_assert_present = false
  let mut root_binding_deep_equal_present = false
  let mut current_binding_assert_present = false
  let mut current_binding_deep_equal_present = false
  let mut root_deep_equal_compare_present = false
  let mut current_deep_equal_compare_present = false
  match root_env() {
    Some(env) => {
      root_env_present = true
      match global_object(env) {
        Some(obj) => {
          root_global_present = true
          match obj.props.get("assert") {
            Some(prop) => {
              root_assert_present = true
              if gc_debug_value_has_prop(prop.value, "deepEqual") {
                root_deep_equal_present = true
              }
              match gc_debug_prop_value(prop.value, "deepEqual") {
                Some(value) =>
                  if gc_debug_value_has_prop(value, "_compare") {
                    root_deep_equal_compare_present = true
                  }
                None => ()
              }
            }
            None => ()
          }
        }
        None => ()
      }
      match env.bindings.get("assert") {
        Some(value) => {
          root_binding_assert_present = true
          if gc_debug_value_has_prop(value, "deepEqual") {
            root_binding_deep_equal_present = true
          }
        }
        None => ()
      }
    }
    None => ()
  }
  match current_env() {
    Some(env) => {
      current_env_present = true
      match global_object(env) {
        Some(obj) => {
          global_present = true
          match obj.props.get("assert") {
            Some(prop) => {
              assert_present = true
              if gc_debug_value_has_prop(prop.value, "deepEqual") {
                deep_equal_present = true
              }
              match gc_debug_prop_value(prop.value, "deepEqual") {
                Some(value) =>
                  if gc_debug_value_has_prop(value, "_compare") {
                    current_deep_equal_compare_present = true
                  }
                None => ()
              }
            }
            None => ()
          }
        }
        None => ()
      }
      match env.bindings.get("assert") {
        Some(value) => {
          current_binding_assert_present = true
          if gc_debug_value_has_prop(value, "deepEqual") {
            current_binding_deep_equal_present = true
          }
        }
        None => ()
      }
    }
    None => ()
  }
  let mut alloc_count = 0
  gc_alloc_count_ref().update(fn(current) {
    alloc_count = current
    current
  })
  let mut threshold = 0
  gc_threshold_ref().update(fn(current) {
    threshold = current
    current
  })
  let mut job_len = 0
  job_queue_ref.update(fn(queue) {
    job_len = queue.length()
    queue
  })
  let mut timer_len = 0
  timer_queue_ref.update(fn(queue) {
    timer_len = queue.length()
    queue
  })
  let mut source_path = ""
  match current_source_path() {
    Some(path) => source_path = path
    None => ()
  }
  println(
    "gc_debug \{phase} alloc=\{alloc_count} threshold=\{threshold} envs=\{env_len} funcs=\{func_len} roots=\{root_len} root_env=\{root_env_present} root_global=\{root_global_present} root_assert=\{root_assert_present} root_deepEqual=\{root_deep_equal_present} root_deepCompare=\{root_deep_equal_compare_present} root_bind_assert=\{root_binding_assert_present} root_bind_deepEqual=\{root_binding_deep_equal_present} current_env=\{current_env_present} global=\{global_present} assert=\{assert_present} deepEqual=\{deep_equal_present} deepCompare=\{current_deep_equal_compare_present} bind_assert=\{current_binding_assert_present} bind_deepEqual=\{current_binding_deep_equal_present} jobs=\{job_len} timers=\{timer_len} src=\{source_path}",
  )
}

///|
fn gc_debug_dump_meta_for_value(
  state : GcState,
  label : String,
  value : Value,
) -> Unit {
  if !gc_debug_enabled() {
    return ()
  }
  match value_id(value) {
    Some(id) =>
      match state.meta.get(id) {
        Some(meta) =>
          println(
            "gc_debug_meta \{label} id=\{id} ref=\{meta.ref_count} mark=\{meta.mark} in_tmp=\{meta.in_tmp}",
          )
        None => println("gc_debug_meta \{label} id=\{id} ref=missing")
      }
    None => println("gc_debug_meta \{label} id=none")
  }
}

///|
fn gc_debug_dump_meta_for_env(
  state : GcState,
  label : String,
  env : Env,
) -> Unit {
  if !gc_debug_enabled() {
    return ()
  }
  match state.meta.get(env.id) {
    Some(meta) =>
      println(
        "gc_debug_meta \{label} id=\{env.id} ref=\{meta.ref_count} mark=\{meta.mark} in_tmp=\{meta.in_tmp}",
      )
    None => println("gc_debug_meta \{label} id=\{env.id} ref=missing")
  }
}

///|
fn gc_debug_dump_assert_meta(state : GcState, phase : String) -> Unit {
  if !gc_debug_enabled() {
    return ()
  }
  match root_env() {
    Some(env) => {
      gc_debug_dump_meta_for_env(state, "root_env@\{phase}", env)
      match global_object(env) {
        Some(obj) =>
          match obj.props.get("assert") {
            Some(prop) => {
              let assert_value = prop.value
              gc_debug_dump_meta_for_value(
                state,
                "assert@\{phase}",
                assert_value,
              )
              match gc_debug_prop_value(assert_value, "deepEqual") {
                Some(deep_value) => {
                  gc_debug_dump_meta_for_value(
                    state,
                    "assert.deepEqual@\{phase}",
                    deep_value,
                  )
                  match gc_debug_prop_value(deep_value, "_compare") {
                    Some(compare_value) =>
                      gc_debug_dump_meta_for_value(
                        state,
                        "assert.deepEqual._compare@\{phase}",
                        compare_value,
                      )
                    None =>
                      println(
                        "gc_debug_meta assert.deepEqual._compare missing@\{phase}",
                      )
                  }
                }
                None =>
                  println("gc_debug_meta assert.deepEqual missing@\{phase}")
              }
            }
            None => println("gc_debug_meta assert missing@\{phase}")
          }
        None => println("gc_debug_meta global missing@\{phase}")
      }
    }
    None => println("gc_debug_meta root_env missing@\{phase}")
  }
}

///|
fn object_proto() -> ObjectValue? {
  get_proto_ref(object_proto_ref)
}

///|
fn function_proto() -> Value? {
  get_value_ref(function_proto_ref)
}

///|
fn array_proto() -> ObjectValue? {
  get_proto_ref(array_proto_ref)
}

///|
fn array_buffer_proto() -> ObjectValue? {
  get_proto_ref(array_buffer_proto_ref)
}

///|
fn shared_array_buffer_proto() -> ObjectValue? {
  get_proto_ref(shared_array_buffer_proto_ref)
}

///|
fn dataview_proto() -> ObjectValue? {
  get_proto_ref(dataview_proto_ref)
}

///|
fn typed_array_proto_for_kind(kind : TypedArrayKind) -> ObjectValue? {
  match kind {
    TypedArrayKind::Uint8 => get_proto_ref(uint8_array_proto_ref)
    TypedArrayKind::Int8 => get_proto_ref(int8_array_proto_ref)
    TypedArrayKind::Uint8Clamped => get_proto_ref(uint8_clamped_array_proto_ref)
    TypedArrayKind::Uint16 => get_proto_ref(uint16_array_proto_ref)
    TypedArrayKind::Int16 => get_proto_ref(int16_array_proto_ref)
    TypedArrayKind::Uint32 => get_proto_ref(uint32_array_proto_ref)
    TypedArrayKind::Int32 => get_proto_ref(int32_array_proto_ref)
    TypedArrayKind::BigInt64 => get_proto_ref(bigint64_array_proto_ref)
    TypedArrayKind::BigUint64 => get_proto_ref(biguint64_array_proto_ref)
    TypedArrayKind::Float16 => get_proto_ref(float16_array_proto_ref)
    TypedArrayKind::Float32 => get_proto_ref(float32_array_proto_ref)
    TypedArrayKind::Float64 => get_proto_ref(float64_array_proto_ref)
  }
}

///|
fn string_proto() -> ObjectValue? {
  get_proto_ref(string_proto_ref)
}

///|
fn bool_proto() -> ObjectValue? {
  get_proto_ref(bool_proto_ref)
}

///|
fn number_proto() -> ObjectValue? {
  get_proto_ref(number_proto_ref)
}

///|
fn bigint_proto() -> ObjectValue? {
  get_proto_ref(bigint_proto_ref)
}

///|
fn symbol_proto() -> ObjectValue? {
  get_proto_ref(symbol_proto_ref)
}

///|
fn regexp_proto() -> ObjectValue? {
  get_proto_ref(regexp_proto_ref)
}

///|
fn date_proto() -> ObjectValue? {
  get_proto_ref(date_proto_ref)
}

///|
fn generator_proto() -> ObjectValue? {
  get_proto_ref(generator_proto_ref)
}

///|
fn generator_function_proto() -> ObjectValue? {
  get_proto_ref(generator_function_proto_ref)
}

///|
fn async_function_proto() -> ObjectValue? {
  get_proto_ref(async_function_proto_ref)
}

///|
fn async_generator_proto() -> ObjectValue? {
  get_proto_ref(async_generator_proto_ref)
}

///|
fn async_generator_function_proto() -> ObjectValue? {
  get_proto_ref(async_generator_function_proto_ref)
}

///|
fn iterator_proto() -> ObjectValue? {
  get_proto_ref(iterator_proto_ref)
}

///|
fn async_iterator_proto() -> ObjectValue? {
  get_proto_ref(async_iterator_proto_ref)
}

///|
fn async_from_sync_iterator_proto() -> ObjectValue? {
  get_proto_ref(async_from_sync_iterator_proto_ref)
}

///|
fn iterator_concat_proto() -> ObjectValue? {
  get_proto_ref(iterator_concat_proto_ref)
}

///|
fn iterator_helper_proto() -> ObjectValue? {
  get_proto_ref(iterator_helper_proto_ref)
}

///|
fn iterator_wrap_proto() -> ObjectValue? {
  get_proto_ref(iterator_wrap_proto_ref)
}

///|
fn array_iterator_proto() -> ObjectValue? {
  get_proto_ref(array_iterator_proto_ref)
}

///|
fn string_iterator_proto() -> ObjectValue? {
  get_proto_ref(string_iterator_proto_ref)
}

///|
fn regexp_string_iterator_proto() -> ObjectValue? {
  get_proto_ref(regexp_string_iterator_proto_ref)
}

///|
fn map_iterator_proto() -> ObjectValue? {
  get_proto_ref(map_iterator_proto_ref)
}

///|
fn set_iterator_proto() -> ObjectValue? {
  get_proto_ref(set_iterator_proto_ref)
}

///|
fn map_proto() -> ObjectValue? {
  get_proto_ref(map_proto_ref)
}

///|
fn set_proto() -> ObjectValue? {
  get_proto_ref(set_proto_ref_cell)
}

///|
fn weakmap_proto() -> ObjectValue? {
  get_proto_ref(weakmap_proto_ref)
}

///|
fn weakset_proto() -> ObjectValue? {
  get_proto_ref(weakset_proto_ref_cell)
}

///|
fn weakref_proto() -> ObjectValue? {
  get_proto_ref(weakref_proto_ref)
}

///|
fn finreg_proto() -> ObjectValue? {
  get_proto_ref(finreg_proto_ref)
}

///|
fn promise_proto() -> ObjectValue? {
  get_proto_ref(promise_proto_ref)
}

///|
fn error_proto() -> ObjectValue? {
  get_proto_ref(error_proto_ref)
}

///|
fn aggregate_error_proto() -> ObjectValue? {
  get_proto_ref(aggregate_error_proto_ref)
}

///|
fn eval_error_proto() -> ObjectValue? {
  get_proto_ref(eval_error_proto_ref)
}

///|
fn syntax_error_proto() -> ObjectValue? {
  get_proto_ref(syntax_error_proto_ref)
}

///|
fn range_error_proto() -> ObjectValue? {
  get_proto_ref(range_error_proto_ref)
}

///|
fn type_error_proto() -> ObjectValue? {
  get_proto_ref(type_error_proto_ref)
}

///|
fn reference_error_proto() -> ObjectValue? {
  get_proto_ref(reference_error_proto_ref)
}

///|
fn uri_error_proto() -> ObjectValue? {
  get_proto_ref(uri_error_proto_ref)
}

///|
pub fn Env::new(parent : Env?) -> Env {
  let strict = match parent {
    Some(parent_env) => parent_env.strict
    None => false
  }
  let new_target = match parent {
    Some(parent_env) => parent_env.new_target
    None => Undefined
  }
  let allow_new_target = match parent {
    Some(parent_env) => parent_env.allow_new_target
    None => false
  }
  let allow_super = match parent {
    Some(parent_env) => parent_env.allow_super
    None => false
  }
  let allow_super_call = match parent {
    Some(parent_env) => parent_env.allow_super_call
    None => false
  }
  let env = Env::{
    id: alloc_id(),
    parent,
    bindings: @hashmap.new(),
    readonly_bindings: @hashmap.new(),
    deletable_bindings: @hashmap.new(),
    private_bindings: @hashmap.new(),
    strict,
    with_object: None,
    var_object: None,
    new_target,
    allow_new_target,
    allow_super,
    allow_super_call,
    this_uninitialized: false,
    is_param_env: false,
    is_catch_env: false,
    param_binding_names: @hashmap.new(),
    uninitialized_bindings: @hashmap.new(),
    var_env: None,
  }
  register_env(env)
  env
}

///|
pub fn reset_runtime_state() -> Unit {
  run_gc_without_weak()
  gc_release_all()
  gc_alloc_count_ref().update(fn(_) { 0 })
  gc_threshold_ref().update(fn(_) { gc_default_threshold })
  gc_value_root_ref().update(fn(_) { [] })
  gc_pending_ref().update(fn(_) { false })
  id_ref.update(fn(_) { 1 })
  symbol_registry_ref.update(fn(_) { Map::new() })
  symbol_table_ref.update(fn(_) { Map::new() })
  symbol_iterator_ref.update(fn(_) { None })
  symbol_to_string_tag_ref.update(fn(_) { None })
  symbol_async_iterator_ref.update(fn(_) { None })
  symbol_has_instance_ref.update(fn(_) { None })
  symbol_is_concat_spreadable_ref.update(fn(_) { None })
  symbol_match_ref.update(fn(_) { None })
  symbol_match_all_ref.update(fn(_) { None })
  symbol_replace_ref.update(fn(_) { None })
  symbol_search_ref.update(fn(_) { None })
  symbol_species_ref.update(fn(_) { None })
  symbol_split_ref.update(fn(_) { None })
  symbol_to_primitive_ref.update(fn(_) { None })
  symbol_unscopables_ref.update(fn(_) { None })
  throw_type_error_ref.update(fn(_) { Map::new() })
  template_registry_ref.update(fn(_) { Map::new() })
  annex_b_var_func_decls_ref.update(fn(_) { [] })
  top_level_func_decls_ref.update(fn(_) { [] })
  object_proto_ref.update(fn(_) { None })
  function_proto_ref.update(fn(_) { None })
  array_proto_ref.update(fn(_) { None })
  string_proto_ref.update(fn(_) { None })
  dataview_proto_ref.update(fn(_) { None })
  typed_array_proto_ref.update(fn(_) { None })
  uint8_array_proto_ref.update(fn(_) { None })
  int8_array_proto_ref.update(fn(_) { None })
  uint8_clamped_array_proto_ref.update(fn(_) { None })
  uint16_array_proto_ref.update(fn(_) { None })
  int16_array_proto_ref.update(fn(_) { None })
  uint32_array_proto_ref.update(fn(_) { None })
  int32_array_proto_ref.update(fn(_) { None })
  bigint64_array_proto_ref.update(fn(_) { None })
  biguint64_array_proto_ref.update(fn(_) { None })
  float16_array_proto_ref.update(fn(_) { None })
  float32_array_proto_ref.update(fn(_) { None })
  float64_array_proto_ref.update(fn(_) { None })
  bool_proto_ref.update(fn(_) { None })
  number_proto_ref.update(fn(_) { None })
  bigint_proto_ref.update(fn(_) { None })
  symbol_proto_ref.update(fn(_) { None })
  regexp_proto_ref.update(fn(_) { None })
  date_proto_ref.update(fn(_) { None })
  generator_proto_ref.update(fn(_) { None })
  generator_function_proto_ref.update(fn(_) { None })
  async_function_proto_ref.update(fn(_) { None })
  generator_function_ctor_ref.update(fn(_) { None })
  async_generator_proto_ref.update(fn(_) { None })
  async_generator_function_proto_ref.update(fn(_) { None })
  async_generator_function_ctor_ref.update(fn(_) { None })
  iterator_proto_ref.update(fn(_) { None })
  async_iterator_proto_ref.update(fn(_) { None })
  async_from_sync_iterator_proto_ref.update(fn(_) { None })
  generator_proto_env_ref.update(fn(_) { Map::new() })
  async_generator_proto_env_ref.update(fn(_) { Map::new() })
  generator_function_ctor_env_ref.update(fn(_) { Map::new() })
  async_generator_function_ctor_env_ref.update(fn(_) { Map::new() })
  async_function_ctor_env_ref.update(fn(_) { Map::new() })
  promise_ctor_env_ref.update(fn(_) { Map::new() })
  async_iterator_proto_env_ref.update(fn(_) { Map::new() })
  iterator_concat_proto_ref.update(fn(_) { None })
  iterator_helper_proto_ref.update(fn(_) { None })
  iterator_wrap_proto_ref.update(fn(_) { None })
  array_iterator_proto_ref.update(fn(_) { None })
  string_iterator_proto_ref.update(fn(_) { None })
  regexp_string_iterator_proto_ref.update(fn(_) { None })
  map_iterator_proto_ref.update(fn(_) { None })
  set_iterator_proto_ref.update(fn(_) { None })
  map_proto_ref.update(fn(_) { None })
  set_proto_ref_cell.update(fn(_) { None })
  weakmap_proto_ref.update(fn(_) { None })
  weakset_proto_ref_cell.update(fn(_) { None })
  weakref_proto_ref.update(fn(_) { None })
  finreg_proto_ref.update(fn(_) { None })
  promise_proto_ref.update(fn(_) { None })
  error_proto_ref.update(fn(_) { None })
  aggregate_error_proto_ref.update(fn(_) { None })
  eval_error_proto_ref.update(fn(_) { None })
  syntax_error_proto_ref.update(fn(_) { None })
  range_error_proto_ref.update(fn(_) { None })
  type_error_proto_ref.update(fn(_) { None })
  reference_error_proto_ref.update(fn(_) { None })
  uri_error_proto_ref.update(fn(_) { None })
  root_env_ref.update(fn(_) { None })
  env_stack_ref.update(fn(_) { [] })
  source_stack_ref.update(fn(_) { [] })
  expr_pos_stack_ref.update(fn(_) { [] })
  source_path_stack_ref.update(fn(_) { [] })
  math_rand_state_ref.update(fn(_) { 0x6a09e667f3bcc909UL })
  current_function_stack_ref.update(fn(_) { [] })
  current_generator_data_ref.update(fn(_) { None })
  print_log_ref().update(fn(_) { [] })
  async_done_ref().update(fn(_) { 0 })
  promise_table_ref.update(fn(_) { Map::new() })
  promise_resolve_func_data_ref.update(fn(_) { Map::new() })
  promise_executor_data_ref.update(fn(_) { Map::new() })
  promise_all_element_data_ref.update(fn(_) { Map::new() })
  promise_then_finally_data_ref.update(fn(_) { Map::new() })
  async_from_sync_unwrap_data_ref.update(fn(_) { Map::new() })
  async_from_sync_close_wrap_data_ref.update(fn(_) { Map::new() })
  async_generator_resolve_func_data_ref.update(fn(_) { Map::new() })
  async_function_resolve_func_data_ref.update(fn(_) { Map::new() })
  async_function_data_ref.update(fn(_) { Map::new() })
  promise_finally_value_data_ref.update(fn(_) { Map::new() })
  job_queue_ref.update(fn(_) { [] })
  timer_queue_ref.update(fn(_) { [] })
  next_timer_id_ref.update(fn(_) { 1 })
  worker_table_ref.update(fn(_) { Map::new() })
  next_worker_id_ref.update(fn(_) { 1 })
  agent_table_ref.update(fn(_) { Map::new() })
  agent_report_queue_ref.update(fn(_) { [] })
  agent_lock_queue_ref.update(fn(_) { [] })
  agent_spin_load_ref.update(fn(_) { Map::new() })
  next_agent_id_ref.update(fn(_) { 1 })
  current_agent_id_ref.update(fn(_) { None })
  agent_clock_ref.update(fn(_) { 0 })
  can_block_ref().update(fn(_) { true })
  atomics_waiter_table_ref.update(fn(_) { Map::new() })
  atomics_waiter_list_ref.update(fn(_) { [] })
  atomics_waiter_next_id_ref.update(fn(_) { 1 })
  atomics_waiter_stack_ref.update(fn(_) { Map::new() })
  atomics_notify_time_ref.update(fn(_) { Map::new() })
  module_table_ref.update(fn(_) { Map::new() })
  module_exports_stack_ref.update(fn(_) { [] })
  module_export_info_ref.update(fn(_) { Map::new() })
  module_eval_info_ref.update(fn(_) { Map::new() })
  module_async_eval_timestamp_ref.update(fn(_) { 1 })
  module_async_callback_data_ref.update(fn(_) { Map::new() })
  module_import_dynamic_job_data_ref.update(fn(_) { Map::new() })
  module_builtin_namespace_ref.update(fn(_) { Map::new() })
  module_env_stack_ref.update(fn(_) { [] })
  module_import_stack_ref.update(fn(_) { [] })
  module_env_exports_ref.update(fn(_) { Map::new() })
  module_env_exports_by_obj_ref.update(fn(_) { Map::new() })
  module_env_export_names_ref.update(fn(_) { Map::new() })
  module_env_export_uninitialized_ref.update(fn(_) { Map::new() })
  module_env_ref.update(fn(_) { Map::new() })
}

///|
pub fn set_can_block(flag : Bool) -> Unit {
  can_block_ref().update(fn(_) { flag })
}

///|
fn can_block() -> Bool {
  let mut value = true
  can_block_ref().update(fn(current) {
    value = current
    current
  })
  value
}

///|
pub fn Vm::new() -> Vm {
  let runtime = RuntimeState::new()
  let _ = set_current_runtime_state(runtime)
  let env = Env::new(None)
  set_root_env(env)
  let object_proto_value = new_object_value_with_proto(None)
  let object_proto_obj = match object_proto_value {
    Object(obj) => obj
    _ => new_object_struct(None)
  }
  object_proto_obj.immutable_proto = true
  set_proto_ref(object_proto_ref, Some(object_proto_obj))
  let function_proto_props = Map::new()
  function_proto_props.set("length", property_data_readonly(Number(0.0)))
  function_proto_props.set("name", property_data_readonly(String("")))
  let function_proto_value = {
    let func = register_function_value(FunctionValue::{
      name: None,
      source: None,
      source_root: None,
      source_path: None,
      line_number: None,
      column_number: None,
      local_name_binding: false,
      params: [],
      param_inits: [],
      body: [],
      env,
      id: alloc_id(),
      props: function_proto_props,
      proto: Some(Object(object_proto_obj)),
      home_object: None,
      super_constructor: None,
      instance_fields: [],
      private_instance_fields: [],
      private_instance_props: Map::new(),
      is_constructor: false,
      is_class_constructor: false,
      is_default_constructor: false,
      extensible: true,
      is_strict: false,
      is_generator: false,
      is_async: false,
      is_arrow: false,
      in_class_field_init: false,
    })
    Function(func)
  }
  set_value_ref(function_proto_ref, Some(function_proto_value))
  let throw_type_error = throw_type_error_value_for_env(env)
  match function_proto_value {
    Function(func) => {
      func.props.set(
        "caller",
        property_accessor(throw_type_error, throw_type_error),
      )
      func.props.set(
        "arguments",
        property_accessor(throw_type_error, throw_type_error),
      )
      func.props.set(
        "call",
        property_data_non_enum(new_builtin_value(BuiltinFunction::FunctionCall)),
      )
      func.props.set(
        "apply",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::FunctionApply),
        ),
      )
      func.props.set(
        "bind",
        property_data_non_enum(new_builtin_value(BuiltinFunction::FunctionBind)),
      )
      func.props.set(
        "toString",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::FunctionToString),
        ),
      )
      func.props.set(
        "lineNumber",
        property_accessor(
          new_builtin_value(BuiltinFunction::FunctionProtoLineNumber),
          Undefined,
        ),
      )
      func.props.set(
        "columnNumber",
        property_accessor(
          new_builtin_value(BuiltinFunction::FunctionProtoColumnNumber),
          Undefined,
        ),
      )
    }
    _ => ()
  }
  let generator_function_proto_value = new_object_value_with_proto(
    function_proto(),
  )
  let generator_function_proto_obj = match generator_function_proto_value {
    Object(obj) => obj
    _ => new_object_struct(function_proto())
  }
  set_proto_ref(
    generator_function_proto_ref,
    Some(generator_function_proto_obj),
  )
  let generator_function_ctor_value = new_object_value_with_proto(
    function_proto(),
  )
  let generator_function_ctor_obj = match generator_function_ctor_value {
    Object(obj) => obj
    _ => new_object_struct(function_proto())
  }
  set_proto_ref(generator_function_ctor_ref, Some(generator_function_ctor_obj))
  generator_function_ctor_obj.props.set(
    "prototype",
    property_data_const(Object(generator_function_proto_obj)),
  )
  generator_function_proto_obj.props.set(
    "constructor",
    property_data_non_enum(Object(generator_function_ctor_obj)),
  )
  let async_generator_function_proto_value = new_object_value_with_proto(
    function_proto(),
  )
  let async_generator_function_proto_obj = match
    async_generator_function_proto_value {
    Object(obj) => obj
    _ => new_object_struct(function_proto())
  }
  set_proto_ref(
    async_generator_function_proto_ref,
    Some(async_generator_function_proto_obj),
  )
  let async_generator_function_ctor_value = new_object_value_with_proto(
    function_proto(),
  )
  let async_generator_function_ctor_obj = match
    async_generator_function_ctor_value {
    Object(obj) => obj
    _ => new_object_struct(function_proto())
  }
  set_proto_ref(
    async_generator_function_ctor_ref,
    Some(async_generator_function_ctor_obj),
  )
  async_generator_function_ctor_obj.props.set(
    "prototype",
    property_data_const(Object(async_generator_function_proto_obj)),
  )
  async_generator_function_proto_obj.props.set(
    "constructor",
    property_data_non_enum(Object(async_generator_function_ctor_obj)),
  )
  let async_function_proto_value = new_object_value_with_proto(function_proto())
  let async_function_proto_obj = match async_function_proto_value {
    Object(obj) => obj
    _ => new_object_struct(function_proto())
  }
  set_proto_ref(async_function_proto_ref, Some(async_function_proto_obj))
  let array_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let array_proto_obj = match array_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(array_proto_ref, Some(array_proto_obj))
  array_proto_obj.props.set("length", Property::{
    value: Number(0.0),
    writable: true,
    configurable: false,
    enumerable: false,
    getter: None,
    setter: None,
  })
  array_proto_obj.props.set(
    "toString",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayToString)),
  )
  array_proto_obj.props.set(
    "toLocaleString",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::ArrayToLocaleString),
    ),
  )
  array_proto_obj.props.set(
    "at",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayAt)),
  )
  array_proto_obj.props.set(
    "push",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayPush)),
  )
  array_proto_obj.props.set(
    "pop",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayPop)),
  )
  array_proto_obj.props.set(
    "shift",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayShift)),
  )
  array_proto_obj.props.set(
    "unshift",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayUnshift)),
  )
  array_proto_obj.props.set(
    "splice",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArraySplice)),
  )
  array_proto_obj.props.set(
    "slice",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArraySlice)),
  )
  array_proto_obj.props.set(
    "reverse",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayReverse)),
  )
  array_proto_obj.props.set(
    "concat",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayConcat)),
  )
  array_proto_obj.props.set(
    "join",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayJoin)),
  )
  array_proto_obj.props.set(
    "indexOf",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayIndexOf)),
  )
  array_proto_obj.props.set(
    "lastIndexOf",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayLastIndexOf)),
  )
  array_proto_obj.props.set(
    "includes",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayIncludes)),
  )
  array_proto_obj.props.set(
    "copyWithin",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayCopyWithin)),
  )
  array_proto_obj.props.set(
    "fill",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayFill)),
  )
  array_proto_obj.props.set(
    "find",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayFind)),
  )
  array_proto_obj.props.set(
    "findIndex",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayFindIndex)),
  )
  array_proto_obj.props.set(
    "findLast",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayFindLast)),
  )
  array_proto_obj.props.set(
    "findLastIndex",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::ArrayFindLastIndex),
    ),
  )
  array_proto_obj.props.set(
    "flat",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayFlat)),
  )
  array_proto_obj.props.set(
    "flatMap",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayFlatMap)),
  )
  array_proto_obj.props.set(
    "toReversed",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayToReversed)),
  )
  array_proto_obj.props.set(
    "toSorted",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayToSorted)),
  )
  array_proto_obj.props.set(
    "toSpliced",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayToSpliced)),
  )
  array_proto_obj.props.set(
    "with",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayWith)),
  )
  array_proto_obj.props.set(
    "map",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayMap)),
  )
  array_proto_obj.props.set(
    "forEach",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayForEach)),
  )
  array_proto_obj.props.set(
    "filter",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayFilter)),
  )
  array_proto_obj.props.set(
    "every",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayEvery)),
  )
  array_proto_obj.props.set(
    "some",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArraySome)),
  )
  array_proto_obj.props.set(
    "reduce",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayReduce)),
  )
  array_proto_obj.props.set(
    "reduceRight",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayReduceRight)),
  )
  array_proto_obj.props.set(
    "sort",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArraySort)),
  )
  let array_values_func = new_builtin_value(BuiltinFunction::ArrayValues)
  array_proto_obj.props.set("values", property_data_non_enum(array_values_func))
  array_proto_obj.props.set(
    "keys",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayKeys)),
  )
  array_proto_obj.props.set(
    "entries",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayEntries)),
  )
  match symbol_iterator_key() {
    Some(key) =>
      array_proto_obj.props.set(key, property_data_non_enum(array_values_func))
    None => ()
  }
  let array_buffer_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let array_buffer_proto_obj = match array_buffer_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(array_buffer_proto_ref, Some(array_buffer_proto_obj))
  set_accessor_property_with_enum(
    array_buffer_proto_obj.props,
    "byteLength",
    Some(new_builtin_value(BuiltinFunction::ArrayBufferByteLength)),
    None,
    false,
  )
  set_accessor_property_with_enum(
    array_buffer_proto_obj.props,
    "maxByteLength",
    Some(new_builtin_value(BuiltinFunction::ArrayBufferMaxByteLength)),
    None,
    false,
  )
  set_accessor_property_with_enum(
    array_buffer_proto_obj.props,
    "resizable",
    Some(new_builtin_value(BuiltinFunction::ArrayBufferResizable)),
    None,
    false,
  )
  set_accessor_property_with_enum(
    array_buffer_proto_obj.props,
    "detached",
    Some(new_builtin_value(BuiltinFunction::ArrayBufferDetached)),
    None,
    false,
  )
  array_buffer_proto_obj.props.set(
    "resize",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::ArrayBufferResize),
    ),
  )
  array_buffer_proto_obj.props.set(
    "slice",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayBufferSlice)),
  )
  array_buffer_proto_obj.props.set(
    "transfer",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::ArrayBufferTransfer),
    ),
  )
  array_buffer_proto_obj.props.set(
    "transferToFixedLength",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::ArrayBufferTransferToFixedLength),
    ),
  )
  let shared_array_buffer_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let shared_array_buffer_proto_obj = match shared_array_buffer_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(
    shared_array_buffer_proto_ref,
    Some(shared_array_buffer_proto_obj),
  )
  set_accessor_property_with_enum(
    shared_array_buffer_proto_obj.props,
    "byteLength",
    Some(new_builtin_value(BuiltinFunction::SharedArrayBufferByteLength)),
    None,
    false,
  )
  set_accessor_property_with_enum(
    shared_array_buffer_proto_obj.props,
    "maxByteLength",
    Some(new_builtin_value(BuiltinFunction::SharedArrayBufferMaxByteLength)),
    None,
    false,
  )
  set_accessor_property_with_enum(
    shared_array_buffer_proto_obj.props,
    "growable",
    Some(new_builtin_value(BuiltinFunction::SharedArrayBufferGrowable)),
    None,
    false,
  )
  shared_array_buffer_proto_obj.props.set(
    "grow",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::SharedArrayBufferGrow),
    ),
  )
  shared_array_buffer_proto_obj.props.set(
    "slice",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::SharedArrayBufferSlice),
    ),
  )
  let dataview_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let dataview_proto_obj = match dataview_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(dataview_proto_ref, Some(dataview_proto_obj))
  set_accessor_property_with_enum(
    dataview_proto_obj.props,
    "buffer",
    Some(new_builtin_value(BuiltinFunction::DataViewGetBuffer)),
    None,
    false,
  )
  set_accessor_property_with_enum(
    dataview_proto_obj.props,
    "byteLength",
    Some(new_builtin_value(BuiltinFunction::DataViewGetByteLength)),
    None,
    false,
  )
  set_accessor_property_with_enum(
    dataview_proto_obj.props,
    "byteOffset",
    Some(new_builtin_value(BuiltinFunction::DataViewGetByteOffset)),
    None,
    false,
  )
  dataview_proto_obj.props.set(
    "getInt8",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DataViewGetInt8)),
  )
  dataview_proto_obj.props.set(
    "getUint8",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DataViewGetUint8)),
  )
  dataview_proto_obj.props.set(
    "getInt16",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DataViewGetInt16)),
  )
  dataview_proto_obj.props.set(
    "getUint16",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DataViewGetUint16),
    ),
  )
  dataview_proto_obj.props.set(
    "getInt32",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DataViewGetInt32)),
  )
  dataview_proto_obj.props.set(
    "getUint32",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DataViewGetUint32),
    ),
  )
  dataview_proto_obj.props.set(
    "getBigInt64",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DataViewGetBigInt64),
    ),
  )
  dataview_proto_obj.props.set(
    "getBigUint64",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DataViewGetBigUint64),
    ),
  )
  dataview_proto_obj.props.set(
    "getFloat16",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DataViewGetFloat16),
    ),
  )
  dataview_proto_obj.props.set(
    "getFloat32",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DataViewGetFloat32),
    ),
  )
  dataview_proto_obj.props.set(
    "getFloat64",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DataViewGetFloat64),
    ),
  )
  dataview_proto_obj.props.set(
    "setInt8",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DataViewSetInt8)),
  )
  dataview_proto_obj.props.set(
    "setUint8",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DataViewSetUint8)),
  )
  dataview_proto_obj.props.set(
    "setInt16",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DataViewSetInt16)),
  )
  dataview_proto_obj.props.set(
    "setUint16",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DataViewSetUint16),
    ),
  )
  dataview_proto_obj.props.set(
    "setInt32",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DataViewSetInt32)),
  )
  dataview_proto_obj.props.set(
    "setUint32",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DataViewSetUint32),
    ),
  )
  dataview_proto_obj.props.set(
    "setBigInt64",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DataViewSetBigInt64),
    ),
  )
  dataview_proto_obj.props.set(
    "setBigUint64",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DataViewSetBigUint64),
    ),
  )
  dataview_proto_obj.props.set(
    "setFloat16",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DataViewSetFloat16),
    ),
  )
  dataview_proto_obj.props.set(
    "setFloat32",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DataViewSetFloat32),
    ),
  )
  dataview_proto_obj.props.set(
    "setFloat64",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DataViewSetFloat64),
    ),
  )
  let typed_array_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let typed_array_proto_obj = match typed_array_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(typed_array_proto_ref, Some(typed_array_proto_obj))
  let string_proto_value = {
    let obj = register_object_value(ObjectValue::{
      id: alloc_id(),
      props: Map::new(),
      proto: Some(Object(object_proto_obj)),
      string_data: Some(""),
      number_data: None,
      bool_data: None,
      bigint_data: None,
      symbol_data: None,
      regexp_data: None,
      generator_data: None,
      async_generator_data: None,
      proxy_data: None,
      map_data: None,
      set_data: None,
      map_iter_data: None,
      set_iter_data: None,
      iterator_wrap_data: None,
      iterator_concat_data: None,
      iterator_helper_data: None,
      weakmap_data: None,
      weakset_data: None,
      weakref_data: None,
      finreg_data: None,
      date_data: None,
      array_buffer_data: None,
      dataview_data: None,
      is_html_dda: false,
      is_error: false,
      is_module_namespace: false,
      realm_env: None,
      immutable_proto: false,
      extensible: true,
    })
    Object(obj)
  }
  let string_proto_obj = match string_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(string_proto_ref, Some(string_proto_obj))
  string_proto_obj.props.set(
    "charCodeAt",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringCharCodeAt)),
  )
  string_proto_obj.props.set(
    "charAt",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringCharAt)),
  )
  string_proto_obj.props.set(
    "codePointAt",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::StringCodePointAt),
    ),
  )
  string_proto_obj.props.set(
    "at",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringAt)),
  )
  string_proto_obj.props.set(
    "concat",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringConcat)),
  )
  string_proto_obj.props.set(
    "substring",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringSubstring)),
  )
  string_proto_obj.props.set(
    "substr",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringSubstr)),
  )
  string_proto_obj.props.set(
    "slice",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringSlice)),
  )
  string_proto_obj.props.set(
    "indexOf",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringIndexOf)),
  )
  string_proto_obj.props.set(
    "lastIndexOf",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::StringLastIndexOf),
    ),
  )
  string_proto_obj.props.set(
    "includes",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringIncludes)),
  )
  string_proto_obj.props.set(
    "startsWith",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringStartsWith)),
  )
  string_proto_obj.props.set(
    "endsWith",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringEndsWith)),
  )
  string_proto_obj.props.set(
    "match",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringMatch)),
  )
  string_proto_obj.props.set(
    "matchAll",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringMatchAll)),
  )
  string_proto_obj.props.set(
    "search",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringSearch)),
  )
  string_proto_obj.props.set(
    "split",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringSplit)),
  )
  string_proto_obj.props.set(
    "padStart",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringPadStart)),
  )
  string_proto_obj.props.set(
    "padEnd",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringPadEnd)),
  )
  string_proto_obj.props.set(
    "repeat",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringRepeat)),
  )
  string_proto_obj.props.set(
    "replace",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringReplace)),
  )
  string_proto_obj.props.set(
    "replaceAll",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringReplaceAll)),
  )
  string_proto_obj.props.set(
    "trim",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringTrim)),
  )
  let trim_start = new_builtin_value(BuiltinFunction::StringTrimStart)
  let trim_end = new_builtin_value(BuiltinFunction::StringTrimEnd)
  string_proto_obj.props.set("trimStart", property_data_non_enum(trim_start))
  string_proto_obj.props.set("trimEnd", property_data_non_enum(trim_end))
  string_proto_obj.props.set("trimLeft", property_data_non_enum(trim_start))
  string_proto_obj.props.set("trimRight", property_data_non_enum(trim_end))
  string_proto_obj.props.set(
    "toLowerCase",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::StringToLowerCase),
    ),
  )
  string_proto_obj.props.set(
    "toUpperCase",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::StringToUpperCase),
    ),
  )
  string_proto_obj.props.set(
    "toLocaleLowerCase",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::StringToLocaleLowerCase),
    ),
  )
  string_proto_obj.props.set(
    "toLocaleUpperCase",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::StringToLocaleUpperCase),
    ),
  )
  string_proto_obj.props.set(
    "localeCompare",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::StringLocaleCompare),
    ),
  )
  string_proto_obj.props.set(
    "normalize",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringNormalize)),
  )
  string_proto_obj.props.set(
    "isWellFormed",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::StringIsWellFormed),
    ),
  )
  string_proto_obj.props.set(
    "toWellFormed",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::StringToWellFormed),
    ),
  )
  string_proto_obj.props.set(
    "toString",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringToString)),
  )
  string_proto_obj.props.set(
    "valueOf",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringValueOf)),
  )
  string_proto_obj.props.set(
    "anchor",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringAnchor)),
  )
  string_proto_obj.props.set(
    "big",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringBig)),
  )
  string_proto_obj.props.set(
    "blink",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringBlink)),
  )
  string_proto_obj.props.set(
    "bold",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringBold)),
  )
  string_proto_obj.props.set(
    "fixed",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringFixed)),
  )
  string_proto_obj.props.set(
    "fontcolor",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringFontcolor)),
  )
  string_proto_obj.props.set(
    "fontsize",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringFontsize)),
  )
  string_proto_obj.props.set(
    "italics",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringItalics)),
  )
  string_proto_obj.props.set(
    "link",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringLink)),
  )
  string_proto_obj.props.set(
    "small",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringSmall)),
  )
  string_proto_obj.props.set(
    "strike",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringStrike)),
  )
  string_proto_obj.props.set(
    "sub",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringSub)),
  )
  string_proto_obj.props.set(
    "sup",
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringSup)),
  )
  match symbol_iterator_key() {
    Some(key) =>
      string_proto_obj.props.set(
        key,
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::StringIterator),
        ),
      )
    None => ()
  }
  let number_proto_value = {
    let obj = register_object_value(ObjectValue::{
      id: alloc_id(),
      props: Map::new(),
      proto: Some(Object(object_proto_obj)),
      string_data: None,
      number_data: Some(0.0),
      bool_data: None,
      bigint_data: None,
      symbol_data: None,
      regexp_data: None,
      generator_data: None,
      async_generator_data: None,
      proxy_data: None,
      map_data: None,
      set_data: None,
      map_iter_data: None,
      set_iter_data: None,
      iterator_wrap_data: None,
      iterator_concat_data: None,
      iterator_helper_data: None,
      weakmap_data: None,
      weakset_data: None,
      weakref_data: None,
      finreg_data: None,
      date_data: None,
      array_buffer_data: None,
      dataview_data: None,
      is_html_dda: false,
      is_error: false,
      is_module_namespace: false,
      realm_env: None,
      immutable_proto: false,
      extensible: true,
    })
    Object(obj)
  }
  let number_proto_obj = match number_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(number_proto_ref, Some(number_proto_obj))
  number_proto_obj.props.set(
    "toString",
    property_data_non_enum(new_builtin_value(BuiltinFunction::NumberToString)),
  )
  number_proto_obj.props.set(
    "toLocaleString",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::NumberToLocaleString),
    ),
  )
  number_proto_obj.props.set(
    "toFixed",
    property_data_non_enum(new_builtin_value(BuiltinFunction::NumberToFixed)),
  )
  number_proto_obj.props.set(
    "toExponential",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::NumberToExponential),
    ),
  )
  number_proto_obj.props.set(
    "toPrecision",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::NumberToPrecision),
    ),
  )
  number_proto_obj.props.set(
    "valueOf",
    property_data_non_enum(new_builtin_value(BuiltinFunction::NumberValueOf)),
  )
  let bool_proto_value = {
    let obj = register_object_value(ObjectValue::{
      id: alloc_id(),
      props: Map::new(),
      proto: Some(Object(object_proto_obj)),
      string_data: None,
      number_data: None,
      bool_data: Some(false),
      bigint_data: None,
      symbol_data: None,
      regexp_data: None,
      generator_data: None,
      async_generator_data: None,
      proxy_data: None,
      map_data: None,
      set_data: None,
      map_iter_data: None,
      set_iter_data: None,
      iterator_wrap_data: None,
      iterator_concat_data: None,
      iterator_helper_data: None,
      weakmap_data: None,
      weakset_data: None,
      weakref_data: None,
      finreg_data: None,
      date_data: None,
      array_buffer_data: None,
      dataview_data: None,
      is_html_dda: false,
      is_error: false,
      is_module_namespace: false,
      realm_env: None,
      immutable_proto: false,
      extensible: true,
    })
    Object(obj)
  }
  let bool_proto_obj = match bool_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(bool_proto_ref, Some(bool_proto_obj))
  bool_proto_obj.props.set(
    "toString",
    property_data_non_enum(new_builtin_value(BuiltinFunction::BooleanToString)),
  )
  bool_proto_obj.props.set(
    "valueOf",
    property_data_non_enum(new_builtin_value(BuiltinFunction::BooleanValueOf)),
  )
  let bigint_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let bigint_proto_obj = match bigint_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(bigint_proto_ref, Some(bigint_proto_obj))
  match symbol_to_string_tag_key() {
    Some(key) =>
      bigint_proto_obj.props.set(key, property_data_readonly(String("BigInt")))
    None => ()
  }
  bigint_proto_obj.props.set(
    "toString",
    property_data_non_enum(new_builtin_value(BuiltinFunction::BigIntToString)),
  )
  bigint_proto_obj.props.set(
    "valueOf",
    property_data_non_enum(new_builtin_value(BuiltinFunction::BigIntValueOf)),
  )
  let symbol_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let symbol_proto_obj = match symbol_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(symbol_proto_ref, Some(symbol_proto_obj))
  symbol_proto_obj.props.set(
    "toString",
    property_data_non_enum(new_builtin_value(BuiltinFunction::SymbolToString)),
  )
  symbol_proto_obj.props.set(
    "valueOf",
    property_data_non_enum(new_builtin_value(BuiltinFunction::SymbolValueOf)),
  )
  let regexp_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let regexp_proto_obj = match regexp_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(regexp_proto_ref, Some(regexp_proto_obj))
  regexp_proto_obj.props.set(
    "exec",
    property_data_non_enum(new_builtin_value(BuiltinFunction::RegExpExec)),
  )
  regexp_proto_obj.props.set(
    "test",
    property_data_non_enum(new_builtin_value(BuiltinFunction::RegExpTest)),
  )
  regexp_proto_obj.props.set(
    "toString",
    property_data_non_enum(new_builtin_value(BuiltinFunction::RegExpToString)),
  )
  regexp_proto_obj.props.set(
    "compile",
    property_data_non_enum(new_builtin_value(BuiltinFunction::RegExpCompile)),
  )
  set_accessor_property_with_enum(
    regexp_proto_obj.props,
    "flags",
    Some(new_builtin_value(BuiltinFunction::RegExpGetFlags)),
    None,
    false,
  )
  set_accessor_property_with_enum(
    regexp_proto_obj.props,
    "source",
    Some(new_builtin_value(BuiltinFunction::RegExpGetSource)),
    None,
    false,
  )
  set_accessor_property_with_enum(
    regexp_proto_obj.props,
    "global",
    Some(new_builtin_value(BuiltinFunction::RegExpGetGlobal)),
    None,
    false,
  )
  set_accessor_property_with_enum(
    regexp_proto_obj.props,
    "ignoreCase",
    Some(new_builtin_value(BuiltinFunction::RegExpGetIgnoreCase)),
    None,
    false,
  )
  set_accessor_property_with_enum(
    regexp_proto_obj.props,
    "multiline",
    Some(new_builtin_value(BuiltinFunction::RegExpGetMultiline)),
    None,
    false,
  )
  set_accessor_property_with_enum(
    regexp_proto_obj.props,
    "dotAll",
    Some(new_builtin_value(BuiltinFunction::RegExpGetDotAll)),
    None,
    false,
  )
  set_accessor_property_with_enum(
    regexp_proto_obj.props,
    "unicode",
    Some(new_builtin_value(BuiltinFunction::RegExpGetUnicode)),
    None,
    false,
  )
  set_accessor_property_with_enum(
    regexp_proto_obj.props,
    "unicodeSets",
    Some(new_builtin_value(BuiltinFunction::RegExpGetUnicodeSets)),
    None,
    false,
  )
  set_accessor_property_with_enum(
    regexp_proto_obj.props,
    "sticky",
    Some(new_builtin_value(BuiltinFunction::RegExpGetSticky)),
    None,
    false,
  )
  set_accessor_property_with_enum(
    regexp_proto_obj.props,
    "hasIndices",
    Some(new_builtin_value(BuiltinFunction::RegExpGetHasIndices)),
    None,
    false,
  )
  let date_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let date_proto_obj = match date_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(date_proto_ref, Some(date_proto_obj))
  date_proto_obj.props.set(
    "toISOString",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateToISOString)),
  )
  date_proto_obj.props.set(
    "toString",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateToString)),
  )
  date_proto_obj.props.set(
    "valueOf",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateValueOf)),
  )
  let date_to_utc_func = new_builtin_value(BuiltinFunction::DateToUTCString)
  date_proto_obj.props.set(
    "toUTCString",
    property_data_non_enum(date_to_utc_func),
  )
  date_proto_obj.props.set(
    "toGMTString",
    property_data_non_enum(date_to_utc_func),
  )
  date_proto_obj.props.set(
    "toDateString",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateToDateString)),
  )
  date_proto_obj.props.set(
    "toTimeString",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateToTimeString)),
  )
  date_proto_obj.props.set(
    "toLocaleString",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DateToLocaleString),
    ),
  )
  date_proto_obj.props.set(
    "toLocaleDateString",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DateToLocaleDateString),
    ),
  )
  date_proto_obj.props.set(
    "toLocaleTimeString",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DateToLocaleTimeString),
    ),
  )
  date_proto_obj.props.set(
    "toJSON",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateToJSON)),
  )
  date_proto_obj.props.set(
    "getTimezoneOffset",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DateGetTimezoneOffset),
    ),
  )
  date_proto_obj.props.set(
    "getTime",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateGetTime)),
  )
  date_proto_obj.props.set(
    "getYear",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateGetYear)),
  )
  date_proto_obj.props.set(
    "getFullYear",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateGetFullYear)),
  )
  date_proto_obj.props.set(
    "getUTCFullYear",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DateGetUTCFullYear),
    ),
  )
  date_proto_obj.props.set(
    "getMonth",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateGetMonth)),
  )
  date_proto_obj.props.set(
    "getUTCMonth",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateGetUTCMonth)),
  )
  date_proto_obj.props.set(
    "getDate",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateGetDate)),
  )
  date_proto_obj.props.set(
    "getUTCDate",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateGetUTCDate)),
  )
  date_proto_obj.props.set(
    "getDay",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateGetDay)),
  )
  date_proto_obj.props.set(
    "getUTCDay",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateGetUTCDay)),
  )
  date_proto_obj.props.set(
    "getHours",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateGetHours)),
  )
  date_proto_obj.props.set(
    "getUTCHours",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateGetUTCHours)),
  )
  date_proto_obj.props.set(
    "getMinutes",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateGetMinutes)),
  )
  date_proto_obj.props.set(
    "getUTCMinutes",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DateGetUTCMinutes),
    ),
  )
  date_proto_obj.props.set(
    "getSeconds",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateGetSeconds)),
  )
  date_proto_obj.props.set(
    "getUTCSeconds",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DateGetUTCSeconds),
    ),
  )
  date_proto_obj.props.set(
    "getMilliseconds",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DateGetMilliseconds),
    ),
  )
  date_proto_obj.props.set(
    "getUTCMilliseconds",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DateGetUTCMilliseconds),
    ),
  )
  date_proto_obj.props.set(
    "setTime",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateSetTime)),
  )
  date_proto_obj.props.set(
    "setMilliseconds",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DateSetMilliseconds),
    ),
  )
  date_proto_obj.props.set(
    "setUTCMilliseconds",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DateSetUTCMilliseconds),
    ),
  )
  date_proto_obj.props.set(
    "setSeconds",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateSetSeconds)),
  )
  date_proto_obj.props.set(
    "setUTCSeconds",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DateSetUTCSeconds),
    ),
  )
  date_proto_obj.props.set(
    "setMinutes",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateSetMinutes)),
  )
  date_proto_obj.props.set(
    "setUTCMinutes",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DateSetUTCMinutes),
    ),
  )
  date_proto_obj.props.set(
    "setHours",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateSetHours)),
  )
  date_proto_obj.props.set(
    "setUTCHours",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateSetUTCHours)),
  )
  date_proto_obj.props.set(
    "setDate",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateSetDate)),
  )
  date_proto_obj.props.set(
    "setUTCDate",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateSetUTCDate)),
  )
  date_proto_obj.props.set(
    "setMonth",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateSetMonth)),
  )
  date_proto_obj.props.set(
    "setUTCMonth",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateSetUTCMonth)),
  )
  date_proto_obj.props.set(
    "setYear",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateSetYear)),
  )
  date_proto_obj.props.set(
    "setFullYear",
    property_data_non_enum(new_builtin_value(BuiltinFunction::DateSetFullYear)),
  )
  date_proto_obj.props.set(
    "setUTCFullYear",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::DateSetUTCFullYear),
    ),
  )
  let generator_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let generator_proto_obj = match generator_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(generator_proto_ref, Some(generator_proto_obj))
  generator_function_proto_obj.props.set(
    "prototype",
    property_data_readonly(Object(generator_proto_obj)),
  )
  generator_proto_obj.props.set(
    "constructor",
    property_data_readonly(Object(generator_function_proto_obj)),
  )
  match symbol_to_string_tag_key() {
    Some(key) =>
      generator_proto_obj.props.set(
        key,
        property_data_readonly(String("Generator")),
      )
    None => ()
  }
  generator_proto_obj.props.set(
    "next",
    property_data_non_enum(new_builtin_value(BuiltinFunction::GeneratorNext)),
  )
  generator_proto_obj.props.set(
    "return",
    property_data_non_enum(new_builtin_value(BuiltinFunction::GeneratorReturn)),
  )
  generator_proto_obj.props.set(
    "throw",
    property_data_non_enum(new_builtin_value(BuiltinFunction::GeneratorThrow)),
  )
  let async_generator_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let async_generator_proto_obj = match async_generator_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(async_generator_proto_ref, Some(async_generator_proto_obj))
  async_generator_function_proto_obj.props.set(
    "prototype",
    property_data_readonly(Object(async_generator_proto_obj)),
  )
  async_generator_proto_obj.props.set(
    "constructor",
    property_data_readonly(Object(async_generator_function_proto_obj)),
  )
  match symbol_to_string_tag_key() {
    Some(key) =>
      async_generator_proto_obj.props.set(
        key,
        property_data_readonly(String("AsyncGenerator")),
      )
    None => ()
  }
  async_generator_proto_obj.props.set(
    "next",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::AsyncGeneratorNext),
    ),
  )
  async_generator_proto_obj.props.set(
    "return",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::AsyncGeneratorReturn),
    ),
  )
  async_generator_proto_obj.props.set(
    "throw",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::AsyncGeneratorThrow),
    ),
  )
  match symbol_async_iterator_key() {
    Some(key) =>
      async_generator_proto_obj.props.set(
        key,
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::AsyncIteratorReturnSelf),
        ),
      )
    None => ()
  }
  let iterator_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let iterator_proto_obj = match iterator_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  generator_proto_obj.proto = Some(Object(iterator_proto_obj))
  set_proto_ref(iterator_proto_ref, Some(iterator_proto_obj))
  let async_iterator_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let async_iterator_proto_obj = match async_iterator_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(async_iterator_proto_ref, Some(async_iterator_proto_obj))
  async_generator_proto_obj.proto = value_from_object(async_iterator_proto())
  let async_from_sync_iterator_proto_value = new_object_value_with_proto(
    value_from_object(async_iterator_proto()),
  )
  let async_from_sync_iterator_proto_obj = match
    async_from_sync_iterator_proto_value {
    Object(obj) => obj
    _ => new_object_struct(value_from_object(async_iterator_proto()))
  }
  set_proto_ref(
    async_from_sync_iterator_proto_ref,
    Some(async_from_sync_iterator_proto_obj),
  )
  async_from_sync_iterator_proto_obj.props.set(
    "next",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::AsyncFromSyncIteratorNext),
    ),
  )
  async_from_sync_iterator_proto_obj.props.set(
    "return",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::AsyncFromSyncIteratorReturn),
    ),
  )
  async_from_sync_iterator_proto_obj.props.set(
    "throw",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::AsyncFromSyncIteratorThrow),
    ),
  )
  iterator_proto_obj.props.set(
    "drop",
    property_data_non_enum(new_builtin_value(BuiltinFunction::IteratorDrop)),
  )
  iterator_proto_obj.props.set(
    "filter",
    property_data_non_enum(new_builtin_value(BuiltinFunction::IteratorFilter)),
  )
  iterator_proto_obj.props.set(
    "flatMap",
    property_data_non_enum(new_builtin_value(BuiltinFunction::IteratorFlatMap)),
  )
  iterator_proto_obj.props.set(
    "map",
    property_data_non_enum(new_builtin_value(BuiltinFunction::IteratorMap)),
  )
  iterator_proto_obj.props.set(
    "take",
    property_data_non_enum(new_builtin_value(BuiltinFunction::IteratorTake)),
  )
  iterator_proto_obj.props.set(
    "every",
    property_data_non_enum(new_builtin_value(BuiltinFunction::IteratorEvery)),
  )
  iterator_proto_obj.props.set(
    "find",
    property_data_non_enum(new_builtin_value(BuiltinFunction::IteratorFind)),
  )
  iterator_proto_obj.props.set(
    "forEach",
    property_data_non_enum(new_builtin_value(BuiltinFunction::IteratorForEach)),
  )
  iterator_proto_obj.props.set(
    "some",
    property_data_non_enum(new_builtin_value(BuiltinFunction::IteratorSome)),
  )
  iterator_proto_obj.props.set(
    "reduce",
    property_data_non_enum(new_builtin_value(BuiltinFunction::IteratorReduce)),
  )
  iterator_proto_obj.props.set(
    "toArray",
    property_data_non_enum(new_builtin_value(BuiltinFunction::IteratorToArray)),
  )
  iterator_proto_obj.props.set("constructor", Property::{
    value: Undefined,
    writable: false,
    configurable: true,
    enumerable: false,
    getter: Some(new_builtin_value(BuiltinFunction::IteratorConstructorGetter)),
    setter: Some(new_builtin_value(BuiltinFunction::IteratorConstructorSetter)),
  })
  match generator_proto() {
    Some(obj) => obj.proto = value_from_object(iterator_proto())
    None => ()
  }
  let iterator_helper_proto_value = new_object_value_with_proto(
    Some(Object(iterator_proto_obj)),
  )
  let iterator_helper_proto_obj = match iterator_helper_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(iterator_proto_obj)))
  }
  set_proto_ref(iterator_helper_proto_ref, Some(iterator_helper_proto_obj))
  iterator_helper_proto_obj.props.set(
    "next",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::IteratorHelperNext),
    ),
  )
  iterator_helper_proto_obj.props.set(
    "return",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::IteratorHelperReturn),
    ),
  )
  let iterator_concat_proto_value = new_object_value_with_proto(
    Some(Object(iterator_helper_proto_obj)),
  )
  let iterator_concat_proto_obj = match iterator_concat_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(iterator_helper_proto_obj)))
  }
  set_proto_ref(iterator_concat_proto_ref, Some(iterator_concat_proto_obj))
  iterator_concat_proto_obj.props.set(
    "next",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::IteratorConcatNext),
    ),
  )
  iterator_concat_proto_obj.props.set(
    "return",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::IteratorConcatReturn),
    ),
  )
  let iterator_wrap_proto_value = new_object_value_with_proto(
    Some(Object(iterator_proto_obj)),
  )
  let iterator_wrap_proto_obj = match iterator_wrap_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(iterator_proto_obj)))
  }
  set_proto_ref(iterator_wrap_proto_ref, Some(iterator_wrap_proto_obj))
  iterator_wrap_proto_obj.props.set(
    "next",
    property_data_non_enum(new_builtin_value(BuiltinFunction::IteratorWrapNext)),
  )
  iterator_wrap_proto_obj.props.set(
    "return",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::IteratorWrapReturn),
    ),
  )
  let array_iterator_proto_value = new_object_value_with_proto(
    Some(Object(iterator_proto_obj)),
  )
  let array_iterator_proto_obj = match array_iterator_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(iterator_proto_obj)))
  }
  set_proto_ref(array_iterator_proto_ref, Some(array_iterator_proto_obj))
  array_iterator_proto_obj.props.set(
    "next",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::ArrayIteratorNext),
    ),
  )
  let string_iterator_proto_value = new_object_value_with_proto(
    Some(Object(iterator_proto_obj)),
  )
  let string_iterator_proto_obj = match string_iterator_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(iterator_proto_obj)))
  }
  set_proto_ref(string_iterator_proto_ref, Some(string_iterator_proto_obj))
  string_iterator_proto_obj.props.set(
    "next",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::StringIteratorNext),
    ),
  )
  let regexp_string_iterator_proto_value = new_object_value_with_proto(
    Some(Object(iterator_proto_obj)),
  )
  let regexp_string_iterator_proto_obj = match
    regexp_string_iterator_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(iterator_proto_obj)))
  }
  set_proto_ref(
    regexp_string_iterator_proto_ref,
    Some(regexp_string_iterator_proto_obj),
  )
  regexp_string_iterator_proto_obj.props.set(
    "next",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::RegExpStringIteratorNext),
    ),
  )
  let map_iterator_proto_value = new_object_value_with_proto(
    Some(Object(iterator_proto_obj)),
  )
  let map_iterator_proto_obj = match map_iterator_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(iterator_proto_obj)))
  }
  set_proto_ref(map_iterator_proto_ref, Some(map_iterator_proto_obj))
  map_iterator_proto_obj.props.set(
    "next",
    property_data_non_enum(new_builtin_value(BuiltinFunction::MapIteratorNext)),
  )
  let set_iterator_proto_value = new_object_value_with_proto(
    Some(Object(iterator_proto_obj)),
  )
  let set_iterator_proto_obj = match set_iterator_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(iterator_proto_obj)))
  }
  set_proto_ref(set_iterator_proto_ref, Some(set_iterator_proto_obj))
  set_iterator_proto_obj.props.set(
    "next",
    property_data_non_enum(new_builtin_value(BuiltinFunction::SetIteratorNext)),
  )
  let map_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let map_proto_obj = match map_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(map_proto_ref, Some(map_proto_obj))
  map_proto_obj.props.set(
    "get",
    property_data_non_enum(new_builtin_value(BuiltinFunction::MapGet)),
  )
  map_proto_obj.props.set(
    "getOrInsert",
    property_data_non_enum(new_builtin_value(BuiltinFunction::MapGetOrInsert)),
  )
  map_proto_obj.props.set(
    "getOrInsertComputed",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::MapGetOrInsertComputed),
    ),
  )
  map_proto_obj.props.set(
    "set",
    property_data_non_enum(new_builtin_value(BuiltinFunction::MapSet)),
  )
  map_proto_obj.props.set(
    "has",
    property_data_non_enum(new_builtin_value(BuiltinFunction::MapHas)),
  )
  map_proto_obj.props.set(
    "delete",
    property_data_non_enum(new_builtin_value(BuiltinFunction::MapDelete)),
  )
  map_proto_obj.props.set(
    "forEach",
    property_data_non_enum(new_builtin_value(BuiltinFunction::MapForEach)),
  )
  map_proto_obj.props.set(
    "clear",
    property_data_non_enum(new_builtin_value(BuiltinFunction::MapClear)),
  )
  let map_keys_func = new_builtin_value(BuiltinFunction::MapKeys)
  let map_values_func = new_builtin_value(BuiltinFunction::MapValues)
  let map_entries_func = new_builtin_value(BuiltinFunction::MapEntries)
  map_proto_obj.props.set("keys", property_data_non_enum(map_keys_func))
  map_proto_obj.props.set("values", property_data_non_enum(map_values_func))
  map_proto_obj.props.set("entries", property_data_non_enum(map_entries_func))
  match symbol_iterator_key() {
    Some(key) =>
      map_proto_obj.props.set(key, property_data_non_enum(map_entries_func))
    None => ()
  }
  map_proto_obj.props.set("size", Property::{
    value: Undefined,
    writable: false,
    configurable: true,
    enumerable: false,
    getter: Some(new_builtin_value(BuiltinFunction::MapSize)),
    setter: None,
  })
  let set_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let set_proto_obj = match set_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(set_proto_ref_cell, Some(set_proto_obj))
  set_proto_obj.props.set(
    "add",
    property_data_non_enum(new_builtin_value(BuiltinFunction::SetAdd)),
  )
  set_proto_obj.props.set(
    "has",
    property_data_non_enum(new_builtin_value(BuiltinFunction::SetHas)),
  )
  set_proto_obj.props.set(
    "delete",
    property_data_non_enum(new_builtin_value(BuiltinFunction::SetDelete)),
  )
  set_proto_obj.props.set(
    "clear",
    property_data_non_enum(new_builtin_value(BuiltinFunction::SetClear)),
  )
  set_proto_obj.props.set(
    "forEach",
    property_data_non_enum(new_builtin_value(BuiltinFunction::SetForEach)),
  )
  set_proto_obj.props.set(
    "isDisjointFrom",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::SetIsDisjointFrom),
    ),
  )
  set_proto_obj.props.set(
    "isSubsetOf",
    property_data_non_enum(new_builtin_value(BuiltinFunction::SetIsSubsetOf)),
  )
  set_proto_obj.props.set(
    "isSupersetOf",
    property_data_non_enum(new_builtin_value(BuiltinFunction::SetIsSupersetOf)),
  )
  set_proto_obj.props.set(
    "intersection",
    property_data_non_enum(new_builtin_value(BuiltinFunction::SetIntersection)),
  )
  set_proto_obj.props.set(
    "difference",
    property_data_non_enum(new_builtin_value(BuiltinFunction::SetDifference)),
  )
  set_proto_obj.props.set(
    "symmetricDifference",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::SetSymmetricDifference),
    ),
  )
  set_proto_obj.props.set(
    "union",
    property_data_non_enum(new_builtin_value(BuiltinFunction::SetUnion)),
  )
  let set_values_func = new_builtin_value(BuiltinFunction::SetValues)
  let set_entries_func = new_builtin_value(BuiltinFunction::SetEntries)
  set_proto_obj.props.set("values", property_data_non_enum(set_values_func))
  set_proto_obj.props.set("keys", property_data_non_enum(set_values_func))
  set_proto_obj.props.set("entries", property_data_non_enum(set_entries_func))
  match symbol_iterator_key() {
    Some(key) =>
      set_proto_obj.props.set(key, property_data_non_enum(set_values_func))
    None => ()
  }
  set_proto_obj.props.set("size", Property::{
    value: Undefined,
    writable: false,
    configurable: true,
    enumerable: false,
    getter: Some(new_builtin_value(BuiltinFunction::SetSize)),
    setter: None,
  })
  let weakmap_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let weakmap_proto_obj = match weakmap_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(weakmap_proto_ref, Some(weakmap_proto_obj))
  weakmap_proto_obj.props.set(
    "get",
    property_data_non_enum(new_builtin_value(BuiltinFunction::WeakMapGet)),
  )
  weakmap_proto_obj.props.set(
    "getOrInsert",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::WeakMapGetOrInsert),
    ),
  )
  weakmap_proto_obj.props.set(
    "getOrInsertComputed",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::WeakMapGetOrInsertComputed),
    ),
  )
  weakmap_proto_obj.props.set(
    "set",
    property_data_non_enum(new_builtin_value(BuiltinFunction::WeakMapSet)),
  )
  weakmap_proto_obj.props.set(
    "has",
    property_data_non_enum(new_builtin_value(BuiltinFunction::WeakMapHas)),
  )
  weakmap_proto_obj.props.set(
    "delete",
    property_data_non_enum(new_builtin_value(BuiltinFunction::WeakMapDelete)),
  )
  let weakset_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let weakset_proto_obj = match weakset_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(weakset_proto_ref_cell, Some(weakset_proto_obj))
  weakset_proto_obj.props.set(
    "add",
    property_data_non_enum(new_builtin_value(BuiltinFunction::WeakSetAdd)),
  )
  weakset_proto_obj.props.set(
    "has",
    property_data_non_enum(new_builtin_value(BuiltinFunction::WeakSetHas)),
  )
  weakset_proto_obj.props.set(
    "delete",
    property_data_non_enum(new_builtin_value(BuiltinFunction::WeakSetDelete)),
  )
  let weakref_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let weakref_proto_obj = match weakref_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(weakref_proto_ref, Some(weakref_proto_obj))
  weakref_proto_obj.props.set(
    "deref",
    property_data_non_enum(new_builtin_value(BuiltinFunction::WeakRefDeref)),
  )
  match symbol_to_string_tag_key() {
    Some(key) =>
      weakref_proto_obj.props.set(
        key,
        property_data_readonly(String("WeakRef")),
      )
    None => ()
  }
  let finreg_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let finreg_proto_obj = match finreg_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(finreg_proto_ref, Some(finreg_proto_obj))
  finreg_proto_obj.props.set(
    "register",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::FinalizationRegistryRegister),
    ),
  )
  finreg_proto_obj.props.set(
    "unregister",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::FinalizationRegistryUnregister),
    ),
  )
  match symbol_to_string_tag_key() {
    Some(key) =>
      finreg_proto_obj.props.set(
        key,
        property_data_readonly(String("FinalizationRegistry")),
      )
    None => ()
  }
  let promise_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let promise_proto_obj = match promise_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(promise_proto_ref, Some(promise_proto_obj))
  match symbol_to_string_tag_key() {
    Some(key) =>
      promise_proto_obj.props.set(
        key,
        property_data_readonly(String("Promise")),
      )
    None => ()
  }
  promise_proto_obj.props.set(
    "then",
    property_data_non_enum(new_builtin_value(BuiltinFunction::PromiseThen)),
  )
  promise_proto_obj.props.set(
    "catch",
    property_data_non_enum(new_builtin_value(BuiltinFunction::PromiseCatch)),
  )
  promise_proto_obj.props.set(
    "finally",
    property_data_non_enum(new_builtin_value(BuiltinFunction::PromiseFinally)),
  )
  let error_proto_value = new_object_value_with_proto(
    Some(Object(object_proto_obj)),
  )
  let error_proto_obj = match error_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(object_proto_obj)))
  }
  set_proto_ref(error_proto_ref, Some(error_proto_obj))
  error_proto_obj.props.set("name", property_data_non_enum(String("Error")))
  error_proto_obj.props.set("message", property_data_non_enum(String("")))
  let aggregate_error_proto_value = new_object_value_with_proto(
    Some(Object(error_proto_obj)),
  )
  let aggregate_error_proto_obj = match aggregate_error_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(error_proto_obj)))
  }
  set_proto_ref(aggregate_error_proto_ref, Some(aggregate_error_proto_obj))
  aggregate_error_proto_obj.props.set(
    "name",
    property_data_non_enum(String("AggregateError")),
  )
  aggregate_error_proto_obj.props.set(
    "message",
    property_data_non_enum(String("")),
  )
  let eval_error_proto_value = new_object_value_with_proto(
    Some(Object(error_proto_obj)),
  )
  let eval_error_proto_obj = match eval_error_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(error_proto_obj)))
  }
  set_proto_ref(eval_error_proto_ref, Some(eval_error_proto_obj))
  eval_error_proto_obj.props.set(
    "name",
    property_data_non_enum(String("EvalError")),
  )
  eval_error_proto_obj.props.set("message", property_data_non_enum(String("")))
  let syntax_error_proto_value = new_object_value_with_proto(
    Some(Object(error_proto_obj)),
  )
  let syntax_error_proto_obj = match syntax_error_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(error_proto_obj)))
  }
  set_proto_ref(syntax_error_proto_ref, Some(syntax_error_proto_obj))
  syntax_error_proto_obj.props.set(
    "name",
    property_data_non_enum(String("SyntaxError")),
  )
  syntax_error_proto_obj.props.set(
    "message",
    property_data_non_enum(String("")),
  )
  let range_error_proto_value = new_object_value_with_proto(
    Some(Object(error_proto_obj)),
  )
  let range_error_proto_obj = match range_error_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(error_proto_obj)))
  }
  set_proto_ref(range_error_proto_ref, Some(range_error_proto_obj))
  range_error_proto_obj.props.set(
    "name",
    property_data_non_enum(String("RangeError")),
  )
  range_error_proto_obj.props.set("message", property_data_non_enum(String("")))
  let type_error_proto_value = new_object_value_with_proto(
    Some(Object(error_proto_obj)),
  )
  let type_error_proto_obj = match type_error_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(error_proto_obj)))
  }
  set_proto_ref(type_error_proto_ref, Some(type_error_proto_obj))
  type_error_proto_obj.props.set(
    "name",
    property_data_non_enum(String("TypeError")),
  )
  type_error_proto_obj.props.set("message", property_data_non_enum(String("")))
  let reference_error_proto_value = new_object_value_with_proto(
    Some(Object(error_proto_obj)),
  )
  let reference_error_proto_obj = match reference_error_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(error_proto_obj)))
  }
  set_proto_ref(reference_error_proto_ref, Some(reference_error_proto_obj))
  reference_error_proto_obj.props.set(
    "name",
    property_data_non_enum(String("ReferenceError")),
  )
  reference_error_proto_obj.props.set(
    "message",
    property_data_non_enum(String("")),
  )
  let uri_error_proto_value = new_object_value_with_proto(
    Some(Object(error_proto_obj)),
  )
  let uri_error_proto_obj = match uri_error_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(error_proto_obj)))
  }
  set_proto_ref(uri_error_proto_ref, Some(uri_error_proto_obj))
  uri_error_proto_obj.props.set(
    "name",
    property_data_non_enum(String("URIError")),
  )
  uri_error_proto_obj.props.set("message", property_data_non_enum(String("")))
  let global = new_object_value_with_proto(Some(Object(object_proto_obj)))
  env.bindings.set("this", global)
  let object_ctor = new_builtin_value(BuiltinFunction::ObjectConstructor)
  match object_ctor {
    Builtin(builtin) => {
      builtin.props.set("prototype", property_data_const(object_proto_value))
      builtin.props.set(
        "defineProperty",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ObjectDefineProperty),
        ),
      )
      builtin.props.set(
        "defineProperties",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ObjectDefineProperties),
        ),
      )
      builtin.props.set(
        "getOwnPropertyDescriptor",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ObjectGetOwnPropertyDescriptor),
        ),
      )
      builtin.props.set(
        "getOwnPropertyNames",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ObjectGetOwnPropertyNames),
        ),
      )
      builtin.props.set(
        "getOwnPropertySymbols",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ObjectGetOwnPropertySymbols),
        ),
      )
      builtin.props.set(
        "getPrototypeOf",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ObjectGetPrototypeOf),
        ),
      )
      builtin.props.set(
        "setPrototypeOf",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ObjectSetPrototypeOf),
        ),
      )
      builtin.props.set(
        "create",
        property_data_non_enum(new_builtin_value(BuiltinFunction::ObjectCreate)),
      )
      builtin.props.set(
        "keys",
        property_data_non_enum(new_builtin_value(BuiltinFunction::ObjectKeys)),
      )
      builtin.props.set(
        "values",
        property_data_non_enum(new_builtin_value(BuiltinFunction::ObjectValues)),
      )
      builtin.props.set(
        "entries",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ObjectEntries),
        ),
      )
      builtin.props.set(
        "groupBy",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ObjectGroupBy),
        ),
      )
      builtin.props.set(
        "is",
        property_data_non_enum(new_builtin_value(BuiltinFunction::ObjectIs)),
      )
      builtin.props.set(
        "isExtensible",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ObjectIsExtensible),
        ),
      )
      builtin.props.set(
        "preventExtensions",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ObjectPreventExtensions),
        ),
      )
      builtin.props.set(
        "seal",
        property_data_non_enum(new_builtin_value(BuiltinFunction::ObjectSeal)),
      )
      builtin.props.set(
        "isSealed",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ObjectIsSealed),
        ),
      )
      builtin.props.set(
        "isFrozen",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ObjectIsFrozen),
        ),
      )
      builtin.props.set(
        "freeze",
        property_data_non_enum(new_builtin_value(BuiltinFunction::ObjectFreeze)),
      )
      builtin.props.set(
        "getOwnPropertyDescriptors",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ObjectGetOwnPropertyDescriptors),
        ),
      )
      builtin.props.set(
        "fromEntries",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ObjectFromEntries),
        ),
      )
      builtin.props.set(
        "assign",
        property_data_non_enum(new_builtin_value(BuiltinFunction::ObjectAssign)),
      )
      builtin.props.set(
        "hasOwn",
        property_data_non_enum(new_builtin_value(BuiltinFunction::ObjectHasOwn)),
      )
    }
    _ => ()
  }
  object_proto_obj.props.set("constructor", property_data_non_enum(object_ctor))
  object_proto_obj.props.set(
    "toString",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ObjectToString)),
  )
  object_proto_obj.props.set(
    "toLocaleString",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::ObjectToLocaleString),
    ),
  )
  object_proto_obj.props.set(
    "valueOf",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ObjectValueOf)),
  )
  object_proto_obj.props.set(
    "hasOwnProperty",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::ObjectHasOwnProperty),
    ),
  )
  object_proto_obj.props.set(
    "propertyIsEnumerable",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::ObjectPropertyIsEnumerable),
    ),
  )
  object_proto_obj.props.set(
    "isPrototypeOf",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::ObjectIsPrototypeOf),
    ),
  )
  object_proto_obj.props.set(
    "__defineGetter__",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::ObjectDefineGetter),
    ),
  )
  object_proto_obj.props.set(
    "__defineSetter__",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::ObjectDefineSetter),
    ),
  )
  object_proto_obj.props.set(
    "__lookupGetter__",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::ObjectLookupGetter),
    ),
  )
  object_proto_obj.props.set(
    "__lookupSetter__",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::ObjectLookupSetter),
    ),
  )
  set_accessor_property_with_enum(
    object_proto_obj.props,
    "__proto__",
    Some(new_builtin_value(BuiltinFunction::ObjectProtoGet)),
    Some(new_builtin_value(BuiltinFunction::ObjectProtoSet)),
    false,
  )
  let function_ctor = new_builtin_value(BuiltinFunction::FunctionConstructor)
  match function_ctor {
    Builtin(builtin) =>
      builtin.props.set("prototype", property_data_const(function_proto_value))
    _ => ()
  }
  match function_proto_value {
    Function(func) =>
      func.props.set("constructor", property_data_non_enum(function_ctor))
    Builtin(builtin) =>
      builtin.props.set("constructor", property_data_non_enum(function_ctor))
    _ => ()
  }
  let generator_function_ctor = new_builtin_value(
    BuiltinFunction::GeneratorFunctionConstructor,
  )
  match generator_function_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(function_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(Object(generator_function_proto_obj)),
      )
    }
    _ => ()
  }
  generator_function_proto_obj.props.set(
    "constructor",
    property_data_readonly(generator_function_ctor),
  )
  let async_generator_function_ctor = new_builtin_value(
    BuiltinFunction::AsyncGeneratorFunctionConstructor,
  )
  match async_generator_function_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(function_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(Object(async_generator_function_proto_obj)),
      )
    }
    _ => ()
  }
  async_generator_function_proto_obj.props.set(
    "constructor",
    property_data_readonly(async_generator_function_ctor),
  )
  let async_function_ctor = new_builtin_value(
    BuiltinFunction::AsyncFunctionConstructor,
  )
  match async_function_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(function_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(Object(async_function_proto_obj)),
      )
    }
    _ => ()
  }
  async_function_proto_obj.props.set(
    "constructor",
    property_data_readonly(async_function_ctor),
  )
  let string_ctor = new_builtin_value(BuiltinFunction::StringConstructor)
  match string_ctor {
    Builtin(builtin) => {
      builtin.props.set("prototype", property_data_const(string_proto_value))
      builtin.props.set(
        "fromCharCode",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::StringFromCharCode),
        ),
      )
      builtin.props.set(
        "fromCodePoint",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::StringFromCodePoint),
        ),
      )
      builtin.props.set(
        "raw",
        property_data_non_enum(new_builtin_value(BuiltinFunction::StringRaw)),
      )
    }
    _ => ()
  }
  string_proto_obj.props.set("constructor", property_data_non_enum(string_ctor))
  let parse_int_func = new_builtin_value(BuiltinFunction::ParseInt)
  let parse_float_func = new_builtin_value(BuiltinFunction::ParseFloat)
  let number_ctor = new_builtin_value(BuiltinFunction::NumberConstructor)
  match number_ctor {
    Builtin(builtin) => {
      builtin.props.set("prototype", property_data_const(number_proto_value))
      builtin.props.set("parseInt", property_data_non_enum(parse_int_func))
      builtin.props.set("parseFloat", property_data_non_enum(parse_float_func))
      builtin.props.set(
        "isNaN",
        property_data_non_enum(new_builtin_value(BuiltinFunction::NumberIsNaN)),
      )
      builtin.props.set(
        "isFinite",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::NumberIsFinite),
        ),
      )
      builtin.props.set(
        "isInteger",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::NumberIsInteger),
        ),
      )
      builtin.props.set(
        "isSafeInteger",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::NumberIsSafeInteger),
        ),
      )
      builtin.props.set(
        "MAX_VALUE",
        property_data_const(Number(1.7976931348623157e308)),
      )
      builtin.props.set(
        "MIN_VALUE",
        property_data_const(Number(number_min_value())),
      )
      builtin.props.set("NaN", property_data_const(Number(nan())))
      builtin.props.set(
        "NEGATIVE_INFINITY",
        property_data_const(Number(0.0 - inf())),
      )
      builtin.props.set("POSITIVE_INFINITY", property_data_const(Number(inf())))
      builtin.props.set(
        "EPSILON",
        property_data_const(Number(number_epsilon())),
      )
      builtin.props.set(
        "MAX_SAFE_INTEGER",
        property_data_const(Number(9007199254740991.0)),
      )
      builtin.props.set(
        "MIN_SAFE_INTEGER",
        property_data_const(Number(-9007199254740991.0)),
      )
    }
    _ => ()
  }
  number_proto_obj.props.set("constructor", property_data_non_enum(number_ctor))
  let bool_ctor = new_builtin_value(BuiltinFunction::BooleanConstructor)
  match bool_ctor {
    Builtin(builtin) =>
      builtin.props.set("prototype", property_data_const(bool_proto_value))
    _ => ()
  }
  bool_proto_obj.props.set("constructor", property_data_non_enum(bool_ctor))
  let bigint_ctor = new_builtin_value(BuiltinFunction::BigIntConstructor)
  match bigint_ctor {
    Builtin(builtin) => {
      builtin.props.set("prototype", property_data_const(bigint_proto_value))
      builtin.props.set(
        "asIntN",
        property_data_non_enum(new_builtin_value(BuiltinFunction::BigIntAsIntN)),
      )
      builtin.props.set(
        "asUintN",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::BigIntAsUintN),
        ),
      )
    }
    _ => ()
  }
  bigint_proto_obj.props.set("constructor", property_data_non_enum(bigint_ctor))
  let symbol_ctor = new_builtin_value(BuiltinFunction::SymbolConstructor)
  match symbol_ctor {
    Builtin(builtin) => {
      builtin.props.set("prototype", property_data_const(symbol_proto_value))
      builtin.props.set(
        "for",
        property_data_non_enum(new_builtin_value(BuiltinFunction::SymbolFor)),
      )
      builtin.props.set(
        "keyFor",
        property_data_non_enum(new_builtin_value(BuiltinFunction::SymbolKeyFor)),
      )
    }
    _ => ()
  }
  symbol_proto_obj.props.set("constructor", property_data_non_enum(symbol_ctor))
  let iterator_ctor = new_builtin_value(BuiltinFunction::IteratorConstructor)
  match iterator_ctor {
    Builtin(builtin) => {
      builtin.props.set(
        "prototype",
        property_data_const(Object(iterator_proto_obj)),
      )
      builtin.props.set(
        "from",
        property_data_non_enum(new_builtin_value(BuiltinFunction::IteratorFrom)),
      )
      builtin.props.set(
        "concat",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::IteratorConcat),
        ),
      )
    }
    _ => ()
  }
  let symbol_iterator = SymbolValue::{
    id: alloc_symbol_id(),
    description: Some("Symbol.iterator"),
    key: None,
  }
  register_symbol(symbol_iterator)
  symbol_iterator_ref.update(fn(_) { Some(symbol_iterator) })
  let iterator_key = symbol_prop_key(symbol_iterator)
  let symbol_to_string_tag = SymbolValue::{
    id: alloc_symbol_id(),
    description: Some("Symbol.toStringTag"),
    key: None,
  }
  register_symbol(symbol_to_string_tag)
  symbol_to_string_tag_ref.update(fn(_) { Some(symbol_to_string_tag) })
  let to_string_tag_key = symbol_prop_key(symbol_to_string_tag)
  match iterator_proto() {
    Some(obj) => {
      obj.props.set(to_string_tag_key, Property::{
        value: Undefined,
        writable: false,
        configurable: true,
        enumerable: false,
        getter: Some(
          new_builtin_value(BuiltinFunction::IteratorToStringTagGetter),
        ),
        setter: Some(
          new_builtin_value(BuiltinFunction::IteratorToStringTagSetter),
        ),
      })
      obj.props.set(
        iterator_key,
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::IteratorReturnSelf),
        ),
      )
    }
    None => ()
  }
  match iterator_helper_proto() {
    Some(obj) =>
      obj.props.set(
        to_string_tag_key,
        property_data_readonly(String("Iterator Helper")),
      )
    None => ()
  }
  match array_iterator_proto() {
    Some(obj) =>
      obj.props.set(
        to_string_tag_key,
        property_data_readonly(String("Array Iterator")),
      )
    None => ()
  }
  match string_iterator_proto() {
    Some(obj) =>
      obj.props.set(
        to_string_tag_key,
        property_data_readonly(String("String Iterator")),
      )
    None => ()
  }
  match regexp_string_iterator_proto() {
    Some(obj) =>
      obj.props.set(
        to_string_tag_key,
        property_data_readonly(String("RegExp String Iterator")),
      )
    None => ()
  }
  match map_iterator_proto() {
    Some(obj) =>
      obj.props.set(
        to_string_tag_key,
        property_data_readonly(String("Map Iterator")),
      )
    None => ()
  }
  match set_iterator_proto() {
    Some(obj) =>
      obj.props.set(
        to_string_tag_key,
        property_data_readonly(String("Set Iterator")),
      )
    None => ()
  }
  match generator_function_proto() {
    Some(obj) =>
      obj.props.set(
        to_string_tag_key,
        property_data_readonly(String("GeneratorFunction")),
      )
    None => ()
  }
  match async_generator_function_proto() {
    Some(obj) =>
      obj.props.set(
        to_string_tag_key,
        property_data_readonly(String("AsyncGeneratorFunction")),
      )
    None => ()
  }
  match async_function_proto() {
    Some(obj) =>
      obj.props.set(
        to_string_tag_key,
        property_data_readonly(String("AsyncFunction")),
      )
    None => ()
  }
  match dataview_proto() {
    Some(obj) =>
      obj.props.set(
        to_string_tag_key,
        property_data_readonly(String("DataView")),
      )
    None => ()
  }
  match generator_proto() {
    Some(obj) =>
      obj.props.set(
        to_string_tag_key,
        property_data_readonly(String("Generator")),
      )
    None => ()
  }
  match async_generator_proto() {
    Some(obj) => {
      obj.props.set(
        to_string_tag_key,
        property_data_readonly(String("AsyncGenerator")),
      )
      match symbol_async_iterator_key() {
        Some(key) =>
          obj.props.set(
            key,
            property_data_non_enum(
              new_builtin_value(BuiltinFunction::AsyncIteratorReturnSelf),
            ),
          )
        None => ()
      }
    }
    None => ()
  }
  match bigint_proto() {
    Some(obj) =>
      obj.props.set(to_string_tag_key, property_data_readonly(String("BigInt")))
    None => ()
  }
  match promise_proto() {
    Some(obj) =>
      obj.props.set(
        to_string_tag_key,
        property_data_readonly(String("Promise")),
      )
    None => ()
  }
  match weakref_proto() {
    Some(obj) =>
      obj.props.set(
        to_string_tag_key,
        property_data_readonly(String("WeakRef")),
      )
    None => ()
  }
  match finreg_proto() {
    Some(obj) =>
      obj.props.set(
        to_string_tag_key,
        property_data_readonly(String("FinalizationRegistry")),
      )
    None => ()
  }
  let symbol_async_iterator = SymbolValue::{
    id: alloc_symbol_id(),
    description: Some("Symbol.asyncIterator"),
    key: None,
  }
  register_symbol(symbol_async_iterator)
  symbol_async_iterator_ref.update(fn(_) { Some(symbol_async_iterator) })
  let symbol_has_instance = SymbolValue::{
    id: alloc_symbol_id(),
    description: Some("Symbol.hasInstance"),
    key: None,
  }
  register_symbol(symbol_has_instance)
  symbol_has_instance_ref.update(fn(_) { Some(symbol_has_instance) })
  let symbol_is_concat_spreadable = SymbolValue::{
    id: alloc_symbol_id(),
    description: Some("Symbol.isConcatSpreadable"),
    key: None,
  }
  register_symbol(symbol_is_concat_spreadable)
  symbol_is_concat_spreadable_ref.update(fn(_) {
    Some(symbol_is_concat_spreadable)
  })
  let symbol_match = SymbolValue::{
    id: alloc_symbol_id(),
    description: Some("Symbol.match"),
    key: None,
  }
  register_symbol(symbol_match)
  symbol_match_ref.update(fn(_) { Some(symbol_match) })
  let symbol_match_all = SymbolValue::{
    id: alloc_symbol_id(),
    description: Some("Symbol.matchAll"),
    key: None,
  }
  register_symbol(symbol_match_all)
  symbol_match_all_ref.update(fn(_) { Some(symbol_match_all) })
  let symbol_replace = SymbolValue::{
    id: alloc_symbol_id(),
    description: Some("Symbol.replace"),
    key: None,
  }
  register_symbol(symbol_replace)
  symbol_replace_ref.update(fn(_) { Some(symbol_replace) })
  let symbol_search = SymbolValue::{
    id: alloc_symbol_id(),
    description: Some("Symbol.search"),
    key: None,
  }
  register_symbol(symbol_search)
  symbol_search_ref.update(fn(_) { Some(symbol_search) })
  let symbol_species = SymbolValue::{
    id: alloc_symbol_id(),
    description: Some("Symbol.species"),
    key: None,
  }
  register_symbol(symbol_species)
  symbol_species_ref.update(fn(_) { Some(symbol_species) })
  let symbol_split = SymbolValue::{
    id: alloc_symbol_id(),
    description: Some("Symbol.split"),
    key: None,
  }
  register_symbol(symbol_split)
  symbol_split_ref.update(fn(_) { Some(symbol_split) })
  let symbol_to_primitive = SymbolValue::{
    id: alloc_symbol_id(),
    description: Some("Symbol.toPrimitive"),
    key: None,
  }
  register_symbol(symbol_to_primitive)
  symbol_to_primitive_ref.update(fn(_) { Some(symbol_to_primitive) })
  let symbol_unscopables = SymbolValue::{
    id: alloc_symbol_id(),
    description: Some("Symbol.unscopables"),
    key: None,
  }
  register_symbol(symbol_unscopables)
  symbol_unscopables_ref.update(fn(_) { Some(symbol_unscopables) })
  let async_iterator_key = symbol_prop_key(symbol_async_iterator)
  let has_instance_key = symbol_prop_key(symbol_has_instance)
  let match_key = symbol_prop_key(symbol_match)
  let match_all_key = symbol_prop_key(symbol_match_all)
  let replace_key = symbol_prop_key(symbol_replace)
  let search_key = symbol_prop_key(symbol_search)
  let species_key = symbol_prop_key(symbol_species)
  let split_key = symbol_prop_key(symbol_split)
  let unscopables_key = symbol_prop_key(symbol_unscopables)
  match async_iterator_proto() {
    Some(obj) =>
      obj.props.set(
        async_iterator_key,
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::AsyncIteratorReturnSelf),
        ),
      )
    None => ()
  }
  match async_generator_proto() {
    Some(obj) =>
      obj.props.set(
        async_iterator_key,
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::AsyncIteratorReturnSelf),
        ),
      )
    None => ()
  }
  match symbol_ctor {
    Builtin(builtin) => {
      builtin.props.set(
        "iterator",
        property_data_const(Symbol(symbol_iterator)),
      )
      builtin.props.set(
        "asyncIterator",
        property_data_const(Symbol(symbol_async_iterator)),
      )
      builtin.props.set(
        "hasInstance",
        property_data_const(Symbol(symbol_has_instance)),
      )
      builtin.props.set(
        "isConcatSpreadable",
        property_data_const(Symbol(symbol_is_concat_spreadable)),
      )
      builtin.props.set("match", property_data_const(Symbol(symbol_match)))
      builtin.props.set(
        "matchAll",
        property_data_const(Symbol(symbol_match_all)),
      )
      builtin.props.set("replace", property_data_const(Symbol(symbol_replace)))
      builtin.props.set("search", property_data_const(Symbol(symbol_search)))
      builtin.props.set("species", property_data_const(Symbol(symbol_species)))
      builtin.props.set("split", property_data_const(Symbol(symbol_split)))
      builtin.props.set(
        "toPrimitive",
        property_data_const(Symbol(symbol_to_primitive)),
      )
      builtin.props.set(
        "toStringTag",
        property_data_const(Symbol(symbol_to_string_tag)),
      )
      builtin.props.set(
        "unscopables",
        property_data_const(Symbol(symbol_unscopables)),
      )
    }
    _ => ()
  }
  let to_primitive_key = symbol_prop_key(symbol_to_primitive)
  symbol_proto_obj.props.set(
    to_primitive_key,
    property_data_readonly(
      new_builtin_value(BuiltinFunction::SymbolToPrimitive),
    ),
  )
  symbol_proto_obj.props.set(
    to_string_tag_key,
    property_data_readonly(String("Symbol")),
  )
  set_accessor_property_with_enum(
    symbol_proto_obj.props,
    "description",
    Some(new_builtin_value(BuiltinFunction::SymbolDescription)),
    None,
    false,
  )
  match function_proto_value {
    Function(func) =>
      func.props.set(
        has_instance_key,
        property_data_const(
          new_builtin_value(BuiltinFunction::FunctionSymbolHasInstance),
        ),
      )
    Builtin(builtin) =>
      builtin.props.set(
        has_instance_key,
        property_data_const(
          new_builtin_value(BuiltinFunction::FunctionSymbolHasInstance),
        ),
      )
    _ => ()
  }
  array_proto_obj.props.set(
    iterator_key,
    property_data_non_enum(array_values_func),
  )
  array_buffer_proto_obj.props.set(
    to_string_tag_key,
    property_data_readonly(String("ArrayBuffer")),
  )
  shared_array_buffer_proto_obj.props.set(
    to_string_tag_key,
    property_data_readonly(String("SharedArrayBuffer")),
  )
  regexp_proto_obj.props.set(
    replace_key,
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::RegExpSymbolReplace),
    ),
  )
  regexp_proto_obj.props.set(
    match_key,
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::RegExpSymbolMatch),
    ),
  )
  regexp_proto_obj.props.set(
    match_all_key,
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::RegExpSymbolMatchAll),
    ),
  )
  regexp_proto_obj.props.set(
    search_key,
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::RegExpSymbolSearch),
    ),
  )
  regexp_proto_obj.props.set(
    split_key,
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::RegExpSymbolSplit),
    ),
  )
  let array_unscopables_value = new_object_value_with_proto(None)
  match array_unscopables_value {
    Object(obj) => {
      obj.props.set("at", property_data(Bool(true)))
      obj.props.set("copyWithin", property_data(Bool(true)))
      obj.props.set("entries", property_data(Bool(true)))
      obj.props.set("fill", property_data(Bool(true)))
      obj.props.set("find", property_data(Bool(true)))
      obj.props.set("findIndex", property_data(Bool(true)))
      obj.props.set("findLast", property_data(Bool(true)))
      obj.props.set("findLastIndex", property_data(Bool(true)))
      obj.props.set("flat", property_data(Bool(true)))
      obj.props.set("flatMap", property_data(Bool(true)))
      obj.props.set("includes", property_data(Bool(true)))
      obj.props.set("keys", property_data(Bool(true)))
      obj.props.set("toReversed", property_data(Bool(true)))
      obj.props.set("toSorted", property_data(Bool(true)))
      obj.props.set("toSpliced", property_data(Bool(true)))
      obj.props.set("values", property_data(Bool(true)))
    }
    _ => ()
  }
  array_proto_obj.props.set(
    unscopables_key,
    property_data_readonly(array_unscopables_value),
  )
  map_proto_obj.props.set(
    iterator_key,
    property_data_non_enum(map_entries_func),
  )
  set_proto_obj.props.set(iterator_key, property_data_non_enum(set_values_func))
  string_proto_obj.props.set(
    iterator_key,
    property_data_non_enum(new_builtin_value(BuiltinFunction::StringIterator)),
  )
  map_proto_obj.props.set(
    to_string_tag_key,
    property_data_readonly(String("Map")),
  )
  set_proto_obj.props.set(
    to_string_tag_key,
    property_data_readonly(String("Set")),
  )
  weakmap_proto_obj.props.set(
    to_string_tag_key,
    property_data_readonly(String("WeakMap")),
  )
  weakset_proto_obj.props.set(
    to_string_tag_key,
    property_data_readonly(String("WeakSet")),
  )
  let regexp_ctor = new_builtin_value(BuiltinFunction::RegExpConstructor)
  match regexp_ctor {
    Builtin(builtin) => {
      builtin.props.set("prototype", property_data_const(regexp_proto_value))
      builtin.props.set(
        "escape",
        property_data_non_enum(new_builtin_value(BuiltinFunction::RegExpEscape)),
      )
      set_accessor_property_with_enum(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
        false,
      )
    }
    _ => ()
  }
  regexp_proto_obj.props.set("constructor", property_data_non_enum(regexp_ctor))
  let date_ctor = new_builtin_value(BuiltinFunction::DateConstructor)
  match date_ctor {
    Builtin(builtin) => {
      builtin.props.set("prototype", property_data_const(date_proto_value))
      builtin.props.set(
        "parse",
        property_data_non_enum(new_builtin_value(BuiltinFunction::DateParse)),
      )
      builtin.props.set(
        "UTC",
        property_data_non_enum(new_builtin_value(BuiltinFunction::DateUTC)),
      )
      builtin.props.set(
        "now",
        property_data_non_enum(new_builtin_value(BuiltinFunction::DateNow)),
      )
    }
    _ => ()
  }
  date_proto_obj.props.set("constructor", property_data_non_enum(date_ctor))
  date_proto_obj.props.set(
    to_primitive_key,
    property_data_readonly(
      new_builtin_value(BuiltinFunction::DateSymbolToPrimitive),
    ),
  )
  let map_ctor = new_builtin_value(BuiltinFunction::MapConstructor)
  match map_ctor {
    Builtin(builtin) => {
      builtin.props.set("prototype", property_data_const(map_proto_value))
      builtin.props.set(
        "groupBy",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MapGroupBy)),
      )
      set_accessor_property_with_enum(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
        false,
      )
    }
    _ => ()
  }
  map_proto_obj.props.set("constructor", property_data_non_enum(map_ctor))
  let set_ctor = new_builtin_value(BuiltinFunction::SetConstructor)
  match set_ctor {
    Builtin(builtin) => {
      builtin.props.set("prototype", property_data_const(set_proto_value))
      set_accessor_property_with_enum(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
        false,
      )
    }
    _ => ()
  }
  set_proto_obj.props.set("constructor", property_data_non_enum(set_ctor))
  let weakmap_ctor = new_builtin_value(BuiltinFunction::WeakMapConstructor)
  match weakmap_ctor {
    Builtin(builtin) =>
      builtin.props.set("prototype", property_data_const(weakmap_proto_value))
    _ => ()
  }
  weakmap_proto_obj.props.set(
    "constructor",
    property_data_non_enum(weakmap_ctor),
  )
  let weakset_ctor = new_builtin_value(BuiltinFunction::WeakSetConstructor)
  match weakset_ctor {
    Builtin(builtin) =>
      builtin.props.set("prototype", property_data_const(weakset_proto_value))
    _ => ()
  }
  weakset_proto_obj.props.set(
    "constructor",
    property_data_non_enum(weakset_ctor),
  )
  let weakref_ctor = new_builtin_value(BuiltinFunction::WeakRefConstructor)
  match weakref_ctor {
    Builtin(builtin) =>
      builtin.props.set("prototype", property_data_const(weakref_proto_value))
    _ => ()
  }
  weakref_proto_obj.props.set(
    "constructor",
    property_data_non_enum(weakref_ctor),
  )
  let finreg_ctor = new_builtin_value(
    BuiltinFunction::FinalizationRegistryConstructor,
  )
  match finreg_ctor {
    Builtin(builtin) =>
      builtin.props.set("prototype", property_data_const(finreg_proto_value))
    _ => ()
  }
  finreg_proto_obj.props.set("constructor", property_data_non_enum(finreg_ctor))
  let promise_ctor = new_builtin_value(BuiltinFunction::PromiseConstructor)
  match promise_ctor {
    Builtin(builtin) => {
      builtin.props.set("prototype", property_data_const(promise_proto_value))
      builtin.props.set(
        "resolve",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::PromiseResolve),
        ),
      )
      builtin.props.set(
        "reject",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::PromiseReject),
        ),
      )
      builtin.props.set(
        "all",
        property_data_non_enum(new_builtin_value(BuiltinFunction::PromiseAll)),
      )
      builtin.props.set(
        "allSettled",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::PromiseAllSettled),
        ),
      )
      builtin.props.set(
        "any",
        property_data_non_enum(new_builtin_value(BuiltinFunction::PromiseAny)),
      )
      builtin.props.set(
        "race",
        property_data_non_enum(new_builtin_value(BuiltinFunction::PromiseRace)),
      )
      builtin.props.set(
        "try",
        property_data_non_enum(new_builtin_value(BuiltinFunction::PromiseTry)),
      )
      builtin.props.set(
        "withResolvers",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::PromiseWithResolvers),
        ),
      )
      set_accessor_property_with_enum(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
        false,
      )
    }
    _ => ()
  }
  promise_proto_obj.props.set(
    "constructor",
    property_data_non_enum(promise_ctor),
  )
  match promise_ctor {
    Builtin(builtin) => register_promise_ctor_for_env(env, builtin)
    _ => ()
  }
  let proxy_ctor = new_builtin_value(BuiltinFunction::ProxyConstructor)
  match proxy_ctor {
    Builtin(builtin) =>
      builtin.props.set(
        "revocable",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ProxyRevocable),
        ),
      )
    _ => ()
  }
  let array_ctor = new_builtin_value(BuiltinFunction::ArrayConstructor)
  match array_ctor {
    Builtin(builtin) => {
      builtin.props.set("prototype", property_data_const(array_proto_value))
      builtin.props.set(
        "isArray",
        property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayIsArray)),
      )
      builtin.props.set(
        "from",
        property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayFrom)),
      )
      builtin.props.set(
        "of",
        property_data_non_enum(new_builtin_value(BuiltinFunction::ArrayOf)),
      )
      set_accessor_property_with_enum(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
        false,
      )
    }
    _ => ()
  }
  array_proto_obj.props.set("constructor", property_data_non_enum(array_ctor))
  let array_buffer_ctor = new_builtin_value(
    BuiltinFunction::ArrayBufferConstructor,
  )
  match array_buffer_ctor {
    Builtin(builtin) => {
      builtin.props.set(
        "prototype",
        property_data_const(array_buffer_proto_value),
      )
      builtin.props.set(
        "isView",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ArrayBufferIsView),
        ),
      )
      set_accessor_property_with_enum(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
        false,
      )
    }
    _ => ()
  }
  array_buffer_proto_obj.props.set(
    "constructor",
    property_data_non_enum(array_buffer_ctor),
  )
  let shared_array_buffer_ctor = new_builtin_value(
    BuiltinFunction::SharedArrayBufferConstructor,
  )
  match shared_array_buffer_ctor {
    Builtin(builtin) => {
      builtin.props.set(
        "prototype",
        property_data_const(shared_array_buffer_proto_value),
      )
      set_accessor_property_with_enum(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
        false,
      )
    }
    _ => ()
  }
  shared_array_buffer_proto_obj.props.set(
    "constructor",
    property_data_non_enum(shared_array_buffer_ctor),
  )
  let dataview_ctor = new_builtin_value(BuiltinFunction::DataViewConstructor)
  match dataview_ctor {
    Builtin(builtin) =>
      builtin.props.set("prototype", property_data_const(dataview_proto_value))
    _ => ()
  }
  dataview_proto_obj.props.set(
    "constructor",
    property_data_non_enum(dataview_ctor),
  )
  let typed_array_ctor = new_builtin_value(
    BuiltinFunction::TypedArrayConstructor,
  )
  match typed_array_ctor {
    Builtin(builtin) => {
      builtin.props.set(
        "prototype",
        property_data_const(Object(typed_array_proto_obj)),
      )
      builtin.props.set(
        "from",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::TypedArrayFrom),
        ),
      )
      builtin.props.set(
        "of",
        property_data_non_enum(new_builtin_value(BuiltinFunction::TypedArrayOf)),
      )
      set_accessor_property_with_enum(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
        false,
      )
    }
    _ => ()
  }
  typed_array_proto_obj.props.set(
    "constructor",
    property_data_non_enum(typed_array_ctor),
  )
  set_accessor_property_with_enum(
    typed_array_proto_obj.props,
    "length",
    Some(new_builtin_value(BuiltinFunction::TypedArrayGetLength)),
    None,
    false,
  )
  typed_array_proto_obj.props.set(
    "at",
    property_data_non_enum(new_builtin_value(BuiltinFunction::TypedArrayAt)),
  )
  typed_array_proto_obj.props.set(
    "with",
    property_data_non_enum(new_builtin_value(BuiltinFunction::TypedArrayWith)),
  )
  set_accessor_property_with_enum(
    typed_array_proto_obj.props,
    "buffer",
    Some(new_builtin_value(BuiltinFunction::TypedArrayGetBuffer)),
    None,
    false,
  )
  set_accessor_property_with_enum(
    typed_array_proto_obj.props,
    "byteLength",
    Some(new_builtin_value(BuiltinFunction::TypedArrayGetByteLength)),
    None,
    false,
  )
  set_accessor_property_with_enum(
    typed_array_proto_obj.props,
    "byteOffset",
    Some(new_builtin_value(BuiltinFunction::TypedArrayGetByteOffset)),
    None,
    false,
  )
  typed_array_proto_obj.props.set(
    "set",
    property_data_non_enum(new_builtin_value(BuiltinFunction::TypedArraySet)),
  )
  let typed_array_values_func = new_builtin_value(
    BuiltinFunction::TypedArrayValues,
  )
  typed_array_proto_obj.props.set(
    "values",
    property_data_non_enum(typed_array_values_func),
  )
  typed_array_proto_obj.props.set(
    "keys",
    property_data_non_enum(new_builtin_value(BuiltinFunction::TypedArrayKeys)),
  )
  typed_array_proto_obj.props.set(
    "entries",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::TypedArrayEntries),
    ),
  )
  match symbol_iterator_key() {
    Some(key) =>
      typed_array_proto_obj.props.set(
        key,
        property_data_non_enum(typed_array_values_func),
      )
    None => ()
  }
  match symbol_to_string_tag_key() {
    Some(key) =>
      set_accessor_property_with_enum(
        typed_array_proto_obj.props,
        key,
        Some(new_builtin_value(BuiltinFunction::TypedArrayGetToStringTag)),
        None,
        false,
      )
    None => ()
  }
  typed_array_proto_obj.props.set(
    "copyWithin",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::TypedArrayCopyWithin),
    ),
  )
  typed_array_proto_obj.props.set(
    "every",
    property_data_non_enum(new_builtin_value(BuiltinFunction::TypedArrayEvery)),
  )
  typed_array_proto_obj.props.set(
    "some",
    property_data_non_enum(new_builtin_value(BuiltinFunction::TypedArraySome)),
  )
  typed_array_proto_obj.props.set(
    "forEach",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::TypedArrayForEach),
    ),
  )
  typed_array_proto_obj.props.set(
    "map",
    property_data_non_enum(new_builtin_value(BuiltinFunction::TypedArrayMap)),
  )
  typed_array_proto_obj.props.set(
    "filter",
    property_data_non_enum(new_builtin_value(BuiltinFunction::TypedArrayFilter)),
  )
  typed_array_proto_obj.props.set(
    "reduce",
    property_data_non_enum(new_builtin_value(BuiltinFunction::TypedArrayReduce)),
  )
  typed_array_proto_obj.props.set(
    "reduceRight",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::TypedArrayReduceRight),
    ),
  )
  typed_array_proto_obj.props.set(
    "fill",
    property_data_non_enum(new_builtin_value(BuiltinFunction::TypedArrayFill)),
  )
  typed_array_proto_obj.props.set(
    "find",
    property_data_non_enum(new_builtin_value(BuiltinFunction::TypedArrayFind)),
  )
  typed_array_proto_obj.props.set(
    "findIndex",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::TypedArrayFindIndex),
    ),
  )
  typed_array_proto_obj.props.set(
    "findLast",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::TypedArrayFindLast),
    ),
  )
  typed_array_proto_obj.props.set(
    "findLastIndex",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::TypedArrayFindLastIndex),
    ),
  )
  typed_array_proto_obj.props.set(
    "reverse",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::TypedArrayReverse),
    ),
  )
  typed_array_proto_obj.props.set(
    "toReversed",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::TypedArrayToReversed),
    ),
  )
  typed_array_proto_obj.props.set(
    "slice",
    property_data_non_enum(new_builtin_value(BuiltinFunction::TypedArraySlice)),
  )
  typed_array_proto_obj.props.set(
    "subarray",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::TypedArraySubarray),
    ),
  )
  typed_array_proto_obj.props.set(
    "sort",
    property_data_non_enum(new_builtin_value(BuiltinFunction::TypedArraySort)),
  )
  typed_array_proto_obj.props.set(
    "toSorted",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::TypedArrayToSorted),
    ),
  )
  typed_array_proto_obj.props.set(
    "join",
    property_data_non_enum(new_builtin_value(BuiltinFunction::TypedArrayJoin)),
  )
  typed_array_proto_obj.props.set(
    "toLocaleString",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::TypedArrayToLocaleString),
    ),
  )
  typed_array_proto_obj.props.set(
    "indexOf",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::TypedArrayIndexOf),
    ),
  )
  typed_array_proto_obj.props.set(
    "lastIndexOf",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::TypedArrayLastIndexOf),
    ),
  )
  typed_array_proto_obj.props.set(
    "includes",
    property_data_non_enum(
      new_builtin_value(BuiltinFunction::TypedArrayIncludes),
    ),
  )
  match array_proto_obj.props.get("toString") {
    Some(prop) =>
      typed_array_proto_obj.props.set(
        "toString",
        property_data_non_enum(prop.value),
      )
    None => ()
  }
  let uint8_array_proto_value = new_object_value_with_proto(
    Some(Object(typed_array_proto_obj)),
  )
  let uint8_array_proto_obj = match uint8_array_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(typed_array_proto_obj)))
  }
  set_proto_ref(uint8_array_proto_ref, Some(uint8_array_proto_obj))
  let int8_array_proto_value = new_object_value_with_proto(
    Some(Object(typed_array_proto_obj)),
  )
  let int8_array_proto_obj = match int8_array_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(typed_array_proto_obj)))
  }
  set_proto_ref(int8_array_proto_ref, Some(int8_array_proto_obj))
  let uint8_clamped_array_proto_value = new_object_value_with_proto(
    Some(Object(typed_array_proto_obj)),
  )
  let uint8_clamped_array_proto_obj = match uint8_clamped_array_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(typed_array_proto_obj)))
  }
  set_proto_ref(
    uint8_clamped_array_proto_ref,
    Some(uint8_clamped_array_proto_obj),
  )
  let uint16_array_proto_value = new_object_value_with_proto(
    Some(Object(typed_array_proto_obj)),
  )
  let uint16_array_proto_obj = match uint16_array_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(typed_array_proto_obj)))
  }
  set_proto_ref(uint16_array_proto_ref, Some(uint16_array_proto_obj))
  let int16_array_proto_value = new_object_value_with_proto(
    Some(Object(typed_array_proto_obj)),
  )
  let int16_array_proto_obj = match int16_array_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(typed_array_proto_obj)))
  }
  set_proto_ref(int16_array_proto_ref, Some(int16_array_proto_obj))
  let uint32_array_proto_value = new_object_value_with_proto(
    Some(Object(typed_array_proto_obj)),
  )
  let uint32_array_proto_obj = match uint32_array_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(typed_array_proto_obj)))
  }
  set_proto_ref(uint32_array_proto_ref, Some(uint32_array_proto_obj))
  let int32_array_proto_value = new_object_value_with_proto(
    Some(Object(typed_array_proto_obj)),
  )
  let int32_array_proto_obj = match int32_array_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(typed_array_proto_obj)))
  }
  set_proto_ref(int32_array_proto_ref, Some(int32_array_proto_obj))
  let bigint64_array_proto_value = new_object_value_with_proto(
    Some(Object(typed_array_proto_obj)),
  )
  let bigint64_array_proto_obj = match bigint64_array_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(typed_array_proto_obj)))
  }
  set_proto_ref(bigint64_array_proto_ref, Some(bigint64_array_proto_obj))
  let biguint64_array_proto_value = new_object_value_with_proto(
    Some(Object(typed_array_proto_obj)),
  )
  let biguint64_array_proto_obj = match biguint64_array_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(typed_array_proto_obj)))
  }
  set_proto_ref(biguint64_array_proto_ref, Some(biguint64_array_proto_obj))
  let float16_array_proto_value = new_object_value_with_proto(
    Some(Object(typed_array_proto_obj)),
  )
  let float16_array_proto_obj = match float16_array_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(typed_array_proto_obj)))
  }
  set_proto_ref(float16_array_proto_ref, Some(float16_array_proto_obj))
  let float32_array_proto_value = new_object_value_with_proto(
    Some(Object(typed_array_proto_obj)),
  )
  let float32_array_proto_obj = match float32_array_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(typed_array_proto_obj)))
  }
  set_proto_ref(float32_array_proto_ref, Some(float32_array_proto_obj))
  let float64_array_proto_value = new_object_value_with_proto(
    Some(Object(typed_array_proto_obj)),
  )
  let float64_array_proto_obj = match float64_array_proto_value {
    Object(obj) => obj
    _ => new_object_struct(Some(Object(typed_array_proto_obj)))
  }
  set_proto_ref(float64_array_proto_ref, Some(float64_array_proto_obj))
  let uint8_array_ctor = new_builtin_value(
    BuiltinFunction::Uint8ArrayConstructor,
  )
  match uint8_array_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(typed_array_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(Object(uint8_array_proto_obj)),
      )
      builtin.props.set(
        "BYTES_PER_ELEMENT",
        property_data_const(Number(Double::from_int(1))),
      )
      set_accessor_property(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
      )
    }
    _ => ()
  }
  uint8_array_proto_obj.props.set(
    "constructor",
    property_data_non_enum(uint8_array_ctor),
  )
  uint8_array_proto_obj.props.set(
    "BYTES_PER_ELEMENT",
    property_data_const(Number(Double::from_int(1))),
  )
  let int8_array_ctor = new_builtin_value(BuiltinFunction::Int8ArrayConstructor)
  match int8_array_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(typed_array_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(Object(int8_array_proto_obj)),
      )
      builtin.props.set(
        "BYTES_PER_ELEMENT",
        property_data_const(Number(Double::from_int(1))),
      )
      set_accessor_property(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
      )
    }
    _ => ()
  }
  int8_array_proto_obj.props.set(
    "constructor",
    property_data_non_enum(int8_array_ctor),
  )
  int8_array_proto_obj.props.set(
    "BYTES_PER_ELEMENT",
    property_data_const(Number(Double::from_int(1))),
  )
  let uint8_clamped_array_ctor = new_builtin_value(
    BuiltinFunction::Uint8ClampedArrayConstructor,
  )
  match uint8_clamped_array_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(typed_array_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(Object(uint8_clamped_array_proto_obj)),
      )
      builtin.props.set(
        "BYTES_PER_ELEMENT",
        property_data_const(Number(Double::from_int(1))),
      )
      set_accessor_property(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
      )
    }
    _ => ()
  }
  uint8_clamped_array_proto_obj.props.set(
    "constructor",
    property_data_non_enum(uint8_clamped_array_ctor),
  )
  uint8_clamped_array_proto_obj.props.set(
    "BYTES_PER_ELEMENT",
    property_data_const(Number(Double::from_int(1))),
  )
  let uint16_array_ctor = new_builtin_value(
    BuiltinFunction::Uint16ArrayConstructor,
  )
  match uint16_array_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(typed_array_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(Object(uint16_array_proto_obj)),
      )
      builtin.props.set(
        "BYTES_PER_ELEMENT",
        property_data_const(Number(Double::from_int(2))),
      )
      set_accessor_property(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
      )
    }
    _ => ()
  }
  uint16_array_proto_obj.props.set(
    "constructor",
    property_data_non_enum(uint16_array_ctor),
  )
  uint16_array_proto_obj.props.set(
    "BYTES_PER_ELEMENT",
    property_data_const(Number(Double::from_int(2))),
  )
  let int16_array_ctor = new_builtin_value(
    BuiltinFunction::Int16ArrayConstructor,
  )
  match int16_array_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(typed_array_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(Object(int16_array_proto_obj)),
      )
      builtin.props.set(
        "BYTES_PER_ELEMENT",
        property_data_const(Number(Double::from_int(2))),
      )
      set_accessor_property(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
      )
    }
    _ => ()
  }
  int16_array_proto_obj.props.set(
    "constructor",
    property_data_non_enum(int16_array_ctor),
  )
  int16_array_proto_obj.props.set(
    "BYTES_PER_ELEMENT",
    property_data_const(Number(Double::from_int(2))),
  )
  let uint32_array_ctor = new_builtin_value(
    BuiltinFunction::Uint32ArrayConstructor,
  )
  match uint32_array_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(typed_array_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(Object(uint32_array_proto_obj)),
      )
      builtin.props.set(
        "BYTES_PER_ELEMENT",
        property_data_const(Number(Double::from_int(4))),
      )
      set_accessor_property(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
      )
    }
    _ => ()
  }
  uint32_array_proto_obj.props.set(
    "constructor",
    property_data_non_enum(uint32_array_ctor),
  )
  uint32_array_proto_obj.props.set(
    "BYTES_PER_ELEMENT",
    property_data_const(Number(Double::from_int(4))),
  )
  let int32_array_ctor = new_builtin_value(
    BuiltinFunction::Int32ArrayConstructor,
  )
  match int32_array_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(typed_array_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(Object(int32_array_proto_obj)),
      )
      builtin.props.set(
        "BYTES_PER_ELEMENT",
        property_data_const(Number(Double::from_int(4))),
      )
      set_accessor_property(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
      )
    }
    _ => ()
  }
  int32_array_proto_obj.props.set(
    "constructor",
    property_data_non_enum(int32_array_ctor),
  )
  int32_array_proto_obj.props.set(
    "BYTES_PER_ELEMENT",
    property_data_const(Number(Double::from_int(4))),
  )
  let bigint64_array_ctor = new_builtin_value(
    BuiltinFunction::BigInt64ArrayConstructor,
  )
  match bigint64_array_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(typed_array_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(Object(bigint64_array_proto_obj)),
      )
      builtin.props.set(
        "BYTES_PER_ELEMENT",
        property_data_const(Number(Double::from_int(8))),
      )
      set_accessor_property(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
      )
    }
    _ => ()
  }
  bigint64_array_proto_obj.props.set(
    "constructor",
    property_data_non_enum(bigint64_array_ctor),
  )
  bigint64_array_proto_obj.props.set(
    "BYTES_PER_ELEMENT",
    property_data_const(Number(Double::from_int(8))),
  )
  let biguint64_array_ctor = new_builtin_value(
    BuiltinFunction::BigUint64ArrayConstructor,
  )
  match biguint64_array_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(typed_array_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(Object(biguint64_array_proto_obj)),
      )
      builtin.props.set(
        "BYTES_PER_ELEMENT",
        property_data_const(Number(Double::from_int(8))),
      )
      set_accessor_property(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
      )
    }
    _ => ()
  }
  biguint64_array_proto_obj.props.set(
    "constructor",
    property_data_non_enum(biguint64_array_ctor),
  )
  biguint64_array_proto_obj.props.set(
    "BYTES_PER_ELEMENT",
    property_data_const(Number(Double::from_int(8))),
  )
  let float16_array_ctor = new_builtin_value(
    BuiltinFunction::Float16ArrayConstructor,
  )
  match float16_array_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(typed_array_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(Object(float16_array_proto_obj)),
      )
      builtin.props.set(
        "BYTES_PER_ELEMENT",
        property_data_const(Number(Double::from_int(2))),
      )
      set_accessor_property(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
      )
    }
    _ => ()
  }
  float16_array_proto_obj.props.set(
    "constructor",
    property_data_non_enum(float16_array_ctor),
  )
  float16_array_proto_obj.props.set(
    "BYTES_PER_ELEMENT",
    property_data_const(Number(Double::from_int(2))),
  )
  let float32_array_ctor = new_builtin_value(
    BuiltinFunction::Float32ArrayConstructor,
  )
  match float32_array_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(typed_array_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(Object(float32_array_proto_obj)),
      )
      builtin.props.set(
        "BYTES_PER_ELEMENT",
        property_data_const(Number(Double::from_int(4))),
      )
      set_accessor_property(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
      )
    }
    _ => ()
  }
  float32_array_proto_obj.props.set(
    "constructor",
    property_data_non_enum(float32_array_ctor),
  )
  float32_array_proto_obj.props.set(
    "BYTES_PER_ELEMENT",
    property_data_const(Number(Double::from_int(4))),
  )
  let float64_array_ctor = new_builtin_value(
    BuiltinFunction::Float64ArrayConstructor,
  )
  match float64_array_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(typed_array_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(Object(float64_array_proto_obj)),
      )
      builtin.props.set(
        "BYTES_PER_ELEMENT",
        property_data_const(Number(Double::from_int(8))),
      )
      set_accessor_property(
        builtin.props,
        species_key,
        Some(new_builtin_value(BuiltinFunction::SpeciesGetter)),
        None,
      )
    }
    _ => ()
  }
  float64_array_proto_obj.props.set(
    "constructor",
    property_data_non_enum(float64_array_ctor),
  )
  float64_array_proto_obj.props.set(
    "BYTES_PER_ELEMENT",
    property_data_const(Number(Double::from_int(8))),
  )
  let error_ctor = new_builtin_value(BuiltinFunction::ErrorConstructor)
  match error_ctor {
    Builtin(builtin) => {
      builtin.props.set("prototype", property_data_const(error_proto_value))
      builtin.props.set(
        "isError",
        property_data_non_enum(new_builtin_value(BuiltinFunction::ErrorIsError)),
      )
    }
    _ => ()
  }
  error_proto_obj.props.set("constructor", property_data_non_enum(error_ctor))
  error_proto_obj.props.set(
    "toString",
    property_data_non_enum(new_builtin_value(BuiltinFunction::ErrorToString)),
  )
  let aggregate_error_ctor = new_builtin_value(
    BuiltinFunction::AggregateErrorConstructor,
  )
  match aggregate_error_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(error_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(aggregate_error_proto_value),
      )
    }
    _ => ()
  }
  aggregate_error_proto_obj.props.set(
    "constructor",
    property_data_non_enum(aggregate_error_ctor),
  )
  let eval_error_ctor = new_builtin_value(BuiltinFunction::EvalErrorConstructor)
  match eval_error_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(error_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(eval_error_proto_value),
      )
    }
    _ => ()
  }
  eval_error_proto_obj.props.set(
    "constructor",
    property_data_non_enum(eval_error_ctor),
  )
  let syntax_error_ctor = new_builtin_value(
    BuiltinFunction::SyntaxErrorConstructor,
  )
  match syntax_error_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(error_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(syntax_error_proto_value),
      )
    }
    _ => ()
  }
  syntax_error_proto_obj.props.set(
    "constructor",
    property_data_non_enum(syntax_error_ctor),
  )
  let range_error_ctor = new_builtin_value(
    BuiltinFunction::RangeErrorConstructor,
  )
  match range_error_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(error_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(range_error_proto_value),
      )
    }
    _ => ()
  }
  range_error_proto_obj.props.set(
    "constructor",
    property_data_non_enum(range_error_ctor),
  )
  let type_error_ctor = new_builtin_value(BuiltinFunction::TypeErrorConstructor)
  match type_error_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(error_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(type_error_proto_value),
      )
    }
    _ => ()
  }
  type_error_proto_obj.props.set(
    "constructor",
    property_data_non_enum(type_error_ctor),
  )
  let reference_error_ctor = new_builtin_value(
    BuiltinFunction::ReferenceErrorConstructor,
  )
  match reference_error_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(error_ctor)
      builtin.props.set(
        "prototype",
        property_data_const(reference_error_proto_value),
      )
    }
    _ => ()
  }
  reference_error_proto_obj.props.set(
    "constructor",
    property_data_non_enum(reference_error_ctor),
  )
  let uri_error_ctor = new_builtin_value(BuiltinFunction::UriErrorConstructor)
  match uri_error_ctor {
    Builtin(builtin) => {
      builtin.proto = Some(error_ctor)
      builtin.props.set("prototype", property_data_const(uri_error_proto_value))
    }
    _ => ()
  }
  uri_error_proto_obj.props.set(
    "constructor",
    property_data_non_enum(uri_error_ctor),
  )
  let json_obj = new_object_value_with_proto(Some(Object(object_proto_obj)))
  match json_obj {
    Object(obj) => {
      obj.props.set(
        "stringify",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::JsonStringify),
        ),
      )
      obj.props.set(
        "parse",
        property_data_non_enum(new_builtin_value(BuiltinFunction::JsonParse)),
      )
      match symbol_to_string_tag_key() {
        Some(key) => obj.props.set(key, property_data_readonly(String("JSON")))
        None => ()
      }
    }
    _ => ()
  }
  let reflect_obj = new_object_value_with_proto(Some(Object(object_proto_obj)))
  match reflect_obj {
    Object(obj) => {
      obj.props.set(
        "apply",
        property_data_non_enum(new_builtin_value(BuiltinFunction::ReflectApply)),
      )
      obj.props.set(
        "construct",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ReflectConstruct),
        ),
      )
      obj.props.set(
        "get",
        property_data_non_enum(new_builtin_value(BuiltinFunction::ReflectGet)),
      )
      obj.props.set(
        "getOwnPropertyDescriptor",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ReflectGetOwnPropertyDescriptor),
        ),
      )
      obj.props.set(
        "getPrototypeOf",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ReflectGetPrototypeOf),
        ),
      )
      obj.props.set(
        "defineProperty",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ReflectDefineProperty),
        ),
      )
      obj.props.set(
        "has",
        property_data_non_enum(new_builtin_value(BuiltinFunction::ReflectHas)),
      )
      obj.props.set(
        "isExtensible",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ReflectIsExtensible),
        ),
      )
      obj.props.set(
        "set",
        property_data_non_enum(new_builtin_value(BuiltinFunction::ReflectSet)),
      )
      obj.props.set(
        "setPrototypeOf",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ReflectSetPrototypeOf),
        ),
      )
      obj.props.set(
        "deleteProperty",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ReflectDeleteProperty),
        ),
      )
      obj.props.set(
        "preventExtensions",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ReflectPreventExtensions),
        ),
      )
      obj.props.set(
        "ownKeys",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::ReflectOwnKeys),
        ),
      )
      match symbol_to_string_tag_key() {
        Some(key) =>
          obj.props.set(key, property_data_readonly(String("Reflect")))
        None => ()
      }
    }
    _ => ()
  }
  let atomics_obj = new_object_value_with_proto(Some(Object(object_proto_obj)))
  match atomics_obj {
    Object(obj) => {
      obj.props.set(
        "add",
        property_data_non_enum(new_builtin_value(BuiltinFunction::AtomicsAdd)),
      )
      obj.props.set(
        "and",
        property_data_non_enum(new_builtin_value(BuiltinFunction::AtomicsAnd)),
      )
      obj.props.set(
        "or",
        property_data_non_enum(new_builtin_value(BuiltinFunction::AtomicsOr)),
      )
      obj.props.set(
        "sub",
        property_data_non_enum(new_builtin_value(BuiltinFunction::AtomicsSub)),
      )
      obj.props.set(
        "xor",
        property_data_non_enum(new_builtin_value(BuiltinFunction::AtomicsXor)),
      )
      obj.props.set(
        "exchange",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::AtomicsExchange),
        ),
      )
      obj.props.set(
        "compareExchange",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::AtomicsCompareExchange),
        ),
      )
      obj.props.set(
        "load",
        property_data_non_enum(new_builtin_value(BuiltinFunction::AtomicsLoad)),
      )
      obj.props.set(
        "store",
        property_data_non_enum(new_builtin_value(BuiltinFunction::AtomicsStore)),
      )
      obj.props.set(
        "isLockFree",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::AtomicsIsLockFree),
        ),
      )
      obj.props.set(
        "pause",
        property_data_non_enum(new_builtin_value(BuiltinFunction::AtomicsPause)),
      )
      obj.props.set(
        "wait",
        property_data_non_enum(new_builtin_value(BuiltinFunction::AtomicsWait)),
      )
      obj.props.set(
        "notify",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::AtomicsNotify),
        ),
      )
      match symbol_to_string_tag_key() {
        Some(key) =>
          obj.props.set(key, property_data_readonly(String("Atomics")))
        None => ()
      }
    }
    _ => ()
  }
  let math_obj = new_object_value_with_proto(Some(Object(object_proto_obj)))
  match math_obj {
    Object(obj) => {
      obj.props.set("E", property_data_const(Number(2.718281828459045)))
      obj.props.set("LN2", property_data_const(Number(0.6931471805599453)))
      obj.props.set("LN10", property_data_const(Number(2.302585092994046)))
      obj.props.set("LOG2E", property_data_const(Number(1.4426950408889634)))
      obj.props.set("LOG10E", property_data_const(Number(0.4342944819032518)))
      obj.props.set("PI", property_data_const(Number(@math.PI)))
      obj.props.set("SQRT1_2", property_data_const(Number(0.7071067811865476)))
      obj.props.set("SQRT2", property_data_const(Number(1.4142135623730951)))
      obj.props.set(
        "abs",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathAbs)),
      )
      obj.props.set(
        "acos",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathAcos)),
      )
      obj.props.set(
        "acosh",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathAcosh)),
      )
      obj.props.set(
        "asin",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathAsin)),
      )
      obj.props.set(
        "asinh",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathAsinh)),
      )
      obj.props.set(
        "atan",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathAtan)),
      )
      obj.props.set(
        "atan2",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathAtan2)),
      )
      obj.props.set(
        "atanh",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathAtanh)),
      )
      obj.props.set(
        "cbrt",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathCbrt)),
      )
      obj.props.set(
        "ceil",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathCeil)),
      )
      obj.props.set(
        "clz32",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathClz32)),
      )
      obj.props.set(
        "cos",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathCos)),
      )
      obj.props.set(
        "cosh",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathCosh)),
      )
      obj.props.set(
        "exp",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathExp)),
      )
      obj.props.set(
        "expm1",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathExpm1)),
      )
      obj.props.set(
        "floor",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathFloor)),
      )
      obj.props.set(
        "fround",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathFround)),
      )
      obj.props.set(
        "f16round",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathF16Round)),
      )
      obj.props.set(
        "hypot",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathHypot)),
      )
      obj.props.set(
        "imul",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathImul)),
      )
      obj.props.set(
        "log",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathLog)),
      )
      obj.props.set(
        "log1p",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathLog1p)),
      )
      obj.props.set(
        "log2",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathLog2)),
      )
      obj.props.set(
        "log10",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathLog10)),
      )
      obj.props.set(
        "max",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathMax)),
      )
      obj.props.set(
        "min",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathMin)),
      )
      obj.props.set(
        "pow",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathPow)),
      )
      obj.props.set(
        "random",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathRandom)),
      )
      obj.props.set(
        "round",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathRound)),
      )
      obj.props.set(
        "sign",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathSign)),
      )
      obj.props.set(
        "sin",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathSin)),
      )
      obj.props.set(
        "sinh",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathSinh)),
      )
      obj.props.set(
        "sqrt",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathSqrt)),
      )
      obj.props.set(
        "tan",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathTan)),
      )
      obj.props.set(
        "tanh",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathTanh)),
      )
      obj.props.set(
        "trunc",
        property_data_non_enum(new_builtin_value(BuiltinFunction::MathTrunc)),
      )
      obj.props.set(
        "sumPrecise",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::MathSumPrecise),
        ),
      )
      match symbol_to_string_tag_key() {
        Some(key) => obj.props.set(key, property_data_readonly(String("Math")))
        None => ()
      }
    }
    _ => ()
  }
  env_declare(env, "globalThis", global)
  env_declare(env, "Object", object_ctor)
  env_declare(env, "Function", function_ctor)
  env_declare(env, "Array", array_ctor)
  env_declare(env, "ArrayBuffer", array_buffer_ctor)
  env_declare(env, "SharedArrayBuffer", shared_array_buffer_ctor)
  env_declare(env, "DataView", dataview_ctor)
  env_declare(env, "TypedArray", typed_array_ctor)
  env_declare(env, "Uint8Array", uint8_array_ctor)
  env_declare(env, "Int8Array", int8_array_ctor)
  env_declare(env, "Uint8ClampedArray", uint8_clamped_array_ctor)
  env_declare(env, "Uint16Array", uint16_array_ctor)
  env_declare(env, "Int16Array", int16_array_ctor)
  env_declare(env, "Uint32Array", uint32_array_ctor)
  env_declare(env, "Int32Array", int32_array_ctor)
  env_declare(env, "BigInt64Array", bigint64_array_ctor)
  env_declare(env, "BigUint64Array", biguint64_array_ctor)
  env_declare(env, "Float16Array", float16_array_ctor)
  env_declare(env, "Float32Array", float32_array_ctor)
  env_declare(env, "Float64Array", float64_array_ctor)
  env_declare(env, "String", string_ctor)
  env_declare(env, "Number", number_ctor)
  env_declare(env, "Boolean", bool_ctor)
  env_declare(env, "BigInt", bigint_ctor)
  env_declare(env, "Symbol", symbol_ctor)
  env_declare(env, "Iterator", iterator_ctor)
  env_declare(env, "RegExp", regexp_ctor)
  env_declare(env, "Date", date_ctor)
  env_declare(env, "Map", map_ctor)
  env_declare(env, "Set", set_ctor)
  env_declare(env, "WeakMap", weakmap_ctor)
  env_declare(env, "WeakSet", weakset_ctor)
  env_declare(env, "WeakRef", weakref_ctor)
  env_declare(env, "FinalizationRegistry", finreg_ctor)
  env_declare(env, "Promise", promise_ctor)
  env_declare(env, "Proxy", proxy_ctor)
  env_declare(env, "Error", error_ctor)
  env_declare(env, "AggregateError", aggregate_error_ctor)
  env_declare(env, "EvalError", eval_error_ctor)
  env_declare(env, "SyntaxError", syntax_error_ctor)
  env_declare(env, "RangeError", range_error_ctor)
  env_declare(env, "TypeError", type_error_ctor)
  env_declare(env, "ReferenceError", reference_error_ctor)
  env_declare(env, "URIError", uri_error_ctor)
  env_declare(env, "JSON", json_obj)
  env_declare(env, "Reflect", reflect_obj)
  env_declare(env, "Atomics", atomics_obj)
  env_declare(env, "Math", math_obj)
  env_declare(env, "parseInt", parse_int_func)
  env_declare(env, "parseFloat", parse_float_func)
  env_declare(env, "eval", new_builtin_value(BuiltinFunction::Eval))
  env_declare(env, "__import", new_builtin_value(BuiltinFunction::ModuleImport))
  env_declare(
    env,
    "__import_dynamic",
    new_builtin_value(BuiltinFunction::ModuleImportDynamic),
  )
  env_declare(
    env,
    "__import_binding",
    new_builtin_value(BuiltinFunction::ModuleImportBinding),
  )
  env_declare(
    env,
    "__binding",
    new_builtin_value(BuiltinFunction::ModuleBinding),
  )
  env_declare(env, "__export", new_builtin_value(BuiltinFunction::ModuleExport))
  env_declare(
    env,
    "__export_star",
    new_builtin_value(BuiltinFunction::ModuleExportStar),
  )
  env_declare(env, "isNaN", new_builtin_value(BuiltinFunction::IsNaN))
  env_declare(env, "isFinite", new_builtin_value(BuiltinFunction::IsFinite))
  env_declare(env, "decodeURI", new_builtin_value(BuiltinFunction::DecodeURI))
  env_declare(
    env,
    "decodeURIComponent",
    new_builtin_value(BuiltinFunction::DecodeURIComponent),
  )
  env_declare(env, "encodeURI", new_builtin_value(BuiltinFunction::EncodeURI))
  env_declare(
    env,
    "encodeURIComponent",
    new_builtin_value(BuiltinFunction::EncodeURIComponent),
  )
  env_declare(env, "escape", new_builtin_value(BuiltinFunction::Escape))
  env_declare(env, "unescape", new_builtin_value(BuiltinFunction::Unescape))
  match global {
    Object(obj) => {
      obj.props.set("NaN", property_data_const(Number(nan())))
      obj.props.set("Infinity", property_data_const(Number(inf())))
      obj.props.set("undefined", property_data_const(Undefined))
    }
    _ => ()
  }
  let std_obj = new_object_value_with_proto(Some(Object(object_proto_obj)))
  match std_obj {
    Object(obj) => {
      obj.props.set(
        "sprintf",
        property_data_non_enum(new_builtin_value(BuiltinFunction::StdSprintf)),
      )
      obj.props.set(
        "loadScript",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::StdLoadScript),
        ),
      )
      obj.props.set(
        "tmpfile",
        property_data_non_enum(new_builtin_value(BuiltinFunction::StdTmpfile)),
      )
      obj.props.set(
        "open",
        property_data_non_enum(new_builtin_value(BuiltinFunction::StdOpen)),
      )
      obj.props.set(
        "loadFile",
        property_data_non_enum(new_builtin_value(BuiltinFunction::StdLoadFile)),
      )
      obj.props.set(
        "popen",
        property_data_non_enum(new_builtin_value(BuiltinFunction::StdPopen)),
      )
      obj.props.set(
        "parseExtJSON",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::StdParseExtJSON),
        ),
      )
      obj.props.set(
        "fdopen",
        property_data_non_enum(new_builtin_value(BuiltinFunction::StdFdopen)),
      )
      obj.props.set(
        "gc",
        property_data_non_enum(new_builtin_value(BuiltinFunction::StdGc)),
      )
      obj.props.set(
        "SEEK_SET",
        property_data_non_enum(Number(Double::from_int(seek_set))),
      )
      obj.props.set(
        "SEEK_CUR",
        property_data_non_enum(Number(Double::from_int(seek_cur))),
      )
      obj.props.set(
        "SEEK_END",
        property_data_non_enum(Number(Double::from_int(seek_end))),
      )
    }
    _ => ()
  }
  env_declare(env, "std", std_obj)
  let os_obj = new_object_value_with_proto(Some(Object(object_proto_obj)))
  match os_obj {
    Object(obj) => {
      obj.props.set(
        "setTimeout",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsSetTimeout)),
      )
      obj.props.set(
        "clearTimeout",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::OsClearTimeout),
        ),
      )
      obj.props.set(
        "Worker",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::WorkerConstructor),
        ),
      )
      obj.props.set(
        "open",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsOpen)),
      )
      obj.props.set(
        "close",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsClose)),
      )
      obj.props.set(
        "read",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsRead)),
      )
      obj.props.set(
        "write",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsWrite)),
      )
      obj.props.set(
        "seek",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsSeek)),
      )
      obj.props.set(
        "readdir",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsReaddir)),
      )
      obj.props.set(
        "stat",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsStat)),
      )
      obj.props.set(
        "lstat",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsLstat)),
      )
      obj.props.set(
        "readlink",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsReadlink)),
      )
      obj.props.set(
        "symlink",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsSymlink)),
      )
      obj.props.set(
        "mkdir",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsMkdir)),
      )
      obj.props.set(
        "remove",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsRemove)),
      )
      obj.props.set(
        "utimes",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsUtimes)),
      )
      obj.props.set(
        "getcwd",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsGetcwd)),
      )
      obj.props.set(
        "realpath",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsRealpath)),
      )
      obj.props.set(
        "isatty",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsIsatty)),
      )
      obj.props.set(
        "exec",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsExec)),
      )
      obj.props.set(
        "pipe",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsPipe)),
      )
      obj.props.set(
        "waitpid",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsWaitpid)),
      )
      obj.props.set(
        "kill",
        property_data_non_enum(new_builtin_value(BuiltinFunction::OsKill)),
      )
      obj.props.set(
        "O_RDONLY",
        property_data_non_enum(Number(Double::from_int(os_flag_rdonly))),
      )
      obj.props.set(
        "O_WRONLY",
        property_data_non_enum(Number(Double::from_int(os_flag_wronly))),
      )
      obj.props.set(
        "O_RDWR",
        property_data_non_enum(Number(Double::from_int(os_flag_rdwr))),
      )
      obj.props.set(
        "O_CREAT",
        property_data_non_enum(Number(Double::from_int(os_flag_creat))),
      )
      obj.props.set(
        "O_TRUNC",
        property_data_non_enum(Number(Double::from_int(os_flag_trunc))),
      )
      obj.props.set(
        "S_IFMT",
        property_data_non_enum(Number(Double::from_int(os_mode_ifmt))),
      )
      obj.props.set(
        "S_IFREG",
        property_data_non_enum(Number(Double::from_int(os_mode_ifreg))),
      )
      obj.props.set(
        "S_IFLNK",
        property_data_non_enum(Number(Double::from_int(os_mode_iflnk))),
      )
      obj.props.set(
        "SIGTERM",
        property_data_non_enum(Number(Double::from_int(os_sigterm))),
      )
    }
    _ => ()
  }
  env_declare(env, "os", os_obj)
  let bjson_obj = new_object_value_with_proto(Some(Object(object_proto_obj)))
  match bjson_obj {
    Object(obj) => {
      obj.props.set(
        "read",
        property_data_non_enum(new_builtin_value(BuiltinFunction::BjsonRead)),
      )
      obj.props.set(
        "write",
        property_data_non_enum(new_builtin_value(BuiltinFunction::BjsonWrite)),
      )
    }
    _ => ()
  }
  env_declare(env, "bjson", bjson_obj)
  let _ = install_test262_helpers(env)
  Vm::{ env, runtime }
}

///|
pub fn Vm::run_gc(self : Vm) -> Unit {
  let prev = set_current_runtime_state(self.runtime)
  run_gc()
  restore_runtime_state(prev)
}

///|
pub fn Vm::set_gc_threshold(self : Vm, threshold : Int) -> Unit {
  self.runtime.gc_threshold_ref.update(fn(_) { threshold })
}

///|
pub fn Vm::set_gc_debug(self : Vm, enabled : Bool) -> Unit {
  self.runtime.gc_debug_ref.update(fn(_) { enabled })
}

///|
pub fn Vm::set_can_block(self : Vm, flag : Bool) -> Unit {
  self.runtime.can_block_ref.update(fn(_) { flag })
}

///|
pub fn Vm::reset_runtime_state(self : Vm) -> Unit {
  let prev = set_current_runtime_state(self.runtime)
  reset_runtime_state()
  restore_runtime_state(prev)
}

///|
pub fn Vm::async_done_count(self : Vm) -> Int {
  let mut value = 0
  self.runtime.async_done_ref.update(fn(current) {
    value = current
    current
  })
  value
}

///|
pub fn Vm::take_print_log(self : Vm) -> Array[String] {
  let mut out : Array[String] = []
  self.runtime.print_log_ref.update(fn(log) {
    out = log
    []
  })
  out
}

///|
pub fn Vm::eval(self : Vm, source : String) -> Value raise {
  let prev_runtime = set_current_runtime_state(self.runtime)
  try {
    let script = parse_script_with_pos(source)
    let result = eval_script(self.env, script)
    run_pending_timers()
    run_pending_workers()
    gc_maybe_collect_with_root(result)
    result
  } catch {
    err => {
      restore_runtime_state(prev_runtime)
      raise err
    }
  } noraise {
    value => {
      restore_runtime_state(prev_runtime)
      value
    }
  }
}

///|
pub fn Vm::eval_with_path(
  self : Vm,
  source : String,
  path : String,
) -> Value raise {
  let prev_runtime = set_current_runtime_state(self.runtime)
  try {
    let script = parse_script_with_pos(source)
    let full_path = resolve_path(path)
    let result = if script.is_module {
      let _ = eval_module_script(script, full_path)
      let promise = module_evaluate(full_path)
      let _ = await_promise_completion(promise)
      Undefined
    } else {
      with_source_path(full_path, fn() raise { eval_script(self.env, script) })
    }
    run_pending_timers()
    run_pending_workers()
    gc_maybe_collect_with_root(result)
    result
  } catch {
    err => {
      restore_runtime_state(prev_runtime)
      raise err
    }
  } noraise {
    value => {
      restore_runtime_state(prev_runtime)
      value
    }
  }
}

///|
pub fn Vm::eval_with_path_mode(
  self : Vm,
  source : String,
  path : String,
  force_module : Bool,
  force_strict : Bool,
) -> Value raise {
  let prev_runtime = set_current_runtime_state(self.runtime)
  try {
    let script = parse_script_with_pos_mode(source, force_module, force_strict)
    validate_context_in_script(script, false, false, false)
    let full_path = resolve_path(path)
    let result = if script.is_module {
      let _ = eval_module_script(script, full_path)
      let promise = module_evaluate(full_path)
      let _ = await_promise_completion(promise)
      Undefined
    } else if force_strict {
      let old_strict = self.env.strict
      self.env.strict = true
      try
        with_source_path(full_path, fn() raise { eval_script(self.env, script) })
      catch {
        err => {
          self.env.strict = old_strict
          raise err
        }
      } noraise {
        value => {
          self.env.strict = old_strict
          value
        }
      }
    } else {
      with_source_path(full_path, fn() raise { eval_script(self.env, script) })
    }
    run_pending_jobs()
    run_pending_timers()
    run_pending_jobs()
    run_pending_workers()
    run_pending_jobs()
    gc_maybe_collect_with_root(result)
    result
  } catch {
    err => {
      restore_runtime_state(prev_runtime)
      raise err
    }
  } noraise {
    value => {
      restore_runtime_state(prev_runtime)
      value
    }
  }
}

///|
pub fn Vm::eval_result(
  self : Vm,
  source : String,
) -> Result[Value, Value] raise {
  Ok(self.eval(source)) catch {
    ThrowSignal(value) => Err(value)
    err => raise err
  }
}

///|
pub fn Vm::eval_result_with_path(
  self : Vm,
  source : String,
  path : String,
) -> Result[Value, Value] raise {
  Ok(self.eval_with_path(source, path)) catch {
    ThrowSignal(value) => Err(value)
    err => raise err
  }
}

///|
pub fn Vm::eval_result_with_path_mode(
  self : Vm,
  source : String,
  path : String,
  force_module : Bool,
  force_strict : Bool,
) -> Result[Value, Value] raise {
  Ok(self.eval_with_path_mode(source, path, force_module, force_strict)) catch {
    ThrowSignal(value) => Err(value)
    err => raise err
  }
}

///|
fn stmt_updates_completion(stmt : @engine.Stmt) -> Bool {
  match stmt {
    @engine.Stmt::Empty
    | @engine.Stmt::VarDecl(_, _)
    | @engine.Stmt::FunctionDecl(_)
    | @engine.Stmt::ClassDecl(_) => false
    @engine.Stmt::Block(stmts) => stmt_list_updates_completion(stmts)
    @engine.Stmt::Label(_, inner) => stmt_updates_completion(inner)
    _ => true
  }
}

///|
fn stmt_list_updates_completion(stmts : Array[@engine.Stmt]) -> Bool {
  for stmt in stmts {
    if stmt_updates_completion(stmt) {
      return true
    }
  }
  false
}

///|
fn eval_script_with_strict(
  env : Env,
  script : @engine.Script,
  inherit_strict : Bool,
  var_configurable : Bool,
  eval_skip_outer_var : Bool,
) -> Value raise {
  let old_strict = env.strict
  env.strict = if inherit_strict {
    env.strict || script.is_strict || script.is_module
  } else {
    script.is_strict || script.is_module
  }
  try
    with_source_value(script.source, fn() raise {
      let top_level_func_decls = collect_top_level_function_decls(script.body)
      let func_var_names = compute_annex_b_var_func_decls(
        script.body,
        env.strict,
        @hashmap.new(),
        false,
      )
      with_top_level_function_decls(top_level_func_decls, fn() raise {
        with_annex_b_var_func_decls(func_var_names, fn() raise {
          if env.parent is None && !script.is_module && !var_configurable {
            check_global_script_decls(env, script.body, env.strict)
          }
          let needs_lex_decls = eval_body_has_lexical_decls(script.body)
          if needs_lex_decls {
            eval_predeclare_lexical_decls(env, script.body)
          }
          hoist_decls(env, script.body, var_configurable, eval_skip_outer_var)
          try {
            let mut last = Undefined
            for stmt in script.body {
              let value = eval_stmt(env, stmt)
              if stmt_updates_completion(stmt) {
                last = value
              }
              gc_maybe_collect_with_root(last)
            }
            last
          } catch {
            ReturnSignal(_) => throw_syntax_error("illegal return")
            BreakSignal((_, _)) => throw_syntax_error("illegal break")
            ContinueSignal((_, _)) => throw_syntax_error("illegal continue")
            ThrowSignal(value) => raise ThrowSignal(value)
            err => raise err
          }
        })
      })
    })
  catch {
    err => {
      env.strict = old_strict
      raise err
    }
  } noraise {
    result => {
      env.strict = old_strict
      result
    }
  }
}

///|
fn eval_script(env : Env, script : @engine.Script) -> Value raise {
  eval_script_with_strict(env, script, true, false, false)
}

///|
#warnings("-unused_error_type")
fn initialize_binding_assign(
  env : Env,
  name : String,
  value : Value,
) -> Unit raise {
  env_initialize_binding(env, name, value)
}

///|
fn assign_binding_value(
  env : Env,
  binding : @engine.VarBinding,
  value : Value,
  assign : (String, Value) -> Unit raise,
) -> Unit raise {
  match binding {
    @engine.VarBinding::Name(name) => assign(name, value)
    @engine.VarBinding::ArrayPattern(pattern) =>
      destructure_array_pattern(env, pattern, value, assign)
    @engine.VarBinding::ObjectPattern(pattern) =>
      destructure_object_pattern(env, pattern, value, assign)
    @engine.VarBinding::Target(expr) => assign_for_in_expr(env, expr, value)
  }
}

///|
fn prepare_identifier_assignment_target(
  env : Env,
  name : String,
  strict : Bool,
) -> ((Value) -> Unit raise) raise {
  match env.with_object {
    Some(obj) =>
      if has_property_value(obj, name) && !is_unscopable(obj, name) {
        return fn(value) raise {
          if has_property_value(obj, name) {
            let _ = property_set(obj, name, value, strict)

          } else if strict {
            let _ = throw_reference_error("undefined variable")

          } else {
            let _ = property_set(obj, name, value, false)

          }
        }
      }
    None => ()
  }
  match env.bindings.get(name) {
    Some(_) =>
      fn(value) raise { env_set_with_strict_no_with(env, name, value, strict) }
    None =>
      match env.parent {
        Some(parent) =>
          prepare_identifier_assignment_target(parent, name, strict)
        None =>
          match global_object(env) {
            Some(obj) =>
              if has_property_in_chain(obj.props, obj.proto, name) {
                fn(value) raise {
                  if has_property_in_chain(obj.props, obj.proto, name) {
                    let _ = property_set(
                      Value::Object(obj),
                      name,
                      value,
                      strict,
                    )

                  } else if strict {
                    let _ = throw_reference_error("undefined variable")

                  } else {
                    let _ = property_set(Value::Object(obj), name, value, false)

                  }
                }
              } else {
                fn(value) raise {
                  if strict {
                    let _ = throw_reference_error("undefined variable")

                  } else {
                    let _ = property_set(Value::Object(obj), name, value, false)

                  }
                }
              }
            None => fn(value) { env.bindings.set(name, value) }
          }
      }
  }
}

///|
fn prepare_member_assignment_target_with_roots(
  env : Env,
  obj_expr : @engine.Expr,
  key : @engine.MemberKey,
) -> (Array[Value], (Value) -> Unit raise) raise {
  let roots : Array[Value] = []
  match obj_expr {
    @engine.Expr::Super =>
      match key {
        @engine.MemberKey::Private(_) => {
          let _ = throw_syntax_error(
            "private class field forbidden after super",
          )
          (roots, fn(_) { () })
        }
        @engine.MemberKey::Computed(expr) => {
          let receiver = env_get(env, "this")
          let base = resolve_super_base()
          let key_value = eval_expr(env, expr)
          roots.push(receiver)
          roots.push(base)
          roots.push(key_value)
          (
            roots,
            fn(value) raise {
              let name = property_key_name(key_value)
              super_set_property(env, base, receiver, name, value)
            },
          )
        }
        _ => {
          let receiver = env_get(env, "this")
          let base = resolve_super_base()
          let name = member_key_name(env, key)
          roots.push(receiver)
          roots.push(base)
          (
            roots,
            fn(value) raise {
              super_set_property(env, base, receiver, name, value)
            },
          )
        }
      }
    _ =>
      match key {
        @engine.MemberKey::Private(name) => {
          let target = eval_expr(env, obj_expr)
          let key_name = env_private_key_checked(env, name)
          roots.push(target)
          (
            roots,
            fn(value) raise {
              private_property_set(target, key_name, name, value)
            },
          )
        }
        @engine.MemberKey::Computed(expr) => {
          let target = eval_expr(env, obj_expr)
          let key_value = eval_expr(env, expr)
          roots.push(target)
          roots.push(key_value)
          (
            roots,
            fn(value) raise {
              let name = property_key_name(key_value)
              let _ = set_property_for_value(target, name, value, env.strict)

            },
          )
        }
        _ => {
          let target = eval_expr(env, obj_expr)
          let name = member_key_name(env, key)
          roots.push(target)
          (
            roots,
            fn(value) raise {
              let _ = set_property_for_value(target, name, value, env.strict)

            },
          )
        }
      }
  }
}

///|
fn prepare_assignment_target_with_roots(
  env : Env,
  expr : @engine.Expr,
) -> (Array[Value], (Value) -> Unit raise) raise {
  match expr {
    @engine.Expr::Ident(name, _) =>
      ([], prepare_identifier_assignment_target(env, name, env.strict))
    @engine.Expr::Member(obj_expr, key, _) =>
      prepare_member_assignment_target_with_roots(env, obj_expr, key)
    @engine.Expr::Paren(inner) =>
      prepare_assignment_target_with_roots(env, inner)
    _ => {
      let _ = throw_type_error("invalid assignment target")
      ([], fn(_) { () })
    }
  }
}

///|
fn destructure_array_pattern(
  env : Env,
  pattern : Array[@engine.ArrayPatternElem],
  value : Value,
  assign : (String, Value) -> Unit raise,
) -> Unit raise {
  let _ = with_gc_frame(fn() raise {
    let (iterator, next_method) = get_iterator_from_value(value)
    let _ = gc_root_push(iterator)
    let _ = gc_root_push(next_method)
    let mut done = false
    for elem in pattern {
      match elem {
        @engine.ArrayPatternElem::Hole =>
          if !done {
            let (is_done, _) = iterator_step_value(iterator, next_method)
            done = is_done
          }
        @engine.ArrayPatternElem::Bind(binding, default) => {
          let mut target_info : (Array[Value], (Value) -> Unit raise)? = None
          match binding {
            @engine.VarBinding::Target(expr) =>
              target_info = Some(
                prepare_assignment_target_with_roots(env, expr) catch {
                  err => {
                    if !done {
                      iterator_close_on_error(iterator)
                    }
                    raise err
                  }
                },
              )
            _ => ()
          }
          let mut element = Undefined
          if !done {
            let (is_done, item) = iterator_step_value(iterator, next_method)
            done = is_done
            if !is_done {
              element = item
            }
          }
          try {
            match target_info {
              Some(info) => {
                let _ = with_gc_frame(fn() raise {
                  let (roots, assigner) = info
                  for root in roots {
                    let _ = gc_root_push(root)

                  }
                  match default {
                    Some(expr) =>
                      if element is Undefined {
                        let value = match binding {
                          @engine.VarBinding::Name(name) =>
                            eval_named_expr(env, expr, name, None)
                          _ => eval_expr(env, expr)
                        }
                        element = value
                      }
                    None => ()
                  }
                  let _ = gc_root_push(element)
                  assigner(element)
                  Undefined
                })

              }
              None => {
                let _ = with_gc_frame(fn() raise {
                  match default {
                    Some(expr) =>
                      if element is Undefined {
                        let value = match binding {
                          @engine.VarBinding::Name(name) =>
                            eval_named_expr(env, expr, name, None)
                          _ => eval_expr(env, expr)
                        }
                        element = value
                      }
                    None => ()
                  }
                  let _ = gc_root_push(element)
                  assign_binding_value(env, binding, element, assign)
                  Undefined
                })

              }
            }
          } catch {
            err => {
              if !done {
                iterator_close_on_error(iterator)
              }
              raise err
            }
          }
        }
        @engine.ArrayPatternElem::Rest(binding) => {
          let mut target_info : (Array[Value], (Value) -> Unit raise)? = None
          match binding {
            @engine.VarBinding::Target(expr) =>
              target_info = Some(
                prepare_assignment_target_with_roots(env, expr) catch {
                  err => {
                    if !done {
                      iterator_close_on_error(iterator)
                    }
                    raise err
                  }
                },
              )
            _ => ()
          }
          let rest_values : Array[Value?] = []
          if !done {
            for {
              let (is_done, item) = iterator_step_value(iterator, next_method)
              if is_done {
                done = true
                break
              }
              rest_values.push(Some(item))
            }
          }
          try {
            match target_info {
              Some(info) => {
                let _ = with_gc_frame(fn() raise {
                  let (roots, assigner) = info
                  for root in roots {
                    let _ = gc_root_push(root)

                  }
                  let rest_value = new_array_value(rest_values)
                  let _ = gc_root_push(rest_value)
                  assigner(rest_value)
                  Undefined
                })

              }
              None => {
                let _ = with_gc_frame(fn() raise {
                  let rest_value = new_array_value(rest_values)
                  let _ = gc_root_push(rest_value)
                  assign_binding_value(env, binding, rest_value, assign)
                  Undefined
                })

              }
            }
          } catch {
            err => {
              if !done {
                iterator_close_on_error(iterator)
              }
              raise err
            }
          }
          done = true
        }
      }
    }
    if !done {
      iterator_close(iterator)
    }
    Undefined
  })

}

///|
fn own_enumerable_string_keys(target : Value) -> Array[String] raise {
  let names_value = object_keys(target)
  match names_value {
    Array(arr) => {
      let names : Array[String] = []
      for entry in arr.elements {
        match entry {
          Some(String(name)) => names.push(name)
          _ => ()
        }
      }
      names
    }
    _ => []
  }
}

///|
fn own_string_keys(target : Value) -> Array[String] raise {
  let names_value = object_get_own_property_names(target)
  match names_value {
    Array(arr) => {
      let names : Array[String] = []
      for entry in arr.elements {
        match entry {
          Some(String(name)) => names.push(name)
          _ => ()
        }
      }
      names
    }
    _ => []
  }
}

///|
fn enumerable_string_keys_in_chain(target : Value) -> Array[String] raise {
  let mut current = to_object(target)
  let names : Array[String] = []
  let seen : Map[String, Bool] = Map::new()
  while true {
    let enum_keys = own_enumerable_string_keys(current)
    for key in enum_keys {
      if !seen.contains(key) {
        seen.set(key, true)
        names.push(key)
      }
    }
    let all_keys = own_string_keys(current)
    for key in all_keys {
      if !seen.contains(key) {
        seen.set(key, true)
      }
    }
    let proto = get_proto_of_value(current)
    match proto {
      Some(obj) => current = obj
      None => break
    }
  }
  names
}

///|
fn is_enumerable_key_in_chain(target : Value, key : String) -> Bool raise {
  let mut current = to_object(target)
  while true {
    let desc = get_own_property_descriptor(current, key)
    match desc {
      Undefined => ()
      _ =>
        if !is_object_like(desc) {
          let _ = throw_type_error("invalid property descriptor")
          return false
        } else {
          let enumerable_value = property_get(desc, "enumerable")
          return is_truthy(enumerable_value)
        }
    }
    let proto = get_proto_of_value(current)
    match proto {
      Some(obj) => current = obj
      None => return false
    }
  }
  false
}

///|
fn destructure_object_pattern(
  env : Env,
  pattern : Array[@engine.ObjectPatternElem],
  value : Value,
  assign : (String, Value) -> Unit raise,
) -> Unit raise {
  let _ = with_gc_frame(fn() raise {
    let obj = to_object(value)
    let _ = gc_root_push(obj)
    let bound : Array[String] = []
    for elem in pattern {
      match elem {
        @engine.ObjectPatternElem::Bind(key, binding, default) => {
          let key_name = match key {
            @engine.ObjKey::Computed(expr) => {
              let base = gc_root_depth()
              try {
                let key_value = eval_expr(env, expr)
                let _ = gc_root_push(key_value)
                let name = property_key_name(key_value)
                gc_root_pop_to(base)
                name
              } catch {
                err => {
                  gc_root_pop_to(base)
                  raise err
                }
              }
            }
            _ => obj_key_simple_name(key)
          }
          bound.push(key_name)
          let mut target_info : (Array[Value], (Value) -> Unit raise)? = None
          match binding {
            @engine.VarBinding::Target(expr) =>
              target_info = Some(
                prepare_assignment_target_with_roots(env, expr),
              )
            _ => ()
          }
          let mut with_obj : Value? = None
          let mut with_has : Bool? = None
          match binding {
            @engine.VarBinding::Name(name) =>
              match env.with_object {
                Some(obj) => {
                  with_obj = Some(obj)
                  with_has = Some(has_property_value(obj, name))
                }
                None => ()
              }
            _ => ()
          }
          let mut prop_value = property_get(obj, key_name)
          match target_info {
            Some(info) => {
              let _ = with_gc_frame(fn() raise {
                let (roots, assigner) = info
                for root in roots {
                  let _ = gc_root_push(root)

                }
                match default {
                  Some(expr) =>
                    if prop_value is Undefined {
                      let value = match binding {
                        @engine.VarBinding::Name(name) =>
                          eval_named_expr(env, expr, name, None)
                        _ => eval_expr(env, expr)
                      }
                      prop_value = value
                    }
                  None => ()
                }
                let _ = gc_root_push(prop_value)
                assigner(prop_value)
                Undefined
              })

            }
            None => {
              let _ = with_gc_frame(fn() raise {
                match default {
                  Some(expr) =>
                    if prop_value is Undefined {
                      let value = match binding {
                        @engine.VarBinding::Name(name) =>
                          eval_named_expr(env, expr, name, None)
                        _ => eval_expr(env, expr)
                      }
                      prop_value = value
                    }
                  None => ()
                }
                let _ = gc_root_push(prop_value)
                match binding {
                  @engine.VarBinding::Name(name) =>
                    match with_obj {
                      Some(target) =>
                        match with_has {
                          Some(has_with) =>
                            if has_with {
                              let _ = property_set(
                                target,
                                name,
                                prop_value,
                                env.strict,
                              )

                            } else {
                              env_set_with_strict_no_with(
                                env,
                                name,
                                prop_value,
                                env.strict,
                              )
                            }
                          None =>
                            assign_binding_value(
                              env, binding, prop_value, assign,
                            )
                        }
                      None =>
                        assign_binding_value(env, binding, prop_value, assign)
                    }
                  _ => assign_binding_value(env, binding, prop_value, assign)
                }
                Undefined
              })

            }
          }
        }
        @engine.ObjectPatternElem::Rest(binding) => {
          let mut target_info : (Array[Value], (Value) -> Unit raise)? = None
          match binding {
            @engine.VarBinding::Target(expr) =>
              target_info = Some(
                prepare_assignment_target_with_roots(env, expr),
              )
            _ => ()
          }
          match target_info {
            Some(info) => {
              let _ = with_gc_frame(fn() raise {
                let (roots, assigner) = info
                for root in roots {
                  let _ = gc_root_push(root)

                }
                let rest_value = new_object_value()
                match rest_value {
                  Object(rest_obj) =>
                    copy_data_properties_excluding(rest_obj, obj, bound)
                  _ => ()
                }
                let _ = gc_root_push(rest_value)
                assigner(rest_value)
                Undefined
              })

            }
            None => {
              let _ = with_gc_frame(fn() raise {
                let rest_value = new_object_value()
                match rest_value {
                  Object(rest_obj) =>
                    copy_data_properties_excluding(rest_obj, obj, bound)
                  _ => ()
                }
                let _ = gc_root_push(rest_value)
                assign_binding_value(env, binding, rest_value, assign)
                Undefined
              })

            }
          }
        }
      }
    }
    Undefined
  })

}

///|
fn label_matches(signal_label : String?, target_label : String?) -> Bool {
  match signal_label {
    None => true
    Some(name) =>
      match target_label {
        Some(target) => target == name
        None => false
      }
  }
}

///|
fn update_empty(value_opt : Value?, fallback : Value) -> Value {
  match value_opt {
    Some(value) => value
    None => fallback
  }
}

///|
fn eval_while_with_label(
  env : Env,
  label : String?,
  cond_expr : @engine.Expr,
  body : @engine.Stmt,
) -> Value raise {
  let mut last = Undefined
  let mut gc_tick = 0
  while is_truthy(eval_expr(env, cond_expr)) {
    try {
      last = eval_stmt(env, body)
    } catch {
      BreakSignal((signal_label, value_opt)) => {
        let updated = update_empty(value_opt, last)
        if label_matches(signal_label, label) {
          last = updated
          gc_tick = loop_gc_maybe(env, last, gc_tick)
          break
        } else {
          raise BreakSignal((signal_label, Some(updated)))
        }
      }
      ContinueSignal((signal_label, value_opt)) => {
        let updated = update_empty(value_opt, last)
        if label_matches(signal_label, label) {
          last = updated
          gc_tick = loop_gc_maybe(env, last, gc_tick)
          continue
        } else {
          raise ContinueSignal((signal_label, Some(updated)))
        }
      }
      err => raise err
    }
    gc_tick = loop_gc_maybe(env, last, gc_tick)
  }
  last
}

///|
fn for_init_binding_names(init : @engine.ForInit) -> Array[String] {
  let names : @hashmap.HashMap[String, Bool] = @hashmap.new()
  match init {
    @engine.ForInit::Var(_, decls) =>
      for decl in decls {
        let (binding, _) = decl
        collect_binding_names(binding, names)
      }
    _ => ()
  }
  let result : Array[String] = []
  for name, _ in names {
    result.push(name)
  }
  result
}

///|
fn create_for_iteration_env(
  source_env : Env,
  outer_env : Env,
  names : Array[String],
  is_const : Bool,
) -> Env raise {
  let iter_env = Env::new(Some(outer_env))
  for name in names {
    let value = env_get(source_env, name)
    if is_const {
      env_define_readonly(iter_env, name, value, true)
    } else {
      env_initialize_binding(iter_env, name, value)
    }
  }
  iter_env
}

///|
fn eval_for_with_label(
  env : Env,
  label : String?,
  init : @engine.ForInit,
  test_expr : @engine.Expr?,
  update_expr : @engine.Expr?,
  body : @engine.Stmt,
) -> Value raise {
  let mut last = Undefined
  let (use_loop_env, loop_is_const) = match init {
    @engine.ForInit::Var(kind, _) =>
      if kind is @engine.VarKind::Var {
        (false, false)
      } else {
        (true, kind is @engine.VarKind::ConstDecl)
      }
    _ => (false, false)
  }
  let loop_env = if use_loop_env { Env::new(Some(env)) } else { env }
  let loop_names = if use_loop_env {
    for_init_binding_names(init)
  } else {
    ([] : Array[String])
  }
  let reuse_iter_env = use_loop_env &&
    !loop_is_const &&
    !for_loop_needs_per_iteration_env(init, test_expr, update_expr, body)
  if use_loop_env {
    hoist_functions(loop_env, body, false, false)
  }
  let _ = with_env_value(loop_env, fn() raise {
    eval_for_init(loop_env, init)
    Undefined
  })
  let mut iter_env = if use_loop_env {
    if reuse_iter_env {
      loop_env
    } else {
      create_for_iteration_env(loop_env, loop_env, loop_names, loop_is_const)
    }
  } else {
    loop_env
  }
  let mut gc_tick = 0
  while true {
    let current_env = if use_loop_env { iter_env } else { loop_env }
    let should_continue = match test_expr {
      Some(expr) =>
        is_truthy(
          with_env_value(current_env, fn() raise {
            eval_expr(current_env, expr)
          }),
        )
      None => true
    }
    if !should_continue {
      break
    }
    let mut do_update = false
    try {
      last = with_env_value(current_env, fn() raise {
        eval_stmt(current_env, body)
      })
      do_update = true
    } catch {
      BreakSignal((signal_label, value_opt)) => {
        let updated = update_empty(value_opt, last)
        if label_matches(signal_label, label) {
          last = updated
          gc_tick = loop_gc_maybe(current_env, last, gc_tick)
          break
        } else {
          raise BreakSignal((signal_label, Some(updated)))
        }
      }
      ContinueSignal((signal_label, value_opt)) => {
        let updated = update_empty(value_opt, last)
        if label_matches(signal_label, label) {
          last = updated
          do_update = true
        } else {
          raise ContinueSignal((signal_label, Some(updated)))
        }
      }
      err => raise err
    }
    if do_update {
      let update_env = if use_loop_env {
        if reuse_iter_env {
          loop_env
        } else {
          let created = create_for_iteration_env(
            current_env, loop_env, loop_names, loop_is_const,
          )
          iter_env = created
          created
        }
      } else {
        loop_env
      }
      match update_expr {
        Some(expr) => {
          let _ = with_env_value(update_env, fn() raise {
            eval_expr(update_env, expr)
          })

        }
        None => ()
      }
      gc_tick = loop_gc_maybe(current_env, last, gc_tick)
    }
  }
  last
}

///|
fn initialize_var_binding(
  env : Env,
  binding : @engine.VarBinding,
  value : Value,
) -> Unit raise {
  let assign = fn(name : String, v : Value) raise {
    initialize_binding_assign(env, name, v)
  }
  match binding {
    @engine.VarBinding::Name(name) => assign(name, value)
    @engine.VarBinding::ArrayPattern(pattern) =>
      destructure_array_pattern(env, pattern, value, assign)
    @engine.VarBinding::ObjectPattern(pattern) =>
      destructure_object_pattern(env, pattern, value, assign)
    @engine.VarBinding::Target(expr) => assign_for_in_expr(env, expr, value)
  }
}

///|
fn assign_var_binding(
  env : Env,
  binding : @engine.VarBinding,
  value : Value,
  use_env_set : Bool,
) -> Unit raise {
  let assign = fn(name : String, v : Value) raise {
    if use_env_set {
      env_set(env, name, v)
    } else {
      env_set_local(env, name, v)
    }
  }
  match binding {
    @engine.VarBinding::Name(name) => assign(name, value)
    @engine.VarBinding::ArrayPattern(pattern) =>
      destructure_array_pattern(env, pattern, value, assign)
    @engine.VarBinding::ObjectPattern(pattern) =>
      destructure_object_pattern(env, pattern, value, assign)
    @engine.VarBinding::Target(expr) => assign_for_in_expr(env, expr, value)
  }
}

///|
fn assign_for_in_const_binding(
  env : Env,
  binding : @engine.VarBinding,
  value : Value,
) -> Unit raise {
  let assign = fn(name : String, v : Value) {
    env_define_readonly(env, name, v, true)
  }
  match binding {
    @engine.VarBinding::Name(name) => assign(name, value)
    @engine.VarBinding::ArrayPattern(pattern) =>
      destructure_array_pattern(env, pattern, value, fn(name, v) {
        assign(name, v)
      })
    @engine.VarBinding::ObjectPattern(pattern) =>
      destructure_object_pattern(env, pattern, value, fn(name, v) {
        assign(name, v)
      })
    @engine.VarBinding::Target(expr) => assign_for_in_expr(env, expr, value)
  }
}

///|
fn assign_for_in_expr(
  env : Env,
  expr : @engine.Expr,
  value : Value,
) -> Unit raise {
  match expr {
    @engine.Expr::Ident(name, _) => env_set(env, name, value)
    @engine.Expr::Member(obj_expr, key, _) =>
      match obj_expr {
        @engine.Expr::Super =>
          match key {
            @engine.MemberKey::Private(_) => {
              let _ = throw_syntax_error(
                "private class field forbidden after super",
              )
              ()
            }
            @engine.MemberKey::Computed(expr) => {
              let receiver = env_get(env, "this")
              let base = resolve_super_base()
              let key_value = eval_expr(env, expr)
              let name = property_key_name(key_value)
              super_set_property(env, base, receiver, name, value)
            }
            _ => {
              let receiver = env_get(env, "this")
              let base = resolve_super_base()
              let name = member_key_name(env, key)
              super_set_property(env, base, receiver, name, value)
            }
          }
        _ =>
          match key {
            @engine.MemberKey::Private(name) => {
              let target = eval_expr(env, obj_expr)
              let key_name = env_private_key_checked(env, name)
              private_property_set(target, key_name, name, value)
            }
            _ => {
              let target = eval_expr(env, obj_expr)
              let name = member_key_name(env, key)
              let _ = set_property_for_value(target, name, value, env.strict)

            }
          }
      }
    @engine.Expr::Paren(inner) => assign_for_in_expr(env, inner, value)
    @engine.Expr::AssignArray(pattern, _) =>
      destructure_array_pattern(env, pattern, value, fn(name, v) raise {
        env_set(env, name, v)
      })
    @engine.Expr::AssignObject(pattern, _) =>
      destructure_object_pattern(env, pattern, value, fn(name, v) raise {
        env_set(env, name, v)
      })
    @engine.Expr::Call(_, _, _) => {
      let _ = eval_expr(env, expr)
      let _ = throw_reference_error("invalid assignment target")

    }
    _ => {
      let _ = throw_type_error("invalid for-in target")

    }
  }
}

///|
fn gen_assign_var_binding(
  env : Env,
  binding : @engine.VarBinding,
  value : Value,
  use_env_set : Bool,
  k : () -> GenStep raise,
) -> GenStep raise {
  let assign = fn(name : String, v : Value) raise {
    if use_env_set {
      env_set(env, name, v)
    } else {
      env_set_local(env, name, v)
    }
  }
  match binding {
    @engine.VarBinding::Name(name) => {
      assign(name, value)
      k()
    }
    @engine.VarBinding::ArrayPattern(pattern) =>
      gen_destructure_array_pattern(env, pattern, value, assign, k)
    @engine.VarBinding::ObjectPattern(pattern) => {
      let obj = to_object(value)
      gen_destructure_object_pattern(env, pattern, obj, [], 0, assign, k)
    }
    @engine.VarBinding::Target(expr) =>
      gen_assign_for_in_expr(env, expr, value, k)
  }
}

///|
#warnings("-unused_error_type")
fn define_readonly_assign(
  env : Env,
  name : String,
  value : Value,
) -> Unit raise {
  env_define_readonly(env, name, value, true)
}

///|
fn gen_assign_for_in_const_binding(
  env : Env,
  binding : @engine.VarBinding,
  value : Value,
  k : () -> GenStep raise,
) -> GenStep raise {
  let assign = fn(name : String, v : Value) raise {
    define_readonly_assign(env, name, v)
  }
  match binding {
    @engine.VarBinding::Name(name) => {
      assign(name, value)
      k()
    }
    @engine.VarBinding::ArrayPattern(pattern) =>
      gen_destructure_array_pattern(env, pattern, value, assign, k)
    @engine.VarBinding::ObjectPattern(pattern) => {
      let obj = to_object(value)
      gen_destructure_object_pattern(env, pattern, obj, [], 0, assign, k)
    }
    @engine.VarBinding::Target(expr) =>
      gen_assign_for_in_expr(env, expr, value, k)
  }
}

///|
fn gen_assign_for_in_expr(
  env : Env,
  expr : @engine.Expr,
  value : Value,
  k : () -> GenStep raise,
) -> GenStep raise {
  gen_with_root_frame(fn() raise {
    let _ = gen_root_push(value)
    match expr {
      @engine.Expr::Ident(name, _) => {
        env_set(env, name, value)
        k()
      }
      @engine.Expr::Member(obj_expr, key, _) =>
        match obj_expr {
          @engine.Expr::Super =>
            match key {
              @engine.MemberKey::Private(_) => {
                let _ = throw_syntax_error(
                  "private class field forbidden after super",
                )
                k()
              }
              @engine.MemberKey::Computed(expr) =>
                gen_eval_expr_cont(env, expr, fn(key_value) raise {
                  let receiver = env_get(env, "this")
                  let base = resolve_super_base()
                  let name = property_key_name(key_value)
                  super_set_property(env, base, receiver, name, value)
                  k()
                })
              _ => {
                let receiver = env_get(env, "this")
                let base = resolve_super_base()
                let name = member_key_name(env, key)
                super_set_property(env, base, receiver, name, value)
                k()
              }
            }
          _ =>
            match key {
              @engine.MemberKey::Private(name) =>
                gen_eval_expr_cont(env, obj_expr, fn(target) raise {
                  let key_name = env_private_key_checked(env, name)
                  private_property_set(target, key_name, name, value)
                  k()
                })
              _ =>
                gen_eval_expr_cont(env, obj_expr, fn(target) raise {
                  let _ = gen_root_push(target)
                  gen_eval_member_key(env, key, fn(name) raise {
                    let _ = set_property_for_value(
                      target,
                      name,
                      value,
                      env.strict,
                    )
                    k()
                  })
                })
            }
        }
      @engine.Expr::Paren(inner) => gen_assign_for_in_expr(env, inner, value, k)
      @engine.Expr::AssignArray(pattern, _) =>
        gen_destructure_array_pattern(
          env,
          pattern,
          value,
          fn(name, v) raise { env_set(env, name, v) },
          k,
        )
      @engine.Expr::AssignObject(pattern, _) => {
        let obj = to_object(value)
        gen_destructure_object_pattern(
          env,
          pattern,
          obj,
          [],
          0,
          fn(name, v) raise { env_set(env, name, v) },
          k,
        )
      }
      @engine.Expr::Call(_, _, _) =>
        gen_eval_expr_cont(env, expr, fn(_) raise {
          let _ = throw_reference_error("invalid assignment target")
          Done(Throw(Undefined))
        })
      _ => {
        let _ = throw_type_error("invalid for-in target")
        Done(Throw(Undefined))
      }
    }
  })
}

///|
fn gen_assign_for_in_target(
  env : Env,
  init : @engine.ForInit,
  value : Value,
  k : () -> GenStep raise,
) -> GenStep raise {
  match init {
    @engine.ForInit::Var(kind, decls) =>
      if !decls.is_empty() {
        let (binding, _) = decls[0]
        if kind is @engine.VarKind::ConstDecl {
          gen_assign_for_in_const_binding(env, binding, value, k)
        } else {
          let use_env_set = kind is @engine.VarKind::Var
          gen_assign_var_binding(env, binding, value, use_env_set, k)
        }
      } else {
        k()
      }
    @engine.ForInit::Expr(expr) => gen_assign_for_in_expr(env, expr, value, k)
    @engine.ForInit::None => k()
  }
}

///|
fn assign_for_in_target(
  env : Env,
  init : @engine.ForInit,
  value : Value,
) -> Unit raise {
  match init {
    @engine.ForInit::Var(kind, decls) =>
      if !decls.is_empty() {
        let (binding, _) = decls[0]
        if kind is @engine.VarKind::ConstDecl {
          assign_for_in_const_binding(env, binding, value)
        } else {
          let use_env_set = kind is @engine.VarKind::Var
          assign_var_binding(env, binding, value, use_env_set)
        }
      }
    @engine.ForInit::Expr(expr) => assign_for_in_expr(env, expr, value)
    @engine.ForInit::None => ()
  }
}

///|
fn eval_for_in_with_label(
  env : Env,
  label : String?,
  init : @engine.ForInit,
  expr : @engine.Expr,
  body : @engine.Stmt,
) -> Value raise {
  let mut last = Undefined
  let use_loop_env = match init {
    @engine.ForInit::Var(kind, _) => !(kind is @engine.VarKind::Var)
    _ => false
  }
  let loop_is_const = match init {
    @engine.ForInit::Var(kind, _) => kind is @engine.VarKind::ConstDecl
    _ => false
  }
  let reuse_iter_env = use_loop_env &&
    !loop_is_const &&
    !for_init_contains_function_like(init) &&
    !stmt_contains_function_like(body)
  let mut pre_eval_var_init = false
  if !use_loop_env {
    match init {
      @engine.ForInit::Var(kind, decls) =>
        if kind is @engine.VarKind::Var {
          let mut has_init = false
          for decl in decls {
            let (_, init_expr) = decl
            if init_expr is Some(_) {
              has_init = true
              break
            }
          }
          if has_init {
            eval_var_decls_no_name(env, kind, decls)
            pre_eval_var_init = true
          }
        }
      _ => ()
    }
  }
  let mut expr_env = env
  if use_loop_env {
    let tdz_env = Env::new(Some(env))
    match init {
      @engine.ForInit::Var(kind, decls) =>
        if !(kind is @engine.VarKind::Var) {
          for decl in decls {
            let (binding, _) = decl
            declare_binding_uninitialized(tdz_env, binding)
          }
        }
      _ => ()
    }
    expr_env = tdz_env
  }
  let target_value = with_env_value(expr_env, fn() raise {
    eval_expr(expr_env, expr)
  })
  let mut target = target_value
  let mut keys : Array[String] = []
  if !(target_value is Null || target_value is Undefined) {
    target = to_object(target_value)
    keys = enumerable_string_keys_in_chain(target)
  }
  let loop_env = if use_loop_env { Env::new(Some(env)) } else { env }
  if use_loop_env {
    hoist_functions(loop_env, body, false, false)
  }
  if use_loop_env {
    match init {
      @engine.ForInit::Var(kind, decls) => {
        let mut has_init = false
        for decl in decls {
          let (_, init_expr) = decl
          if init_expr is Some(_) {
            has_init = true
            break
          }
        }
        if kind is @engine.VarKind::ConstDecl && !has_init {
          for decl in decls {
            let (binding, _) = decl
            declare_binding_names(loop_env, binding)
          }
        } else {
          eval_var_decls(loop_env, kind, decls)
        }
      }
      _ => ()
    }
  } else {
    match init {
      @engine.ForInit::Var(kind, decls) => {
        let mut has_init = false
        for decl in decls {
          let (_, init_expr) = decl
          if init_expr is Some(_) {
            has_init = true
            break
          }
        }
        if kind is @engine.VarKind::ConstDecl && !has_init {
          for decl in decls {
            let (binding, _) = decl
            declare_binding_names(env, binding)
          }
        } else if !(pre_eval_var_init && kind is @engine.VarKind::Var) {
          eval_var_decls(env, kind, decls)
        }
      }
      _ => ()
    }
  }
  let result = with_gc_frame(fn() raise {
    let _ = gc_root_push(target)
    let mut gc_tick = 0
    for key in keys {
      if !is_enumerable_key_in_chain(target, key) {
        continue
      }
      let iter_env = if use_loop_env {
        if reuse_iter_env {
          loop_env
        } else {
          Env::new(Some(loop_env))
        }
      } else {
        loop_env
      }
      try {
        last = with_env_value(iter_env, fn() raise {
          assign_for_in_target(iter_env, init, String(key))
          eval_stmt(iter_env, body)
        })
      } catch {
        BreakSignal((signal_label, value_opt)) => {
          let updated = update_empty(value_opt, last)
          if label_matches(signal_label, label) {
            last = updated
            gc_tick = loop_gc_maybe(loop_env, last, gc_tick)
            break
          } else {
            raise BreakSignal((signal_label, Some(updated)))
          }
        }
        ContinueSignal((signal_label, value_opt)) => {
          let updated = update_empty(value_opt, last)
          if label_matches(signal_label, label) {
            last = updated
            gc_tick = loop_gc_maybe(loop_env, last, gc_tick)
          } else {
            raise ContinueSignal((signal_label, Some(updated)))
          }
        }
        err => raise err
      }
      gc_tick = loop_gc_maybe(loop_env, last, gc_tick)
    }
    last
  })
  result
}

///|
fn eval_for_of_with_label(
  env : Env,
  label : String?,
  init : @engine.ForInit,
  expr : @engine.Expr,
  body : @engine.Stmt,
) -> Value raise {
  let mut last = Undefined
  let use_loop_env = match init {
    @engine.ForInit::Var(kind, _) => !(kind is @engine.VarKind::Var)
    _ => false
  }
  let loop_is_const = match init {
    @engine.ForInit::Var(kind, _) => kind is @engine.VarKind::ConstDecl
    _ => false
  }
  let reuse_iter_env = use_loop_env &&
    !loop_is_const &&
    !for_init_contains_function_like(init) &&
    !stmt_contains_function_like(body)
  let mut expr_env = env
  if use_loop_env {
    let tdz_env = Env::new(Some(env))
    match init {
      @engine.ForInit::Var(kind, decls) =>
        if !(kind is @engine.VarKind::Var) {
          for decl in decls {
            let (binding, _) = decl
            declare_binding_uninitialized(tdz_env, binding)
          }
        }
      _ => ()
    }
    expr_env = tdz_env
  }
  let iterable = with_env_value(expr_env, fn() raise {
    eval_expr(expr_env, expr)
  })
  let loop_env = if use_loop_env { Env::new(Some(env)) } else { env }
  if use_loop_env {
    hoist_functions(loop_env, body, false, false)
  }
  if use_loop_env {
    match init {
      @engine.ForInit::Var(kind, decls) => {
        let mut has_init = false
        for decl in decls {
          let (_, init_expr) = decl
          if init_expr is Some(_) {
            has_init = true
            break
          }
        }
        if kind is @engine.VarKind::ConstDecl && !has_init {
          for decl in decls {
            let (binding, _) = decl
            declare_binding_names(loop_env, binding)
          }
        } else {
          eval_var_decls(loop_env, kind, decls)
        }
      }
      _ => ()
    }
  } else {
    match init {
      @engine.ForInit::Var(kind, decls) => {
        let mut has_init = false
        for decl in decls {
          let (_, init_expr) = decl
          if init_expr is Some(_) {
            has_init = true
            break
          }
        }
        if kind is @engine.VarKind::ConstDecl && !has_init {
          for decl in decls {
            let (binding, _) = decl
            declare_binding_names(env, binding)
          }
        } else {
          eval_var_decls(env, kind, decls)
        }
      }
      _ => ()
    }
  }
  let (iterator, next_method) = get_iterator_from_value(iterable)
  let result = with_gc_frame(fn() raise {
    let _ = gc_root_push(iterator)
    let _ = gc_root_push(next_method)
    let mut gc_tick = 0
    while true {
      let (done, value) = iterator_step_value(iterator, next_method)
      if done {
        break
      }
      try {
        let iter_env = if use_loop_env {
          if reuse_iter_env {
            loop_env
          } else {
            Env::new(Some(loop_env))
          }
        } else {
          loop_env
        }
        last = with_env_value(iter_env, fn() raise {
          assign_for_in_target(iter_env, init, value)
          eval_stmt(iter_env, body)
        })
      } catch {
        BreakSignal((signal_label, value_opt)) => {
          let updated = update_empty(value_opt, last)
          if label_matches(signal_label, label) {
            last = updated
            gc_tick = loop_gc_maybe(loop_env, last, gc_tick)
            iterator_close(iterator)
            break
          } else {
            iterator_close(iterator)
            raise BreakSignal((signal_label, Some(updated)))
          }
        }
        ContinueSignal((signal_label, value_opt)) => {
          let updated = update_empty(value_opt, last)
          if label_matches(signal_label, label) {
            last = updated
            gc_tick = loop_gc_maybe(loop_env, last, gc_tick)
          } else {
            iterator_close(iterator)
            raise ContinueSignal((signal_label, Some(updated)))
          }
        }
        ReturnSignal(value) => {
          iterator_close(iterator)
          raise ReturnSignal(value)
        }
        ThrowSignal(value) => {
          iterator_close_on_error(iterator)
          raise ThrowSignal(value)
        }
        err => {
          iterator_close_on_error(iterator)
          raise err
        }
      }
      gc_tick = loop_gc_maybe(loop_env, last, gc_tick)
    }
    last
  })
  result
}

///|
fn eval_for_await_of_with_label(
  env : Env,
  label : String?,
  init : @engine.ForInit,
  expr : @engine.Expr,
  body : @engine.Stmt,
) -> Value raise {
  let mut last = Undefined
  let use_loop_env = match init {
    @engine.ForInit::Var(kind, _) => !(kind is @engine.VarKind::Var)
    _ => false
  }
  let loop_is_const = match init {
    @engine.ForInit::Var(kind, _) => kind is @engine.VarKind::ConstDecl
    _ => false
  }
  let reuse_iter_env = use_loop_env &&
    !loop_is_const &&
    !for_init_contains_function_like(init) &&
    !stmt_contains_function_like(body)
  let mut expr_env = env
  if use_loop_env {
    let tdz_env = Env::new(Some(env))
    match init {
      @engine.ForInit::Var(kind, decls) =>
        if !(kind is @engine.VarKind::Var) {
          for decl in decls {
            let (binding, _) = decl
            declare_binding_uninitialized(tdz_env, binding)
          }
        }
      _ => ()
    }
    expr_env = tdz_env
  }
  let iterable = with_env_value(expr_env, fn() raise {
    eval_expr(expr_env, expr)
  })
  let loop_env = if use_loop_env { Env::new(Some(env)) } else { env }
  if use_loop_env {
    hoist_functions(loop_env, body, false, false)
  }
  if use_loop_env {
    match init {
      @engine.ForInit::Var(kind, decls) => {
        let mut has_init = false
        for decl in decls {
          let (_, init_expr) = decl
          if init_expr is Some(_) {
            has_init = true
            break
          }
        }
        if kind is @engine.VarKind::ConstDecl && !has_init {
          for decl in decls {
            let (binding, _) = decl
            declare_binding_names(loop_env, binding)
          }
        } else {
          eval_var_decls(loop_env, kind, decls)
        }
      }
      _ => ()
    }
  } else {
    match init {
      @engine.ForInit::Var(kind, decls) => {
        let mut has_init = false
        for decl in decls {
          let (_, init_expr) = decl
          if init_expr is Some(_) {
            has_init = true
            break
          }
        }
        if kind is @engine.VarKind::ConstDecl && !has_init {
          for decl in decls {
            let (binding, _) = decl
            declare_binding_names(env, binding)
          }
        } else {
          eval_var_decls(env, kind, decls)
        }
      }
      _ => ()
    }
  }
  let (iterator, next_method) = get_async_iterator_from_value(iterable)
  let result = with_gc_frame(fn() raise {
    let _ = gc_root_push(iterator)
    let _ = gc_root_push(next_method)
    let mut gc_tick = 0
    while true {
      let (done, value) = async_iterator_step_value(iterator, next_method)
      if done {
        break
      }
      try {
        let iter_env = if use_loop_env {
          if reuse_iter_env {
            loop_env
          } else {
            Env::new(Some(loop_env))
          }
        } else {
          loop_env
        }
        last = with_env_value(iter_env, fn() raise {
          assign_for_in_target(iter_env, init, value)
          eval_stmt(iter_env, body)
        })
      } catch {
        BreakSignal((signal_label, value_opt)) => {
          let updated = update_empty(value_opt, last)
          if label_matches(signal_label, label) {
            last = updated
            gc_tick = loop_gc_maybe(loop_env, last, gc_tick)
            async_iterator_close(iterator)
            break
          } else {
            async_iterator_close(iterator)
            raise BreakSignal((signal_label, Some(updated)))
          }
        }
        ContinueSignal((signal_label, value_opt)) => {
          let updated = update_empty(value_opt, last)
          if label_matches(signal_label, label) {
            last = updated
            gc_tick = loop_gc_maybe(loop_env, last, gc_tick)
          } else {
            async_iterator_close(iterator)
            raise ContinueSignal((signal_label, Some(updated)))
          }
        }
        ReturnSignal(value) => {
          async_iterator_close(iterator)
          raise ReturnSignal(value)
        }
        ThrowSignal(value) => {
          async_iterator_close_on_error(iterator)
          raise ThrowSignal(value)
        }
        err => {
          async_iterator_close_on_error(iterator)
          raise err
        }
      }
      gc_tick = loop_gc_maybe(loop_env, last, gc_tick)
    }
    last
  })
  result
}

///|
fn eval_do_while_with_label(
  env : Env,
  label : String?,
  body : @engine.Stmt,
  cond_expr : @engine.Expr,
) -> Value raise {
  let mut last = Undefined
  let mut gc_tick = 0
  while true {
    try {
      last = eval_stmt(env, body)
    } catch {
      BreakSignal((signal_label, value_opt)) => {
        let updated = update_empty(value_opt, last)
        if label_matches(signal_label, label) {
          last = updated
          gc_tick = loop_gc_maybe(env, last, gc_tick)
          break
        } else {
          raise BreakSignal((signal_label, Some(updated)))
        }
      }
      ContinueSignal((signal_label, value_opt)) => {
        let updated = update_empty(value_opt, last)
        if label_matches(signal_label, label) {
          last = updated
        } else {
          raise ContinueSignal((signal_label, Some(updated)))
        }
      }
      err => raise err
    }
    gc_tick = loop_gc_maybe(env, last, gc_tick)
    if !is_truthy(eval_expr(env, cond_expr)) {
      break
    }
  }
  last
}

///|
fn eval_switch_with_label(
  env : Env,
  label : String?,
  discriminant : @engine.Expr,
  cases : Array[@engine.SwitchCase],
) -> Value raise {
  let mut last = Undefined
  let value = eval_expr(env, discriminant)
  let switch_env = Env::new(Some(env))
  let case_stmts : Array[@engine.Stmt] = []
  for clause in cases {
    let body = match clause {
      @engine.SwitchCase::Case(_, stmts) => stmts
      @engine.SwitchCase::Default(stmts) => stmts
    }
    for stmt in body {
      case_stmts.push(stmt)
    }
  }
  if !case_stmts.is_empty() {
    hoist_block_functions(switch_env, case_stmts)
    eval_predeclare_lexical_decls(switch_env, case_stmts)
  }
  let mut start : Int? = None
  for i, clause in cases {
    match clause {
      @engine.SwitchCase::Case(expr, _) => {
        let case_value = eval_expr(switch_env, expr)
        if strict_eq(value, case_value) {
          start = Some(i)
          break
        }
      }
      @engine.SwitchCase::Default(_) => if start is None { start = Some(i) }
    }
  }
  match start {
    None => ()
    Some(start_index) =>
      for j = start_index; j < cases.length(); j = j + 1 {
        let clause = cases[j]
        let stmts = match clause {
          @engine.SwitchCase::Case(_, body) => body
          @engine.SwitchCase::Default(body) => body
        }
        try {
          for stmt in stmts {
            let value = eval_stmt(switch_env, stmt)
            if stmt_updates_completion(stmt) {
              last = value
            }
          }
        } catch {
          BreakSignal((signal_label, value_opt)) => {
            let updated = update_empty(value_opt, last)
            if label_matches(signal_label, label) {
              last = updated
              break
            } else {
              raise BreakSignal((signal_label, Some(updated)))
            }
          }
          ContinueSignal((signal_label, value_opt)) => {
            let updated = update_empty(value_opt, last)
            raise ContinueSignal((signal_label, Some(updated)))
          }
          err => raise err
        }
      }
  }
  last
}

///|
fn eval_stmt(env : Env, stmt : @engine.Stmt) -> Value raise {
  if current_module_env_id() is Some(_) && stmt_is_import_decl(stmt) {
    return Undefined
  }
  match stmt {
    Empty => Undefined
    ExprStmt(expr) => eval_expr(env, expr)
    VarDecl(kind, decls) => {
      eval_var_decls(env, kind, decls)
      Undefined
    }
    Block(stmts) => eval_block(env, stmts)
    FunctionDecl(func) => {
      if top_level_function_decl_contains(func) {
        return Undefined
      }
      let decl_value = Value::Function(to_function_value(env, func, false))
      let value = match func.name {
        Some(name) =>
          match env.bindings.get(name) {
            Some(_) => env_get_binding_value(env, name)
            None =>
              match env.var_object {
                Some(Object(obj)) =>
                  match obj.props.get(name) {
                    Some(prop) =>
                      if is_data_property(prop) {
                        prop.value
                      } else {
                        property_get(Value::Object(obj), name)
                      }
                    None => decl_value
                  }
                Some(_) => decl_value
                None =>
                  if env.parent is None {
                    match global_object(env) {
                      Some(obj) =>
                        match obj.props.get(name) {
                          Some(prop) =>
                            if is_data_property(prop) {
                              prop.value
                            } else {
                              property_get(Value::Object(obj), name)
                            }
                          None => decl_value
                        }
                      None => decl_value
                    }
                  } else {
                    decl_value
                  }
              }
          }
        None => decl_value
      }
      match func.name {
        Some(name) => {
          env_set_local_or_var_object(env, name, value, true)
          if !env.strict && !func.is_async && !func.is_generator {
            let var_env = var_env_for(env)
            if var_env.id != env.id && annex_b_var_func_decl_contains(func) {
              env_set(var_env, name, decl_value)
            }
          }
        }
        None => ()
      }
      Undefined
    }
    ClassDecl(class_def) => {
      let value = eval_class(env, class_def)
      match class_def.name {
        Some(name) => env_initialize_binding(env, name, value)
        None => ()
      }
      Undefined
    }
    If(cond_expr, conseq, alt) => {
      let cond = eval_expr(env, cond_expr)
      if is_truthy(cond) {
        eval_stmt_in_block_if_needed(env, conseq)
      } else {
        match alt {
          Some(stmt) => eval_stmt_in_block_if_needed(env, stmt)
          None => Undefined
        }
      }
    }
    With(expr, body) => {
      if env.strict {
        let _ = throw_syntax_error("with not allowed in strict mode")

      }
      let obj = to_object(eval_expr(env, expr))
      let with_env = Env::{
        id: alloc_id(),
        parent: Some(env),
        bindings: @hashmap.new(),
        readonly_bindings: @hashmap.new(),
        deletable_bindings: @hashmap.new(),
        private_bindings: @hashmap.new(),
        strict: env.strict,
        with_object: Some(obj),
        var_object: None,
        new_target: env.new_target,
        allow_new_target: env.allow_new_target,
        allow_super: env.allow_super,
        allow_super_call: env.allow_super_call,
        this_uninitialized: false,
        is_param_env: false,
        is_catch_env: false,
        param_binding_names: @hashmap.new(),
        uninitialized_bindings: @hashmap.new(),
        var_env: None,
      }
      register_env(with_env)
      with_env_value(with_env, fn() raise { eval_stmt(with_env, body) })
    }
    While(cond_expr, body) => eval_while_with_label(env, None, cond_expr, body)
    For(init, test_expr, update_expr, body) =>
      eval_for_with_label(env, None, init, test_expr, update_expr, body)
    ForIn(init, expr, body) =>
      eval_for_in_with_label(env, None, init, expr, body)
    ForOf(init, expr, body) =>
      eval_for_of_with_label(env, None, init, expr, body)
    ForAwaitOf(init, expr, body) =>
      eval_for_await_of_with_label(env, None, init, expr, body)
    DoWhile(body, cond_expr) =>
      eval_do_while_with_label(env, None, body, cond_expr)
    Switch(discriminant, cases) =>
      eval_switch_with_label(env, None, discriminant, cases)
    Throw(expr) => {
      let value = eval_expr(env, expr)
      raise ThrowSignal(value)
    }
    Try(try_body, catch_clause, finally_body) => {
      let (pending, try_last) = match try_body {
        @engine.Stmt::Block(stmts) =>
          eval_block_control_with_last_stmts(env, stmts)
        _ => (eval_block_control(env, try_body), Undefined)
      }
      let handled = match pending {
        Throw(err_value) =>
          match catch_clause {
            Some(clause) => {
              let catch_env = Env::new(Some(env))
              catch_env.is_catch_env = true
              match clause.name {
                Some(name) => env_set_local(catch_env, name, err_value)
                None => ()
              }
              let catch_updates = stmt_updates_completion(clause.body)
              let caught = match clause.body {
                @engine.Stmt::Block(stmts) =>
                  match clause.name {
                    Some(name) =>
                      if stmts.length() > 0 {
                        match stmts[0] {
                          @engine.Stmt::VarDecl(kind, decls) =>
                            if !(kind is @engine.VarKind::Let) {
                              eval_block_control(catch_env, clause.body)
                            } else if decls.length() == 1 {
                              let (_, init_expr_opt) = decls[0]
                              match init_expr_opt {
                                Some(@engine.Expr::Ident(init_name, _)) =>
                                  if init_name == name {
                                    eval_var_decls(catch_env, kind, decls)
                                    let rest : Array[@engine.Stmt] = []
                                    let mut idx = 1
                                    while idx < stmts.length() {
                                      rest.push(stmts[idx])
                                      idx = idx + 1
                                    }
                                    eval_block_control_stmts(catch_env, rest)
                                  } else {
                                    eval_block_control(catch_env, clause.body)
                                  }
                                _ => eval_block_control(catch_env, clause.body)
                              }
                            } else {
                              eval_block_control(catch_env, clause.body)
                            }
                          _ => eval_block_control(catch_env, clause.body)
                        }
                      } else {
                        eval_block_control(catch_env, clause.body)
                      }
                    None => eval_block_control(catch_env, clause.body)
                  }
                _ => eval_block_control(catch_env, clause.body)
              }
              match caught {
                Normal(value) =>
                  if catch_updates {
                    Normal(value)
                  } else {
                    Normal(try_last)
                  }
                Break(label, value_opt) =>
                  match value_opt {
                    Some(_) => caught
                    None => Break(label, Some(try_last))
                  }
                Continue(label, value_opt) =>
                  match value_opt {
                    Some(_) => caught
                    None => Continue(label, Some(try_last))
                  }
                _ => caught
              }
            }
            None => pending
          }
        _ => pending
      }
      let final_control = match finally_body {
        Some(final_body) =>
          apply_finally_control(handled, eval_block_control(env, final_body))
        None => handled
      }
      match final_control {
        Normal(value) => value
        Throw(value) => raise ThrowSignal(value)
        Return(value) => raise ReturnSignal(value)
        Break(label, value) => raise BreakSignal((label, value))
        Continue(label, value) => raise ContinueSignal((label, value))
      }
    }
    Break(label) => raise BreakSignal((label, None))
    Continue(label) => raise ContinueSignal((label, None))
    Label(name, body) =>
      match body {
        While(cond_expr, inner) =>
          eval_while_with_label(env, Some(name), cond_expr, inner)
        For(init, test_expr, update_expr, inner) =>
          eval_for_with_label(
            env,
            Some(name),
            init,
            test_expr,
            update_expr,
            inner,
          )
        ForIn(init, expr, inner) =>
          eval_for_in_with_label(env, Some(name), init, expr, inner)
        ForOf(init, expr, inner) =>
          eval_for_of_with_label(env, Some(name), init, expr, inner)
        ForAwaitOf(init, expr, inner) =>
          eval_for_await_of_with_label(env, Some(name), init, expr, inner)
        DoWhile(inner, cond_expr) =>
          eval_do_while_with_label(env, Some(name), inner, cond_expr)
        Switch(discriminant, cases) =>
          eval_switch_with_label(env, Some(name), discriminant, cases)
        _ =>
          eval_stmt(env, body) catch {
            BreakSignal((signal_label, value_opt)) =>
              match signal_label {
                Some(label) =>
                  if label == name {
                    update_empty(value_opt, Undefined)
                  } else {
                    raise BreakSignal((signal_label, value_opt))
                  }
                None => raise BreakSignal((signal_label, value_opt))
              }
            ContinueSignal((signal_label, value_opt)) =>
              raise ContinueSignal((signal_label, value_opt))
            err => raise err
          }
      }
    Return(expr) => {
      let value = match expr {
        Some(inner) => eval_expr(env, inner)
        None => Undefined
      }
      raise ReturnSignal(value)
    }
  }
}

///|
fn expr_is_export_call(expr : @engine.Expr) -> Bool {
  match expr {
    @engine.Expr::Call(callee, _, _) =>
      match callee {
        @engine.Expr::Ident(name, _) => name == "__export"
        _ => false
      }
    @engine.Expr::Sequence(exprs) => {
      for inner in exprs {
        if expr_is_export_call(inner) {
          return true
        }
      }
      false
    }
    @engine.Expr::Paren(inner) => expr_is_export_call(inner)
    _ => false
  }
}

///|
fn block_is_export_wrapper(body : Array[@engine.Stmt]) -> Bool {
  if body.length() == 1 {
    return match body[0] {
      @engine.Stmt::ExprStmt(expr) => expr_is_export_call(expr)
      _ => false
    }
  }
  if body.length() != 2 {
    return false
  }
  let first_ok = match body[0] {
    @engine.Stmt::FunctionDecl(_)
    | @engine.Stmt::ClassDecl(_)
    | @engine.Stmt::VarDecl(_, _) => true
    _ => false
  }
  if !first_ok {
    return false
  }
  match body[1] {
    @engine.Stmt::ExprStmt(expr) => expr_is_export_call(expr)
    _ => false
  }
}

///|
fn eval_block(env : Env, body : Array[@engine.Stmt]) -> Value raise {
  if current_module_env_id() is Some(_) && block_is_export_wrapper(body) {
    return eval_block_raw(env, body)
  }
  if block_needs_lex_env(body, env.strict) {
    let block_env = Env::new(Some(env))
    hoist_block_functions(block_env, body)
    eval_predeclare_lexical_decls(block_env, body)
    with_env_value(block_env, fn() raise { eval_block_raw(block_env, body) })
  } else {
    eval_block_raw(env, body)
  }
}

///|
fn eval_block_raw(env : Env, body : Array[@engine.Stmt]) -> Value raise {
  let mut last = Undefined
  for stmt in body {
    try {
      let value = eval_stmt(env, stmt)
      if stmt_updates_completion(stmt) {
        last = value
      }
    } catch {
      BreakSignal((label, value_opt)) => {
        let updated = update_empty(value_opt, last)
        raise BreakSignal((label, Some(updated)))
      }
      ContinueSignal((label, value_opt)) => {
        let updated = update_empty(value_opt, last)
        raise ContinueSignal((label, Some(updated)))
      }
      err => raise err
    }
  }
  last
}

///|
fn eval_stmt_in_block_if_needed(env : Env, stmt : @engine.Stmt) -> Value raise {
  match stmt {
    @engine.Stmt::Block(_) => eval_stmt(env, stmt)
    _ =>
      if stmt_needs_lex_env(stmt, env.strict) {
        let block_env = Env::new(Some(env))
        let stmts : Array[@engine.Stmt] = [stmt]
        hoist_block_functions(block_env, stmts)
        eval_predeclare_lexical_decls(block_env, stmts)
        with_env_value(block_env, fn() raise { eval_stmt(block_env, stmt) })
      } else {
        eval_stmt(env, stmt)
      }
  }
}

///|
fn block_needs_lex_env(body : Array[@engine.Stmt], is_strict : Bool) -> Bool {
  for stmt in body {
    if stmt_needs_lex_env(stmt, is_strict) {
      return true
    }
  }
  false
}

///|
fn stmt_needs_lex_env(stmt : @engine.Stmt, is_strict : Bool) -> Bool {
  match stmt {
    @engine.Stmt::VarDecl(kind, _) => !(kind is @engine.VarKind::Var)
    @engine.Stmt::ClassDecl(_) => true
    @engine.Stmt::FunctionDecl(_) => true
    @engine.Stmt::Label(_, inner) => stmt_needs_lex_env(inner, is_strict)
    _ => false
  }
}

///|
fn hoist_block_functions(
  block_env : Env,
  body : Array[@engine.Stmt],
) -> Unit raise {
  for stmt in body {
    hoist_block_functions_in_stmt(block_env, stmt)
  }
}

///|
fn hoist_block_functions_in_stmt(
  block_env : Env,
  stmt : @engine.Stmt,
) -> Unit raise {
  match stmt {
    @engine.Stmt::FunctionDecl(func) =>
      match func.name {
        Some(name) => {
          let value = Value::Function(to_function_value(block_env, func, false))
          env_set_local(block_env, name, value)
        }
        None => ()
      }
    @engine.Stmt::Label(_, inner) =>
      hoist_block_functions_in_stmt(block_env, inner)
    _ => ()
  }
}

///|
fn eval_template_literal(
  env : Env,
  parts : @engine.TemplateParts,
  exprs : Array[@engine.Expr],
) -> Value raise {
  let mut result = ""
  let cooked = parts.cooked
  if !cooked.is_empty() {
    match cooked[0] {
      Some(text) => result = text
      None => {
        let _ = throw_syntax_error(
          "invalid escape sequence in template literal",
        )

      }
    }
  }
  let mut i = 0
  while i < exprs.length() {
    let value = eval_expr(env, exprs[i])
    result = result + to_string_strict(value)
    if i + 1 < cooked.length() {
      match cooked[i + 1] {
        Some(text) => result = result + text
        None => {
          let _ = throw_syntax_error(
            "invalid escape sequence in template literal",
          )

        }
      }
    }
    i = i + 1
  }
  String(result)
}

///|
fn build_template_object(
  env : Env,
  parts : @engine.TemplateParts,
) -> Value raise {
  let registry = template_registry_for_env(env)
  match registry.get(parts.site_id) {
    Some(value) => value
    None => {
      let cooked : Array[Value?] = []
      let raw_parts : Array[Value?] = []
      for part in parts.cooked {
        match part {
          Some(text) => cooked.push(Some(String(text)))
          None => cooked.push(Some(Undefined))
        }
      }
      for part in parts.raw {
        raw_parts.push(Some(String(part)))
      }
      let cooked_value = new_array_value(cooked)
      let raw_value = new_array_value(raw_parts)
      match cooked_value {
        Array(arr) => arr.props.set("raw", property_data_non_enum(raw_value))
        _ => ()
      }
      let _ = object_freeze(raw_value)
      let _ = object_freeze(cooked_value)
      registry.set(parts.site_id, cooked_value)
      cooked_value
    }
  }
}

///|
fn eval_tagged_template(
  env : Env,
  callee : @engine.Expr,
  parts : @engine.TemplateParts,
  exprs : Array[@engine.Expr],
) -> Value raise {
  let mut this_value : Value? = None
  let callee_value = match callee {
    @engine.Expr::Member(obj_expr, key, _) => {
      let target = eval_expr(env, obj_expr)
      this_value = Some(target)
      match key {
        @engine.MemberKey::Private(name) => {
          let key_name = env_private_key_checked(env, name)
          private_property_get(target, key_name, name)
        }
        _ => {
          let name = member_key_name(env, key)
          let target_obj = to_object(target)
          property_get_with_receiver(target_obj, name, target)
        }
      }
    }
    _ => eval_expr(env, callee)
  }
  let template_obj = build_template_object(env, parts)
  let argv : Array[Value] = [template_obj]
  for expr in exprs {
    argv.push(eval_expr(env, expr))
  }
  match this_value {
    Some(target) => call_value_with_this(callee_value, argv, target)
    None => call_value(callee_value, argv)
  }
}

///|
fn eval_typeof(env : Env, expr : @engine.Expr) -> Value raise {
  match expr {
    @engine.Expr::Ident(name, _) =>
      if env_has(env, name) {
        String(typeof_value(env_get(env, name)))
      } else {
        String("undefined")
      }
    @engine.Expr::Paren(inner) => eval_typeof(env, inner)
    _ => {
      let value = eval_expr(env, expr)
      String(typeof_value(value))
    }
  }
}

///|
fn eval_expr(env : Env, expr : @engine.Expr) -> Value raise {
  match expr {
    Number(value, _, _) => Number(value)
    Bool(value) => Bool(value)
    Null => Null
    String(value, _, _) => String(value)
    TemplateLiteral(parts, exprs) => eval_template_literal(env, parts, exprs)
    TaggedTemplate(callee, parts, exprs) =>
      eval_tagged_template(env, callee, parts, exprs)
    Regexp(pattern, flags, offset) => {
      let proto = match value_from_object(regexp_proto_for_env(env)) {
        Some(value) => Some(value)
        None => value_from_object(regexp_proto())
      }
      new_regexp_value(pattern, flags, proto, offset~)
    }
    BigInt(value) => BigInt(parse_bigint_literal(value))
    Ident(name, offset) =>
      with_expr_pos(offset, fn() raise { env_get(env, name) })
    This => env_get(env, "this")
    NewTarget(_) => env.new_target
    ImportMeta(_) => import_meta_value()
    Super => throw_reference_error("super is not defined")
    Yield(_, _) => throw_type_error("yield not supported")
    Await(inner, offset) =>
      with_expr_pos(offset, fn() raise {
        let value = eval_expr(env, inner)
        match current_function() {
          Some(func) => if func.is_async { await_value(value) } else { value }
          None => value
        }
      })
    Unary(Typeof, inner, offset) =>
      with_expr_pos(offset, fn() raise { eval_typeof(env, inner) })
    Unary(op, inner, offset) =>
      with_expr_pos(offset, fn() raise {
        match op {
          Delete => eval_delete(env, inner)
          _ => eval_unary(op, eval_expr(env, inner))
        }
      })
    Update(op, inner, kind, offset) =>
      with_expr_pos(offset, fn() raise { eval_update(env, op, inner, kind) })
    New(callee, args) => eval_new(env, callee, args)
    Binary(op, left, right, offset) =>
      with_expr_pos(offset, fn() raise {
        with_gc_frame(fn() raise {
          let l = eval_expr(env, left)
          let _ = gc_root_push(l)
          match op {
            LogicalAnd => if is_truthy(l) { eval_expr(env, right) } else { l }
            LogicalOr => if is_truthy(l) { l } else { eval_expr(env, right) }
            Coalesce => if is_nullish(l) { eval_expr(env, right) } else { l }
            _ => {
              let r = eval_expr(env, right)
              eval_binary(op, l, r)
            }
          }
        })
      })
    PrivateIn(name, right, offset) =>
      with_expr_pos(offset, fn() raise {
        let target = eval_expr(env, right)
        Bool(eval_private_in(env, name, target))
      })
    Conditional(test_expr, conseq, alt) =>
      if is_truthy(eval_expr(env, test_expr)) {
        eval_expr(env, conseq)
      } else {
        eval_expr(env, alt)
      }
    Sequence(exprs) => {
      let mut last = Undefined
      for inner in exprs {
        last = eval_expr(env, inner)
      }
      last
    }
    Assign(name, rhs, offset, is_cover) =>
      with_expr_pos(offset, fn() raise {
        with_gc_frame(fn() raise {
          let assigner = prepare_identifier_assignment_target(
            env,
            name,
            env.strict,
          )
          let value = eval_expr(env, rhs)
          let _ = gc_root_push(value)
          if !is_cover && is_anonymous_function_definition(rhs) {
            set_anonymous_function_name(value, name, None)
          }
          assigner(value)
          value
        })
      })
    AssignInvalid(lhs, _, offset) =>
      with_expr_pos(offset, fn() raise {
        let _ = eval_expr(env, lhs)
        throw_reference_error("invalid assignment target")
      })
    AssignArray(pattern, rhs) =>
      with_gc_frame(fn() raise {
        let value = eval_expr(env, rhs)
        let _ = gc_root_push(value)
        destructure_array_pattern(env, pattern, value, fn(name, v) raise {
          env_set(env, name, v)
        })
        value
      })
    AssignObject(pattern, rhs) =>
      with_gc_frame(fn() raise {
        let value = eval_expr(env, rhs)
        let _ = gc_root_push(value)
        destructure_object_pattern(env, pattern, value, fn(name, v) raise {
          env_set(env, name, v)
        })
        value
      })
    AssignOp(op, lhs, rhs, offset) =>
      with_expr_pos(offset, fn() raise { eval_assign_op(env, op, lhs, rhs) })
    AssignMember(obj, key, rhs, offset) =>
      with_expr_pos(offset, fn() raise {
        with_gc_frame(fn() raise {
          let (roots, assigner) = prepare_member_assignment_target_with_roots(
            env, obj, key,
          )
          for root in roots {
            let _ = gc_root_push(root)

          }
          let value = eval_expr(env, rhs)
          let _ = gc_root_push(value)
          assigner(value)
          value
        })
      })
    Call(callee, args, offset) =>
      with_expr_pos(offset, fn() raise {
        match callee {
          Super => eval_super_call(env, args)
          Member(Super, key, _) => eval_super_member_call(env, key, args)
          _ => eval_call(env, callee, args)
        }
      })
    Member(obj, key, offset) =>
      with_expr_pos(offset, fn() raise {
        match obj {
          Super => eval_super_member(env, key)
          _ => eval_member(env, obj, key)
        }
      })
    OptionalChain(base, segments) => eval_optional_chain(env, base, segments)
    FunctionExpr(func) =>
      match func.name {
        Some(name) => {
          let name_env = Env::new(Some(env))
          let func_value = to_function_value(name_env, func, false)
          env_define_readonly(
            name_env,
            name,
            Value::Function(func_value),
            false,
          )
          Value::Function(func_value)
        }
        None => Value::Function(to_function_value(env, func, false))
      }
    ClassExpr(class_def) => eval_class(env, class_def)
    ObjectLiteral(props) => eval_object_literal(env, props)
    ArrayLiteral(elems) => eval_array_literal(env, elems)
    Spread(expr) => eval_expr(env, expr)
    Paren(expr) => eval_expr(env, expr)
  }
}

///|
fn check_eval_var_conflict_name(env : Env, name : String) -> Unit raise {
  match env.param_binding_names.get(name) {
    Some(_) => {
      let _ = throw_syntax_error("invalid identifier")

    }
    None => ()
  }
}

///|
fn check_eval_var_conflicts_in_binding(
  env : Env,
  binding : @engine.VarBinding,
) -> Unit raise {
  match binding {
    @engine.VarBinding::Name(name) => check_eval_var_conflict_name(env, name)
    @engine.VarBinding::ArrayPattern(pattern) =>
      for elem in pattern {
        match elem {
          @engine.ArrayPatternElem::Bind(inner, _) =>
            check_eval_var_conflicts_in_binding(env, inner)
          @engine.ArrayPatternElem::Rest(inner) =>
            check_eval_var_conflicts_in_binding(env, inner)
          @engine.ArrayPatternElem::Hole => ()
        }
      }
    @engine.VarBinding::ObjectPattern(pattern) =>
      for elem in pattern {
        match elem {
          @engine.ObjectPatternElem::Bind(_, inner, _) =>
            check_eval_var_conflicts_in_binding(env, inner)
          @engine.ObjectPatternElem::Rest(inner) =>
            check_eval_var_conflicts_in_binding(env, inner)
        }
      }
    @engine.VarBinding::Target(_) => ()
  }
}

///|
fn check_eval_var_conflicts_in_stmt(
  env : Env,
  stmt : @engine.Stmt,
) -> Unit raise {
  match stmt {
    VarDecl(kind, decls) =>
      if kind is @engine.VarKind::Var {
        for decl in decls {
          let (binding, _) = decl
          check_eval_var_conflicts_in_binding(env, binding)
        }
      }
    FunctionDecl(func) =>
      match func.name {
        Some(name) => check_eval_var_conflict_name(env, name)
        None => ()
      }
    Block(stmts) =>
      for inner in stmts {
        check_eval_var_conflicts_in_stmt(env, inner)
      }
    Label(_, body) => check_eval_var_conflicts_in_stmt(env, body)
    With(_, body) => check_eval_var_conflicts_in_stmt(env, body)
    If(_, conseq, alt) => {
      check_eval_var_conflicts_in_stmt(env, conseq)
      match alt {
        Some(inner) => check_eval_var_conflicts_in_stmt(env, inner)
        None => ()
      }
    }
    While(_, body) => check_eval_var_conflicts_in_stmt(env, body)
    For(init, _, _, body) => {
      match init {
        @engine.ForInit::Var(kind, decls) =>
          if kind is @engine.VarKind::Var {
            for decl in decls {
              let (binding, _) = decl
              check_eval_var_conflicts_in_binding(env, binding)
            }
          }
        _ => ()
      }
      check_eval_var_conflicts_in_stmt(env, body)
    }
    ForIn(init, _, body) => {
      match init {
        @engine.ForInit::Var(kind, decls) =>
          if kind is @engine.VarKind::Var {
            for decl in decls {
              let (binding, _) = decl
              check_eval_var_conflicts_in_binding(env, binding)
            }
          }
        _ => ()
      }
      check_eval_var_conflicts_in_stmt(env, body)
    }
    ForOf(init, _, body) => {
      match init {
        @engine.ForInit::Var(kind, decls) =>
          if kind is @engine.VarKind::Var {
            for decl in decls {
              let (binding, _) = decl
              check_eval_var_conflicts_in_binding(env, binding)
            }
          }
        _ => ()
      }
      check_eval_var_conflicts_in_stmt(env, body)
    }
    ForAwaitOf(init, _, body) => {
      match init {
        @engine.ForInit::Var(kind, decls) =>
          if kind is @engine.VarKind::Var {
            for decl in decls {
              let (binding, _) = decl
              check_eval_var_conflicts_in_binding(env, binding)
            }
          }
        _ => ()
      }
      check_eval_var_conflicts_in_stmt(env, body)
    }
    DoWhile(body, _) => check_eval_var_conflicts_in_stmt(env, body)
    Switch(_, cases) =>
      for clause in cases {
        let body = match clause {
          @engine.SwitchCase::Case(_, stmts) => stmts
          @engine.SwitchCase::Default(stmts) => stmts
        }
        for inner in body {
          check_eval_var_conflicts_in_stmt(env, inner)
        }
      }
    Try(try_body, catch_clause, finally_body) => {
      check_eval_var_conflicts_in_stmt(env, try_body)
      match catch_clause {
        Some(clause) => check_eval_var_conflicts_in_stmt(env, clause.body)
        None => ()
      }
      match finally_body {
        Some(inner) => check_eval_var_conflicts_in_stmt(env, inner)
        None => ()
      }
    }
    _ => ()
  }
}

///|
fn check_eval_var_conflicts(
  env : Env,
  body : Array[@engine.Stmt],
) -> Unit raise {
  if !env.is_param_env || env.param_binding_names.is_empty() {
    return
  }
  for stmt in body {
    check_eval_var_conflicts_in_stmt(env, stmt)
  }
}

///|
fn eval_body_has_lexical_decls(body : Array[@engine.Stmt]) -> Bool {
  for stmt in body {
    match stmt {
      VarDecl(kind, _) => if !(kind is @engine.VarKind::Var) { return true }
      ClassDecl(_) => return true
      Block(stmts) =>
        if current_module_env_id() is Some(_) && block_is_export_wrapper(stmts) {
          for inner in stmts {
            match inner {
              VarDecl(kind, _) =>
                if !(kind is @engine.VarKind::Var) {
                  return true
                }
              ClassDecl(_) => return true
              _ => ()
            }
          }
        }
      _ => ()
    }
  }
  false
}

///|
fn collect_top_level_function_decls(
  body : Array[@engine.Stmt],
) -> @hashmap.HashMap[Int, Bool] {
  let out : @hashmap.HashMap[Int, Bool] = @hashmap.new()
  for stmt in body {
    match stmt {
      FunctionDecl(func) => out.set(func.offset, true)
      Block(stmts) =>
        if current_module_env_id() is Some(_) && block_is_export_wrapper(stmts) {
          for inner in stmts {
            match inner {
              FunctionDecl(func) => out.set(func.offset, true)
              _ => ()
            }
          }
        }
      _ => ()
    }
  }
  out
}

///|
fn eval_predeclare_lexical_decls(
  env : Env,
  body : Array[@engine.Stmt],
) -> Unit raise {
  for stmt in body {
    if current_module_env_id() is Some(_) && stmt_is_import_decl(stmt) {
      continue
    }
    match stmt {
      Block(stmts) =>
        if current_module_env_id() is Some(_) && block_is_export_wrapper(stmts) {
          eval_predeclare_lexical_decls(env, stmts)
        }
      VarDecl(kind, decls) =>
        if !(kind is @engine.VarKind::Var) {
          for decl in decls {
            let (binding, _) = decl
            if env.parent is None {
              let names : Array[String] = []
              eval_collect_var_names_in_binding(binding, names)
              for name in names {
                if global_has_restricted_property(env, name) {
                  let _ = throw_syntax_error("invalid identifier")

                }
              }
            }
            declare_binding_uninitialized(env, binding)
          }
        }
      ClassDecl(class_def) =>
        match class_def.name {
          Some(name) =>
            if env.parent is None && global_has_restricted_property(env, name) {
              let _ = throw_syntax_error("invalid identifier")

            } else {
              env_declare_uninitialized(env, name)
            }
          None => ()
        }
      _ => ()
    }
  }
}

///|
fn eval_collect_var_names_in_binding(
  binding : @engine.VarBinding,
  names : Array[String],
) -> Unit {
  match binding {
    @engine.VarBinding::Name(name) => names.push(name)
    @engine.VarBinding::ArrayPattern(pattern) =>
      for elem in pattern {
        match elem {
          @engine.ArrayPatternElem::Bind(inner, _) =>
            eval_collect_var_names_in_binding(inner, names)
          @engine.ArrayPatternElem::Rest(inner) =>
            eval_collect_var_names_in_binding(inner, names)
          @engine.ArrayPatternElem::Hole => ()
        }
      }
    @engine.VarBinding::ObjectPattern(pattern) =>
      for elem in pattern {
        match elem {
          @engine.ObjectPatternElem::Bind(_, inner, _) =>
            eval_collect_var_names_in_binding(inner, names)
          @engine.ObjectPatternElem::Rest(inner) =>
            eval_collect_var_names_in_binding(inner, names)
        }
      }
    @engine.VarBinding::Target(_) => ()
  }
}

///|
fn eval_collect_var_names_in_stmt(
  stmt : @engine.Stmt,
  names : Array[String],
) -> Unit {
  match stmt {
    VarDecl(kind, decls) =>
      if kind is @engine.VarKind::Var {
        for decl in decls {
          let (binding, _) = decl
          eval_collect_var_names_in_binding(binding, names)
        }
      }
    Block(stmts) =>
      for inner in stmts {
        eval_collect_var_names_in_stmt(inner, names)
      }
    Label(_, body) => eval_collect_var_names_in_stmt(body, names)
    With(_, body) => eval_collect_var_names_in_stmt(body, names)
    If(_, conseq, alt) => {
      eval_collect_var_names_in_stmt(conseq, names)
      match alt {
        Some(inner) => eval_collect_var_names_in_stmt(inner, names)
        None => ()
      }
    }
    While(_, body) => eval_collect_var_names_in_stmt(body, names)
    For(init, _, _, body) => {
      match init {
        @engine.ForInit::Var(kind, decls) =>
          if kind is @engine.VarKind::Var {
            for decl in decls {
              let (binding, _) = decl
              eval_collect_var_names_in_binding(binding, names)
            }
          }
        _ => ()
      }
      eval_collect_var_names_in_stmt(body, names)
    }
    ForIn(init, _, body) => {
      match init {
        @engine.ForInit::Var(kind, decls) =>
          if kind is @engine.VarKind::Var {
            for decl in decls {
              let (binding, _) = decl
              eval_collect_var_names_in_binding(binding, names)
            }
          }
        _ => ()
      }
      eval_collect_var_names_in_stmt(body, names)
    }
    ForOf(init, _, body) => {
      match init {
        @engine.ForInit::Var(kind, decls) =>
          if kind is @engine.VarKind::Var {
            for decl in decls {
              let (binding, _) = decl
              eval_collect_var_names_in_binding(binding, names)
            }
          }
        _ => ()
      }
      eval_collect_var_names_in_stmt(body, names)
    }
    ForAwaitOf(init, _, body) => {
      match init {
        @engine.ForInit::Var(kind, decls) =>
          if kind is @engine.VarKind::Var {
            for decl in decls {
              let (binding, _) = decl
              eval_collect_var_names_in_binding(binding, names)
            }
          }
        _ => ()
      }
      eval_collect_var_names_in_stmt(body, names)
    }
    DoWhile(body, _) => eval_collect_var_names_in_stmt(body, names)
    Switch(_, cases) =>
      for clause in cases {
        let body = match clause {
          @engine.SwitchCase::Case(_, stmts) => stmts
          @engine.SwitchCase::Default(stmts) => stmts
        }
        for inner in body {
          eval_collect_var_names_in_stmt(inner, names)
        }
      }
    Try(try_body, catch_clause, finally_body) => {
      eval_collect_var_names_in_stmt(try_body, names)
      match catch_clause {
        Some(clause) => eval_collect_var_names_in_stmt(clause.body, names)
        None => ()
      }
      match finally_body {
        Some(inner) => eval_collect_var_names_in_stmt(inner, names)
        None => ()
      }
    }
    _ => ()
  }
}

///|
fn eval_collect_var_names(body : Array[@engine.Stmt]) -> Array[String] {
  let names : Array[String] = []
  for stmt in body {
    eval_collect_var_names_in_stmt(stmt, names)
  }
  names
}

///|
fn eval_collect_function_decls_in_stmt(
  stmt : @engine.Stmt,
  in_block : Bool,
  is_strict : Bool,
  decls : Array[@engine.FunctionDef],
) -> Unit {
  match stmt {
    FunctionDecl(func) =>
      if !(is_strict && in_block) {
        match func.name {
          Some(_) =>
            if !in_block || annex_b_var_func_decl_contains(func) {
              decls.push(func)
            }
          None => ()
        }
      }
    Block(stmts) =>
      for inner in stmts {
        eval_collect_function_decls_in_stmt(inner, true, is_strict, decls)
      }
    Label(_, body) =>
      eval_collect_function_decls_in_stmt(body, in_block, is_strict, decls)
    With(_, body) =>
      eval_collect_function_decls_in_stmt(body, true, is_strict, decls)
    If(_, conseq, alt) => {
      eval_collect_function_decls_in_stmt(conseq, true, is_strict, decls)
      match alt {
        Some(inner) =>
          eval_collect_function_decls_in_stmt(inner, true, is_strict, decls)
        None => ()
      }
    }
    While(_, body) =>
      eval_collect_function_decls_in_stmt(body, true, is_strict, decls)
    For(_, _, _, body) =>
      eval_collect_function_decls_in_stmt(body, true, is_strict, decls)
    ForIn(_, _, body) =>
      eval_collect_function_decls_in_stmt(body, true, is_strict, decls)
    ForOf(_, _, body) =>
      eval_collect_function_decls_in_stmt(body, true, is_strict, decls)
    ForAwaitOf(_, _, body) =>
      eval_collect_function_decls_in_stmt(body, true, is_strict, decls)
    DoWhile(body, _) =>
      eval_collect_function_decls_in_stmt(body, true, is_strict, decls)
    Switch(_, cases) =>
      for clause in cases {
        let body = match clause {
          @engine.SwitchCase::Case(_, stmts) => stmts
          @engine.SwitchCase::Default(stmts) => stmts
        }
        for inner in body {
          eval_collect_function_decls_in_stmt(inner, true, is_strict, decls)
        }
      }
    Try(try_body, catch_clause, finally_body) => {
      eval_collect_function_decls_in_stmt(try_body, true, is_strict, decls)
      match catch_clause {
        Some(clause) =>
          eval_collect_function_decls_in_stmt(
            clause.body,
            true,
            is_strict,
            decls,
          )
        None => ()
      }
      match finally_body {
        Some(inner) =>
          eval_collect_function_decls_in_stmt(inner, true, is_strict, decls)
        None => ()
      }
    }
    _ => ()
  }
}

///|
fn eval_collect_function_decls(
  body : Array[@engine.Stmt],
  is_strict : Bool,
) -> Array[@engine.FunctionDef] {
  let decls : Array[@engine.FunctionDef] = []
  for stmt in body {
    eval_collect_function_decls_in_stmt(stmt, false, is_strict, decls)
  }
  decls
}

///|
fn eval_check_global_var_lex_conflicts(
  env : Env,
  body : Array[@engine.Stmt],
  is_strict : Bool,
) -> Unit raise {
  if !(env.parent is None) {
    return
  }
  let names = eval_collect_var_names(body)
  for name in names {
    if global_has_lexical_declaration(env, name) {
      let _ = throw_syntax_error("invalid identifier")

    }
  }
  let funcs = eval_collect_function_decls(body, is_strict)
  for func in funcs {
    match func.name {
      Some(name) =>
        if global_has_lexical_declaration(env, name) {
          let _ = throw_syntax_error("invalid identifier")

        }
      None => ()
    }
  }
}

///|
fn eval_check_var_lex_conflicts(
  env : Env,
  var_env : Env,
  body : Array[@engine.Stmt],
  is_strict : Bool,
) -> Unit raise {
  if env.id == var_env.id {
    return
  }
  let names = eval_collect_var_names(body)
  let funcs = eval_collect_function_decls(body, is_strict)
  for func in funcs {
    match func.name {
      Some(name) => names.push(name)
      None => ()
    }
  }
  let mut current : Env? = Some(env)
  while true {
    match current {
      Some(scope) =>
        if scope.id == var_env.id {
          break
        } else {
          if scope.with_object is None && !scope.is_catch_env {
            for name in names {
              if scope.bindings.contains(name) {
                let _ = throw_syntax_error("invalid identifier")

              }
            }
          }
          current = scope.parent
        }
      None => break
    }
  }
}

///|
fn eval_check_global_function_decls(
  env : Env,
  body : Array[@engine.Stmt],
  is_strict : Bool,
) -> Unit raise {
  if !(env.parent is None) {
    return
  }
  let decls = eval_collect_function_decls(body, is_strict)
  let seen = Map::new()
  let mut i = decls.length()
  while i > 0 {
    i = i - 1
    match decls[i].name {
      Some(name) =>
        if !seen.contains(name) {
          seen.set(name, true)
          if !global_can_declare_function(env, name) {
            let _ = throw_type_error("cannot declare global function")

          }
        }
      None => ()
    }
  }
}

///|
fn check_global_script_decls(
  env : Env,
  body : Array[@engine.Stmt],
  is_strict : Bool,
) -> Unit raise {
  if !(env.parent is None) {
    return
  }
  let lex_names = collect_global_lex_names(body)
  for name, _ in lex_names {
    if global_has_restricted_property(env, name) ||
      global_has_lexical_declaration(env, name) {
      let _ = throw_syntax_error("invalid identifier")

    }
  }
  let var_names = eval_collect_var_names(body)
  let funcs = eval_collect_function_decls(body, is_strict)
  let var_like_names : Array[String] = []
  for name in var_names {
    var_like_names.push(name)
  }
  for func in funcs {
    match func.name {
      Some(name) => var_like_names.push(name)
      None => ()
    }
  }
  for name in var_like_names {
    if lex_names.contains(name) || global_has_lexical_declaration(env, name) {
      let _ = throw_syntax_error("invalid identifier")

    }
  }
  for name in var_names {
    if !global_can_declare_var(env, name) {
      let _ = throw_type_error("cannot declare global var")

    }
  }
  eval_check_global_function_decls(env, body, is_strict)
}

///|
fn validate_context_in_expr_opt(
  expr_opt : @engine.Expr?,
  allow_new_target : Bool,
  allow_super : Bool,
  allow_super_call : Bool,
) -> Unit raise {
  match expr_opt {
    Some(expr) =>
      validate_context_in_expr(
        expr, allow_new_target, allow_super, allow_super_call,
      )
    None => ()
  }
}

///|
fn validate_context_in_expr_list(
  exprs : Array[@engine.Expr],
  allow_new_target : Bool,
  allow_super : Bool,
  allow_super_call : Bool,
) -> Unit raise {
  for expr in exprs {
    validate_context_in_expr(
      expr, allow_new_target, allow_super, allow_super_call,
    )
  }
}

///|
fn validate_context_in_member_key(
  key : @engine.MemberKey,
  allow_new_target : Bool,
  allow_super : Bool,
  allow_super_call : Bool,
) -> Unit raise {
  match key {
    @engine.MemberKey::Computed(expr) =>
      validate_context_in_expr(
        expr, allow_new_target, allow_super, allow_super_call,
      )
    _ => ()
  }
}

///|
fn validate_context_in_obj_key(
  key : @engine.ObjKey,
  allow_new_target : Bool,
  allow_super : Bool,
  allow_super_call : Bool,
) -> Unit raise {
  match key {
    @engine.ObjKey::Computed(expr) =>
      validate_context_in_expr(
        expr, allow_new_target, allow_super, allow_super_call,
      )
    _ => ()
  }
}

///|
fn validate_context_in_var_binding(
  binding : @engine.VarBinding,
  allow_new_target : Bool,
  allow_super : Bool,
  allow_super_call : Bool,
) -> Unit raise {
  match binding {
    @engine.VarBinding::Name(_) => ()
    @engine.VarBinding::ArrayPattern(pattern) =>
      validate_context_in_array_pattern(
        pattern, allow_new_target, allow_super, allow_super_call,
      )
    @engine.VarBinding::ObjectPattern(pattern) =>
      validate_context_in_object_pattern(
        pattern, allow_new_target, allow_super, allow_super_call,
      )
    @engine.VarBinding::Target(expr) =>
      validate_context_in_expr(
        expr, allow_new_target, allow_super, allow_super_call,
      )
  }
}

///|
fn validate_context_in_array_pattern(
  pattern : Array[@engine.ArrayPatternElem],
  allow_new_target : Bool,
  allow_super : Bool,
  allow_super_call : Bool,
) -> Unit raise {
  for elem in pattern {
    match elem {
      @engine.ArrayPatternElem::Bind(inner, init) => {
        validate_context_in_var_binding(
          inner, allow_new_target, allow_super, allow_super_call,
        )
        validate_context_in_expr_opt(
          init, allow_new_target, allow_super, allow_super_call,
        )
      }
      @engine.ArrayPatternElem::Rest(inner) =>
        validate_context_in_var_binding(
          inner, allow_new_target, allow_super, allow_super_call,
        )
      @engine.ArrayPatternElem::Hole => ()
    }
  }
}

///|
fn validate_context_in_object_pattern(
  pattern : Array[@engine.ObjectPatternElem],
  allow_new_target : Bool,
  allow_super : Bool,
  allow_super_call : Bool,
) -> Unit raise {
  for elem in pattern {
    match elem {
      @engine.ObjectPatternElem::Bind(key, inner, init) => {
        validate_context_in_obj_key(
          key, allow_new_target, allow_super, allow_super_call,
        )
        validate_context_in_var_binding(
          inner, allow_new_target, allow_super, allow_super_call,
        )
        validate_context_in_expr_opt(
          init, allow_new_target, allow_super, allow_super_call,
        )
      }
      @engine.ObjectPatternElem::Rest(inner) =>
        validate_context_in_var_binding(
          inner, allow_new_target, allow_super, allow_super_call,
        )
    }
  }
}

///|
fn validate_context_in_function(
  func : @engine.FunctionDef,
  parent_allow_new_target : Bool,
  parent_allow_super : Bool,
  parent_allow_super_call : Bool,
  allow_super : Bool,
  allow_super_call : Bool,
) -> Unit raise {
  let (next_allow_new_target, next_allow_super, next_allow_super_call) = if func.is_arrow {
    (parent_allow_new_target, parent_allow_super, parent_allow_super_call)
  } else {
    (true, allow_super, allow_super_call)
  }
  for init in func.param_inits {
    validate_context_in_expr_opt(
      init, next_allow_new_target, next_allow_super, next_allow_super_call,
    )
  }
  for param in func.params {
    validate_context_in_var_binding(
      param.binding,
      next_allow_new_target,
      next_allow_super,
      next_allow_super_call,
    )
  }
  for stmt in func.body {
    validate_context_in_stmt(
      stmt, next_allow_new_target, next_allow_super, next_allow_super_call,
    )
  }
}

///|
fn obj_key_is_constructor(key : @engine.ObjKey) -> Bool {
  match key {
    @engine.ObjKey::Ident(name) => name == "constructor"
    @engine.ObjKey::String(name) => name == "constructor"
    _ => false
  }
}

///|
fn validate_context_in_class(
  class_def : @engine.ClassDef,
  allow_new_target : Bool,
  allow_super : Bool,
  allow_super_call : Bool,
) -> Unit raise {
  match class_def.super_class {
    Some(expr) =>
      validate_context_in_expr(
        expr, allow_new_target, allow_super, allow_super_call,
      )
    None => ()
  }
  let is_derived = class_def.super_class is Some(_)
  for member_ in class_def.body {
    match member_ {
      @engine.ClassMember::Method(key, func, is_static) => {
        validate_context_in_obj_key(
          key, allow_new_target, allow_super, allow_super_call,
        )
        let is_ctor = !is_static && obj_key_is_constructor(key)
        let ctor_allow_super_call = is_ctor && is_derived
        validate_context_in_function(
          func, allow_new_target, allow_super, allow_super_call, true, ctor_allow_super_call,
        )
      }
      @engine.ClassMember::Getter(key, func, _) => {
        validate_context_in_obj_key(
          key, allow_new_target, allow_super, allow_super_call,
        )
        validate_context_in_function(
          func, allow_new_target, allow_super, allow_super_call, true, false,
        )
      }
      @engine.ClassMember::Setter(key, func, _) => {
        validate_context_in_obj_key(
          key, allow_new_target, allow_super, allow_super_call,
        )
        validate_context_in_function(
          func, allow_new_target, allow_super, allow_super_call, true, false,
        )
      }
      @engine.ClassMember::Field(key, init, _) => {
        validate_context_in_obj_key(
          key, allow_new_target, allow_super, allow_super_call,
        )
        match init {
          Some(expr) => validate_context_in_expr(expr, true, true, false)
          None => ()
        }
      }
      @engine.ClassMember::StaticBlock(stmts) =>
        for stmt in stmts {
          validate_context_in_stmt(stmt, true, true, false)
        }
    }
  }
}

///|
fn validate_context_in_expr(
  expr : @engine.Expr,
  allow_new_target : Bool,
  allow_super : Bool,
  allow_super_call : Bool,
) -> Unit raise {
  match expr {
    @engine.Expr::TemplateLiteral(_, exprs) =>
      validate_context_in_expr_list(
        exprs, allow_new_target, allow_super, allow_super_call,
      )
    @engine.Expr::TaggedTemplate(callee, _, exprs) => {
      validate_context_in_expr(
        callee, allow_new_target, allow_super, allow_super_call,
      )
      validate_context_in_expr_list(
        exprs, allow_new_target, allow_super, allow_super_call,
      )
    }
    @engine.Expr::Await(inner, _) =>
      validate_context_in_expr(
        inner, allow_new_target, allow_super, allow_super_call,
      )
    @engine.Expr::Unary(_, inner, _) =>
      validate_context_in_expr(
        inner, allow_new_target, allow_super, allow_super_call,
      )
    @engine.Expr::Update(_, inner, _, _) =>
      validate_context_in_expr(
        inner, allow_new_target, allow_super, allow_super_call,
      )
    @engine.Expr::Yield(expr_opt, _) =>
      validate_context_in_expr_opt(
        expr_opt, allow_new_target, allow_super, allow_super_call,
      )
    @engine.Expr::NewTarget(_) =>
      if !allow_new_target {
        let _ = throw_syntax_error("new.target only allowed within functions")

      }
    @engine.Expr::Super => {
      let _ = throw_syntax_error("invalid use of 'super'")

    }
    @engine.Expr::New(callee, args) => {
      validate_context_in_expr(
        callee, allow_new_target, allow_super, allow_super_call,
      )
      validate_context_in_expr_list(
        args, allow_new_target, allow_super, allow_super_call,
      )
    }
    @engine.Expr::Binary(_, left, right, _) => {
      validate_context_in_expr(
        left, allow_new_target, allow_super, allow_super_call,
      )
      validate_context_in_expr(
        right, allow_new_target, allow_super, allow_super_call,
      )
    }
    @engine.Expr::PrivateIn(_, rhs, _) =>
      validate_context_in_expr(
        rhs, allow_new_target, allow_super, allow_super_call,
      )
    @engine.Expr::Conditional(cond_expr, conseq, alt) => {
      validate_context_in_expr(
        cond_expr, allow_new_target, allow_super, allow_super_call,
      )
      validate_context_in_expr(
        conseq, allow_new_target, allow_super, allow_super_call,
      )
      validate_context_in_expr(
        alt, allow_new_target, allow_super, allow_super_call,
      )
    }
    @engine.Expr::Sequence(exprs) =>
      validate_context_in_expr_list(
        exprs, allow_new_target, allow_super, allow_super_call,
      )
    @engine.Expr::Paren(inner) =>
      validate_context_in_expr(
        inner, allow_new_target, allow_super, allow_super_call,
      )
    @engine.Expr::Assign(_, rhs, _, _) =>
      validate_context_in_expr(
        rhs, allow_new_target, allow_super, allow_super_call,
      )
    @engine.Expr::AssignInvalid(lhs, rhs, _) => {
      validate_context_in_expr(
        lhs, allow_new_target, allow_super, allow_super_call,
      )
      validate_context_in_expr(
        rhs, allow_new_target, allow_super, allow_super_call,
      )
    }
    @engine.Expr::AssignArray(pattern, rhs) => {
      validate_context_in_array_pattern(
        pattern, allow_new_target, allow_super, allow_super_call,
      )
      validate_context_in_expr(
        rhs, allow_new_target, allow_super, allow_super_call,
      )
    }
    @engine.Expr::AssignObject(pattern, rhs) => {
      validate_context_in_object_pattern(
        pattern, allow_new_target, allow_super, allow_super_call,
      )
      validate_context_in_expr(
        rhs, allow_new_target, allow_super, allow_super_call,
      )
    }
    @engine.Expr::AssignOp(_, lhs, rhs, _) => {
      validate_context_in_expr(
        lhs, allow_new_target, allow_super, allow_super_call,
      )
      validate_context_in_expr(
        rhs, allow_new_target, allow_super, allow_super_call,
      )
    }
    @engine.Expr::AssignMember(obj, key, rhs, _) =>
      match obj {
        @engine.Expr::Super => {
          if !allow_super {
            let _ = throw_syntax_error("'super' is only valid in a method")

          }
          validate_context_in_member_key(
            key, allow_new_target, allow_super, allow_super_call,
          )
          validate_context_in_expr(
            rhs, allow_new_target, allow_super, allow_super_call,
          )
        }
        _ => {
          validate_context_in_expr(
            obj, allow_new_target, allow_super, allow_super_call,
          )
          validate_context_in_member_key(
            key, allow_new_target, allow_super, allow_super_call,
          )
          validate_context_in_expr(
            rhs, allow_new_target, allow_super, allow_super_call,
          )
        }
      }
    @engine.Expr::Call(callee, args, _) => {
      match callee {
        @engine.Expr::Super =>
          if !allow_super_call {
            let _ = throw_syntax_error(
              "super() is only valid in a derived class constructor",
            )

          }
        @engine.Expr::Member(@engine.Expr::Super, key, _) => {
          if !allow_super {
            let _ = throw_syntax_error("'super' is only valid in a method")

          }
          validate_context_in_member_key(
            key, allow_new_target, allow_super, allow_super_call,
          )
        }
        _ =>
          validate_context_in_expr(
            callee, allow_new_target, allow_super, allow_super_call,
          )
      }
      validate_context_in_expr_list(
        args, allow_new_target, allow_super, allow_super_call,
      )
    }
    @engine.Expr::Member(obj, key, _) =>
      match obj {
        @engine.Expr::Super => {
          if !allow_super {
            let _ = throw_syntax_error("'super' is only valid in a method")

          }
          validate_context_in_member_key(
            key, allow_new_target, allow_super, allow_super_call,
          )
        }
        _ => {
          validate_context_in_expr(
            obj, allow_new_target, allow_super, allow_super_call,
          )
          validate_context_in_member_key(
            key, allow_new_target, allow_super, allow_super_call,
          )
        }
      }
    @engine.Expr::OptionalChain(base, segments) => {
      validate_context_in_expr(
        base, allow_new_target, allow_super, allow_super_call,
      )
      for segment in segments {
        match segment {
          @engine.ChainSegment::Member(key, _, _) =>
            validate_context_in_member_key(
              key, allow_new_target, allow_super, allow_super_call,
            )
          @engine.ChainSegment::Call(args, _, _) =>
            validate_context_in_expr_list(
              args, allow_new_target, allow_super, allow_super_call,
            )
        }
      }
    }
    @engine.Expr::FunctionExpr(func) => {
      let inner_labels : Array[(String, Bool)] = []
      for inner in func.body {
        validate_break_continue_in_stmt(inner, 0, 0, inner_labels)
      }
      validate_context_in_function(
        func, allow_new_target, allow_super, allow_super_call, false, false,
      )
    }
    @engine.Expr::ClassExpr(class_def) => {
      for member_ in class_def.body {
        match member_ {
          @engine.ClassMember::Method(_, func, _)
          | @engine.ClassMember::Getter(_, func, _)
          | @engine.ClassMember::Setter(_, func, _) => {
            let inner_labels : Array[(String, Bool)] = []
            for inner in func.body {
              validate_break_continue_in_stmt(inner, 0, 0, inner_labels)
            }
          }
          @engine.ClassMember::StaticBlock(stmts) => {
            let inner_labels : Array[(String, Bool)] = []
            for inner in stmts {
              validate_break_continue_in_stmt(inner, 0, 0, inner_labels)
            }
          }
          _ => ()
        }
      }
      validate_context_in_class(
        class_def, allow_new_target, allow_super, allow_super_call,
      )
    }
    @engine.Expr::ObjectLiteral(props) =>
      for prop in props {
        match prop {
          @engine.ObjectProp::KeyValue(key, value) => {
            validate_context_in_obj_key(
              key, allow_new_target, allow_super, allow_super_call,
            )
            validate_context_in_expr(
              value, allow_new_target, allow_super, allow_super_call,
            )
          }
          @engine.ObjectProp::Method(key, func) => {
            validate_context_in_obj_key(
              key, allow_new_target, allow_super, allow_super_call,
            )
            validate_context_in_function(
              func, allow_new_target, allow_super, allow_super_call, true, false,
            )
          }
          @engine.ObjectProp::Getter(key, func) => {
            validate_context_in_obj_key(
              key, allow_new_target, allow_super, allow_super_call,
            )
            validate_context_in_function(
              func, allow_new_target, allow_super, allow_super_call, true, false,
            )
          }
          @engine.ObjectProp::Setter(key, func) => {
            validate_context_in_obj_key(
              key, allow_new_target, allow_super, allow_super_call,
            )
            validate_context_in_function(
              func, allow_new_target, allow_super, allow_super_call, true, false,
            )
          }
          @engine.ObjectProp::Shorthand(_) => ()
          @engine.ObjectProp::Spread(inner) =>
            validate_context_in_expr(
              inner, allow_new_target, allow_super, allow_super_call,
            )
        }
      }
    @engine.Expr::ArrayLiteral(elems) =>
      for elem in elems {
        match elem {
          Some(inner) =>
            validate_context_in_expr(
              inner, allow_new_target, allow_super, allow_super_call,
            )
          None => ()
        }
      }
    @engine.Expr::Spread(inner) =>
      validate_context_in_expr(
        inner, allow_new_target, allow_super, allow_super_call,
      )
    _ => ()
  }
}

///|
fn validate_context_in_stmt(
  stmt : @engine.Stmt,
  allow_new_target : Bool,
  allow_super : Bool,
  allow_super_call : Bool,
) -> Unit raise {
  match stmt {
    @engine.Stmt::Empty => ()
    @engine.Stmt::ExprStmt(expr) =>
      validate_context_in_expr(
        expr, allow_new_target, allow_super, allow_super_call,
      )
    @engine.Stmt::VarDecl(_, decls) =>
      for decl in decls {
        let (binding, init) = decl
        validate_context_in_var_binding(
          binding, allow_new_target, allow_super, allow_super_call,
        )
        validate_context_in_expr_opt(
          init, allow_new_target, allow_super, allow_super_call,
        )
      }
    @engine.Stmt::Block(stmts) =>
      for inner in stmts {
        validate_context_in_stmt(
          inner, allow_new_target, allow_super, allow_super_call,
        )
      }
    @engine.Stmt::Label(_, body) =>
      validate_context_in_stmt(
        body, allow_new_target, allow_super, allow_super_call,
      )
    @engine.Stmt::FunctionDecl(func) =>
      validate_context_in_function(
        func, allow_new_target, allow_super, allow_super_call, false, false,
      )
    @engine.Stmt::ClassDecl(class_def) =>
      validate_context_in_class(
        class_def, allow_new_target, allow_super, allow_super_call,
      )
    @engine.Stmt::Return(expr_opt) =>
      validate_context_in_expr_opt(
        expr_opt, allow_new_target, allow_super, allow_super_call,
      )
    @engine.Stmt::If(cond_expr, conseq, alt) => {
      validate_context_in_expr(
        cond_expr, allow_new_target, allow_super, allow_super_call,
      )
      validate_context_in_stmt(
        conseq, allow_new_target, allow_super, allow_super_call,
      )
      match alt {
        Some(inner) =>
          validate_context_in_stmt(
            inner, allow_new_target, allow_super, allow_super_call,
          )
        None => ()
      }
    }
    @engine.Stmt::With(expr, body) => {
      validate_context_in_expr(
        expr, allow_new_target, allow_super, allow_super_call,
      )
      validate_context_in_stmt(
        body, allow_new_target, allow_super, allow_super_call,
      )
    }
    @engine.Stmt::While(cond_expr, body) => {
      validate_context_in_expr(
        cond_expr, allow_new_target, allow_super, allow_super_call,
      )
      validate_context_in_stmt(
        body, allow_new_target, allow_super, allow_super_call,
      )
    }
    @engine.Stmt::For(init, test_expr, update_expr, body) => {
      match init {
        @engine.ForInit::Var(_, decls) =>
          for decl in decls {
            let (binding, init_expr) = decl
            validate_context_in_var_binding(
              binding, allow_new_target, allow_super, allow_super_call,
            )
            validate_context_in_expr_opt(
              init_expr, allow_new_target, allow_super, allow_super_call,
            )
          }
        @engine.ForInit::Expr(expr) =>
          validate_context_in_expr(
            expr, allow_new_target, allow_super, allow_super_call,
          )
        @engine.ForInit::None => ()
      }
      validate_context_in_expr_opt(
        test_expr, allow_new_target, allow_super, allow_super_call,
      )
      validate_context_in_expr_opt(
        update_expr, allow_new_target, allow_super, allow_super_call,
      )
      validate_for_head_lexical_conflicts(init, body)
      validate_context_in_stmt(
        body, allow_new_target, allow_super, allow_super_call,
      )
    }
    @engine.Stmt::ForIn(init, expr, body) => {
      match init {
        @engine.ForInit::Var(_, decls) =>
          for decl in decls {
            let (binding, init_expr) = decl
            validate_context_in_var_binding(
              binding, allow_new_target, allow_super, allow_super_call,
            )
            validate_context_in_expr_opt(
              init_expr, allow_new_target, allow_super, allow_super_call,
            )
          }
        @engine.ForInit::Expr(expr) =>
          validate_context_in_expr(
            expr, allow_new_target, allow_super, allow_super_call,
          )
        @engine.ForInit::None => ()
      }
      validate_context_in_expr(
        expr, allow_new_target, allow_super, allow_super_call,
      )
      validate_for_head_lexical_conflicts(init, body)
      validate_context_in_stmt(
        body, allow_new_target, allow_super, allow_super_call,
      )
    }
    @engine.Stmt::ForOf(init, expr, body) => {
      match init {
        @engine.ForInit::Var(_, decls) =>
          for decl in decls {
            let (binding, init_expr) = decl
            validate_context_in_var_binding(
              binding, allow_new_target, allow_super, allow_super_call,
            )
            validate_context_in_expr_opt(
              init_expr, allow_new_target, allow_super, allow_super_call,
            )
          }
        @engine.ForInit::Expr(expr) =>
          validate_context_in_expr(
            expr, allow_new_target, allow_super, allow_super_call,
          )
        @engine.ForInit::None => ()
      }
      validate_context_in_expr(
        expr, allow_new_target, allow_super, allow_super_call,
      )
      validate_for_head_lexical_conflicts(init, body)
      validate_context_in_stmt(
        body, allow_new_target, allow_super, allow_super_call,
      )
    }
    @engine.Stmt::ForAwaitOf(init, expr, body) => {
      match init {
        @engine.ForInit::Var(_, decls) =>
          for decl in decls {
            let (binding, init_expr) = decl
            validate_context_in_var_binding(
              binding, allow_new_target, allow_super, allow_super_call,
            )
            validate_context_in_expr_opt(
              init_expr, allow_new_target, allow_super, allow_super_call,
            )
          }
        @engine.ForInit::Expr(expr) =>
          validate_context_in_expr(
            expr, allow_new_target, allow_super, allow_super_call,
          )
        @engine.ForInit::None => ()
      }
      validate_context_in_expr(
        expr, allow_new_target, allow_super, allow_super_call,
      )
      validate_for_head_lexical_conflicts(init, body)
      validate_context_in_stmt(
        body, allow_new_target, allow_super, allow_super_call,
      )
    }
    @engine.Stmt::DoWhile(body, cond_expr) => {
      validate_context_in_stmt(
        body, allow_new_target, allow_super, allow_super_call,
      )
      validate_context_in_expr(
        cond_expr, allow_new_target, allow_super, allow_super_call,
      )
    }
    @engine.Stmt::Switch(discriminant, cases) => {
      validate_context_in_expr(
        discriminant, allow_new_target, allow_super, allow_super_call,
      )
      for clause in cases {
        let body = match clause {
          @engine.SwitchCase::Case(expr, stmts) => {
            validate_context_in_expr(
              expr, allow_new_target, allow_super, allow_super_call,
            )
            stmts
          }
          @engine.SwitchCase::Default(stmts) => stmts
        }
        for inner in body {
          validate_context_in_stmt(
            inner, allow_new_target, allow_super, allow_super_call,
          )
        }
      }
    }
    @engine.Stmt::Throw(expr) =>
      validate_context_in_expr(
        expr, allow_new_target, allow_super, allow_super_call,
      )
    @engine.Stmt::Try(try_body, catch_clause, finally_body) => {
      validate_context_in_stmt(
        try_body, allow_new_target, allow_super, allow_super_call,
      )
      match catch_clause {
        Some(clause) =>
          validate_context_in_stmt(
            clause.body,
            allow_new_target,
            allow_super,
            allow_super_call,
          )
        None => ()
      }
      match finally_body {
        Some(inner) =>
          validate_context_in_stmt(
            inner, allow_new_target, allow_super, allow_super_call,
          )
        None => ()
      }
    }
    _ => ()
  }
}

///|
fn validate_for_head_lexical_conflicts(
  init : @engine.ForInit,
  body : @engine.Stmt,
) -> Unit raise {
  match init {
    @engine.ForInit::Var(kind, decls) =>
      if !(kind is @engine.VarKind::Var) {
        let bound_names : Array[String] = []
        for decl in decls {
          let (binding, _) = decl
          eval_collect_var_names_in_binding(binding, bound_names)
        }
        if !bound_names.is_empty() {
          let var_names : Array[String] = []
          eval_collect_var_names_in_stmt(body, var_names)
          let seen : Map[String, Bool] = Map::new()
          for name in var_names {
            seen.set(name, true)
          }
          for name in bound_names {
            if seen.contains(name) {
              let _ = throw_syntax_error("invalid identifier")

            }
          }
        }
      }
    _ => ()
  }
}

///|
fn label_targets_iteration(stmt : @engine.Stmt) -> Bool {
  match stmt {
    @engine.Stmt::While(_, _)
    | @engine.Stmt::For(_, _, _, _)
    | @engine.Stmt::ForIn(_, _, _)
    | @engine.Stmt::ForOf(_, _, _)
    | @engine.Stmt::ForAwaitOf(_, _, _)
    | @engine.Stmt::DoWhile(_, _) => true
    @engine.Stmt::Label(_, inner) => label_targets_iteration(inner)
    _ => false
  }
}

///|
fn find_label(labels : Array[(String, Bool)], name : String) -> Bool? {
  if labels.is_empty() {
    return None
  }
  let mut i = labels.length() - 1
  while i >= 0 {
    let (label_name, is_iteration) = labels[i]
    if label_name == name {
      return Some(is_iteration)
    }
    i = i - 1
  }
  None
}

///|
fn validate_break_continue_in_script(script : @engine.Script) -> Unit raise {
  let labels : Array[(String, Bool)] = []
  for stmt in script.body {
    validate_break_continue_in_stmt(stmt, 0, 0, labels)
  }
}

///|
fn validate_break_continue_in_stmt(
  stmt : @engine.Stmt,
  loop_depth : Int,
  switch_depth : Int,
  labels : Array[(String, Bool)],
) -> Unit raise {
  match stmt {
    @engine.Stmt::Break(label_opt) =>
      match label_opt {
        None =>
          if loop_depth == 0 && switch_depth == 0 {
            let _ = throw_syntax_error("break must be inside loop or switch")

          }
        Some(name) =>
          match find_label(labels, name) {
            Some(_) => ()
            None => {
              let _ = throw_syntax_error("break/continue label not found")

            }
          }
      }
    @engine.Stmt::Continue(label_opt) =>
      match label_opt {
        None =>
          if loop_depth == 0 {
            let _ = throw_syntax_error("continue must be inside loop")

          }
        Some(name) =>
          match find_label(labels, name) {
            Some(true) => ()
            _ => {
              let _ = throw_syntax_error("break/continue label not found")

            }
          }
      }
    @engine.Stmt::Block(stmts) =>
      for inner in stmts {
        validate_break_continue_in_stmt(inner, loop_depth, switch_depth, labels)
      }
    @engine.Stmt::Label(name, body) => {
      match find_label(labels, name) {
        Some(_) => {
          let _ = throw_syntax_error("duplicate label")

        }
        None => ()
      }
      let is_iteration = label_targets_iteration(body)
      labels.push((name, is_iteration))
      validate_break_continue_in_stmt(body, loop_depth, switch_depth, labels)
      let _ = labels.pop()

    }
    @engine.Stmt::With(_, body) =>
      validate_break_continue_in_stmt(body, loop_depth, switch_depth, labels)
    @engine.Stmt::If(_, conseq, alt) => {
      validate_break_continue_in_stmt(conseq, loop_depth, switch_depth, labels)
      match alt {
        Some(inner) =>
          validate_break_continue_in_stmt(
            inner, loop_depth, switch_depth, labels,
          )
        None => ()
      }
    }
    @engine.Stmt::While(_, body) =>
      validate_break_continue_in_stmt(
        body,
        loop_depth + 1,
        switch_depth,
        labels,
      )
    @engine.Stmt::For(_, _, _, body) =>
      validate_break_continue_in_stmt(
        body,
        loop_depth + 1,
        switch_depth,
        labels,
      )
    @engine.Stmt::ForIn(_, _, body) =>
      validate_break_continue_in_stmt(
        body,
        loop_depth + 1,
        switch_depth,
        labels,
      )
    @engine.Stmt::ForOf(_, _, body) =>
      validate_break_continue_in_stmt(
        body,
        loop_depth + 1,
        switch_depth,
        labels,
      )
    @engine.Stmt::ForAwaitOf(_, _, body) =>
      validate_break_continue_in_stmt(
        body,
        loop_depth + 1,
        switch_depth,
        labels,
      )
    @engine.Stmt::DoWhile(body, _) =>
      validate_break_continue_in_stmt(
        body,
        loop_depth + 1,
        switch_depth,
        labels,
      )
    @engine.Stmt::Switch(_, cases) =>
      for clause in cases {
        let body = match clause {
          @engine.SwitchCase::Case(_, stmts) => stmts
          @engine.SwitchCase::Default(stmts) => stmts
        }
        for inner in body {
          validate_break_continue_in_stmt(
            inner,
            loop_depth,
            switch_depth + 1,
            labels,
          )
        }
      }
    @engine.Stmt::Try(try_body, catch_clause, finally_body) => {
      validate_break_continue_in_stmt(
        try_body, loop_depth, switch_depth, labels,
      )
      match catch_clause {
        Some(clause) =>
          validate_break_continue_in_stmt(
            clause.body,
            loop_depth,
            switch_depth,
            labels,
          )
        None => ()
      }
      match finally_body {
        Some(inner) =>
          validate_break_continue_in_stmt(
            inner, loop_depth, switch_depth, labels,
          )
        None => ()
      }
    }
    @engine.Stmt::FunctionDecl(func) => {
      let inner_labels : Array[(String, Bool)] = []
      for inner in func.body {
        validate_break_continue_in_stmt(inner, 0, 0, inner_labels)
      }
    }
    @engine.Stmt::ClassDecl(class_def) =>
      for member_ in class_def.body {
        match member_ {
          @engine.ClassMember::Method(_, func, _)
          | @engine.ClassMember::Getter(_, func, _)
          | @engine.ClassMember::Setter(_, func, _) => {
            let inner_labels : Array[(String, Bool)] = []
            for inner in func.body {
              validate_break_continue_in_stmt(inner, 0, 0, inner_labels)
            }
          }
          @engine.ClassMember::StaticBlock(stmts) => {
            let inner_labels : Array[(String, Bool)] = []
            for inner in stmts {
              validate_break_continue_in_stmt(inner, 0, 0, inner_labels)
            }
          }
          _ => ()
        }
      }
    _ => ()
  }
}

///|
fn validate_context_in_script(
  script : @engine.Script,
  allow_new_target : Bool,
  allow_super : Bool,
  allow_super_call : Bool,
) -> Unit raise {
  if script.is_module {
    validate_module_decl_positions(script.body)
    validate_module_export_bindings(script)
    validate_module_returns(script.body)
  }
  validate_break_continue_in_script(script)
  for stmt in script.body {
    validate_context_in_stmt(
      stmt, allow_new_target, allow_super, allow_super_call,
    )
  }
}

///|
fn validate_module_decl_positions(body : Array[@engine.Stmt]) -> Unit raise {
  for stmt in body {
    validate_module_decl_positions_in_stmt(stmt, true)
  }
}

///|
fn validate_module_returns(body : Array[@engine.Stmt]) -> Unit raise {
  for stmt in body {
    if module_stmt_contains_return(stmt) {
      let _ = throw_syntax_error("illegal return")

    }
  }
}

///|
fn module_stmt_contains_return(stmt : @engine.Stmt) -> Bool {
  match stmt {
    @engine.Stmt::Return(_) => true
    @engine.Stmt::Block(stmts) => module_stmts_contain_return(stmts)
    @engine.Stmt::Label(_, body) => module_stmt_contains_return(body)
    @engine.Stmt::If(_, conseq, alt) =>
      if module_stmt_contains_return(conseq) {
        true
      } else {
        match alt {
          Some(inner) => module_stmt_contains_return(inner)
          None => false
        }
      }
    @engine.Stmt::While(_, body) => module_stmt_contains_return(body)
    @engine.Stmt::For(_, _, _, body) => module_stmt_contains_return(body)
    @engine.Stmt::ForIn(_, _, body) => module_stmt_contains_return(body)
    @engine.Stmt::ForOf(_, _, body) => module_stmt_contains_return(body)
    @engine.Stmt::ForAwaitOf(_, _, body) => module_stmt_contains_return(body)
    @engine.Stmt::DoWhile(body, _) => module_stmt_contains_return(body)
    @engine.Stmt::Switch(_, cases) => module_cases_contain_return(cases)
    @engine.Stmt::Try(try_body, catch_clause, finally_body) => {
      if module_stmt_contains_return(try_body) {
        return true
      }
      match catch_clause {
        Some(clause) =>
          if module_stmt_contains_return(clause.body) {
            return true
          }
        None => ()
      }
      match finally_body {
        Some(inner) => module_stmt_contains_return(inner)
        None => false
      }
    }
    @engine.Stmt::FunctionDecl(_) | @engine.Stmt::ClassDecl(_) => false
    _ => false
  }
}

///|
fn module_stmts_contain_return(stmts : Array[@engine.Stmt]) -> Bool {
  for stmt in stmts {
    if module_stmt_contains_return(stmt) {
      return true
    }
  }
  false
}

///|
fn module_cases_contain_return(cases : Array[@engine.SwitchCase]) -> Bool {
  for clause in cases {
    let body = match clause {
      @engine.SwitchCase::Case(_, stmts) => stmts
      @engine.SwitchCase::Default(stmts) => stmts
    }
    if module_stmts_contain_return(body) {
      return true
    }
  }
  false
}

///|
fn validate_module_export_bindings(script : @engine.Script) -> Unit raise {
  let info = module_export_info_from_script(script)
  let declared = module_declared_names_from_script(script)
  for _, binding in info.local_exports {
    if binding.is_empty() {
      continue
    }
    if !declared.contains(binding) {
      let _ = throw_syntax_error(
        "exported variable '\{binding}' does not exist",
      )

    }
  }
}

///|
fn module_declared_names_from_script(
  script : @engine.Script,
) -> @hashmap.HashMap[String, Bool] {
  let names = @hashmap.new()
  for stmt in script.body {
    module_declared_names_in_stmt(stmt, names)
  }
  names
}

///|
fn module_declared_names_in_stmt(
  stmt : @engine.Stmt,
  names : @hashmap.HashMap[String, Bool],
) -> Unit {
  match stmt {
    @engine.Stmt::VarDecl(_, decls) =>
      for decl in decls {
        let (binding, _) = decl
        collect_binding_names(binding, names)
      }
    @engine.Stmt::FunctionDecl(func) =>
      match func.name {
        Some(name) => names.set(name, true)
        None => ()
      }
    @engine.Stmt::ClassDecl(class_def) =>
      match class_def.name {
        Some(name) => names.set(name, true)
        None => ()
      }
    @engine.Stmt::Block(body) =>
      if block_is_export_wrapper(body) {
        for inner in body {
          module_declared_names_in_stmt(inner, names)
        }
      }
    _ => ()
  }
}

///|
fn stmt_is_export_decl(stmt : @engine.Stmt) -> Bool {
  match stmt {
    @engine.Stmt::ExprStmt(expr) =>
      expr_is_export_call(expr) || expr_is_export_star(expr)
    @engine.Stmt::Block(body) => block_is_export_wrapper(body)
    _ => false
  }
}

///|
fn validate_module_decl_positions_in_stmt(
  stmt : @engine.Stmt,
  top_level : Bool,
) -> Unit raise {
  if top_level {
    if stmt_is_import_decl(stmt) || stmt_is_export_decl(stmt) {
      return
    }
  } else if stmt_is_import_decl(stmt) || stmt_is_export_decl(stmt) {
    let _ = throw_syntax_error("invalid declaration position")

  }
  match stmt {
    @engine.Stmt::Block(stmts) =>
      for inner in stmts {
        validate_module_decl_positions_in_stmt(inner, false)
      }
    @engine.Stmt::Label(_, body) =>
      validate_module_decl_positions_in_stmt(body, false)
    @engine.Stmt::If(_, conseq, alt) => {
      validate_module_decl_positions_in_stmt(conseq, false)
      match alt {
        Some(inner) => validate_module_decl_positions_in_stmt(inner, false)
        None => ()
      }
    }
    @engine.Stmt::While(_, body) =>
      validate_module_decl_positions_in_stmt(body, false)
    @engine.Stmt::For(_, _, _, body) =>
      validate_module_decl_positions_in_stmt(body, false)
    @engine.Stmt::ForIn(_, _, body) =>
      validate_module_decl_positions_in_stmt(body, false)
    @engine.Stmt::ForOf(_, _, body) =>
      validate_module_decl_positions_in_stmt(body, false)
    @engine.Stmt::ForAwaitOf(_, _, body) =>
      validate_module_decl_positions_in_stmt(body, false)
    @engine.Stmt::DoWhile(body, _) =>
      validate_module_decl_positions_in_stmt(body, false)
    @engine.Stmt::Switch(_, cases) =>
      for clause in cases {
        let body = match clause {
          @engine.SwitchCase::Case(_, stmts) => stmts
          @engine.SwitchCase::Default(stmts) => stmts
        }
        for inner in body {
          validate_module_decl_positions_in_stmt(inner, false)
        }
      }
    @engine.Stmt::Try(try_body, catch_clause, finally_body) => {
      validate_module_decl_positions_in_stmt(try_body, false)
      match catch_clause {
        Some(clause) =>
          validate_module_decl_positions_in_stmt(clause.body, false)
        None => ()
      }
      match finally_body {
        Some(inner) => validate_module_decl_positions_in_stmt(inner, false)
        None => ()
      }
    }
    _ => ()
  }
}

///|
fn eval_with_env(env : Env, args : Array[Value]) -> Value raise {
  eval_with_env_mode(env, args, true)
}

///|
fn collect_eval_private_names(env : Env) -> Array[String] {
  let names : Array[String] = []
  let seen : @hashmap.HashMap[String, Bool] = @hashmap.new()
  let mut current : Env? = Some(env)
  while true {
    match current {
      Some(frame) => {
        for name, _ in frame.private_bindings {
          if seen.get(name) is None {
            seen.set(name, true)
            names.push(name)
          }
        }
        current = frame.parent
      }
      None => break
    }
  }
  names
}

///|

///|
fn new_eval_with_var_object_env(parent : Env, obj : Value) -> Env {
  let env = Env::{
    id: alloc_id(),
    parent: Some(parent),
    bindings: @hashmap.new(),
    readonly_bindings: @hashmap.new(),
    deletable_bindings: @hashmap.new(),
    private_bindings: @hashmap.new(),
    strict: parent.strict,
    with_object: None,
    var_object: Some(obj),
    new_target: parent.new_target,
    allow_new_target: parent.allow_new_target,
    allow_super: parent.allow_super,
    allow_super_call: parent.allow_super_call,
    this_uninitialized: false,
    is_param_env: false,
    is_catch_env: false,
    param_binding_names: @hashmap.new(),
    uninitialized_bindings: @hashmap.new(),
    var_env: None,
  }
  register_env(env)
  env.var_env = Some(env)
  env
}

///|
fn eval_with_env_mode(
  env : Env,
  args : Array[Value],
  direct : Bool,
) -> Value raise {
  if args.is_empty() {
    return Undefined
  }
  match args[0] {
    String(source) => {
      if @engine.contains_module_syntax(source) {
        let _ = throw_syntax_error("unexpected token")

      }
      let direct_strict = if direct { env.strict } else { false }
      let force_strict = if direct { direct_strict } else { false }
      let script = if direct {
        let private_names = collect_eval_private_names(env)
        parse_script_with_pos_mode_private(
          source, false, force_strict, private_names,
        )
      } else {
        parse_script_with_pos_mode(source, false, force_strict)
      }
      let eval_strict = if direct {
        direct_strict || script.is_strict
      } else {
        script.is_strict
      }
      let eval_skip_outer_var = direct && !eval_strict
      if direct {
        check_eval_var_conflicts(env, script.body)
      }
      let in_class_field_eval = direct && in_class_field_init_context()
      if in_class_field_eval && @engine.script_contains_arguments(script) {
        let _ = throw_syntax_error(
          "arguments not allowed in class field initializer",
        )

      }
      let (allow_new_target_value, allow_super_value, allow_super_call_value) = if direct {
        (env.allow_new_target, env.allow_super, env.allow_super_call)
      } else {
        (false, false, false)
      }
      let mut allow_new_target = allow_new_target_value
      let mut allow_super = allow_super_value
      let mut allow_super_call = allow_super_call_value
      if in_class_field_eval {
        allow_new_target = true
        allow_super = true
        allow_super_call = false
      }
      validate_context_in_script(
        script, allow_new_target, allow_super, allow_super_call,
      )
      let eval_base_env = if direct && !eval_strict {
        match env.with_object {
          Some(obj) => new_eval_with_var_object_env(env, obj)
          None => env
        }
      } else {
        env
      }
      let var_env = if direct {
        var_env_for(eval_base_env)
      } else {
        eval_base_env
      }
      let eval_has_arguments_binding = if direct {
        match current_function() {
          Some(func) => !func.is_arrow
          None => false
        }
      } else {
        false
      }
      let func_var_names = compute_annex_b_var_func_decls(
        script.body,
        eval_strict,
        @hashmap.new(),
        eval_has_arguments_binding,
      )
      with_annex_b_var_func_decls(func_var_names, fn() raise {
        if direct && !eval_strict {
          eval_check_var_lex_conflicts(
            eval_base_env,
            var_env,
            script.body,
            eval_strict,
          )
        }
        if !eval_strict {
          eval_check_global_var_lex_conflicts(var_env, script.body, eval_strict)
        }
        eval_check_global_function_decls(var_env, script.body, eval_strict)
        let needs_lex_env = eval_body_has_lexical_decls(script.body)
        if direct {
          if eval_strict || needs_lex_env {
            let eval_env = Env::new(Some(eval_base_env))
            let eval_var_env = if eval_strict { eval_env } else { var_env }
            eval_env.var_env = Some(eval_var_env)
            if needs_lex_env {
              eval_predeclare_lexical_decls(eval_env, script.body)
            }
            eval_script_with_strict(
              eval_env, script, direct_strict, true, eval_skip_outer_var,
            )
          } else {
            eval_script_with_strict(
              eval_base_env, script, direct_strict, true, eval_skip_outer_var,
            )
          }
        } else {
          let eval_env = Env::new(Some(var_env))
          let eval_var_env = if eval_strict { eval_env } else { var_env }
          eval_env.var_env = Some(eval_var_env)
          if needs_lex_env {
            eval_predeclare_lexical_decls(eval_env, script.body)
          }
          eval_script_with_strict(
            eval_env, script, false, true, eval_skip_outer_var,
          )
        }
      })
    }
    _ => args[0]
  }
}

///|
fn gen_bind(step : GenStep, f : (GenControl) -> GenStep raise) -> GenStep raise {
  match step {
    Yield(value, next_step) =>
      Yield(value, fn(resume_state) raise {
        gen_bind(next_step(resume_state), f)
      })
    Await(value, next_step) =>
      Await(value, fn(resume_state) raise {
        gen_bind(next_step(resume_state), f)
      })
    Done(control) => f(control)
  }
}

///|
fn gen_bind_noraise(step : GenStep, f : (GenControl) -> GenStep) -> GenStep {
  match step {
    Yield(value, next_step) =>
      Yield(value, fn(resume_state) raise {
        gen_bind_noraise(next_step(resume_state), f)
      })
    Await(value, next_step) =>
      Await(value, fn(resume_state) raise {
        gen_bind_noraise(next_step(resume_state), f)
      })
    Done(control) => f(control)
  }
}

///|
fn gen_await_value(value : Value, k : (Value) -> GenStep raise) -> GenStep {
  Await(value, fn(resume_state) raise {
    match resume_state {
      GenResume::Next(arg) => k(arg)
      GenResume::Return(arg) => Done(Return(arg))
      GenResume::Throw(arg) => Done(Throw(arg))
    }
  })
}

///|
fn gen_unwrap_async_yield_resume(
  resume_state : GenResume,
  k : (GenResume) -> GenStep raise,
) -> GenStep {
  match resume_state {
    GenResume::Next(arg) =>
      gen_await_value(arg, fn(awaited) raise { k(GenResume::Next(awaited)) })
    GenResume::Return(arg) =>
      gen_await_value(arg, fn(awaited) raise { k(GenResume::Return(awaited)) })
    GenResume::Throw(arg) =>
      gen_await_value(arg, fn(awaited) raise { k(GenResume::Throw(awaited)) })
  }
}

///|
fn gen_async_return(value : Value) -> GenStep {
  Await(value, fn(resume_state) {
    match resume_state {
      GenResume::Next(arg) => Done(Return(arg))
      GenResume::Return(arg) => Done(Return(arg))
      GenResume::Throw(arg) => Done(Throw(arg))
    }
  })
}

///|
fn gen_eval_stmt_seq(
  env : Env,
  stmts : Array[@engine.Stmt],
  index : Int,
) -> GenStep raise {
  if index >= stmts.length() {
    return Done(Normal(Undefined))
  }
  gen_bind(gen_eval_stmt(env, stmts[index]), fn(control) {
    match control {
      Normal(value) => {
        gc_maybe_collect_with_root(value)
        gen_eval_stmt_seq(env, stmts, index + 1)
      }
      _ => Done(control)
    }
  })
}

///|
fn gen_eval_block(env : Env, stmts : Array[@engine.Stmt]) -> GenStep raise {
  if current_module_env_id() is Some(_) && block_is_export_wrapper(stmts) {
    return gen_eval_stmt_seq(env, stmts, 0)
  }
  if block_needs_lex_env(stmts, env.strict) {
    let block_env = Env::new(Some(env))
    hoist_block_functions(block_env, stmts)
    with_env_step(block_env, fn() raise {
      eval_predeclare_lexical_decls(block_env, stmts)
      gen_eval_stmt_seq(block_env, stmts, 0)
    })
  } else {
    gen_eval_stmt_seq(env, stmts, 0)
  }
}

///|
fn gen_eval_stmt_in_block_if_needed(
  env : Env,
  stmt : @engine.Stmt,
) -> GenStep raise {
  match stmt {
    @engine.Stmt::Block(_) => gen_eval_stmt(env, stmt)
    _ =>
      if stmt_needs_lex_env(stmt, env.strict) {
        let block_env = Env::new(Some(env))
        let stmts : Array[@engine.Stmt] = [stmt]
        hoist_block_functions(block_env, stmts)
        with_env_step(block_env, fn() raise {
          eval_predeclare_lexical_decls(block_env, stmts)
          gen_eval_stmt(block_env, stmt)
        })
      } else {
        gen_eval_stmt(env, stmt)
      }
  }
}

///|
fn gen_eval_stmt(env : Env, stmt : @engine.Stmt) -> GenStep raise {
  if !stmt_contains_yield(stmt) && !current_function_is_generator() {
    return try {
      let value = eval_stmt(env, stmt)
      Done(Normal(value))
    } catch {
      ReturnSignal(value) => Done(Return(value))
      BreakSignal((label, value_opt)) => Done(Break(label, value_opt))
      ContinueSignal((label, value_opt)) => Done(Continue(label, value_opt))
      ThrowSignal(value) => Done(Throw(value))
      err => raise err
    }
  }
  match stmt {
    Empty => Done(Normal(Undefined))
    ExprStmt(expr) =>
      gen_eval_expr_cont(env, expr, fn(value) { Done(Normal(value)) })
    VarDecl(kind, decls) => gen_eval_var_decls(env, kind, decls, 0)
    Block(stmts) => gen_eval_block(env, stmts)
    FunctionDecl(func) => {
      if top_level_function_decl_contains(func) {
        return Done(Normal(Undefined))
      }
      let value = match func.name {
        Some(name) =>
          match env.bindings.get(name) {
            Some(_) => env_get_binding_value(env, name)
            None =>
              match env.var_object {
                Some(Object(obj)) =>
                  match obj.props.get(name) {
                    Some(prop) =>
                      if is_data_property(prop) {
                        prop.value
                      } else {
                        property_get(Value::Object(obj), name)
                      }
                    None => Value::Function(to_function_value(env, func, false))
                  }
                Some(_) => Value::Function(to_function_value(env, func, false))
                None => Value::Function(to_function_value(env, func, false))
              }
          }
        None => Value::Function(to_function_value(env, func, false))
      }
      match func.name {
        Some(name) => {
          env_set_local_or_var_object(env, name, value, true)
          if !env.strict && !func.is_async && !func.is_generator {
            let var_env = var_env_for(env)
            if var_env.id != env.id && annex_b_var_func_decl_contains(func) {
              env_set(var_env, name, value)
            }
          }
        }
        None => ()
      }
      Done(Normal(Undefined))
    }
    ClassDecl(class_def) =>
      gen_bind(gen_eval_class(env, class_def), fn(control) {
        match control {
          Normal(value) => {
            match class_def.name {
              Some(name) => env_initialize_binding(env, name, value)
              None => ()
            }
            Done(Normal(Undefined))
          }
          Return(value) => Done(Return(value))
          Throw(value) => Done(Throw(value))
          Break(label, value_opt) => Done(Break(label, value_opt))
          Continue(label, value_opt) => Done(Continue(label, value_opt))
        }
      })
    If(cond_expr, conseq, alt) =>
      gen_eval_expr_cont(env, cond_expr, fn(cond) {
        if is_truthy(cond) {
          gen_eval_stmt_in_block_if_needed(env, conseq)
        } else {
          match alt {
            Some(stmt) => gen_eval_stmt_in_block_if_needed(env, stmt)
            None => Done(Normal(Undefined))
          }
        }
      })
    With(expr, body) =>
      if env.strict {
        let _ = throw_syntax_error("with not allowed in strict mode")
        Done(Throw(Undefined))
      } else {
        gen_eval_expr_cont(env, expr, fn(value) raise {
          let obj = to_object(value)
          let with_env = Env::{
            id: alloc_id(),
            parent: Some(env),
            bindings: @hashmap.new(),
            readonly_bindings: @hashmap.new(),
            deletable_bindings: @hashmap.new(),
            private_bindings: @hashmap.new(),
            strict: env.strict,
            with_object: Some(obj),
            var_object: None,
            new_target: env.new_target,
            allow_new_target: env.allow_new_target,
            allow_super: env.allow_super,
            allow_super_call: env.allow_super_call,
            this_uninitialized: false,
            is_param_env: false,
            is_catch_env: false,
            param_binding_names: @hashmap.new(),
            uninitialized_bindings: @hashmap.new(),
            var_env: None,
          }
          register_env(with_env)
          with_env_step(with_env, fn() raise { gen_eval_stmt(with_env, body) })
        })
      }
    While(cond_expr, body) => gen_eval_while(env, None, cond_expr, body)
    For(init, test_expr, update_expr, body) =>
      gen_eval_for(env, None, init, test_expr, update_expr, body)
    ForIn(init, expr, body) => gen_eval_for_in(env, None, init, expr, body)
    ForOf(init, expr, body) => gen_eval_for_of(env, None, init, expr, body)
    ForAwaitOf(init, expr, body) =>
      gen_eval_for_await_of(env, None, init, expr, body)
    DoWhile(body, cond_expr) => gen_eval_do_while(env, None, body, cond_expr)
    Throw(expr) =>
      gen_eval_expr_cont(env, expr, fn(value) { Done(Throw(value)) })
    Try(try_body, catch_clause, finally_body) =>
      gen_eval_try(env, try_body, catch_clause, finally_body)
    Break(label) => Done(Break(label, None))
    Continue(label) => Done(Continue(label, None))
    Return(expr) => {
      let is_async_gen = current_function_is_async_generator()
      match expr {
        Some(inner) =>
          gen_eval_expr_cont(env, inner, fn(value) {
            if is_async_gen {
              gen_async_return(value)
            } else {
              Done(Return(value))
            }
          })
        None =>
          if is_async_gen {
            Done(Return(Undefined))
          } else {
            Done(Return(Undefined))
          }
      }
    }
    Label(name, body) =>
      match body {
        While(cond_expr, inner) =>
          gen_eval_while(env, Some(name), cond_expr, inner)
        For(init, test_expr, update_expr, inner) =>
          gen_eval_for(env, Some(name), init, test_expr, update_expr, inner)
        ForIn(init, expr, inner) =>
          gen_eval_for_in(env, Some(name), init, expr, inner)
        ForOf(init, expr, inner) =>
          gen_eval_for_of(env, Some(name), init, expr, inner)
        ForAwaitOf(init, expr, inner) =>
          gen_eval_for_await_of(env, Some(name), init, expr, inner)
        DoWhile(inner, cond_expr) =>
          gen_eval_do_while(env, Some(name), inner, cond_expr)
        _ =>
          gen_bind(gen_eval_stmt(env, body), fn(control) {
            match control {
              Break(label, value_opt) =>
                match label {
                  Some(label_name) =>
                    if label_name == name {
                      Done(Normal(update_empty(value_opt, Undefined)))
                    } else {
                      Done(Break(label, value_opt))
                    }
                  None => Done(Break(label, value_opt))
                }
              Continue(label, value_opt) => Done(Continue(label, value_opt))
              _ => Done(control)
            }
          })
      }
    _ => {
      let _ = throw_type_error("unsupported generator statement")
      Done(Throw(Undefined))
    }
  }
}

///|
fn gen_eval_var_decls(
  env : Env,
  kind : @engine.VarKind,
  decls : Array[(@engine.VarBinding, @engine.Expr?)],
  index : Int,
) -> GenStep raise {
  if index >= decls.length() {
    return Done(Normal(Undefined))
  }
  let assign = fn(name : String, value : Value) raise {
    match kind {
      @engine.VarKind::ConstDecl => env_define_readonly(env, name, value, true)
      @engine.VarKind::Var => env_set(env, name, value)
      _ => env_initialize_binding(env, name, value)
    }
  }
  let (binding, init) = decls[index]
  match binding {
    @engine.VarBinding::Name(name) =>
      match init {
        Some(expr) =>
          gen_eval_expr_cont(env, expr, fn(value) raise {
            assign(name, value)
            gen_eval_var_decls(env, kind, decls, index + 1)
          })
        None =>
          if kind is @engine.VarKind::ConstDecl {
            let _ = throw_syntax_error(
              "missing initializer in const declaration",
            )
            Done(Throw(Undefined))
          } else if kind is @engine.VarKind::Var {
            gen_eval_var_decls(env, kind, decls, index + 1)
          } else {
            env_declare(env, name, Undefined)
            gen_eval_var_decls(env, kind, decls, index + 1)
          }
      }
    @engine.VarBinding::ArrayPattern(pattern) =>
      match init {
        Some(expr) =>
          gen_eval_expr_cont(env, expr, fn(value) raise {
            gen_destructure_array_pattern(
              env,
              pattern,
              value,
              fn(name, v) raise { assign(name, v) },
              fn() raise { gen_eval_var_decls(env, kind, decls, index + 1) },
            )
          })
        None =>
          if kind is @engine.VarKind::ConstDecl {
            let _ = throw_syntax_error(
              "missing initializer in const declaration",
            )
            Done(Throw(Undefined))
          } else if kind is @engine.VarKind::Var {
            gen_eval_var_decls(env, kind, decls, index + 1)
          } else {
            declare_binding_names(env, binding)
            gen_eval_var_decls(env, kind, decls, index + 1)
          }
      }
    @engine.VarBinding::ObjectPattern(pattern) =>
      match init {
        Some(expr) =>
          gen_eval_expr_cont(env, expr, fn(value) raise {
            let obj = to_object(value)
            gen_destructure_object_pattern(
              env,
              pattern,
              obj,
              [],
              0,
              fn(name, v) raise { assign(name, v) },
              fn() raise { gen_eval_var_decls(env, kind, decls, index + 1) },
            )
          })
        None =>
          if kind is @engine.VarKind::ConstDecl {
            let _ = throw_syntax_error(
              "missing initializer in const declaration",
            )
            Done(Throw(Undefined))
          } else if kind is @engine.VarKind::Var {
            gen_eval_var_decls(env, kind, decls, index + 1)
          } else {
            declare_binding_names(env, binding)
            gen_eval_var_decls(env, kind, decls, index + 1)
          }
      }
    @engine.VarBinding::Target(_) => {
      let _ = throw_syntax_error("invalid binding")
      Done(Throw(Undefined))
    }
  }
}

///|
fn gen_eval_while(
  env : Env,
  label : String?,
  cond_expr : @engine.Expr,
  body : @engine.Stmt,
) -> GenStep raise {
  gen_eval_while_loop(env, label, cond_expr, body)
}

///|
fn gen_eval_while_loop(
  env : Env,
  label : String?,
  cond_expr : @engine.Expr,
  body : @engine.Stmt,
) -> GenStep raise {
  gen_eval_expr_cont(env, cond_expr, fn(cond) raise {
    if !is_truthy(cond) {
      Done(Normal(Undefined))
    } else {
      gen_bind(gen_eval_stmt(env, body), fn(control) raise {
        match control {
          Normal(_) => gen_eval_while_loop(env, label, cond_expr, body)
          Continue(signal_label, value_opt) => {
            let updated = update_empty(value_opt, Undefined)
            if label_matches(signal_label, label) {
              gen_eval_while_loop(env, label, cond_expr, body)
            } else {
              Done(Continue(signal_label, Some(updated)))
            }
          }
          Break(signal_label, value_opt) => {
            let updated = update_empty(value_opt, Undefined)
            if label_matches(signal_label, label) {
              Done(Normal(updated))
            } else {
              Done(Break(signal_label, Some(updated)))
            }
          }
          Return(value) => Done(Return(value))
          Throw(value) => Done(Throw(value))
        }
      })
    }
  })
}

///|
fn gen_eval_for(
  env : Env,
  label : String?,
  init : @engine.ForInit,
  test_expr : @engine.Expr?,
  update_expr : @engine.Expr?,
  body : @engine.Stmt,
) -> GenStep raise {
  let (use_loop_env, loop_is_const) = match init {
    @engine.ForInit::Var(kind, _) =>
      if kind is @engine.VarKind::Var {
        (false, false)
      } else {
        (true, kind is @engine.VarKind::ConstDecl)
      }
    _ => (false, false)
  }
  let loop_env = if use_loop_env { Env::new(Some(env)) } else { env }
  let loop_names = if use_loop_env {
    for_init_binding_names(init)
  } else {
    ([] : Array[String])
  }
  if use_loop_env {
    hoist_functions(loop_env, body, false, false)
  }
  let start = match init {
    @engine.ForInit::None => Done(Normal(Undefined))
    @engine.ForInit::Var(kind, decls) =>
      gen_eval_var_decls(loop_env, kind, decls, 0)
    @engine.ForInit::Expr(expr) =>
      gen_eval_expr_cont(loop_env, expr, fn(_) { Done(Normal(Undefined)) })
  }
  gen_bind(start, fn(control) raise {
    match control {
      Normal(_) => {
        let iter_env = if use_loop_env {
          create_for_iteration_env(
            loop_env, loop_env, loop_names, loop_is_const,
          )
        } else {
          loop_env
        }
        gen_eval_for_loop(
          loop_env, label, test_expr, update_expr, body, use_loop_env, loop_names,
          loop_is_const, iter_env,
        )
      }
      _ => Done(control)
    }
  })
}

///|
fn gen_eval_for_loop(
  loop_env : Env,
  label : String?,
  test_expr : @engine.Expr?,
  update_expr : @engine.Expr?,
  body : @engine.Stmt,
  use_loop_env : Bool,
  loop_names : Array[String],
  loop_is_const : Bool,
  iter_env : Env,
) -> GenStep raise {
  let current_env = if use_loop_env { iter_env } else { loop_env }
  let test_step = match test_expr {
    Some(expr) =>
      gen_eval_expr_cont(current_env, expr, fn(value) { Done(Normal(value)) })
    None => Done(Normal(Bool(true)))
  }
  gen_bind(test_step, fn(control) {
    match control {
      Normal(value) =>
        if !is_truthy(value) {
          Done(Normal(Undefined))
        } else {
          gen_bind(gen_eval_stmt(current_env, body), fn(body_control) {
            match body_control {
              Normal(_) => {
                let next_iter_env = if use_loop_env {
                  create_for_iteration_env(
                    current_env, loop_env, loop_names, loop_is_const,
                  )
                } else {
                  loop_env
                }
                gen_eval_for_update(
                  loop_env, next_iter_env, label, test_expr, update_expr, body, use_loop_env,
                  loop_names, loop_is_const,
                )
              }
              Continue(signal_label, value_opt) => {
                let updated = update_empty(value_opt, Undefined)
                if label_matches(signal_label, label) {
                  let next_iter_env = if use_loop_env {
                    create_for_iteration_env(
                      current_env, loop_env, loop_names, loop_is_const,
                    )
                  } else {
                    loop_env
                  }
                  gen_eval_for_update(
                    loop_env, next_iter_env, label, test_expr, update_expr, body,
                    use_loop_env, loop_names, loop_is_const,
                  )
                } else {
                  Done(Continue(signal_label, Some(updated)))
                }
              }
              Break(signal_label, value_opt) => {
                let updated = update_empty(value_opt, Undefined)
                if label_matches(signal_label, label) {
                  Done(Normal(updated))
                } else {
                  Done(Break(signal_label, Some(updated)))
                }
              }
              Return(value) => Done(Return(value))
              Throw(value) => Done(Throw(value))
            }
          })
        }
      _ => Done(control)
    }
  })
}

///|
fn gen_eval_for_in(
  env : Env,
  label : String?,
  init : @engine.ForInit,
  expr : @engine.Expr,
  body : @engine.Stmt,
) -> GenStep raise {
  let start = match init {
    @engine.ForInit::None => Done(Normal(Undefined))
    @engine.ForInit::Var(kind, decls) => {
      let mut has_init = false
      for decl in decls {
        let (_, init_expr) = decl
        if init_expr is Some(_) {
          has_init = true
          break
        }
      }
      if kind is @engine.VarKind::ConstDecl && !has_init {
        for decl in decls {
          let (binding, _) = decl
          declare_binding_names(env, binding)
        }
        Done(Normal(Undefined))
      } else {
        gen_eval_var_decls(env, kind, decls, 0)
      }
    }
    @engine.ForInit::Expr(_) => Done(Normal(Undefined))
  }
  gen_bind(start, fn(control) {
    match control {
      Normal(_) =>
        gen_eval_expr_cont(env, expr, fn(value) raise {
          gen_with_root_frame(fn() raise {
            let target = to_object(value)
            let _ = gen_root_push(target)
            let keys = enumerable_string_keys_in_chain(target)
            gen_eval_for_in_loop(env, label, init, target, keys, 0, body)
          })
        })
      _ => Done(control)
    }
  })
}

///|
fn gen_iterator_close(iterator : Value, control : GenControl) -> GenStep raise {
  try {
    match control {
      Throw(_) => iterator_close_on_error(iterator)
      _ => iterator_close(iterator)
    }
    Done(control)
  } catch {
    ThrowSignal(value) => Done(Throw(value))
    err => raise err
  }
}

///|
fn gen_async_iterator_close(
  iterator : Value,
  control : GenControl,
) -> GenStep raise {
  try {
    match control {
      Throw(_) => async_iterator_close_on_error(iterator)
      _ => async_iterator_close(iterator)
    }
    Done(control)
  } catch {
    ThrowSignal(value) => Done(Throw(value))
    err => raise err
  }
}

///|
fn gen_async_iterator_step_value(
  iterator : Value,
  next_method : Value,
  k : (Bool, Value) -> GenStep raise,
) -> GenStep raise {
  let result = call_value_with_this(next_method, [], iterator) catch {
    ThrowSignal(value) => return Done(Throw(value))
    err => raise err
  }
  gen_await_value(result, fn(awaited) raise {
    if !is_object_like(awaited) {
      return Done(Throw(type_error_value("iterator must return an object")))
    }
    try {
      let done = is_truthy(property_get(awaited, "done"))
      let value = property_get(awaited, "value")
      k(done, value)
    } catch {
      ThrowSignal(value) => Done(Throw(value))
      err => raise err
    }
  })
}

///|
fn gen_eval_for_of(
  env : Env,
  label : String?,
  init : @engine.ForInit,
  expr : @engine.Expr,
  body : @engine.Stmt,
) -> GenStep raise {
  let start = match init {
    @engine.ForInit::None => Done(Normal(Undefined))
    @engine.ForInit::Var(kind, decls) => {
      let mut has_init = false
      for decl in decls {
        let (_, init_expr) = decl
        if init_expr is Some(_) {
          has_init = true
          break
        }
      }
      if kind is @engine.VarKind::ConstDecl && !has_init {
        for decl in decls {
          let (binding, _) = decl
          declare_binding_names(env, binding)
        }
        Done(Normal(Undefined))
      } else {
        gen_eval_var_decls(env, kind, decls, 0)
      }
    }
    @engine.ForInit::Expr(_) => Done(Normal(Undefined))
  }
  gen_bind(start, fn(control) raise {
    match control {
      Normal(_) =>
        gen_eval_expr_cont(env, expr, fn(value) raise {
          gen_with_root_frame(fn() raise {
            let (iterator, next_method) = get_iterator_from_value(value)
            let _ = gen_root_push(iterator)
            let _ = gen_root_push(next_method)
            gen_eval_for_of_loop(env, label, init, iterator, next_method, body)
          })
        })
      _ => Done(control)
    }
  })
}

///|
fn gen_eval_for_await_of(
  env : Env,
  label : String?,
  init : @engine.ForInit,
  expr : @engine.Expr,
  body : @engine.Stmt,
) -> GenStep raise {
  let start = match init {
    @engine.ForInit::None => Done(Normal(Undefined))
    @engine.ForInit::Var(kind, decls) => {
      let mut has_init = false
      for decl in decls {
        let (_, init_expr) = decl
        if init_expr is Some(_) {
          has_init = true
          break
        }
      }
      if kind is @engine.VarKind::ConstDecl && !has_init {
        for decl in decls {
          let (binding, _) = decl
          declare_binding_names(env, binding)
        }
        Done(Normal(Undefined))
      } else {
        gen_eval_var_decls(env, kind, decls, 0)
      }
    }
    @engine.ForInit::Expr(_) => Done(Normal(Undefined))
  }
  gen_bind(start, fn(control) raise {
    match control {
      Normal(_) =>
        gen_eval_expr_cont(env, expr, fn(value) raise {
          gen_with_root_frame(fn() raise {
            let (iterator, next_method) = get_async_iterator_from_value(value)
            let _ = gen_root_push(iterator)
            let _ = gen_root_push(next_method)
            gen_eval_for_await_of_loop(
              env, label, init, iterator, next_method, body,
            )
          })
        })
      _ => Done(control)
    }
  })
}

///|
fn gen_eval_for_of_loop(
  env : Env,
  label : String?,
  init : @engine.ForInit,
  iterator : Value,
  next_method : Value,
  body : @engine.Stmt,
) -> GenStep raise {
  let (done, value) = iterator_step_value(iterator, next_method) catch {
    ThrowSignal(value) => return Done(Throw(value))
    err => raise err
  }
  if done {
    return Done(Normal(Undefined))
  }
  gen_bind(
    gen_assign_for_in_target(env, init, value, fn() { Done(Normal(Undefined)) }),
    fn(control) {
      match control {
        Normal(_) =>
          gen_bind(gen_eval_stmt(env, body), fn(control) {
            match control {
              Normal(_) =>
                gen_eval_for_of_loop(
                  env, label, init, iterator, next_method, body,
                )
              Continue(signal_label, value_opt) => {
                let updated = update_empty(value_opt, Undefined)
                if label_matches(signal_label, label) {
                  gen_eval_for_of_loop(
                    env, label, init, iterator, next_method, body,
                  )
                } else {
                  gen_iterator_close(
                    iterator,
                    Continue(signal_label, Some(updated)),
                  )
                }
              }
              Break(signal_label, value_opt) => {
                let updated = update_empty(value_opt, Undefined)
                if label_matches(signal_label, label) {
                  gen_iterator_close(iterator, Normal(updated))
                } else {
                  gen_iterator_close(
                    iterator,
                    Break(signal_label, Some(updated)),
                  )
                }
              }
              Return(value) => gen_iterator_close(iterator, Return(value))
              Throw(value) => gen_iterator_close(iterator, Throw(value))
            }
          })
        Return(value) => gen_iterator_close(iterator, Return(value))
        Break(label_name, value_opt) =>
          gen_iterator_close(iterator, Break(label_name, value_opt))
        Continue(label_name, value_opt) =>
          gen_iterator_close(iterator, Continue(label_name, value_opt))
        Throw(value) => gen_iterator_close(iterator, Throw(value))
      }
    },
  )
}

///|
fn gen_eval_for_await_of_loop(
  env : Env,
  label : String?,
  init : @engine.ForInit,
  iterator : Value,
  next_method : Value,
  body : @engine.Stmt,
) -> GenStep raise {
  gen_async_iterator_step_value(iterator, next_method, fn(done, value) raise {
    if done {
      return Done(Normal(Undefined))
    }
    gen_bind(
      gen_assign_for_in_target(env, init, value, fn() {
        Done(Normal(Undefined))
      }),
      fn(control) {
        match control {
          Normal(_) =>
            gen_bind(gen_eval_stmt(env, body), fn(control) {
              match control {
                Normal(_) =>
                  gen_eval_for_await_of_loop(
                    env, label, init, iterator, next_method, body,
                  )
                Continue(signal_label, value_opt) => {
                  let updated = update_empty(value_opt, Undefined)
                  if label_matches(signal_label, label) {
                    gen_eval_for_await_of_loop(
                      env, label, init, iterator, next_method, body,
                    )
                  } else {
                    gen_async_iterator_close(
                      iterator,
                      Continue(signal_label, Some(updated)),
                    )
                  }
                }
                Break(signal_label, value_opt) => {
                  let updated = update_empty(value_opt, Undefined)
                  if label_matches(signal_label, label) {
                    gen_async_iterator_close(iterator, Normal(updated))
                  } else {
                    gen_async_iterator_close(
                      iterator,
                      Break(signal_label, Some(updated)),
                    )
                  }
                }
                Return(value) =>
                  gen_async_iterator_close(iterator, Return(value))
                Throw(value) => gen_async_iterator_close(iterator, Throw(value))
              }
            })
          Return(value) => gen_async_iterator_close(iterator, Return(value))
          Break(label_name, value_opt) =>
            gen_async_iterator_close(iterator, Break(label_name, value_opt))
          Continue(label_name, value_opt) =>
            gen_async_iterator_close(iterator, Continue(label_name, value_opt))
          Throw(value) => gen_async_iterator_close(iterator, Throw(value))
        }
      },
    )
  })
}

///|
fn gen_eval_for_in_loop(
  env : Env,
  label : String?,
  init : @engine.ForInit,
  target : Value,
  keys : Array[String],
  index : Int,
  body : @engine.Stmt,
) -> GenStep raise {
  if index >= keys.length() {
    return Done(Normal(Undefined))
  }
  if !is_enumerable_key_in_chain(target, keys[index]) {
    return gen_eval_for_in_loop(env, label, init, target, keys, index + 1, body)
  }
  gen_bind(
    gen_assign_for_in_target(env, init, String(keys[index]), fn() {
      Done(Normal(Undefined))
    }),
    fn(control) {
      match control {
        Normal(_) =>
          gen_bind(gen_eval_stmt(env, body), fn(control) {
            match control {
              Normal(_) =>
                gen_eval_for_in_loop(
                  env,
                  label,
                  init,
                  target,
                  keys,
                  index + 1,
                  body,
                )
              Continue(signal_label, value_opt) => {
                let updated = update_empty(value_opt, Undefined)
                if label_matches(signal_label, label) {
                  gen_eval_for_in_loop(
                    env,
                    label,
                    init,
                    target,
                    keys,
                    index + 1,
                    body,
                  )
                } else {
                  Done(Continue(signal_label, Some(updated)))
                }
              }
              Break(signal_label, value_opt) => {
                let updated = update_empty(value_opt, Undefined)
                if label_matches(signal_label, label) {
                  Done(Normal(updated))
                } else {
                  Done(Break(signal_label, Some(updated)))
                }
              }
              Return(value) => Done(Return(value))
              Throw(value) => Done(Throw(value))
            }
          })
        Return(value) => Done(Return(value))
        Break(label_name, value_opt) => Done(Break(label_name, value_opt))
        Continue(label_name, value_opt) => Done(Continue(label_name, value_opt))
        Throw(value) => Done(Throw(value))
      }
    },
  )
}

///|
fn gen_eval_for_update(
  loop_env : Env,
  iter_env : Env,
  label : String?,
  test_expr : @engine.Expr?,
  update_expr : @engine.Expr?,
  body : @engine.Stmt,
  use_loop_env : Bool,
  loop_names : Array[String],
  loop_is_const : Bool,
) -> GenStep raise {
  let update_step = match update_expr {
    Some(expr) =>
      gen_eval_expr_cont(iter_env, expr, fn(_) { Done(Normal(Undefined)) })
    None => Done(Normal(Undefined))
  }
  gen_bind(update_step, fn(control) raise {
    match control {
      Normal(_) =>
        gen_eval_for_loop(
          loop_env, label, test_expr, update_expr, body, use_loop_env, loop_names,
          loop_is_const, iter_env,
        )
      _ => Done(control)
    }
  })
}

///|
fn gen_eval_do_while(
  env : Env,
  label : String?,
  body : @engine.Stmt,
  cond_expr : @engine.Expr,
) -> GenStep raise {
  gen_bind(gen_eval_stmt(env, body), fn(control) raise {
    match control {
      Normal(_) =>
        gen_eval_expr_cont(env, cond_expr, fn(cond) raise {
          if is_truthy(cond) {
            gen_eval_do_while(env, label, body, cond_expr)
          } else {
            Done(Normal(Undefined))
          }
        })
      Continue(signal_label, value_opt) => {
        let updated = update_empty(value_opt, Undefined)
        if label_matches(signal_label, label) {
          gen_eval_expr_cont(env, cond_expr, fn(cond) raise {
            if is_truthy(cond) {
              gen_eval_do_while(env, label, body, cond_expr)
            } else {
              Done(Normal(Undefined))
            }
          })
        } else {
          Done(Continue(signal_label, Some(updated)))
        }
      }
      Break(signal_label, value_opt) => {
        let updated = update_empty(value_opt, Undefined)
        if label_matches(signal_label, label) {
          Done(Normal(updated))
        } else {
          Done(Break(signal_label, Some(updated)))
        }
      }
      Return(value) => Done(Return(value))
      Throw(value) => Done(Throw(value))
    }
  })
}

///|
fn gen_eval_try(
  env : Env,
  try_body : @engine.Stmt,
  catch_clause : @engine.CatchClause?,
  finally_body : @engine.Stmt?,
) -> GenStep raise {
  gen_bind(gen_eval_stmt(env, try_body), fn(control) raise {
    let handled = match control {
      Throw(err_value) =>
        match catch_clause {
          Some(clause) => gen_eval_catch(env, clause, err_value)
          None => Done(Throw(err_value))
        }
      _ => Done(control)
    }
    gen_bind(handled, fn(pending) raise {
      match finally_body {
        Some(final_body) =>
          gen_apply_finally(pending, gen_eval_stmt(env, final_body))
        None => Done(pending)
      }
    })
  })
}

///|
fn gen_eval_catch(
  env : Env,
  clause : @engine.CatchClause,
  err_value : Value,
) -> GenStep raise {
  let catch_env = Env::new(Some(env))
  catch_env.is_catch_env = true
  match clause.name {
    Some(name) => env_set_local(catch_env, name, err_value)
    None => ()
  }
  gen_eval_stmt(catch_env, clause.body)
}

///|
fn gen_apply_finally(
  pending : GenControl,
  final_step : GenStep,
) -> GenStep raise {
  gen_bind(final_step, fn(final_control) {
    match final_control {
      Normal(_) => Done(pending)
      Return(value) => Done(Return(value))
      Throw(value) => Done(Throw(value))
      Break(label, value_opt) => Done(Break(label, value_opt))
      Continue(label, value_opt) => Done(Continue(label, value_opt))
    }
  })
}

///|
fn gen_eval_expr_cont(
  env : Env,
  expr : @engine.Expr,
  k : (Value) -> GenStep raise,
) -> GenStep raise {
  if !expr_contains_yield(expr) {
    return try {
      let value = eval_expr(env, expr)
      k(value)
    } catch {
      ThrowSignal(value) => Done(Throw(value))
      err => raise err
    }
  }
  match expr {
    Yield(expr_opt, delegate) =>
      if delegate {
        match expr_opt {
          Some(inner) => gen_eval_yield_star(env, inner, k)
          None => {
            let _ = throw_syntax_error("missing yield* operand")
            Done(Throw(Undefined))
          }
        }
      } else {
        let is_async_gen = current_function_is_async_generator()
        let yield_with_value = fn(value : Value) {
          Yield(value, fn(resume_state) {
            match resume_state {
              GenResume::Next(arg) => k(arg)
              GenResume::Return(arg) =>
                if is_async_gen {
                  gen_async_return(arg)
                } else {
                  Done(Return(arg))
                }
              GenResume::Throw(arg) => Done(Throw(arg))
            }
          })
        }
        match expr_opt {
          Some(inner) =>
            gen_eval_expr_cont(env, inner, fn(value) {
              if is_async_gen {
                Await(value, fn(resume_state) {
                  match resume_state {
                    GenResume::Next(arg) => yield_with_value(arg)
                    GenResume::Return(arg) => gen_async_return(arg)
                    GenResume::Throw(arg) => Done(Throw(arg))
                  }
                })
              } else {
                yield_with_value(value)
              }
            })
          None =>
            if is_async_gen {
              Await(Undefined, fn(resume_state) {
                match resume_state {
                  GenResume::Next(arg) => yield_with_value(arg)
                  GenResume::Return(arg) => gen_async_return(arg)
                  GenResume::Throw(arg) => Done(Throw(arg))
                }
              })
            } else {
              yield_with_value(Undefined)
            }
        }
      }
    Binary(op, left, right, _) =>
      gen_with_root_frame(fn() raise {
        gen_eval_expr_cont(env, left, fn(l) raise {
          let _ = gen_root_push(l)
          match op {
            @engine.BinaryOp::LogicalAnd =>
              if is_truthy(l) {
                gen_eval_expr_cont(env, right, fn(r) raise { k(r) })
              } else {
                k(l)
              }
            @engine.BinaryOp::LogicalOr =>
              if is_truthy(l) {
                k(l)
              } else {
                gen_eval_expr_cont(env, right, fn(r) raise { k(r) })
              }
            @engine.BinaryOp::Coalesce =>
              if is_nullish(l) {
                gen_eval_expr_cont(env, right, fn(r) raise { k(r) })
              } else {
                k(l)
              }
            _ =>
              gen_eval_expr_cont(env, right, fn(r) raise {
                k(eval_binary(op, l, r))
              })
          }
        })
      })
    PrivateIn(name, right, _) =>
      gen_eval_expr_cont(env, right, fn(target) raise {
        k(Bool(eval_private_in(env, name, target)))
      })
    Conditional(test_expr, conseq, alt) =>
      gen_eval_expr_cont(env, test_expr, fn(test_value) raise {
        if is_truthy(test_value) {
          gen_eval_expr_cont(env, conseq, k)
        } else {
          gen_eval_expr_cont(env, alt, k)
        }
      })
    Sequence(exprs) => gen_eval_sequence(env, exprs, 0, k)
    Assign(name, rhs, _, is_cover) =>
      gen_with_root_frame(fn() raise {
        let assigner = prepare_identifier_assignment_target(
          env,
          name,
          env.strict,
        )
        gen_eval_expr_cont(env, rhs, fn(value) raise {
          let _ = gen_root_push(value)
          if !is_cover && is_anonymous_function_definition(rhs) {
            set_anonymous_function_name(value, name, None)
          }
          gen_bind(gen_apply_assign_target(assigner, value), fn(control) raise {
            match control {
              Normal(_) => k(value)
              Return(v) => Done(Return(v))
              Throw(v) => Done(Throw(v))
              Break(label, v) => Done(Break(label, v))
              Continue(label, v) => Done(Continue(label, v))
            }
          })
        })
      })
    AssignInvalid(lhs, _, _) =>
      gen_eval_expr_cont(env, lhs, fn(_) raise {
        let _ = throw_reference_error("invalid assignment target")
        Done(Throw(Undefined))
      })
    AssignArray(pattern, rhs) =>
      gen_with_root_frame(fn() raise {
        gen_eval_expr_cont(env, rhs, fn(value) raise {
          let _ = gen_root_push(value)
          gen_destructure_array_pattern(
            env,
            pattern,
            value,
            fn(name, v) raise { env_set(env, name, v) },
            fn() raise { k(value) },
          )
        })
      })
    AssignObject(pattern, rhs) =>
      gen_with_root_frame(fn() raise {
        gen_eval_expr_cont(env, rhs, fn(value) raise {
          let _ = gen_root_push(value)
          let obj = to_object(value)
          let _ = gen_root_push(obj)
          gen_destructure_object_pattern(
            env,
            pattern,
            obj,
            [],
            0,
            fn(name, v) raise { env_set(env, name, v) },
            fn() raise { k(value) },
          )
        })
      })
    AssignOp(op, lhs, rhs, _) => gen_eval_assign_op(env, op, lhs, rhs, k)
    AssignMember(obj_expr, key, rhs, _) =>
      gen_with_root_frame(fn() raise {
        gen_prepare_member_assignment_target(env, obj_expr, key, fn(
          assigner,
        ) raise {
          gen_eval_expr_cont(env, rhs, fn(value) raise {
            let _ = gen_root_push(value)
            gen_bind(gen_apply_assign_target(assigner, value), fn(
              control,
            ) raise {
              match control {
                Normal(_) => k(value)
                Return(v) => Done(Return(v))
                Throw(v) => Done(Throw(v))
                Break(label, v) => Done(Break(label, v))
                Continue(label, v) => Done(Continue(label, v))
              }
            })
          })
        })
      })
    Await(inner, _) =>
      gen_eval_expr_cont(env, inner, fn(value) raise {
        match current_function() {
          Some(func) =>
            if func.is_async {
              Await(value, fn(resume_state) raise {
                match resume_state {
                  GenResume::Next(arg) => k(arg)
                  GenResume::Return(arg) => Done(Return(arg))
                  GenResume::Throw(arg) => Done(Throw(arg))
                }
              })
            } else {
              k(value)
            }
          None => k(value)
        }
      })
    Unary(op, inner, _) =>
      gen_eval_expr_cont(env, inner, fn(value) raise {
        k(eval_unary(op, value))
      })
    Call(callee, args, _) => gen_eval_call(env, callee, args, k)
    Member(obj_expr, key, _) =>
      gen_with_root_frame(fn() raise {
        gen_eval_expr_cont(env, obj_expr, fn(obj_value) raise {
          let _ = gen_root_push(obj_value)
          match key {
            @engine.MemberKey::Private(name) => {
              let key_name = env_private_key_checked(env, name)
              k(private_property_get(obj_value, key_name, name))
            }
            _ => {
              let target = to_object(obj_value)
              gen_eval_member_key(env, key, fn(name) raise {
                k(property_get_with_receiver(target, name, obj_value))
              })
            }
          }
        })
      })
    OptionalChain(base, segments) =>
      gen_eval_optional_chain(env, base, segments, k)
    New(callee, args) =>
      gen_with_root_frame(fn() raise {
        gen_eval_expr_cont(env, callee, fn(callee_value) raise {
          let _ = gen_root_push(callee_value)
          gen_eval_args(env, args, 0, [], fn(argv) raise {
            k(call_constructor(callee_value, argv))
          })
        })
      })
    TemplateLiteral(parts, exprs) =>
      gen_eval_template_literal(env, parts, exprs, k)
    TaggedTemplate(callee, parts, exprs) =>
      gen_eval_tagged_template(env, callee, parts, exprs, k)
    ClassExpr(class_def) =>
      gen_bind(gen_eval_class(env, class_def), fn(control) raise {
        match control {
          Normal(value) => k(value)
          Return(value) => Done(Return(value))
          Throw(value) => Done(Throw(value))
          Break(label, value_opt) => Done(Break(label, value_opt))
          Continue(label, value_opt) => Done(Continue(label, value_opt))
        }
      })
    ArrayLiteral(elems) =>
      gen_with_root_frame(fn() raise {
        gen_eval_array_literal(env, elems, 0, [], k)
      })
    ObjectLiteral(props) =>
      gen_with_root_frame(fn() raise {
        let obj = new_object_value()
        match obj {
          Object(value) => {
            let _ = gen_root_push(obj)
            gen_eval_object_literal(env, props, 0, value, k)
          }
          _ => k(obj)
        }
      })
    Paren(inner) => gen_eval_expr_cont(env, inner, k)
    Spread(inner) => gen_eval_expr_cont(env, inner, k)
    _ => {
      let _ = throw_type_error("unsupported generator expression")
      Done(Throw(Undefined))
    }
  }
}

///|
fn gen_eval_named_expr_cont(
  env : Env,
  expr : @engine.Expr,
  name : String,
  key_value : Value?,
  k : (Value) -> GenStep raise,
) -> GenStep raise {
  let hint_name = function_name_from_key(name, key_value, None)
  match unwrap_paren(expr) {
    @engine.Expr::ClassExpr(class_def) =>
      if class_def.name is None {
        if expr_contains_yield(expr) {
          return gen_bind(
            gen_eval_class(env, class_def, name_hint=Some(hint_name)),
            fn(control) raise {
              match control {
                Normal(value) => k(value)
                Return(value) => Done(Return(value))
                Throw(value) => Done(Throw(value))
                Break(label, value_opt) => Done(Break(label, value_opt))
                Continue(label, value_opt) => Done(Continue(label, value_opt))
              }
            },
          )
        }
        let value = eval_class(env, class_def, name_hint=Some(hint_name))
        return k(value)
      }
    _ => ()
  }
  gen_eval_expr_cont(env, expr, fn(value) raise {
    if is_anonymous_function_definition(expr) {
      set_anonymous_function_name(value, name, key_value)
    }
    k(value)
  })
}

///|
fn gen_eval_array_literal(
  env : Env,
  elems : Array[@engine.Expr?],
  index : Int,
  values : Array[Value?],
  k : (Value) -> GenStep raise,
) -> GenStep raise {
  if index >= elems.length() {
    let array_proto_value = match value_from_object(array_proto_for_env(env)) {
      Some(value) => Some(value)
      None => value_from_object(array_proto())
    }
    return k(new_array_value_with_proto(values, proto=array_proto_value))
  }
  match elems[index] {
    Some(@engine.Expr::Spread(inner)) =>
      gen_eval_expr_cont(env, inner, fn(value) raise {
        let _ = gen_root_push(value)
        let list = build_spread_list(value)
        for item in list {
          values.push(Some(item))
          let _ = gen_root_push(item)

        }
        gen_eval_array_literal(env, elems, index + 1, values, k)
      })
    Some(expr) =>
      gen_eval_expr_cont(env, expr, fn(value) raise {
        values.push(Some(value))
        let _ = gen_root_push(value)
        gen_eval_array_literal(env, elems, index + 1, values, k)
      })
    None => {
      values.push(None)
      gen_eval_array_literal(env, elems, index + 1, values, k)
    }
  }
}

///|
fn gen_eval_template_literal(
  env : Env,
  parts : @engine.TemplateParts,
  exprs : Array[@engine.Expr],
  k : (Value) -> GenStep raise,
) -> GenStep raise {
  gen_with_root_frame(fn() raise {
    let cooked = parts.cooked
    let mut acc = ""
    if !cooked.is_empty() {
      match cooked[0] {
        Some(text) => acc = text
        None => {
          let _ = throw_syntax_error(
            "invalid escape sequence in template literal",
          )

        }
      }
    }
    gen_eval_template_parts(env, cooked, exprs, 0, acc, k)
  })
}

///|
fn gen_eval_template_parts(
  env : Env,
  parts : Array[String?],
  exprs : Array[@engine.Expr],
  index : Int,
  acc : String,
  k : (Value) -> GenStep raise,
) -> GenStep raise {
  if index >= exprs.length() {
    return k(String(acc))
  }
  gen_eval_expr_cont(env, exprs[index], fn(value) raise {
    let _ = gen_root_push(value)
    let mut next = acc + to_string_strict(value)
    if index + 1 < parts.length() {
      match parts[index + 1] {
        Some(text) => next = next + text
        None => {
          let _ = throw_syntax_error(
            "invalid escape sequence in template literal",
          )

        }
      }
    }
    gen_eval_template_parts(env, parts, exprs, index + 1, next, k)
  })
}

///|
fn gen_eval_template_values(
  env : Env,
  exprs : Array[@engine.Expr],
  index : Int,
  values : Array[Value],
  k : (Array[Value]) -> GenStep raise,
) -> GenStep raise {
  if index >= exprs.length() {
    return k(values)
  }
  gen_eval_expr_cont(env, exprs[index], fn(value) raise {
    values.push(value)
    let _ = gen_root_push(value)
    gen_eval_template_values(env, exprs, index + 1, values, k)
  })
}

///|
fn gen_eval_tagged_template(
  env : Env,
  callee : @engine.Expr,
  parts : @engine.TemplateParts,
  exprs : Array[@engine.Expr],
  k : (Value) -> GenStep raise,
) -> GenStep raise {
  gen_with_root_frame(fn() raise {
    match callee {
      @engine.Expr::Member(obj_expr, key, _) =>
        gen_eval_expr_cont(env, obj_expr, fn(target_value) raise {
          let _ = gen_root_push(target_value)
          let callee_value = match key {
            @engine.MemberKey::Private(name) => {
              let key_name = env_private_key_checked(env, name)
              private_property_get(target_value, key_name, name)
            }
            _ => {
              let name = member_key_name(env, key)
              let target_obj = to_object(target_value)
              property_get_with_receiver(target_obj, name, target_value)
            }
          }
          let _ = gen_root_push(callee_value)
          let template_obj = build_template_object(env, parts)
          let _ = gen_root_push(template_obj)
          gen_eval_template_values(env, exprs, 0, [], fn(values) raise {
            let argv : Array[Value] = [template_obj]
            for value in values {
              argv.push(value)
            }
            k(call_value_with_this(callee_value, argv, target_value))
          })
        })
      _ =>
        gen_eval_expr_cont(env, callee, fn(callee_value) raise {
          let _ = gen_root_push(callee_value)
          let template_obj = build_template_object(env, parts)
          let _ = gen_root_push(template_obj)
          gen_eval_template_values(env, exprs, 0, [], fn(values) raise {
            let argv : Array[Value] = [template_obj]
            for value in values {
              argv.push(value)
            }
            k(call_value(callee_value, argv))
          })
        })
    }
  })
}

///|
fn gen_eval_sequence(
  env : Env,
  exprs : Array[@engine.Expr],
  index : Int,
  k : (Value) -> GenStep raise,
) -> GenStep raise {
  if exprs.is_empty() {
    return k(Undefined)
  }
  if index >= exprs.length() - 1 {
    return gen_eval_expr_cont(env, exprs[index], k)
  }
  gen_eval_expr_cont(env, exprs[index], fn(_) raise {
    gen_eval_sequence(env, exprs, index + 1, k)
  })
}

///|
fn gen_assign_binding_value(
  env : Env,
  binding : @engine.VarBinding,
  value : Value,
  assign : (String, Value) -> Unit raise,
  k : () -> GenStep raise,
) -> GenStep raise {
  match binding {
    @engine.VarBinding::Name(name) => {
      assign(name, value)
      k()
    }
    @engine.VarBinding::ArrayPattern(pattern) =>
      gen_destructure_array_pattern(env, pattern, value, assign, k)
    @engine.VarBinding::ObjectPattern(pattern) => {
      let obj = to_object(value)
      gen_destructure_object_pattern(env, pattern, obj, [], 0, assign, k)
    }
    @engine.VarBinding::Target(expr) =>
      gen_assign_for_in_expr(env, expr, value, k)
  }
}

///|
fn gen_prepare_assignment_target(
  env : Env,
  expr : @engine.Expr,
  k : ((Value) -> Unit raise) -> GenStep raise,
) -> GenStep raise {
  match expr {
    @engine.Expr::Ident(name, _) =>
      k(prepare_identifier_assignment_target(env, name, env.strict))
    @engine.Expr::Member(obj_expr, key, _) =>
      gen_prepare_member_assignment_target(env, obj_expr, key, k)
    @engine.Expr::Paren(inner) => gen_prepare_assignment_target(env, inner, k)
    _ => {
      let _ = throw_type_error("invalid assignment target")
      Done(Throw(Undefined))
    }
  }
}

///|
fn gen_prepare_member_assignment_target(
  env : Env,
  obj_expr : @engine.Expr,
  key : @engine.MemberKey,
  k : ((Value) -> Unit raise) -> GenStep raise,
) -> GenStep raise {
  match obj_expr {
    @engine.Expr::Super =>
      match key {
        @engine.MemberKey::Private(_) => {
          let _ = throw_syntax_error(
            "private class field forbidden after super",
          )
          Done(Throw(Undefined))
        }
        @engine.MemberKey::Computed(expr) => {
          let receiver = env_get(env, "this")
          let base = resolve_super_base()
          let _ = gen_root_push(receiver)
          let _ = gen_root_push(base)
          gen_eval_expr_cont(env, expr, fn(key_value) raise {
            let _ = gen_root_push(key_value)
            k(fn(value) raise {
              let name = property_key_name(key_value)
              super_set_property(env, base, receiver, name, value)
            })
          })
        }
        _ => {
          let receiver = env_get(env, "this")
          let base = resolve_super_base()
          let _ = gen_root_push(receiver)
          let _ = gen_root_push(base)
          gen_eval_member_key(env, key, fn(name) raise {
            k(fn(value) raise {
              super_set_property(env, base, receiver, name, value)
            })
          })
        }
      }
    _ =>
      match key {
        @engine.MemberKey::Private(name) =>
          gen_eval_expr_cont(env, obj_expr, fn(target) raise {
            let key_name = env_private_key_checked(env, name)
            let _ = gen_root_push(target)
            k(fn(value) raise {
              private_property_set(target, key_name, name, value)
            })
          })
        @engine.MemberKey::Computed(expr) =>
          gen_eval_expr_cont(env, obj_expr, fn(target) raise {
            let _ = gen_root_push(target)
            gen_eval_expr_cont(env, expr, fn(key_value) raise {
              let _ = gen_root_push(key_value)
              k(fn(value) raise {
                let name = property_key_name(key_value)
                let _ = set_property_for_value(target, name, value, env.strict)

              })
            })
          })
        _ =>
          gen_eval_expr_cont(env, obj_expr, fn(target) raise {
            let _ = gen_root_push(target)
            gen_eval_member_key(env, key, fn(name) raise {
              k(fn(value) raise {
                let _ = set_property_for_value(target, name, value, env.strict)

              })
            })
          })
      }
  }
}

///|
fn gen_apply_assign_target(
  assign_target : (Value) -> Unit raise,
  value : Value,
) -> GenStep raise {
  try {
    assign_target(value)
    Done(Normal(Undefined))
  } catch {
    ThrowSignal(err) => Done(Throw(err))
    err => raise err
  }
}

///|
fn gen_destructure_array_pattern_iter(
  env : Env,
  pattern : Array[@engine.ArrayPatternElem],
  iterator : Value,
  next_method : Value,
  index : Int,
  done : Bool,
  assign : (String, Value) -> Unit raise,
  k : () -> GenStep raise,
) -> GenStep raise {
  if index >= pattern.length() {
    if done {
      return k()
    }
    return gen_bind(gen_iterator_close(iterator, Normal(Undefined)), fn(
      control,
    ) raise {
      match control {
        Normal(_) => k()
        _ => Done(control)
      }
    })
  }
  match pattern[index] {
    @engine.ArrayPatternElem::Hole =>
      if done {
        gen_destructure_array_pattern_iter(
          env,
          pattern,
          iterator,
          next_method,
          index + 1,
          done,
          assign,
          k,
        )
      } else {
        let (next_done, _) = iterator_step_value(iterator, next_method) catch {
          ThrowSignal(value) => return Done(Throw(value))
          err => raise err
        }
        gen_destructure_array_pattern_iter(
          env,
          pattern,
          iterator,
          next_method,
          index + 1,
          next_done,
          assign,
          k,
        )
      }
    @engine.ArrayPatternElem::Bind(binding, default) =>
      match binding {
        @engine.VarBinding::Target(expr) => {
          let mut target_assign : ((Value) -> Unit raise)? = None
          let prep_step = gen_prepare_assignment_target(env, expr, fn(
            assigner,
          ) {
            target_assign = Some(assigner)
            Done(Normal(Undefined))
          })
          gen_bind(prep_step, fn(control) {
            match control {
              Normal(_) => {
                let assigner = match target_assign {
                  Some(value) => value
                  None => fn(_) { () }
                }
                let mut element = Undefined
                let next_done = if done {
                  true
                } else {
                  let (is_done, item) = iterator_step_value(
                    iterator, next_method,
                  ) catch {
                    ThrowSignal(value) => return Done(Throw(value))
                    err => raise err
                  }
                  if !is_done {
                    element = item
                  }
                  is_done
                }
                let assign_step = match default {
                  Some(expr) =>
                    if element is Undefined {
                      gen_eval_expr_cont(env, expr, fn(def_value) {
                        gen_apply_assign_target(assigner, def_value)
                      })
                    } else {
                      gen_apply_assign_target(assigner, element)
                    }
                  None => gen_apply_assign_target(assigner, element)
                }
                gen_bind(assign_step, fn(control) {
                  match control {
                    Normal(_) =>
                      gen_destructure_array_pattern_iter(
                        env,
                        pattern,
                        iterator,
                        next_method,
                        index + 1,
                        next_done,
                        assign,
                        k,
                      )
                    _ =>
                      if next_done {
                        Done(control)
                      } else {
                        gen_iterator_close(iterator, control)
                      }
                  }
                })
              }
              _ =>
                if done {
                  Done(control)
                } else {
                  gen_iterator_close(iterator, control)
                }
            }
          })
        }
        _ => {
          let mut element = Undefined
          let next_done = if done {
            true
          } else {
            let (is_done, item) = iterator_step_value(iterator, next_method) catch {
              ThrowSignal(value) => return Done(Throw(value))
              err => raise err
            }
            if !is_done {
              element = item
            }
            is_done
          }
          let assign_step = match default {
            Some(expr) =>
              if element is Undefined {
                match binding {
                  @engine.VarBinding::Name(name) =>
                    gen_eval_named_expr_cont(env, expr, name, None, fn(
                      def_value,
                    ) {
                      gen_assign_binding_value(
                        env,
                        binding,
                        def_value,
                        assign,
                        fn() { Done(Normal(Undefined)) },
                      )
                    })
                  _ =>
                    gen_eval_expr_cont(env, expr, fn(def_value) {
                      gen_assign_binding_value(
                        env,
                        binding,
                        def_value,
                        assign,
                        fn() { Done(Normal(Undefined)) },
                      )
                    })
                }
              } else {
                gen_assign_binding_value(env, binding, element, assign, fn() {
                  Done(Normal(Undefined))
                })
              }
            None =>
              gen_assign_binding_value(env, binding, element, assign, fn() {
                Done(Normal(Undefined))
              })
          }
          gen_bind(assign_step, fn(control) {
            match control {
              Normal(_) =>
                gen_destructure_array_pattern_iter(
                  env,
                  pattern,
                  iterator,
                  next_method,
                  index + 1,
                  next_done,
                  assign,
                  k,
                )
              _ =>
                if next_done {
                  Done(control)
                } else {
                  gen_iterator_close(iterator, control)
                }
            }
          })
        }
      }
    @engine.ArrayPatternElem::Rest(binding) =>
      match binding {
        @engine.VarBinding::Target(expr) => {
          let mut target_assign : ((Value) -> Unit raise)? = None
          let prep_step = gen_prepare_assignment_target(env, expr, fn(
            assigner,
          ) {
            target_assign = Some(assigner)
            Done(Normal(Undefined))
          })
          gen_bind(prep_step, fn(control) {
            match control {
              Normal(_) => {
                let assigner = match target_assign {
                  Some(value) => value
                  None => fn(_) { () }
                }
                let rest_values : Array[Value?] = []
                if !done {
                  for {
                    let (is_done, item) = iterator_step_value(
                      iterator, next_method,
                    ) catch {
                      ThrowSignal(value) => return Done(Throw(value))
                      err => raise err
                    }
                    if is_done {
                      break
                    }
                    rest_values.push(Some(item))
                  }
                }
                let rest_value = new_array_value(rest_values)
                gen_bind(gen_apply_assign_target(assigner, rest_value), fn(
                  control,
                ) {
                  match control {
                    Normal(_) => k()
                    _ => Done(control)
                  }
                })
              }
              _ =>
                if done {
                  Done(control)
                } else {
                  gen_iterator_close(iterator, control)
                }
            }
          })
        }
        _ => {
          let rest_values : Array[Value?] = []
          if !done {
            for {
              let (is_done, item) = iterator_step_value(iterator, next_method) catch {
                ThrowSignal(value) => return Done(Throw(value))
                err => raise err
              }
              if is_done {
                break
              }
              rest_values.push(Some(item))
            }
          }
          let rest_value = new_array_value(rest_values)
          gen_bind(
            gen_assign_binding_value(env, binding, rest_value, assign, fn() {
              Done(Normal(Undefined))
            }),
            fn(control) {
              match control {
                Normal(_) => k()
                _ => Done(control)
              }
            },
          )
        }
      }
  }
}

///|
fn gen_destructure_array_pattern(
  env : Env,
  pattern : Array[@engine.ArrayPatternElem],
  value : Value,
  assign : (String, Value) -> Unit raise,
  k : () -> GenStep raise,
) -> GenStep raise {
  gen_with_root_frame(fn() raise {
    let (iterator, next_method) = get_iterator_from_value(value)
    let _ = gen_root_push(iterator)
    let _ = gen_root_push(next_method)
    gen_destructure_array_pattern_iter(
      env, pattern, iterator, next_method, 0, false, assign, k,
    )
  })
}

///|
fn gen_destructure_object_pattern(
  env : Env,
  pattern : Array[@engine.ObjectPatternElem],
  obj : Value,
  bound : Array[String],
  index : Int,
  assign : (String, Value) -> Unit raise,
  k : () -> GenStep raise,
) -> GenStep raise {
  gen_with_root_frame(fn() raise {
    let _ = gen_root_push(obj)
    gen_destructure_object_pattern_inner(
      env, pattern, obj, bound, index, assign, k,
    )
  })
}

///|
fn gen_destructure_object_pattern_inner(
  env : Env,
  pattern : Array[@engine.ObjectPatternElem],
  obj : Value,
  bound : Array[String],
  index : Int,
  assign : (String, Value) -> Unit raise,
  k : () -> GenStep raise,
) -> GenStep raise {
  if index >= pattern.length() {
    return k()
  }
  match pattern[index] {
    @engine.ObjectPatternElem::Bind(key, binding, default) => {
      let handle_key = fn(key_name : String) -> GenStep raise {
        bound.push(key_name)
        match binding {
          @engine.VarBinding::Target(expr) => {
            let mut target_assign : ((Value) -> Unit raise)? = None
            let prep_step = gen_prepare_assignment_target(env, expr, fn(
              assigner,
            ) {
              target_assign = Some(assigner)
              Done(Normal(Undefined))
            })
            gen_bind(prep_step, fn(control) {
              match control {
                Normal(_) => {
                  let assigner = match target_assign {
                    Some(value) => value
                    None => fn(_) { () }
                  }
                  let prop_value = property_get(obj, key_name)
                  let assign_step = match default {
                    Some(expr) =>
                      if prop_value is Undefined {
                        gen_eval_expr_cont(env, expr, fn(def_value) {
                          gen_apply_assign_target(assigner, def_value)
                        })
                      } else {
                        gen_apply_assign_target(assigner, prop_value)
                      }
                    None => gen_apply_assign_target(assigner, prop_value)
                  }
                  gen_bind(assign_step, fn(control) {
                    match control {
                      Normal(_) =>
                        gen_destructure_object_pattern_inner(
                          env,
                          pattern,
                          obj,
                          bound,
                          index + 1,
                          assign,
                          k,
                        )
                      _ => Done(control)
                    }
                  })
                }
                _ => Done(control)
              }
            })
          }
          _ => {
            let prop_value = property_get(obj, key_name)
            match default {
              Some(expr) =>
                if prop_value is Undefined {
                  match binding {
                    @engine.VarBinding::Name(name) =>
                      gen_eval_named_expr_cont(env, expr, name, None, fn(
                        def_value,
                      ) {
                        gen_assign_binding_value(
                          env,
                          binding,
                          def_value,
                          assign,
                          fn() {
                            gen_destructure_object_pattern_inner(
                              env,
                              pattern,
                              obj,
                              bound,
                              index + 1,
                              assign,
                              k,
                            )
                          },
                        )
                      })
                    _ =>
                      gen_eval_expr_cont(env, expr, fn(def_value) {
                        gen_assign_binding_value(
                          env,
                          binding,
                          def_value,
                          assign,
                          fn() {
                            gen_destructure_object_pattern_inner(
                              env,
                              pattern,
                              obj,
                              bound,
                              index + 1,
                              assign,
                              k,
                            )
                          },
                        )
                      })
                  }
                } else {
                  gen_assign_binding_value(env, binding, prop_value, assign, fn() {
                    gen_destructure_object_pattern_inner(
                      env,
                      pattern,
                      obj,
                      bound,
                      index + 1,
                      assign,
                      k,
                    )
                  })
                }
              None =>
                gen_assign_binding_value(env, binding, prop_value, assign, fn() {
                  gen_destructure_object_pattern_inner(
                    env,
                    pattern,
                    obj,
                    bound,
                    index + 1,
                    assign,
                    k,
                  )
                })
            }
          }
        }
      }
      match key {
        @engine.ObjKey::Computed(expr) =>
          gen_eval_expr_cont(env, expr, fn(value) {
            handle_key(property_key_name(value))
          })
        _ => handle_key(obj_key_simple_name(key))
      }
    }
    @engine.ObjectPatternElem::Rest(binding) => {
      let rest_value = new_object_value()
      match rest_value {
        Object(rest_obj) => copy_data_properties_excluding(rest_obj, obj, bound)
        _ => ()
      }
      gen_assign_binding_value(env, binding, rest_value, assign, k)
    }
  }
}

///|
fn gen_eval_assign_op(
  env : Env,
  op : @engine.BinaryOp,
  lhs : @engine.Expr,
  rhs : @engine.Expr,
  k : (Value) -> GenStep raise,
) -> GenStep raise {
  gen_with_root_frame(fn() raise {
    match lhs {
      Ident(name, _) => {
        let assigner = prepare_identifier_assignment_target(
          env,
          name,
          env.strict,
        )
        let current = env_get(env, name)
        let _ = gen_root_push(current)
        match op {
          @engine.BinaryOp::LogicalAnd =>
            if is_truthy(current) {
              gen_eval_expr_cont(env, rhs, fn(value) raise {
                let _ = gen_root_push(value)
                if is_anonymous_function_definition(rhs) {
                  set_anonymous_function_name(value, name, None)
                }
                assigner(value)
                k(value)
              })
            } else {
              k(current)
            }
          @engine.BinaryOp::LogicalOr =>
            if is_truthy(current) {
              k(current)
            } else {
              gen_eval_expr_cont(env, rhs, fn(value) raise {
                let _ = gen_root_push(value)
                if is_anonymous_function_definition(rhs) {
                  set_anonymous_function_name(value, name, None)
                }
                assigner(value)
                k(value)
              })
            }
          @engine.BinaryOp::Coalesce =>
            if is_nullish(current) {
              gen_eval_expr_cont(env, rhs, fn(value) raise {
                let _ = gen_root_push(value)
                if is_anonymous_function_definition(rhs) {
                  set_anonymous_function_name(value, name, None)
                }
                assigner(value)
                k(value)
              })
            } else {
              k(current)
            }
          _ =>
            gen_eval_expr_cont(env, rhs, fn(value) raise {
              let _ = gen_root_push(value)
              let result = eval_binary(op, current, value)
              let _ = gen_root_push(result)
              assigner(result)
              k(result)
            })
        }
      }
      Member(obj_expr, key, _) =>
        match obj_expr {
          @engine.Expr::Super =>
            match key {
              @engine.MemberKey::Private(_) => {
                let _ = throw_syntax_error(
                  "private class field forbidden after super",
                )
                Done(Throw(Undefined))
              }
              @engine.MemberKey::Computed(expr) => {
                let (base, receiver) = super_base_and_receiver(env)
                let _ = gen_root_push(base)
                let _ = gen_root_push(receiver)
                gen_eval_expr_cont(env, expr, fn(key_value) raise {
                  let _ = gen_root_push(key_value)
                  let name = property_key_name(key_value)
                  let base_obj = to_object(base)
                  let _ = gen_root_push(base_obj)
                  let current = property_get_with_receiver(
                    base_obj, name, receiver,
                  )
                  let _ = gen_root_push(current)
                  match op {
                    @engine.BinaryOp::LogicalAnd =>
                      if is_truthy(current) {
                        gen_eval_expr_cont(env, rhs, fn(value) raise {
                          let _ = gen_root_push(value)
                          super_set_property(env, base, receiver, name, value)
                          k(value)
                        })
                      } else {
                        k(current)
                      }
                    @engine.BinaryOp::LogicalOr =>
                      if is_truthy(current) {
                        k(current)
                      } else {
                        gen_eval_expr_cont(env, rhs, fn(value) raise {
                          let _ = gen_root_push(value)
                          super_set_property(env, base, receiver, name, value)
                          k(value)
                        })
                      }
                    @engine.BinaryOp::Coalesce =>
                      if is_nullish(current) {
                        gen_eval_expr_cont(env, rhs, fn(value) raise {
                          let _ = gen_root_push(value)
                          super_set_property(env, base, receiver, name, value)
                          k(value)
                        })
                      } else {
                        k(current)
                      }
                    _ =>
                      gen_eval_expr_cont(env, rhs, fn(value) raise {
                        let _ = gen_root_push(value)
                        let result = eval_binary(op, current, value)
                        let _ = gen_root_push(result)
                        super_set_property(env, base, receiver, name, result)
                        k(result)
                      })
                  }
                })
              }
              _ => {
                let (base, receiver) = super_base_and_receiver(env)
                let name = member_key_name(env, key)
                let base_obj = to_object(base)
                let _ = gen_root_push(base)
                let _ = gen_root_push(receiver)
                let _ = gen_root_push(base_obj)
                let current = property_get_with_receiver(
                  base_obj, name, receiver,
                )
                let _ = gen_root_push(current)
                match op {
                  @engine.BinaryOp::LogicalAnd =>
                    if is_truthy(current) {
                      gen_eval_expr_cont(env, rhs, fn(value) raise {
                        let _ = gen_root_push(value)
                        super_set_property(env, base, receiver, name, value)
                        k(value)
                      })
                    } else {
                      k(current)
                    }
                  @engine.BinaryOp::LogicalOr =>
                    if is_truthy(current) {
                      k(current)
                    } else {
                      gen_eval_expr_cont(env, rhs, fn(value) raise {
                        let _ = gen_root_push(value)
                        super_set_property(env, base, receiver, name, value)
                        k(value)
                      })
                    }
                  @engine.BinaryOp::Coalesce =>
                    if is_nullish(current) {
                      gen_eval_expr_cont(env, rhs, fn(value) raise {
                        let _ = gen_root_push(value)
                        super_set_property(env, base, receiver, name, value)
                        k(value)
                      })
                    } else {
                      k(current)
                    }
                  _ =>
                    gen_eval_expr_cont(env, rhs, fn(value) raise {
                      let _ = gen_root_push(value)
                      let result = eval_binary(op, current, value)
                      let _ = gen_root_push(result)
                      super_set_property(env, base, receiver, name, result)
                      k(result)
                    })
                }
              }
            }
          _ =>
            match key {
              @engine.MemberKey::Private(name) =>
                gen_eval_expr_cont(env, obj_expr, fn(obj_value) raise {
                  let key_name = env_private_key_checked(env, name)
                  let _ = gen_root_push(obj_value)
                  let current = private_property_get(obj_value, key_name, name)
                  let _ = gen_root_push(current)
                  match op {
                    @engine.BinaryOp::LogicalAnd =>
                      if is_truthy(current) {
                        gen_eval_expr_cont(env, rhs, fn(value) raise {
                          let _ = gen_root_push(value)
                          private_property_set(obj_value, key_name, name, value)
                          k(value)
                        })
                      } else {
                        k(current)
                      }
                    @engine.BinaryOp::LogicalOr =>
                      if is_truthy(current) {
                        k(current)
                      } else {
                        gen_eval_expr_cont(env, rhs, fn(value) raise {
                          let _ = gen_root_push(value)
                          private_property_set(obj_value, key_name, name, value)
                          k(value)
                        })
                      }
                    @engine.BinaryOp::Coalesce =>
                      if is_nullish(current) {
                        gen_eval_expr_cont(env, rhs, fn(value) raise {
                          let _ = gen_root_push(value)
                          private_property_set(obj_value, key_name, name, value)
                          k(value)
                        })
                      } else {
                        k(current)
                      }
                    _ =>
                      gen_eval_expr_cont(env, rhs, fn(value) raise {
                        let _ = gen_root_push(value)
                        let result = eval_binary(op, current, value)
                        let _ = gen_root_push(result)
                        private_property_set(obj_value, key_name, name, result)
                        k(result)
                      })
                  }
                })
              _ =>
                gen_eval_expr_cont(env, obj_expr, fn(obj_value) raise {
                  let _ = gen_root_push(obj_value)
                  let target = to_object(obj_value)
                  let _ = gen_root_push(target)
                  gen_eval_member_key(env, key, fn(name) raise {
                    let current = property_get_with_receiver(
                      target, name, obj_value,
                    )
                    let _ = gen_root_push(current)
                    match op {
                      @engine.BinaryOp::LogicalAnd =>
                        if is_truthy(current) {
                          gen_eval_expr_cont(env, rhs, fn(value) raise {
                            let _ = gen_root_push(value)
                            let _ = property_set(
                              target,
                              name,
                              value,
                              env.strict,
                            )
                            k(value)
                          })
                        } else {
                          k(current)
                        }
                      @engine.BinaryOp::LogicalOr =>
                        if is_truthy(current) {
                          k(current)
                        } else {
                          gen_eval_expr_cont(env, rhs, fn(value) raise {
                            let _ = gen_root_push(value)
                            let _ = property_set(
                              target,
                              name,
                              value,
                              env.strict,
                            )
                            k(value)
                          })
                        }
                      @engine.BinaryOp::Coalesce =>
                        if is_nullish(current) {
                          gen_eval_expr_cont(env, rhs, fn(value) raise {
                            let _ = gen_root_push(value)
                            let _ = property_set(
                              target,
                              name,
                              value,
                              env.strict,
                            )
                            k(value)
                          })
                        } else {
                          k(current)
                        }
                      _ =>
                        gen_eval_expr_cont(env, rhs, fn(value) raise {
                          let _ = gen_root_push(value)
                          let result = eval_binary(op, current, value)
                          let _ = gen_root_push(result)
                          let _ = property_set(target, name, result, env.strict)
                          k(result)
                        })
                    }
                  })
                })
            }
        }
      _ =>
        match unwrap_paren(lhs) {
          @engine.Expr::Call(_, _, _) =>
            if !env.strict {
              gen_eval_expr_cont(env, lhs, fn(_) raise {
                let _ = throw_reference_error("invalid assignment target")
                Done(Throw(Undefined))
              })
            } else {
              let _ = throw_type_error("invalid assignment target")
              Done(Throw(Undefined))
            }
          _ => {
            let _ = throw_type_error("invalid assignment target")
            Done(Throw(Undefined))
          }
        }
    }
  })
}

///|
fn gen_eval_call(
  env : Env,
  callee : @engine.Expr,
  args : Array[@engine.Expr],
  k : (Value) -> GenStep raise,
) -> GenStep raise {
  gen_with_root_frame(fn() raise {
    match unwrap_paren(callee) {
      @engine.Expr::Ident(name, offset) => {
        let (callee_value, this_value) = with_expr_pos_call_ref(offset, fn() raise {
          env_get_call_reference(env, name)
        })
        let _ = gen_root_push(callee_value)
        let _ = gen_root_push(this_value)
        gen_eval_args(env, args, 0, [], fn(argv) raise {
          if name == "eval" {
            match callee_value {
              Builtin(builtin) if builtin.kind == BuiltinFunction::Eval =>
                match function_realm_env(callee_value) {
                  Some(realm_env) =>
                    if realm_env_from_env(realm_env).id ==
                      realm_env_from_env(env).id {
                      return k(eval_with_env(env, argv))
                    }
                  None => ()
                }
              _ => ()
            }
          }
          k(call_value_with_this(callee_value, argv, this_value))
        })
      }
      @engine.Expr::Member(obj_expr, key, _) =>
        gen_eval_expr_cont(env, obj_expr, fn(target_value) raise {
          let _ = gen_root_push(target_value)
          match key {
            @engine.MemberKey::Private(name) => {
              let key_name = env_private_key_checked(env, name)
              let callee_value = private_property_get(
                target_value, key_name, name,
              )
              let _ = gen_root_push(callee_value)
              gen_eval_args(env, args, 0, [], fn(argv) raise {
                k(call_value_with_this(callee_value, argv, target_value))
              })
            }
            _ =>
              gen_eval_member_key(env, key, fn(name) raise {
                let target_obj = to_object(target_value)
                let callee_value = property_get_with_receiver(
                  target_obj, name, target_value,
                )
                let _ = gen_root_push(callee_value)
                gen_eval_args(env, args, 0, [], fn(argv) raise {
                  k(call_value_with_this(callee_value, argv, target_value))
                })
              })
          }
        })
      @engine.Expr::OptionalChain(base, segments) =>
        gen_eval_optional_chain_with_this(env, base, segments, fn(
          callee_value,
          this_value,
        ) raise {
          let _ = gen_root_push(callee_value)
          match this_value {
            Some(value) => {
              let _ = gen_root_push(value)

            }
            None => ()
          }
          gen_eval_args(env, args, 0, [], fn(argv) raise {
            let result = match this_value {
              Some(this_obj) =>
                call_value_with_this(callee_value, argv, this_obj)
              None => call_value(callee_value, argv)
            }
            k(result)
          })
        })
      _ =>
        gen_eval_expr_cont(env, callee, fn(callee_value) raise {
          let _ = gen_root_push(callee_value)
          gen_eval_args(env, args, 0, [], fn(argv) raise {
            k(call_value(callee_value, argv))
          })
        })
    }
  })
}

///|
fn gen_eval_args(
  env : Env,
  args : Array[@engine.Expr],
  index : Int,
  values : Array[Value],
  k : (Array[Value]) -> GenStep raise,
) -> GenStep raise {
  if index >= args.length() {
    return k(values)
  }
  let expr = args[index]
  match expr {
    @engine.Expr::Spread(inner) =>
      gen_eval_expr_cont(env, inner, fn(value) raise {
        let _ = gen_root_push(value)
        let list = build_spread_list(value)
        for item in list {
          values.push(item)
          let _ = gen_root_push(item)

        }
        gen_eval_args(env, args, index + 1, values, k)
      })
    _ =>
      gen_eval_expr_cont(env, expr, fn(value) raise {
        values.push(value)
        let _ = gen_root_push(value)
        gen_eval_args(env, args, index + 1, values, k)
      })
  }
}

///|
fn gen_eval_member_key(
  env : Env,
  key : @engine.MemberKey,
  k : (String) -> GenStep raise,
) -> GenStep raise {
  match key {
    @engine.MemberKey::Ident(name) => k(name)
    @engine.MemberKey::Private(name) => k(env_private_key_checked(env, name))
    @engine.MemberKey::Computed(expr) =>
      gen_eval_expr_cont(env, expr, fn(value) raise {
        let _ = gen_root_push(value)
        k(property_key_name(value))
      })
  }
}

///|
fn gen_eval_optional_chain(
  env : Env,
  base : @engine.Expr,
  segments : Array[@engine.ChainSegment],
  k : (Value) -> GenStep raise,
) -> GenStep raise {
  gen_eval_optional_chain_with_this(env, base, segments, fn(value, _) raise {
    k(value)
  })
}

///|
fn gen_eval_optional_chain_with_this(
  env : Env,
  base : @engine.Expr,
  segments : Array[@engine.ChainSegment],
  k : (Value, Value?) -> GenStep raise,
) -> GenStep raise {
  gen_with_root_frame(fn() raise {
    match unwrap_paren(base) {
      @engine.Expr::Member(obj_expr, key, offset) =>
        match obj_expr {
          Super => {
            let value = with_expr_pos(offset, fn() raise {
              eval_super_member(env, key)
            })
            gen_eval_optional_chain_step(
              env,
              segments,
              0,
              value,
              Some(env_get(env, "this")),
              k,
            )
          }
          _ =>
            gen_eval_expr_cont(env, obj_expr, fn(target) raise {
              let _ = gen_root_push(target)
              match key {
                @engine.MemberKey::Ident(name) => {
                  let next = with_expr_pos(offset, fn() raise {
                    let target_obj = to_object(target)
                    property_get_with_receiver(target_obj, name, target)
                  })
                  gen_eval_optional_chain_step(
                    env,
                    segments,
                    0,
                    next,
                    Some(target),
                    k,
                  )
                }
                @engine.MemberKey::Private(name) => {
                  let next = with_expr_pos(offset, fn() raise {
                    let key_name = env_private_key_checked(env, name)
                    private_property_get(target, key_name, name)
                  })
                  gen_eval_optional_chain_step(
                    env,
                    segments,
                    0,
                    next,
                    Some(target),
                    k,
                  )
                }
                @engine.MemberKey::Computed(expr) =>
                  gen_eval_expr_cont(env, expr, fn(value) raise {
                    let _ = gen_root_push(value)
                    let name = property_key_name(value)
                    let next = with_expr_pos(offset, fn() raise {
                      let target_obj = to_object(target)
                      property_get_with_receiver(target_obj, name, target)
                    })
                    gen_eval_optional_chain_step(
                      env,
                      segments,
                      0,
                      next,
                      Some(target),
                      k,
                    )
                  })
              }
            })
        }
      @engine.Expr::OptionalChain(inner_base, inner_segments) =>
        gen_eval_optional_chain_with_this(env, inner_base, inner_segments, fn(
          value,
          this_value,
        ) raise {
          gen_eval_optional_chain_step(env, segments, 0, value, this_value, k)
        })
      _ =>
        gen_eval_expr_cont(env, base, fn(value) raise {
          gen_eval_optional_chain_step(env, segments, 0, value, None, k)
        })
    }
  })
}

///|
fn gen_eval_optional_chain_step(
  env : Env,
  segments : Array[@engine.ChainSegment],
  index : Int,
  current : Value,
  this_value : Value?,
  k : (Value, Value?) -> GenStep raise,
) -> GenStep raise {
  if index >= segments.length() {
    return k(current, this_value)
  }
  let _ = gen_root_push(current)
  match this_value {
    Some(value) => {
      let _ = gen_root_push(value)

    }
    None => ()
  }
  match segments[index] {
    @engine.ChainSegment::Member(key, optional, offset) => {
      if optional && is_nullish(current) {
        return k(Undefined, None)
      }
      match key {
        @engine.MemberKey::Ident(name) => {
          let next = with_expr_pos(offset, fn() raise {
            let target = to_object(current)
            property_get_with_receiver(target, name, current)
          })
          gen_eval_optional_chain_step(
            env,
            segments,
            index + 1,
            next,
            Some(current),
            k,
          )
        }
        @engine.MemberKey::Private(name) => {
          let next = with_expr_pos(offset, fn() raise {
            let key_name = env_private_key_checked(env, name)
            private_property_get(current, key_name, name)
          })
          gen_eval_optional_chain_step(
            env,
            segments,
            index + 1,
            next,
            Some(current),
            k,
          )
        }
        @engine.MemberKey::Computed(expr) =>
          gen_eval_expr_cont(env, expr, fn(value) raise {
            let _ = gen_root_push(value)
            let name = property_key_name(value)
            let next = with_expr_pos(offset, fn() raise {
              let target = to_object(current)
              property_get_with_receiver(target, name, current)
            })
            gen_eval_optional_chain_step(
              env,
              segments,
              index + 1,
              next,
              Some(current),
              k,
            )
          })
      }
    }
    @engine.ChainSegment::Call(args, optional, offset) => {
      if optional && is_nullish(current) {
        return k(Undefined, None)
      }
      gen_eval_args(env, args, 0, [], fn(argv) raise {
        let result = with_expr_pos(offset, fn() raise {
          match this_value {
            Some(this_obj) => call_value_with_this(current, argv, this_obj)
            None => call_value(current, argv)
          }
        })
        gen_eval_optional_chain_step(env, segments, index + 1, result, None, k)
      })
    }
  }
}

///|
fn gen_eval_yield_star(
  env : Env,
  expr : @engine.Expr,
  k : (Value) -> GenStep raise,
) -> GenStep raise {
  gen_eval_expr_cont(env, expr, fn(value) raise {
    gen_with_root_frame(fn() raise {
      let is_async = match current_function() {
        Some(func) => func.is_async
        None => false
      }
      if is_async {
        let (iterator, next_method) = get_async_iterator_from_value(value)
        let _ = gen_root_push(iterator)
        let _ = gen_root_push(next_method)
        gen_async_yield_star_loop(
          iterator,
          next_method,
          GenResume::Next(Undefined),
          true,
          false,
          k,
        )
      } else {
        let (iterator, next_method) = get_iterator_from_value(value)
        let _ = gen_root_push(iterator)
        let _ = gen_root_push(next_method)
        gen_yield_star_loop(
          iterator,
          next_method,
          GenResume::Next(Undefined),
          false,
          k,
        )
      }
    })
  })
}

///|
fn gen_yield_star_loop(
  iterator : Value,
  next_method : Value,
  resume_state : GenResume,
  returning : Bool,
  k : (Value) -> GenStep raise,
) -> GenStep raise {
  try {
    let mut return_mode = returning
    let result = match resume_state {
      GenResume::Next(arg) => {
        let argv = [arg]
        call_value_with_this(next_method, argv, iterator)
      }
      GenResume::Return(arg) => {
        return_mode = true
        let return_method = property_get(iterator, "return")
        match return_method {
          Undefined | Null => return Done(Return(arg))
          _ =>
            if !is_callable(return_method) {
              let _ = throw_type_error("not a function")
              return Done(Throw(Undefined))
            } else {
              call_value_with_this(return_method, [arg], iterator)
            }
        }
      }
      GenResume::Throw(arg) => {
        let throw_method = property_get(iterator, "throw")
        match throw_method {
          Undefined | Null => {
            let return_method = property_get(iterator, "return")
            match return_method {
              Undefined | Null => ()
              _ => {
                let _ = call_value_with_this(return_method, [], iterator)

              }
            }
            let _ = throw_type_error("iterator does not have a throw method")
            return Done(Throw(Undefined))
          }
          _ =>
            if !is_callable(throw_method) {
              let _ = throw_type_error("not a function")
              return Done(Throw(Undefined))
            } else {
              call_value_with_this(throw_method, [arg], iterator)
            }
        }
      }
    }
    if !is_object_like(result) {
      let _ = throw_type_error("iterator must return an object")
      return Done(Throw(Undefined))
    }
    let done = is_truthy(property_get(result, "done"))
    if done {
      let value = property_get(result, "value")
      if return_mode {
        Done(Return(value))
      } else {
        k(value)
      }
    } else {
      set_yield_star_raw(true)
      Yield(result, fn(next_resume) raise {
        gen_yield_star_loop(iterator, next_method, next_resume, return_mode, k)
      })
    }
  } catch {
    ThrowSignal(err) => Done(Throw(err))
    err => raise err
  }
}

///|
fn gen_async_yield_star_loop(
  iterator : Value,
  next_method : Value,
  resume_state : GenResume,
  first : Bool,
  returning : Bool,
  k : (Value) -> GenStep raise,
) -> GenStep raise {
  if !first {
    return gen_unwrap_async_yield_resume(resume_state, fn(unwrapped) raise {
      gen_async_yield_star_loop(
        iterator, next_method, unwrapped, true, returning, k,
      )
    })
  }
  let mut return_mode = returning
  let result = match resume_state {
    GenResume::Next(arg) => {
      let argv = [arg]
      call_value_with_this(next_method, argv, iterator)
    }
    GenResume::Return(arg) => {
      return_mode = true
      let return_method = property_get(iterator, "return")
      match return_method {
        Undefined | Null => return gen_async_return(arg)
        _ =>
          if !is_callable(return_method) {
            let _ = throw_type_error("not a function")
            return Done(Throw(Undefined))
          } else {
            call_value_with_this(return_method, [arg], iterator)
          }
      }
    }
    GenResume::Throw(arg) => {
      let throw_method = property_get(iterator, "throw")
      match throw_method {
        Undefined | Null => {
          async_iterator_close_on_error(iterator)
          let _ = throw_type_error("iterator does not have a throw method")
          return Done(Throw(Undefined))
        }
        _ =>
          if !is_callable(throw_method) {
            let _ = throw_type_error("not a function")
            return Done(Throw(Undefined))
          } else {
            call_value_with_this(throw_method, [arg], iterator)
          }
      }
    }
  }
  Await(result, fn(result_resume) raise {
    match result_resume {
      GenResume::Next(awaited) => {
        if !is_object_like(awaited) {
          let _ = throw_type_error("iterator must return an object")
          return Done(Throw(Undefined))
        }
        let done = is_truthy(property_get(awaited, "done")) catch {
          ThrowSignal(err) => return Done(Throw(err))
          err => raise err
        }
        let value = property_get(awaited, "value") catch {
          ThrowSignal(err) => return Done(Throw(err))
          err => raise err
        }
        if done {
          if return_mode {
            Done(Return(value))
          } else {
            k(value)
          }
        } else {
          Yield(value, fn(next_resume) raise {
            gen_async_yield_star_loop(
              iterator, next_method, next_resume, false, return_mode, k,
            )
          })
        }
      }
      GenResume::Return(arg) => gen_async_return(arg)
      GenResume::Throw(arg) => Done(Throw(arg))
    }
  })
}

///|
fn expr_contains_yield(expr : @engine.Expr) -> Bool {
  match expr {
    Yield(_, _) => true
    Await(_, _) => true
    Unary(_, inner, _) => expr_contains_yield(inner)
    Update(_, inner, _, _) => expr_contains_yield(inner)
    New(callee, args) =>
      expr_contains_yield(callee) || expr_list_contains_yield(args)
    Binary(_, left, right, _) =>
      expr_contains_yield(left) || expr_contains_yield(right)
    PrivateIn(_, right, _) => expr_contains_yield(right)
    Conditional(test_expr, conseq, alt) =>
      expr_contains_yield(test_expr) ||
      expr_contains_yield(conseq) ||
      expr_contains_yield(alt)
    Sequence(exprs) => expr_list_contains_yield(exprs)
    Assign(_, rhs, _, _) => expr_contains_yield(rhs)
    AssignInvalid(lhs, rhs, _) =>
      expr_contains_yield(lhs) || expr_contains_yield(rhs)
    AssignArray(pattern, rhs) =>
      array_pattern_contains_yield(pattern) || expr_contains_yield(rhs)
    AssignObject(pattern, rhs) =>
      object_pattern_contains_yield(pattern) || expr_contains_yield(rhs)
    AssignOp(_, lhs, rhs, _) =>
      expr_contains_yield(lhs) || expr_contains_yield(rhs)
    AssignMember(obj, key, rhs, _) =>
      expr_contains_yield(obj) ||
      member_key_contains_yield(key) ||
      expr_contains_yield(rhs)
    Call(callee, args, _) =>
      expr_contains_yield(callee) || expr_list_contains_yield(args)
    Member(obj, key, _) =>
      expr_contains_yield(obj) || member_key_contains_yield(key)
    OptionalChain(base, segments) =>
      expr_contains_yield(base) || chain_segments_contain_yield(segments)
    TemplateLiteral(_, exprs) => expr_list_contains_yield(exprs)
    TaggedTemplate(callee, _, exprs) =>
      expr_contains_yield(callee) || expr_list_contains_yield(exprs)
    FunctionExpr(_) => false
    ClassExpr(class_def) => class_def_contains_yield(class_def)
    ObjectLiteral(props) => object_props_contain_yield(props)
    ArrayLiteral(elems) => expr_option_list_contains_yield(elems)
    Spread(expr) => expr_contains_yield(expr)
    Paren(expr) => expr_contains_yield(expr)
    _ => false
  }
}

///|
fn class_def_contains_yield(class_def : @engine.ClassDef) -> Bool {
  match class_def.name {
    Some(name) => if name == "yield" { return true }
    None => ()
  }
  match class_def.super_class {
    Some(expr) => if expr_contains_yield(expr) { return true }
    None => ()
  }
  for member_ in class_def.body {
    match member_ {
      @engine.ClassMember::Method(key, _, _)
      | @engine.ClassMember::Getter(key, _, _)
      | @engine.ClassMember::Setter(key, _, _) =>
        if obj_key_contains_yield(key) {
          return true
        }
      @engine.ClassMember::Field(key, init, _) => {
        if obj_key_contains_yield(key) {
          return true
        }
        match init {
          Some(value) => if expr_contains_yield(value) { return true }
          None => ()
        }
      }
      @engine.ClassMember::StaticBlock(stmts) =>
        if stmts_contain_yield(stmts) {
          return true
        }
    }
  }
  false
}

///|
fn chain_segments_contain_yield(segments : Array[@engine.ChainSegment]) -> Bool {
  for segment in segments {
    match segment {
      @engine.ChainSegment::Member(key, _, _) =>
        if member_key_contains_yield(key) {
          return true
        }
      @engine.ChainSegment::Call(args, _, _) =>
        if expr_list_contains_yield(args) {
          return true
        }
    }
  }
  false
}

///|
fn array_pattern_contains_yield(
  pattern : Array[@engine.ArrayPatternElem],
) -> Bool {
  for elem in pattern {
    match elem {
      @engine.ArrayPatternElem::Bind(binding, default) => {
        if var_binding_contains_yield(binding) {
          return true
        }
        match default {
          Some(expr) => if expr_contains_yield(expr) { return true }
          None => ()
        }
      }
      @engine.ArrayPatternElem::Rest(binding) =>
        if var_binding_contains_yield(binding) {
          return true
        }
      @engine.ArrayPatternElem::Hole => ()
    }
  }
  false
}

///|
fn object_pattern_contains_yield(
  pattern : Array[@engine.ObjectPatternElem],
) -> Bool {
  for elem in pattern {
    match elem {
      @engine.ObjectPatternElem::Bind(key, binding, default) => {
        if obj_key_contains_yield(key) {
          return true
        }
        if var_binding_contains_yield(binding) {
          return true
        }
        match default {
          Some(expr) => if expr_contains_yield(expr) { return true }
          None => ()
        }
      }
      @engine.ObjectPatternElem::Rest(binding) =>
        if var_binding_contains_yield(binding) {
          return true
        }
    }
  }
  false
}

///|
fn var_binding_contains_yield(binding : @engine.VarBinding) -> Bool {
  match binding {
    @engine.VarBinding::Name(_) => false
    @engine.VarBinding::ArrayPattern(pattern) =>
      array_pattern_contains_yield(pattern)
    @engine.VarBinding::ObjectPattern(pattern) =>
      object_pattern_contains_yield(pattern)
    @engine.VarBinding::Target(expr) => expr_contains_yield(expr)
  }
}

///|
fn expr_list_contains_yield(exprs : Array[@engine.Expr]) -> Bool {
  for expr in exprs {
    if expr_contains_yield(expr) {
      return true
    }
  }
  false
}

///|
fn expr_option_list_contains_yield(exprs : Array[@engine.Expr?]) -> Bool {
  for expr in exprs {
    match expr {
      Some(value) => if expr_contains_yield(value) { return true }
      None => ()
    }
  }
  false
}

///|
fn member_key_contains_yield(key : @engine.MemberKey) -> Bool {
  match key {
    @engine.MemberKey::Ident(_) => false
    @engine.MemberKey::Private(_) => false
    @engine.MemberKey::Computed(expr) => expr_contains_yield(expr)
  }
}

///|
fn obj_key_contains_yield(key : @engine.ObjKey) -> Bool {
  match key {
    @engine.ObjKey::Computed(expr) => expr_contains_yield(expr)
    _ => false
  }
}

///|
fn object_props_contain_yield(props : Array[@engine.ObjectProp]) -> Bool {
  for prop in props {
    match prop {
      @engine.ObjectProp::KeyValue(key, expr) =>
        if obj_key_contains_yield(key) || expr_contains_yield(expr) {
          return true
        }
      @engine.ObjectProp::Method(key, _) =>
        if obj_key_contains_yield(key) {
          return true
        }
      @engine.ObjectProp::Shorthand(_) => ()
      @engine.ObjectProp::Getter(key, _) =>
        if obj_key_contains_yield(key) {
          return true
        }
      @engine.ObjectProp::Setter(key, _) =>
        if obj_key_contains_yield(key) {
          return true
        }
      @engine.ObjectProp::Spread(expr) =>
        if expr_contains_yield(expr) {
          return true
        }
    }
  }
  false
}

///|
fn stmt_contains_yield(stmt : @engine.Stmt) -> Bool {
  match stmt {
    ExprStmt(expr) => expr_contains_yield(expr)
    VarDecl(_, decls) => {
      for decl in decls {
        let (binding, init) = decl
        if var_binding_contains_yield(binding) {
          return true
        }
        match init {
          Some(expr) => if expr_contains_yield(expr) { return true }
          None => ()
        }
      }
      false
    }
    Block(stmts) => stmts_contain_yield(stmts)
    Label(_, body) => stmt_contains_yield(body)
    FunctionDecl(_) => false
    ClassDecl(class_def) => class_def_contains_yield(class_def)
    If(cond_expr, conseq, alt) =>
      if expr_contains_yield(cond_expr) || stmt_contains_yield(conseq) {
        true
      } else {
        match alt {
          Some(stmt) => stmt_contains_yield(stmt)
          None => false
        }
      }
    With(expr, body) => expr_contains_yield(expr) || stmt_contains_yield(body)
    While(cond_expr, body) =>
      expr_contains_yield(cond_expr) || stmt_contains_yield(body)
    For(init, test_expr, update_expr, body) => {
      let init_has_yield = for_init_contains_yield(init)
      let test_has_yield = match test_expr {
        Some(expr) => expr_contains_yield(expr)
        None => false
      }
      let update_has_yield = match update_expr {
        Some(expr) => expr_contains_yield(expr)
        None => false
      }
      init_has_yield ||
      test_has_yield ||
      update_has_yield ||
      stmt_contains_yield(body)
    }
    ForIn(init, expr, body) =>
      for_init_contains_yield(init) ||
      expr_contains_yield(expr) ||
      stmt_contains_yield(body)
    ForOf(init, expr, body) =>
      for_init_contains_yield(init) ||
      expr_contains_yield(expr) ||
      stmt_contains_yield(body)
    ForAwaitOf(_, _, _) => true
    DoWhile(body, cond_expr) =>
      stmt_contains_yield(body) || expr_contains_yield(cond_expr)
    Switch(discriminant, cases) => {
      if expr_contains_yield(discriminant) {
        return true
      }
      for clause in cases {
        match clause {
          @engine.SwitchCase::Case(expr, body) =>
            if expr_contains_yield(expr) || stmts_contain_yield(body) {
              return true
            }
          @engine.SwitchCase::Default(body) =>
            if stmts_contain_yield(body) {
              return true
            }
        }
      }
      false
    }
    Throw(expr) => expr_contains_yield(expr)
    Try(try_body, catch_clause, finally_body) =>
      if stmt_contains_yield(try_body) {
        true
      } else {
        let catch_has_yield = match catch_clause {
          Some(clause) => stmt_contains_yield(clause.body)
          None => false
        }
        if catch_has_yield {
          true
        } else {
          match finally_body {
            Some(body) => stmt_contains_yield(body)
            None => false
          }
        }
      }
    Return(expr) =>
      match expr {
        Some(inner) => expr_contains_yield(inner)
        None => false
      }
    _ => false
  }
}

///|
fn for_init_contains_yield(init : @engine.ForInit) -> Bool {
  match init {
    @engine.ForInit::None => false
    @engine.ForInit::Var(_, decls) => {
      for decl in decls {
        let (binding, init) = decl
        if var_binding_contains_yield(binding) {
          return true
        }
        match init {
          Some(expr) => if expr_contains_yield(expr) { return true }
          None => ()
        }
      }
      false
    }
    @engine.ForInit::Expr(expr) => expr_contains_yield(expr)
  }
}

///|
fn stmts_contain_yield(stmts : Array[@engine.Stmt]) -> Bool {
  for stmt in stmts {
    if stmt_contains_yield(stmt) {
      return true
    }
  }
  false
}

///|
fn expr_is_direct_eval(expr : @engine.Expr) -> Bool {
  match expr {
    @engine.Expr::Ident(name, _) => name == "eval"
    @engine.Expr::Paren(inner) => expr_is_direct_eval(inner)
    _ => false
  }
}

///|
fn expr_contains_function_like(expr : @engine.Expr) -> Bool {
  match expr {
    @engine.Expr::FunctionExpr(_) => true
    @engine.Expr::ClassExpr(_) => true
    @engine.Expr::Unary(_, inner, _) => expr_contains_function_like(inner)
    @engine.Expr::Update(_, inner, _, _) => expr_contains_function_like(inner)
    @engine.Expr::New(callee, args) =>
      expr_contains_function_like(callee) ||
      expr_list_contains_function_like(args)
    @engine.Expr::Binary(_, left, right, _) =>
      expr_contains_function_like(left) || expr_contains_function_like(right)
    @engine.Expr::PrivateIn(_, right, _) => expr_contains_function_like(right)
    @engine.Expr::Conditional(test_expr, conseq, alt) =>
      expr_contains_function_like(test_expr) ||
      expr_contains_function_like(conseq) ||
      expr_contains_function_like(alt)
    @engine.Expr::Sequence(exprs) => expr_list_contains_function_like(exprs)
    @engine.Expr::Assign(_, rhs, _, _) => expr_contains_function_like(rhs)
    @engine.Expr::AssignInvalid(lhs, rhs, _) =>
      expr_contains_function_like(lhs) || expr_contains_function_like(rhs)
    @engine.Expr::AssignArray(pattern, rhs) =>
      array_pattern_contains_function_like(pattern) ||
      expr_contains_function_like(rhs)
    @engine.Expr::AssignObject(pattern, rhs) =>
      object_pattern_contains_function_like(pattern) ||
      expr_contains_function_like(rhs)
    @engine.Expr::AssignOp(_, lhs, rhs, _) =>
      expr_contains_function_like(lhs) || expr_contains_function_like(rhs)
    @engine.Expr::AssignMember(obj, key, rhs, _) =>
      expr_contains_function_like(obj) ||
      member_key_contains_function_like(key) ||
      expr_contains_function_like(rhs)
    @engine.Expr::Call(callee, args, _) =>
      if expr_is_direct_eval(callee) {
        true
      } else {
        expr_contains_function_like(callee) ||
        expr_list_contains_function_like(args)
      }
    @engine.Expr::Member(obj, key, _) =>
      expr_contains_function_like(obj) || member_key_contains_function_like(key)
    @engine.Expr::OptionalChain(base, segments) =>
      expr_contains_function_like(base) ||
      chain_segments_contain_function_like(segments)
    @engine.Expr::TemplateLiteral(_, exprs) =>
      expr_list_contains_function_like(exprs)
    @engine.Expr::TaggedTemplate(callee, _, exprs) =>
      expr_contains_function_like(callee) ||
      expr_list_contains_function_like(exprs)
    @engine.Expr::ObjectLiteral(props) =>
      object_props_contain_function_like(props)
    @engine.Expr::ArrayLiteral(elems) =>
      expr_option_list_contains_function_like(elems)
    @engine.Expr::Spread(expr) => expr_contains_function_like(expr)
    @engine.Expr::Paren(expr) => expr_contains_function_like(expr)
    _ => false
  }
}

///|
fn expr_list_contains_function_like(exprs : Array[@engine.Expr]) -> Bool {
  for expr in exprs {
    if expr_contains_function_like(expr) {
      return true
    }
  }
  false
}

///|
fn expr_option_list_contains_function_like(
  exprs : Array[@engine.Expr?],
) -> Bool {
  for expr in exprs {
    match expr {
      Some(value) => if expr_contains_function_like(value) { return true }
      None => ()
    }
  }
  false
}

///|
fn member_key_contains_function_like(key : @engine.MemberKey) -> Bool {
  match key {
    @engine.MemberKey::Ident(_) => false
    @engine.MemberKey::Private(_) => false
    @engine.MemberKey::Computed(expr) => expr_contains_function_like(expr)
  }
}

///|
fn obj_key_contains_function_like(key : @engine.ObjKey) -> Bool {
  match key {
    @engine.ObjKey::Computed(expr) => expr_contains_function_like(expr)
    _ => false
  }
}

///|
fn chain_segments_contain_function_like(
  segments : Array[@engine.ChainSegment],
) -> Bool {
  for segment in segments {
    match segment {
      @engine.ChainSegment::Member(key, _, _) =>
        if member_key_contains_function_like(key) {
          return true
        }
      @engine.ChainSegment::Call(args, _, _) =>
        if expr_list_contains_function_like(args) {
          return true
        }
    }
  }
  false
}

///|
fn object_props_contain_function_like(
  props : Array[@engine.ObjectProp],
) -> Bool {
  for prop in props {
    match prop {
      @engine.ObjectProp::KeyValue(key, expr) =>
        if obj_key_contains_function_like(key) ||
          expr_contains_function_like(expr) {
          return true
        }
      @engine.ObjectProp::Method(_, _) => return true
      @engine.ObjectProp::Getter(_, _) => return true
      @engine.ObjectProp::Setter(_, _) => return true
      @engine.ObjectProp::Shorthand(_) => ()
      @engine.ObjectProp::Spread(expr) =>
        if expr_contains_function_like(expr) {
          return true
        }
    }
  }
  false
}

///|
fn array_pattern_contains_function_like(
  pattern : Array[@engine.ArrayPatternElem],
) -> Bool {
  for elem in pattern {
    match elem {
      @engine.ArrayPatternElem::Bind(binding, default) => {
        if var_binding_contains_function_like(binding) {
          return true
        }
        match default {
          Some(expr) => if expr_contains_function_like(expr) { return true }
          None => ()
        }
      }
      @engine.ArrayPatternElem::Rest(binding) =>
        if var_binding_contains_function_like(binding) {
          return true
        }
      @engine.ArrayPatternElem::Hole => ()
    }
  }
  false
}

///|
fn object_pattern_contains_function_like(
  pattern : Array[@engine.ObjectPatternElem],
) -> Bool {
  for elem in pattern {
    match elem {
      @engine.ObjectPatternElem::Bind(key, binding, default) => {
        if obj_key_contains_function_like(key) {
          return true
        }
        if var_binding_contains_function_like(binding) {
          return true
        }
        match default {
          Some(expr) => if expr_contains_function_like(expr) { return true }
          None => ()
        }
      }
      @engine.ObjectPatternElem::Rest(binding) =>
        if var_binding_contains_function_like(binding) {
          return true
        }
    }
  }
  false
}

///|
fn var_binding_contains_function_like(binding : @engine.VarBinding) -> Bool {
  match binding {
    @engine.VarBinding::Name(_) => false
    @engine.VarBinding::ArrayPattern(pattern) =>
      array_pattern_contains_function_like(pattern)
    @engine.VarBinding::ObjectPattern(pattern) =>
      object_pattern_contains_function_like(pattern)
    @engine.VarBinding::Target(expr) => expr_contains_function_like(expr)
  }
}

///|
fn stmt_contains_function_like(stmt : @engine.Stmt) -> Bool {
  match stmt {
    @engine.Stmt::ExprStmt(expr) => expr_contains_function_like(expr)
    @engine.Stmt::VarDecl(_, decls) => {
      for decl in decls {
        let (binding, init) = decl
        if var_binding_contains_function_like(binding) {
          return true
        }
        match init {
          Some(expr) => if expr_contains_function_like(expr) { return true }
          None => ()
        }
      }
      false
    }
    @engine.Stmt::Block(stmts) => stmts_contain_function_like(stmts)
    @engine.Stmt::Label(_, body) => stmt_contains_function_like(body)
    @engine.Stmt::FunctionDecl(_) => true
    @engine.Stmt::ClassDecl(_) => true
    @engine.Stmt::If(cond_expr, conseq, alt) =>
      if expr_contains_function_like(cond_expr) ||
        stmt_contains_function_like(conseq) {
        true
      } else {
        match alt {
          Some(inner) => stmt_contains_function_like(inner)
          None => false
        }
      }
    @engine.Stmt::With(expr, body) =>
      expr_contains_function_like(expr) || stmt_contains_function_like(body)
    @engine.Stmt::While(cond_expr, body) =>
      expr_contains_function_like(cond_expr) ||
      stmt_contains_function_like(body)
    @engine.Stmt::For(init, test_expr, update_expr, body) => {
      let init_has = for_init_contains_function_like(init)
      let test_has = match test_expr {
        Some(expr) => expr_contains_function_like(expr)
        None => false
      }
      let update_has = match update_expr {
        Some(expr) => expr_contains_function_like(expr)
        None => false
      }
      init_has || test_has || update_has || stmt_contains_function_like(body)
    }
    @engine.Stmt::ForIn(init, expr, body) =>
      for_init_contains_function_like(init) ||
      expr_contains_function_like(expr) ||
      stmt_contains_function_like(body)
    @engine.Stmt::ForOf(init, expr, body) =>
      for_init_contains_function_like(init) ||
      expr_contains_function_like(expr) ||
      stmt_contains_function_like(body)
    @engine.Stmt::ForAwaitOf(init, expr, body) =>
      for_init_contains_function_like(init) ||
      expr_contains_function_like(expr) ||
      stmt_contains_function_like(body)
    @engine.Stmt::DoWhile(body, cond_expr) =>
      stmt_contains_function_like(body) ||
      expr_contains_function_like(cond_expr)
    @engine.Stmt::Switch(discriminant, cases) => {
      if expr_contains_function_like(discriminant) {
        return true
      }
      for clause in cases {
        match clause {
          @engine.SwitchCase::Case(expr, body) =>
            if expr_contains_function_like(expr) ||
              stmts_contain_function_like(body) {
              return true
            }
          @engine.SwitchCase::Default(body) =>
            if stmts_contain_function_like(body) {
              return true
            }
        }
      }
      false
    }
    @engine.Stmt::Throw(expr) => expr_contains_function_like(expr)
    @engine.Stmt::Try(try_body, catch_clause, finally_body) =>
      if stmt_contains_function_like(try_body) {
        true
      } else {
        let catch_has = match catch_clause {
          Some(clause) => stmt_contains_function_like(clause.body)
          None => false
        }
        if catch_has {
          true
        } else {
          match finally_body {
            Some(body) => stmt_contains_function_like(body)
            None => false
          }
        }
      }
    @engine.Stmt::Return(expr) =>
      match expr {
        Some(inner) => expr_contains_function_like(inner)
        None => false
      }
    _ => false
  }
}

///|
fn stmts_contain_function_like(stmts : Array[@engine.Stmt]) -> Bool {
  for stmt in stmts {
    if stmt_contains_function_like(stmt) {
      return true
    }
  }
  false
}

///|
fn for_init_contains_function_like(init : @engine.ForInit) -> Bool {
  match init {
    @engine.ForInit::None => false
    @engine.ForInit::Var(_, decls) => {
      for decl in decls {
        let (binding, init) = decl
        if var_binding_contains_function_like(binding) {
          return true
        }
        match init {
          Some(expr) => if expr_contains_function_like(expr) { return true }
          None => ()
        }
      }
      false
    }
    @engine.ForInit::Expr(expr) => expr_contains_function_like(expr)
  }
}

///|
fn for_loop_needs_per_iteration_env(
  init : @engine.ForInit,
  test_expr : @engine.Expr?,
  update_expr : @engine.Expr?,
  body : @engine.Stmt,
) -> Bool {
  if stmt_contains_function_like(body) {
    return true
  }
  if for_init_contains_function_like(init) {
    return true
  }
  match test_expr {
    Some(expr) => if expr_contains_function_like(expr) { return true }
    None => ()
  }
  match update_expr {
    Some(expr) => if expr_contains_function_like(expr) { return true }
    None => ()
  }
  false
}

///|
fn require_generator(this_value : Value?) -> ObjectValue raise {
  match this_value {
    Some(Object(obj)) =>
      match obj.generator_data {
        Some(_) =>
          if obj.async_generator_data is None {
            obj
          } else {
            let _ = throw_type_error("not a generator")
            obj
          }
        None => {
          let _ = throw_type_error("not a generator")
          obj
        }
      }
    _ => {
      let _ = throw_type_error("not a generator")
      new_object_struct(None)
    }
  }
}

///|
fn require_map(this_value : Value?) -> (ObjectValue, MapData) raise {
  match this_value {
    Some(Object(obj)) =>
      match obj.map_data {
        Some(data) => (obj, data)
        None => {
          let _ = throw_type_error("not a map")
          (obj, MapData::{ entries: [] })
        }
      }
    _ => {
      let _ = throw_type_error("not a map")
      (new_object_struct(None), MapData::{ entries: [] })
    }
  }
}

///|
fn require_set(this_value : Value?) -> (ObjectValue, SetData) raise {
  match this_value {
    Some(Object(obj)) =>
      match obj.set_data {
        Some(data) => (obj, data)
        None => {
          let _ = throw_type_error("not a set")
          (obj, SetData::{ entries: [] })
        }
      }
    _ => {
      let _ = throw_type_error("not a set")
      (new_object_struct(None), SetData::{ entries: [] })
    }
  }
}

///|
fn require_weakmap(this_value : Value?) -> (ObjectValue, WeakMapData) raise {
  match this_value {
    Some(Object(obj)) =>
      match obj.weakmap_data {
        Some(data) => (obj, data)
        None => {
          let _ = throw_type_error("not a weakmap")
          (obj, WeakMapData::{ entries: [] })
        }
      }
    _ => {
      let _ = throw_type_error("not a weakmap")
      (new_object_struct(None), WeakMapData::{ entries: [] })
    }
  }
}

///|
fn require_weakset(this_value : Value?) -> (ObjectValue, WeakSetData) raise {
  match this_value {
    Some(Object(obj)) =>
      match obj.weakset_data {
        Some(data) => (obj, data)
        None => {
          let _ = throw_type_error("not a weakset")
          (obj, WeakSetData::{ entries: [] })
        }
      }
    _ => {
      let _ = throw_type_error("not a weakset")
      (new_object_struct(None), WeakSetData::{ entries: [] })
    }
  }
}

///|
fn require_weakref(this_value : Value?) -> WeakRefData raise {
  match this_value {
    Some(Object(obj)) =>
      match obj.weakref_data {
        Some(data) => data
        None => {
          let _ = throw_type_error("not a WeakRef")
          WeakRefData::{ target: Undefined }
        }
      }
    _ => {
      let _ = throw_type_error("not a WeakRef")
      WeakRefData::{ target: Undefined }
    }
  }
}

///|
fn require_finreg(this_value : Value?) -> FinalizationRegistryData raise {
  let fallback_env = match root_env() {
    Some(env) => env
    None => Env::new(None)
  }
  match this_value {
    Some(Object(obj)) =>
      match obj.finreg_data {
        Some(data) => data
        None => {
          let _ = throw_type_error("not a FinalizationRegistry")
          FinalizationRegistryData::{
            callback: Undefined,
            entries: [],
            realm_env: fallback_env,
          }
        }
      }
    _ => {
      let _ = throw_type_error("not a FinalizationRegistry")
      FinalizationRegistryData::{
        callback: Undefined,
        entries: [],
        realm_env: fallback_env,
      }
    }
  }
}

///|
fn require_array_buffer_array(value : Value) -> ArrayValue raise {
  match value {
    Array(arr) => arr
    _ => {
      let _ = throw_type_error("invalid buffer")
      match new_array_value([]) {
        Array(arr) => arr
        _ => fail("invalid array buffer")
      }
    }
  }
}

///|
fn require_array_buffer_data(value : Value) -> ArrayBufferData raise {
  let (_, data) = require_array_buffer(Some(value))
  if data.detached {
    let _ = throw_type_error("ArrayBuffer is detached")
    ArrayBufferData::{
      bytes: [],
      detached: true,
      shared: false,
      max_byte_length: 0,
      resizable: false,
    }
  } else {
    data
  }
}

///|
fn detach_array_buffer(value : Value) -> Unit {
  match value {
    Object(obj) =>
      match obj.array_buffer_data {
        Some(data) =>
          if !data.detached && !data.shared {
            data.detached = true
            data.bytes = []
            obj.array_buffer_data = Some(data)
          }
        None => ()
      }
    _ => ()
  }
}

///|
fn array_buffer_byte_length(value : Value) -> Int raise {
  let data = require_array_buffer_data(value)
  data.bytes.length()
}

///|
fn array_buffer_byte_length_value(this_value : Value?) -> Value raise {
  let (_, data) = require_non_shared_array_buffer(this_value)
  Number(Double::from_int(array_buffer_data_length(data)))
}

///|
fn array_buffer_max_byte_length_value(this_value : Value?) -> Value raise {
  let (_, data) = require_non_shared_array_buffer(this_value)
  let len = array_buffer_data_length(data)
  let max_len = if data.resizable { data.max_byte_length } else { len }
  Number(Double::from_int(max_len))
}

///|
fn array_buffer_resizable_value(this_value : Value?) -> Value raise {
  let (_, data) = require_non_shared_array_buffer(this_value)
  Bool(data.resizable)
}

///|
fn array_buffer_detached_value(this_value : Value?) -> Value raise {
  let (_, data) = require_non_shared_array_buffer(this_value)
  Bool(data.detached)
}

///|
fn shared_array_buffer_byte_length_value(this_value : Value?) -> Value raise {
  let (_, data) = require_shared_array_buffer(this_value)
  Number(Double::from_int(array_buffer_data_length(data)))
}

///|
fn shared_array_buffer_max_byte_length_value(
  this_value : Value?,
) -> Value raise {
  let (_, data) = require_shared_array_buffer(this_value)
  let len = array_buffer_data_length(data)
  let max_len = if data.resizable { data.max_byte_length } else { len }
  Number(Double::from_int(max_len))
}

///|
fn shared_array_buffer_growable_value(this_value : Value?) -> Value raise {
  let (_, data) = require_shared_array_buffer(this_value)
  Bool(data.resizable)
}

///|
fn array_buffer_resize_value(
  obj : ObjectValue,
  data : ArrayBufferData,
  new_len : Int,
) -> Value raise {
  if data.detached {
    return throw_type_error("ArrayBuffer is detached")
  }
  if !data.resizable {
    return throw_type_error("array buffer is not resizable")
  }
  if new_len < 0 || new_len > data.max_byte_length {
    return throw_range_error("invalid array buffer length")
  }
  let current = data.bytes.length()
  if new_len < current {
    data.bytes.truncate(new_len)
  } else if new_len > current {
    while data.bytes.length() < new_len {
      data.bytes.push(Int::to_byte(0))
    }
  }
  obj.array_buffer_data = Some(data)
  Undefined
}

///|
fn shared_array_buffer_grow_value(
  obj : ObjectValue,
  data : ArrayBufferData,
  new_len : Int,
) -> Value raise {
  if data.detached {
    return throw_type_error("ArrayBuffer is detached")
  }
  if !data.resizable {
    return throw_type_error("array buffer is not resizable")
  }
  if new_len < 0 || new_len > data.max_byte_length {
    return throw_range_error("invalid array buffer length")
  }
  let current = data.bytes.length()
  if new_len < current {
    return throw_range_error("invalid array buffer length")
  }
  while data.bytes.length() < new_len {
    data.bytes.push(Int::to_byte(0))
  }
  obj.array_buffer_data = Some(data)
  Undefined
}

///|
fn array_buffer_transfer_value(
  this_value : Value?,
  args : Array[Value],
  to_fixed_length : Bool,
) -> Value raise {
  let (obj, data) = require_non_shared_array_buffer(this_value)
  if data.detached {
    return throw_type_error("ArrayBuffer is detached")
  }
  let new_len64 = if args.is_empty() || args[0] is Undefined {
    Int64::from_int(data.bytes.length())
  } else {
    to_index_int64(args[0])
  }
  let max_int = 2147483647
  if new_len64 > Int64::from_int(max_int) {
    return throw_range_error("invalid array buffer length")
  }
  let new_len = Int64::to_int(new_len64)
  if !to_fixed_length && data.resizable {
    if new_len > data.max_byte_length {
      return throw_type_error("invalid array buffer length")
    }
  }
  let new_max_len = if !to_fixed_length && data.resizable {
    data.max_byte_length
  } else {
    new_len
  }
  let new_resizable = !to_fixed_length && data.resizable
  let new_buffer = new_array_buffer_value_with_options(
    new_len, new_max_len, new_resizable,
  )
  match new_buffer {
    Object(new_obj) =>
      match new_obj.array_buffer_data {
        Some(new_data) => {
          let mut i = 0
          let copy_len = if data.bytes.length() < new_len {
            data.bytes.length()
          } else {
            new_len
          }
          while i < copy_len {
            new_data.bytes[i] = data.bytes[i]
            i = i + 1
          }
          new_obj.array_buffer_data = Some(new_data)
        }
        None => ()
      }
    _ => ()
  }
  data.detached = true
  data.bytes = []
  obj.array_buffer_data = Some(data)
  new_buffer
}

///|
fn array_buffer_slice_value(
  this_value : Value,
  args : Array[Value],
  shared : Bool,
) -> Value raise {
  let (_, data) = if shared {
    require_shared_array_buffer(Some(this_value))
  } else {
    require_non_shared_array_buffer(Some(this_value))
  }
  if data.detached {
    return throw_type_error("ArrayBuffer is detached")
  }
  let len = data.bytes.length()
  let mut start = 0
  if args.length() > 0 {
    start = to_int64_clamp(args[0], 0, len, len)
  }
  let mut end = len
  if args.length() > 1 && !(args[1] is Undefined) {
    end = to_int64_clamp(args[1], 0, len, len)
  }
  let new_len = if end > start { end - start } else { 0 }
  let ctor = property_get(this_value, "constructor")
  let mut species = ctor
  if is_object_like(ctor) {
    match symbol_species_key() {
      Some(key) => {
        let next = property_get(ctor, key)
        species = match next {
          Null => Undefined
          _ => next
        }
      }
      None => ()
    }
  }
  let realm_env = match function_realm_env(ctor) {
    Some(env) => env
    None =>
      match get_proto_of_value_checked(this_value) {
        Some(proto) => realm_env_from_value(Some(proto))
        None =>
          match current_env() {
            Some(env) => env
            None =>
              match root_env() {
                Some(env) => env
                None => Env::new(None)
              }
          }
      }
  }
  let new_obj = if species is Undefined {
    if shared {
      let proto_value = match
        value_from_object(shared_array_buffer_proto_for_env(realm_env)) {
        Some(value) => Some(value)
        None => value_from_object(shared_array_buffer_proto())
      }
      new_shared_array_buffer_value_with_options(
        new_len, new_len, false, proto_value,
      )
    } else {
      let proto_value = match
        value_from_object(array_buffer_proto_for_env(realm_env)) {
        Some(value) => Some(value)
        None => value_from_object(array_buffer_proto())
      }
      new_array_buffer_value_with_options(
        new_len,
        new_len,
        false,
        proto=proto_value,
      )
    }
  } else {
    call_constructor(species, [Number(Double::from_int(new_len))])
  }
  if strict_eq(new_obj, this_value) {
    return throw_type_error("cannot use identical ArrayBuffer")
  }
  let (new_buf_obj, new_data) = if shared {
    require_shared_array_buffer(Some(new_obj))
  } else {
    require_non_shared_array_buffer(Some(new_obj))
  }
  if new_data.detached {
    return throw_type_error("ArrayBuffer is detached")
  }
  if new_data.bytes.length() < new_len {
    return throw_type_error("new ArrayBuffer is too small")
  }
  let (_, updated) = if shared {
    require_shared_array_buffer(Some(this_value))
  } else {
    require_non_shared_array_buffer(Some(this_value))
  }
  if updated.detached || updated.bytes.length() < start + new_len {
    return throw_type_error("ArrayBuffer is detached")
  }
  let mut i = 0
  while i < new_len {
    new_data.bytes[i] = updated.bytes[start + i]
    i = i + 1
  }
  new_buf_obj.array_buffer_data = Some(new_data)
  new_obj
}

///|
fn ensure_array_buffer_range(
  buf_len : Int,
  offset : Int,
  len : Int,
) -> Unit raise {
  let end = offset + len
  if offset < 0 || len < 0 || end < offset || end > buf_len {
    let _ = throw_range_error("read/write array buffer overflow")

  }
}

///|
fn byte_from_value(value : Value) -> Byte {
  match value {
    Number(num) => Int::to_byte(to_int32(num))
    _ => 0
  }
}

///|
fn array_bytes_from_value(
  value : Value,
  offset : Int,
  len : Int,
) -> Array[Byte] raise {
  let buf = require_array_buffer_data(value)
  let buf_len = buf.bytes.length()
  ensure_array_buffer_range(buf_len, offset, len)
  let bytes : Array[Byte] = []
  let mut i = 0
  while i < len {
    bytes.push(buf.bytes[offset + i])
    i = i + 1
  }
  bytes
}

///|
fn write_bytes_to_array(
  value : Value,
  offset : Int,
  bytes : Array[Byte],
) -> Int raise {
  let buf = require_array_buffer_data(value)
  let buf_len = buf.bytes.length()
  ensure_array_buffer_range(buf_len, offset, bytes.length())
  let mut i = 0
  while i < bytes.length() {
    buf.bytes[offset + i] = bytes[i]
    i = i + 1
  }
  bytes.length()
}

///|
fn require_file_fd(this_value : Value?) -> Int raise {
  match this_value {
    Some(Object(obj)) => {
      let fd_value = property_get(Object(obj), "__fd")
      match fd_value {
        Number(num) => to_int32(num)
        _ => {
          let _ = throw_type_error("not a file")
          -1
        }
      }
    }
    _ => {
      let _ = throw_type_error("not a file")
      -1
    }
  }
}

///|
fn new_file_object(fd : Int) -> Value {
  let obj = new_object_value()
  match obj {
    Object(object) => {
      object.props.set(
        "__fd",
        property_data_non_enum(Number(Double::from_int(fd))),
      )
      object.props.set(
        "puts",
        property_data_non_enum(new_builtin_value(BuiltinFunction::FilePuts)),
      )
      object.props.set(
        "putByte",
        property_data_non_enum(new_builtin_value(BuiltinFunction::FilePutByte)),
      )
      object.props.set(
        "seek",
        property_data_non_enum(new_builtin_value(BuiltinFunction::FileSeek)),
      )
      object.props.set(
        "tell",
        property_data_non_enum(new_builtin_value(BuiltinFunction::FileTell)),
      )
      object.props.set(
        "read",
        property_data_non_enum(new_builtin_value(BuiltinFunction::FileRead)),
      )
      object.props.set(
        "readAsString",
        property_data_non_enum(
          new_builtin_value(BuiltinFunction::FileReadAsString),
        ),
      )
      object.props.set(
        "getByte",
        property_data_non_enum(new_builtin_value(BuiltinFunction::FileGetByte)),
      )
      object.props.set(
        "getline",
        property_data_non_enum(new_builtin_value(BuiltinFunction::FileGetline)),
      )
      object.props.set(
        "eof",
        property_data_non_enum(new_builtin_value(BuiltinFunction::FileEof)),
      )
      object.props.set(
        "close",
        property_data_non_enum(new_builtin_value(BuiltinFunction::FileClose)),
      )
    }
    _ => ()
  }
  obj
}

///|
fn resolve_path(path : String) -> String {
  if path.is_empty() {
    return path
  }
  match @env.current_dir() {
    Some(cwd) => {
      let target = @path.Path(path)
      if target.is_absolute() {
        target.resolve().to_string()
      } else {
        let base = @path.Path(cwd)
        base.join(target).resolve().to_string()
      }
    }
    None => path
  }
}

///|
fn resolve_path_from_source(path : String) -> String {
  if path.is_empty() {
    return path
  }
  let target = @path.Path(path)
  if target.is_absolute() {
    return target.resolve().to_string()
  }
  match current_source_path() {
    Some(source_path) => {
      let base = @path.Path(source_path).dirname()
      base.join(target).resolve().to_string()
    }
    None =>
      match current_function() {
        Some(func) =>
          match func.source_path {
            Some(source_path) => {
              let base = @path.Path(source_path).dirname()
              base.join(target).resolve().to_string()
            }
            None => resolve_path(path)
          }
        None => resolve_path(path)
      }
  }
}

///|
fn global_property_value(name : String) -> Value? raise {
  match root_env() {
    Some(env) =>
      match global_object(env) {
        Some(obj) =>
          if has_property_in_chain(obj.props, obj.proto, name) {
            Some(property_get(Value::Object(obj), name))
          } else {
            None
          }
        None => None
      }
    None => None
  }
}

///|
fn props_map_for_value(value : Value) -> Map[String, Property]? {
  match value {
    Object(obj) => Some(obj.props)
    Function(func) => Some(func.props)
    BoundFunction(bound) => Some(bound.props)
    Builtin(builtin) => Some(builtin.props)
    Array(arr) => Some(arr.props)
    Arguments(args) => Some(args.props)
    _ => None
  }
}

///|
let module_binding_target_key = "__module_binding_target"

///|
let module_binding_name_key = "__module_binding_name"

///|
let array_iter_target_key = "__array_iterator_target"

///|
let array_iter_index_key = "__array_iterator_index"

///|
let array_iter_kind_key = "__array_iterator_kind"

///|
let string_iter_target_key = "__string_iterator_target"

///|
let string_iter_index_key = "__string_iterator_index"

///|
let regexp_iter_regexp_key = "__regexp_iterator_regexp"

///|
let regexp_iter_string_key = "__regexp_iterator_string"

///|
let regexp_iter_global_key = "__regexp_iterator_global"

///|
let regexp_iter_unicode_key = "__regexp_iterator_unicode"

///|
let regexp_iter_done_key = "__regexp_iterator_done"

///|
let async_from_sync_iter_target_key = "__async_from_sync_iter_target"

///|
let async_from_sync_iter_next_key = "__async_from_sync_iter_next"

///|
fn new_module_binding_value(module_value : Value, name : String) -> Value raise {
  let target = to_object(module_value)
  let binding_value = new_object_value_with_proto(
    value_from_object(object_proto()),
  )
  match binding_value {
    Object(obj) => {
      obj.props.set(module_binding_target_key, property_data_non_enum(target))
      obj.props.set(
        module_binding_name_key,
        property_data_non_enum(String(name)),
      )
      obj.extensible = false
    }
    _ => ()
  }
  binding_value
}

///|
fn module_binding_info(value : Value) -> (Value, String, Int)? {
  match value {
    Object(obj) =>
      match
        (
          obj.props.get(module_binding_target_key),
          obj.props.get(module_binding_name_key),
        ) {
        (Some(target_prop), Some(name_prop)) =>
          match name_prop.value {
            String(name) => Some((target_prop.value, name, obj.id))
            _ => None
          }
        _ => None
      }
    _ => None
  }
}

///|
fn module_binding_deref(value : Value) -> Value raise {
  let mut current = value
  let seen : Map[Int, Bool] = Map::new()
  while true {
    match module_binding_info(current) {
      Some((target, name, binding_id)) => {
        if seen.contains(binding_id) {
          return Undefined
        }
        seen.set(binding_id, true)
        match target {
          Object(obj) =>
            match module_env_id_for_exports_obj(obj) {
              Some(env_id) =>
                match module_env_get(env_id) {
                  Some(env) =>
                    match module_env_export_binding_for_name(env_id, name) {
                      Some(binding) =>
                        if env.uninitialized_bindings.contains(binding) {
                          let _ = throw_reference_error("undefined variable")
                          return Undefined
                        }
                      None =>
                        if module_env_export_uninitialized_has(env_id, name) {
                          let _ = throw_reference_error("undefined variable")
                          return Undefined
                        }
                    }
                  None => ()
                }
              None => ()
            }
          _ => ()
        }
        current = property_get_raw(target, name)
      }
      None => return current
    }
  } else {
    Undefined
  }
}

///|
fn module_meta_object(path : String, is_main : Bool) -> ObjectValue {
  let meta_value = new_object_value_with_proto(None)
  let meta_obj = match meta_value {
    Object(obj) => obj
    _ => new_object_struct(None)
  }
  let url = if path.contains(":") { path } else { "file://" + path }
  meta_obj.props.set("url", property_data(String(url)))
  meta_obj.props.set("main", property_data(Bool(is_main)))
  meta_obj
}

///|
fn import_meta_value() -> Value raise {
  let mut path : String? = None
  match current_function() {
    Some(func) => path = func.source_path
    None =>
      match current_source_path() {
        Some(value) => path = Some(value)
        None => ()
      }
  }
  match path {
    Some(path) =>
      match module_record_get(path) {
        Some(record) =>
          match record.meta_obj {
            Some(meta_obj) => Object(meta_obj)
            None => {
              let meta_obj = module_meta_object(path, false)
              module_record_set(path, ModuleRecord::{
                exports: record.exports,
                state: record.state,
                module_ns: record.module_ns,
                meta_obj: Some(meta_obj),
                eval_promise: record.eval_promise,
              })
              Object(meta_obj)
            }
          }
        None => throw_type_error("import.meta not supported in this context")
      }
    None => throw_type_error("import.meta not supported in this context")
  }
}

///|
fn module_cache_key_from_specifier(
  specifier : String,
  attributes : Value,
) -> String? raise {
  match module_builtin_value(specifier) {
    Some(_) => None
    None => {
      let full_path = resolve_path_from_source(specifier)
      let mut json_kind = module_test_json(attributes)
      if json_kind == 0 && full_path.has_suffix(".json") {
        json_kind = 1
      }
      let cache_key = if json_kind == 0 {
        full_path
      } else if json_kind == 1 {
        full_path + "|json"
      } else {
        full_path + "|json5"
      }
      Some(cache_key)
    }
  }
}

///|
fn resolve_module_specifier_from(
  base_path : String,
  specifier : String,
) -> String {
  push_source_path(base_path)
  let full_path = resolve_path_from_source(specifier)
  pop_source_path()
  full_path
}

///|
fn module_resolve_export_name(
  path : String,
  export_name : String,
) -> ModuleResolveExportResult raise {
  let resolve_set : Map[String, Bool] = Map::new()
  module_resolve_export_name_inner(path, export_name, resolve_set)
}

///|
fn module_resolve_export_name_inner(
  path : String,
  export_name : String,
  resolve_set : Map[String, Bool],
) -> ModuleResolveExportResult raise {
  let key = path + "\u{00}" + export_name
  if resolve_set.contains(key) {
    return ModuleResolveExportResult::{
      status: 0,
      path: None,
      local_name: None,
    }
  }
  resolve_set.set(key, true)
  let info = match module_export_info_get(path) {
    Some(value) => value
    None =>
      return ModuleResolveExportResult::{
        status: 0,
        path: None,
        local_name: None,
      }
  }
  match info.local_exports.get(export_name) {
    Some(binding) => {
      let resolved_name = if binding == "" { export_name } else { binding }
      return ModuleResolveExportResult::{
        status: 1,
        path: Some(path),
        local_name: Some(resolved_name),
      }
    }
    None => ()
  }
  match info.indirect_exports.get(export_name) {
    Some((specifier, import_name)) => {
      let target_path = resolve_module_specifier_from(path, specifier)
      if import_name == "*" {
        return ModuleResolveExportResult::{
          status: 1,
          path: Some(path),
          local_name: Some("*"),
        }
      }
      return module_resolve_export_name_inner(
        target_path, import_name, resolve_set,
      )
    }
    None => ()
  }
  if export_name == "default" {
    return ModuleResolveExportResult::{
      status: 0,
      path: None,
      local_name: None,
    }
  }
  let mut star_resolution : ModuleResolveExportResult = ModuleResolveExportResult::{
    status: 0,
    path: None,
    local_name: None,
  }
  for specifier in info.star_exports {
    let target_path = resolve_module_specifier_from(path, specifier)
    let result = module_resolve_export_name_inner(
      target_path, export_name, resolve_set,
    )
    if result.status == 2 {
      return result
    }
    if result.status == 1 {
      if star_resolution.status == 0 {
        star_resolution = result
      } else {
        let mut same_binding = false
        match (star_resolution.path, result.path) {
          (Some(resolved_path), Some(next_path)) =>
            match (star_resolution.local_name, result.local_name) {
              (Some(resolved_name), Some(next_name)) =>
                same_binding = resolved_path == next_path &&
                  resolved_name == next_name
              _ => ()
            }
          _ => ()
        }
        if !same_binding {
          return ModuleResolveExportResult::{
            status: 2,
            path: None,
            local_name: None,
          }
        }
      }
    }
  }
  star_resolution
}

///|
fn module_namespace_from_value(value : Value) -> ObjectValue? raise {
  let target = to_object(value)
  let namespace_value = new_object_value_with_proto(None)
  match namespace_value {
    Object(namespace_obj) => {
      namespace_obj.is_module_namespace = true
      namespace_obj.immutable_proto = true
      match props_map_for_value(target) {
        Some(props) => {
          let names = module_namespace_prop_keys(props, false)
          for name in names {
            let prop_value = new_module_binding_value(target, name)
            namespace_obj.props.set(name, Property::{
              value: prop_value,
              writable: false,
              configurable: false,
              enumerable: true,
              getter: None,
              setter: None,
            })
          }
        }
        None => ()
      }
      match symbol_to_string_tag_key() {
        Some(key) =>
          namespace_obj.props.set(key, property_data_const(String("Module")))
        None => ()
      }
      namespace_obj.extensible = false
      Some(namespace_obj)
    }
    _ => None
  }
}

///|
fn module_namespace_add_export(
  path : String,
  exports : ObjectValue,
  name : String,
) -> Unit raise {
  match module_record_get(path) {
    Some(record) =>
      match record.module_ns {
        Some(namespace_obj) =>
          if !namespace_obj.props.contains(name) {
            let prop_value = new_module_binding_value(Object(exports), name)
            namespace_obj.props.set(name, Property::{
              value: prop_value,
              writable: false,
              configurable: false,
              enumerable: true,
              getter: None,
              setter: None,
            })
          }
        None => ()
      }
    None => ()
  }
}

///|
fn module_namespace_remove_export(path : String, name : String) -> Unit {
  match module_record_get(path) {
    Some(record) =>
      match record.module_ns {
        Some(namespace_obj) =>
          if namespace_obj.props.contains(name) {
            namespace_obj.props.remove(name)
          }
        None => ()
      }
    None => ()
  }
}

///|
fn module_builtin_value(name : String) -> Value? raise {
  let mapped = if name == "std" ||
    name == "os" ||
    name == "bjson" ||
    name == "bjson.so" {
    name
  } else if name.has_suffix("/bjson.so") {
    "bjson.so"
  } else {
    name
  }
  let root_id = match root_env() {
    Some(env) => Some(env.id)
    None => None
  }
  match root_id {
    Some(env_id) =>
      match module_builtin_namespace_get(env_id, mapped) {
        Some(obj) => Some(Object(obj))
        None =>
          match mapped {
            "std" | "os" | "bjson" | "bjson.so" => {
              let base_value = if mapped == "bjson.so" {
                global_property_value("bjson")
              } else {
                global_property_value(mapped)
              }
              match base_value {
                Some(value) =>
                  match module_namespace_from_value(value) {
                    Some(namespace_obj) => {
                      module_builtin_namespace_set(
                        env_id, mapped, namespace_obj,
                      )
                      Some(Object(namespace_obj))
                    }
                    None => None
                  }
                None => None
              }
            }
            _ => None
          }
      }
    None =>
      match mapped {
        "std" | "os" | "bjson" | "bjson.so" => {
          let base_value = if mapped == "bjson.so" {
            global_property_value("bjson")
          } else {
            global_property_value(mapped)
          }
          match base_value {
            Some(value) =>
              match module_namespace_from_value(value) {
                Some(namespace_obj) => Some(Object(namespace_obj))
                None => None
              }
            None => None
          }
        }
        _ => None
      }
  }
}

///|
fn module_check_attributes(attributes : Value) -> Unit {
  let _ = attributes

}

///|
fn module_attributes_from_object(attributes_obj : Value) -> Value raise {
  let attrs_value = new_object_value_with_proto(None)
  let keys = own_enumerable_string_keys(attributes_obj)
  for key in keys {
    let value = property_get(attributes_obj, key)
    match value {
      String(_) => ()
      _ => {
        let _ = throw_type_error("module attribute values must be strings")

      }
    }
    match attrs_value {
      Object(obj) => obj.props.set(key, property_data(value))
      _ => ()
    }
  }
  module_check_attributes(attrs_value)
  attrs_value
}

///|
fn module_attributes_from_value(attributes : Value) -> Value raise {
  match attributes {
    Undefined | Null => Undefined
    _ =>
      if !is_object_like(attributes) {
        throw_type_error("module attributes must be an object")
      } else {
        module_attributes_from_object(attributes)
      }
  }
}

///|
fn module_attributes_from_options(options : Value) -> Value raise {
  if options is Undefined {
    return Undefined
  }
  if !is_object_like(options) {
    return throw_type_error("options must be an object")
  }
  let with_value = property_get(options, "with")
  if with_value is Undefined {
    return Undefined
  }
  if !is_object_like(with_value) {
    return throw_type_error("options.with must be an object")
  }
  module_attributes_from_object(with_value)
}

///|
fn module_test_json(attributes : Value) -> Int raise {
  if attributes is Undefined {
    return 0
  }
  let type_value = property_get(attributes, "type")
  match type_value {
    String(text) =>
      if text == "json" {
        1
      } else if text == "json5" {
        2
      } else {
        0
      }
    _ => 0
  }
}

///|
fn eval_module_source(source : String, full_path : String) -> ObjectValue raise {
  let script = parse_script_with_pos_mode(source, true, false)
  eval_module_script(script, full_path)
}

///|
fn expr_is_import_decl(expr : @engine.Expr) -> Bool {
  match expr {
    @engine.Expr::Call(callee, _, _) =>
      match callee {
        @engine.Expr::Ident(name, _) =>
          name == "__import" || name == "__import_binding"
        _ => false
      }
    _ => false
  }
}

///|
fn expr_is_export_star(expr : @engine.Expr) -> Bool {
  match expr {
    @engine.Expr::Call(callee, _, _) =>
      match callee {
        @engine.Expr::Ident(name, _) => name == "__export_star"
        _ => false
      }
    _ => false
  }
}

///|
fn export_call_is_import(args : Array[@engine.Expr]) -> Bool {
  if args.length() < 2 {
    return false
  }
  match args[1] {
    @engine.Expr::Call(callee, _, _) =>
      match callee {
        @engine.Expr::Ident(name, _) =>
          name == "__import" || name == "__import_binding"
        _ => false
      }
    _ => false
  }
}

///|
fn preload_module_import_expr(env : Env, expr : @engine.Expr) -> Unit raise {
  match expr {
    @engine.Expr::Sequence(exprs) =>
      for inner in exprs {
        preload_module_import_expr(env, inner)
      }
    @engine.Expr::Paren(inner) => preload_module_import_expr(env, inner)
    @engine.Expr::Call(callee, args, _) =>
      match callee {
        @engine.Expr::Ident(name, _) =>
          if name == "__import" || name == "__import_binding" {
            let _ = eval_expr(env, expr)

          } else if name == "__export_star" {
            let _ = eval_expr(env, expr)

          } else if name == "__export" && export_call_is_import(args) {
            let _ = eval_expr(env, expr)

          }
        _ => ()
      }
    _ => ()
  }
}

///|
fn stmt_is_import_decl(stmt : @engine.Stmt) -> Bool {
  match stmt {
    @engine.Stmt::ExprStmt(expr) => expr_is_import_decl(expr)
    @engine.Stmt::VarDecl(kind, decls) =>
      match kind {
        @engine.VarKind::ConstDecl => {
          if decls.is_empty() {
            return false
          }
          for entry in decls {
            let (_, init) = entry
            match init {
              Some(expr) => if !expr_is_import_decl(expr) { return false }
              None => return false
            }
          }
          true
        }
        _ => false
      }
    _ => false
  }
}

///|
fn preload_module_imports(env : Env, script : @engine.Script) -> Unit raise {
  for stmt in script.body {
    match stmt {
      @engine.Stmt::ExprStmt(expr) => preload_module_import_expr(env, expr)
      @engine.Stmt::VarDecl(_, decls) =>
        if stmt_is_import_decl(stmt) {
          for entry in decls {
            let (_, init) = entry
            match init {
              Some(expr) => {
                let value = eval_expr(env, expr)
                let (binding, _) = entry
                match binding {
                  @engine.VarBinding::Name(name) =>
                    env_define_readonly(env, name, value, true)
                  _ => ()
                }
              }
              None => ()
            }
          }
        }
      _ => ()
    }
  }
}

///|
fn predeclare_module_exports(
  env_id : Int,
  exports : ObjectValue,
  script : @engine.Script,
) -> Unit raise {
  for stmt in script.body {
    predeclare_module_exports_in_stmt(env_id, exports, stmt)
  }
}

///|
fn predeclare_module_exports_in_stmt(
  env_id : Int,
  exports : ObjectValue,
  stmt : @engine.Stmt,
) -> Unit raise {
  match stmt {
    @engine.Stmt::ExprStmt(expr) =>
      predeclare_module_exports_in_expr(env_id, exports, expr)
    @engine.Stmt::Block(stmts) =>
      for inner in stmts {
        predeclare_module_exports_in_stmt(env_id, exports, inner)
      }
    @engine.Stmt::Label(_, body) =>
      predeclare_module_exports_in_stmt(env_id, exports, body)
    @engine.Stmt::If(_, conseq, alt) => {
      predeclare_module_exports_in_stmt(env_id, exports, conseq)
      match alt {
        Some(inner) => predeclare_module_exports_in_stmt(env_id, exports, inner)
        None => ()
      }
    }
    @engine.Stmt::Switch(_, cases) =>
      for clause in cases {
        let body = match clause {
          @engine.SwitchCase::Case(_, stmts) => stmts
          @engine.SwitchCase::Default(stmts) => stmts
        }
        for inner in body {
          predeclare_module_exports_in_stmt(env_id, exports, inner)
        }
      }
    @engine.Stmt::Try(try_body, catch_clause, finally_body) => {
      predeclare_module_exports_in_stmt(env_id, exports, try_body)
      match catch_clause {
        Some(clause) =>
          predeclare_module_exports_in_stmt(env_id, exports, clause.body)
        None => ()
      }
      match finally_body {
        Some(inner) => predeclare_module_exports_in_stmt(env_id, exports, inner)
        None => ()
      }
    }
    _ => ()
  }
}

///|
fn predeclare_module_exports_in_expr(
  env_id : Int,
  exports : ObjectValue,
  expr : @engine.Expr,
) -> Unit raise {
  match expr {
    @engine.Expr::Sequence(exprs) =>
      for inner in exprs {
        predeclare_module_exports_in_expr(env_id, exports, inner)
      }
    @engine.Expr::Paren(inner) =>
      predeclare_module_exports_in_expr(env_id, exports, inner)
    @engine.Expr::Call(callee, args, _) =>
      match callee {
        @engine.Expr::Ident(name, _) =>
          if name == "__export" {
            predeclare_module_export_call(env_id, exports, args)
          }
        _ => ()
      }
    _ => ()
  }
}

///|
fn predeclare_module_export_call(
  env_id : Int,
  exports : ObjectValue,
  args : Array[@engine.Expr],
) -> Unit raise {
  if args.length() < 2 {
    return
  }
  let export_name = match args[0] {
    @engine.Expr::String(name, _, _) => name
    _ => return
  }
  if !exports.props.contains(export_name) {
    exports.props.set(export_name, Property::{
      value: Undefined,
      writable: false,
      configurable: false,
      enumerable: true,
      getter: None,
      setter: None,
    })
    match current_source_path() {
      Some(path) => module_namespace_add_export(path, exports, export_name)
      None => ()
    }
  }
  if args.length() > 2 {
    match args[2] {
      @engine.Expr::String(binding, _, _) =>
        module_env_export_names_add(env_id, binding, export_name)
      _ => ()
    }
  } else {
    module_env_export_uninitialized_add(env_id, export_name)
  }
}

///|
fn module_imported_bindings_from_script(
  script : @engine.Script,
) -> Map[String, (String, String)] {
  let imported : Map[String, (String, String)] = Map::new()
  for stmt in script.body {
    match stmt {
      @engine.Stmt::VarDecl(_, decls) =>
        if stmt_is_import_decl(stmt) {
          for entry in decls {
            let (binding, init) = entry
            match (binding, init) {
              (@engine.VarBinding::Name(local_name), Some(expr)) =>
                match module_export_info_import_call(expr) {
                  Some((specifier, import_name)) =>
                    imported.set(local_name, (specifier, import_name))
                  None => ()
                }
              _ => ()
            }
          }
        }
      _ => ()
    }
  }
  imported
}

///|
fn module_export_info_from_script(
  script : @engine.Script,
) -> ModuleExportInfo raise {
  let info = ModuleExportInfo::{
    local_exports: Map::new(),
    indirect_exports: Map::new(),
    star_exports: [],
  }
  let imported_bindings = module_imported_bindings_from_script(script)
  for stmt in script.body {
    module_export_info_in_stmt(info, imported_bindings, stmt)
  }
  info
}

///|
fn module_export_info_in_stmt(
  info : ModuleExportInfo,
  imported_bindings : Map[String, (String, String)],
  stmt : @engine.Stmt,
) -> Unit raise {
  match stmt {
    @engine.Stmt::ExprStmt(expr) =>
      module_export_info_in_expr(info, imported_bindings, expr)
    @engine.Stmt::Block(stmts) =>
      for inner in stmts {
        module_export_info_in_stmt(info, imported_bindings, inner)
      }
    @engine.Stmt::Label(_, body) =>
      module_export_info_in_stmt(info, imported_bindings, body)
    @engine.Stmt::If(_, conseq, alt) => {
      module_export_info_in_stmt(info, imported_bindings, conseq)
      match alt {
        Some(inner) =>
          module_export_info_in_stmt(info, imported_bindings, inner)
        None => ()
      }
    }
    @engine.Stmt::Switch(_, cases) =>
      for clause in cases {
        let body = match clause {
          @engine.SwitchCase::Case(_, stmts) => stmts
          @engine.SwitchCase::Default(stmts) => stmts
        }
        for inner in body {
          module_export_info_in_stmt(info, imported_bindings, inner)
        }
      }
    @engine.Stmt::Try(try_body, catch_clause, finally_body) => {
      module_export_info_in_stmt(info, imported_bindings, try_body)
      match catch_clause {
        Some(clause) =>
          module_export_info_in_stmt(info, imported_bindings, clause.body)
        None => ()
      }
      match finally_body {
        Some(inner) =>
          module_export_info_in_stmt(info, imported_bindings, inner)
        None => ()
      }
    }
    _ => ()
  }
}

///|
fn module_export_info_in_expr(
  info : ModuleExportInfo,
  imported_bindings : Map[String, (String, String)],
  expr : @engine.Expr,
) -> Unit raise {
  match expr {
    @engine.Expr::Sequence(exprs) =>
      for inner in exprs {
        module_export_info_in_expr(info, imported_bindings, inner)
      }
    @engine.Expr::Paren(inner) =>
      module_export_info_in_expr(info, imported_bindings, inner)
    @engine.Expr::Call(callee, args, _) =>
      match callee {
        @engine.Expr::Ident(name, _) =>
          if name == "__export" {
            module_export_info_record_export(info, imported_bindings, args)
          } else if name == "__export_star" {
            module_export_info_record_star(info, args)
          }
        _ => ()
      }
    _ => ()
  }
}

///|
fn module_export_info_record_export(
  info : ModuleExportInfo,
  imported_bindings : Map[String, (String, String)],
  args : Array[@engine.Expr],
) -> Unit raise {
  if args.length() < 2 {
    return
  }
  let export_name = match args[0] {
    @engine.Expr::String(name, _, _) => name
    _ => return
  }
  if info.local_exports.contains(export_name) ||
    info.indirect_exports.contains(export_name) {
    let _ = throw_syntax_error("duplicate exported name '\{export_name}'")

  }
  if args.length() > 2 {
    match args[2] {
      @engine.Expr::String(binding, _, _) => {
        let _ = imported_bindings.get(binding)
        info.local_exports.set(export_name, binding)
        return
      }
      _ => ()
    }
  }
  match module_export_info_import_call(args[1]) {
    Some((specifier, import_name)) => {
      info.indirect_exports.set(export_name, (specifier, import_name))
      return
    }
    None => ()
  }
  info.local_exports.set(export_name, "")
}

///|
fn module_export_info_record_star(
  info : ModuleExportInfo,
  args : Array[@engine.Expr],
) -> Unit {
  if args.is_empty() {
    return
  }
  let specifier = match args[0] {
    @engine.Expr::String(text, _, _) => text
    _ => return
  }
  if !info.star_exports.contains(specifier) {
    info.star_exports.push(specifier)
  }
}

///|
fn module_export_info_import_call(expr : @engine.Expr) -> (String, String)? {
  match expr {
    @engine.Expr::Call(callee, args, _) =>
      match callee {
        @engine.Expr::Ident(name, _) =>
          if name == "__import_binding" {
            if args.length() < 2 {
              return None
            }
            match (args[0], args[1]) {
              (
                @engine.Expr::String(specifier, _, _),
                @engine.Expr::String(import_name, _, _),
              ) => Some((specifier, import_name))
              _ => None
            }
          } else if name == "__import" {
            if args.is_empty() {
              return None
            }
            match args[0] {
              @engine.Expr::String(specifier, _, _) => Some((specifier, "*"))
              _ => None
            }
          } else {
            None
          }
        _ => None
      }
    _ => None
  }
}

///|
fn module_has_top_level_await(script : @engine.Script) -> Bool {
  stmts_contain_yield(script.body)
}

///|
fn module_syntax_error_value(env : Env, message : String) -> Value {
  let proto = match syntax_error_proto_for_env(env) {
    Some(value) => Some(value)
    None => syntax_error_proto()
  }
  new_error_value(proto, message)
}

///|
fn gen_eval_module_body(
  env : Env,
  body : Array[@engine.Stmt],
  result_value : Value,
) -> GenStep raise {
  gen_bind(gen_eval_stmt_seq(env, body, 0), fn(control) {
    match control {
      Normal(_) => Done(Normal(result_value))
      Return(_) => Done(Throw(module_syntax_error_value(env, "illegal return")))
      Break(_, _) =>
        Done(Throw(module_syntax_error_value(env, "illegal break")))
      Continue(_, _) =>
        Done(Throw(module_syntax_error_value(env, "illegal continue")))
      Throw(value) => Done(Throw(value))
    }
  })
}

///|
fn module_eval_with_context_step(
  source_path : String,
  source_value : String,
  exports_obj : ObjectValue,
  env_id : Int,
  f : () -> GenStep raise,
) -> GenStep raise {
  with_source_path_step(source_path, fn() raise {
    with_source_value_step(source_value, fn() raise {
      with_module_exports_step(exports_obj, fn() raise {
        with_module_env_id_step(env_id, f)
      })
    })
  })
}

///|
fn module_eval_wrap_next_step(
  next_step : (GenResume) -> GenStep raise,
  source_path : String,
  source_value : String,
  exports_obj : ObjectValue,
  env_id : Int,
) -> (GenResume) -> GenStep raise {
  fn(resume_) raise {
    let step = module_eval_with_context_step(
      source_path,
      source_value,
      exports_obj,
      env_id,
      fn() raise { next_step(resume_) },
    )
    module_eval_wrap_step(step, source_path, source_value, exports_obj, env_id)
  }
}

///|
fn module_eval_wrap_step(
  step : GenStep,
  source_path : String,
  source_value : String,
  exports_obj : ObjectValue,
  env_id : Int,
) -> GenStep {
  match step {
    Yield(value, next_step) =>
      Yield(
        value,
        module_eval_wrap_next_step(
          next_step, source_path, source_value, exports_obj, env_id,
        ),
      )
    Await(value, next_step) =>
      Await(
        value,
        module_eval_wrap_next_step(
          next_step, source_path, source_value, exports_obj, env_id,
        ),
      )
    Done(control) => Done(control)
  }
}

///|
fn module_async_eval(
  env : Env,
  body : Array[@engine.Stmt],
  result_value : Value,
  source_path : String,
  source_value : String,
  exports_obj : ObjectValue,
) -> Value raise {
  let func_def = @engine.FunctionDef::new(
    None,
    ([] : Array[@engine.ParamBinding]),
    ([] : Array[@engine.Expr?]),
    body,
    true,
    false,
    true,
    false,
    0,
    0,
  )
  let func_value = to_function_value(env, func_def, false)
  let top_level_func_decls = collect_top_level_function_decls(body)
  let next_step = fn(_ : GenResume) raise {
    let step = module_eval_with_context_step(
      source_path,
      source_value,
      exports_obj,
      env.id,
      fn() raise {
        let inner = with_top_level_function_decls_step(top_level_func_decls, fn() raise {
          gen_eval_module_body(env, body, result_value)
        })
        top_level_function_decls_wrap_step(inner, top_level_func_decls)
      },
    )
    module_eval_wrap_step(step, source_path, source_value, exports_obj, env.id)
  }
  let gen_data = GeneratorData::{
    state: GeneratorState::SuspendedStart,
    env,
    func: func_value,
    next_step,
    roots: [],
  }
  ensure_function_prototype(func_value)
  let fallback_proto = match
    value_from_object(async_generator_proto_for_env(env)) {
    Some(value) => Some(value)
    None => value_from_object(async_generator_proto())
  }
  let proto_value = match func_value.props.get("prototype") {
    Some(prop) =>
      if is_object_like(prop.value) {
        Some(prop.value)
      } else {
        fallback_proto
      }
    None => fallback_proto
  }
  let obj = register_object_value(ObjectValue::{
    id: alloc_id(),
    props: Map::new(),
    proto: proto_value,
    string_data: None,
    number_data: None,
    bool_data: None,
    bigint_data: None,
    symbol_data: None,
    regexp_data: None,
    generator_data: Some(gen_data),
    async_generator_data: None,
    proxy_data: None,
    map_data: None,
    set_data: None,
    map_iter_data: None,
    set_iter_data: None,
    iterator_wrap_data: None,
    iterator_concat_data: None,
    iterator_helper_data: None,
    weakmap_data: None,
    weakset_data: None,
    weakref_data: None,
    finreg_data: None,
    date_data: None,
    array_buffer_data: None,
    dataview_data: None,
    is_html_dda: false,
    is_error: false,
    is_module_namespace: false,
    realm_env: None,
    immutable_proto: false,
    extensible: true,
  })
  let (promise, resolve, reject) = new_promise_capability(Undefined)
  async_function_data_set(obj.id, AsyncFunctionData::{ resolve, reject })
  async_function_resume(obj, GenResume::Next(Undefined))
  promise
}

///|
fn module_eval_next_timestamp() -> Int64 {
  let mut value : Int64 = 0
  module_async_eval_timestamp_ref.update(fn(current) {
    value = current
    current + 1
  })
  value
}

///|
fn module_is_cycle_root(path : String, info : ModuleEvalInfo) -> Bool {
  match info.cycle_root {
    Some(root) => root == path
    None => true
  }
}

///|
fn module_eval_resolvers_set(
  path : String,
  resolve : Value,
  reject : Value,
) -> Unit {
  match module_eval_info_get(path) {
    Some(info) => {
      let updated = info
      updated.resolve = Some(resolve)
      updated.reject = Some(reject)
      module_eval_info_set(path, updated)
    }
    None => ()
  }
}

///|
fn module_eval_promise_init(path : String) -> Value raise {
  match module_eval_promise_get(path) {
    Some(promise) => promise
    None => {
      let (promise, resolve, reject) = new_promise_capability(Undefined)
      module_eval_promise_set(path, Some(promise))
      module_eval_resolvers_set(path, resolve, reject)
      promise
    }
  }
}

///|
fn module_eval_resolve(path : String) -> Unit raise {
  match module_eval_info_get(path) {
    Some(info) =>
      if module_is_cycle_root(path, info) {
        match info.resolve {
          Some(resolve) => {
            let _ = call_value_with_this(resolve, [Undefined], Undefined)

          }
          None => ()
        }
      }
    None => ()
  }
}

///|
fn module_eval_reject(path : String, error : Value) -> Unit raise {
  match module_eval_info_get(path) {
    Some(info) =>
      if module_is_cycle_root(path, info) {
        match info.reject {
          Some(reject) => {
            let _ = call_value_with_this(reject, [error], Undefined)

          }
          None => ()
        }
      }
    None => ()
  }
}

///|
fn module_execute_sync(path : String) -> Unit raise {
  let info = match module_eval_info_get(path) {
    Some(value) => value
    None => return
  }
  let env = match module_env_get(info.env_id) {
    Some(value) => value
    None => return
  }
  let exports_obj = match module_record_get(path) {
    Some(record) => record.exports
    None => new_object_struct(None)
  }
  let promise = with_source_path(path, fn() raise {
    with_source_value(info.script.source, fn() raise {
      module_async_eval(
        env,
        info.script.body,
        Undefined,
        path,
        info.script.source,
        exports_obj,
      )
    })
  })
  match promise_data_from_value(promise) {
    Some(data) =>
      match data.state {
        PromiseState::Fulfilled => ()
        PromiseState::Rejected => raise ThrowSignal(data.value)
        PromiseState::Pending => {
          let _ = throw_type_error("promise is pending")
          ()
        }
      }
    None => ()
  }
}

///|
fn module_async_callback_data_set(id : Int, path : String) -> Unit {
  module_async_callback_data_ref.update(fn(table) {
    table.set(id, path)
    table
  })
}

///|
fn module_async_callback_data_get(id : Int) -> String? {
  let mut value : String? = None
  module_async_callback_data_ref.update(fn(table) {
    value = table.get(id)
    table
  })
  value
}

///|
fn module_import_dynamic_job_data_set(
  id : Int,
  data : ModuleImportDynamicJobData,
) -> Unit {
  module_import_dynamic_job_data_ref.update(fn(table) {
    table.set(id, data)
    table
  })
}

///|
fn module_import_dynamic_job_data_take(id : Int) -> ModuleImportDynamicJobData? {
  let mut value : ModuleImportDynamicJobData? = None
  module_import_dynamic_job_data_ref.update(fn(table) {
    value = table.get(id)
    match value {
      Some(_) => {
        let _ = table.remove(id)

      }
      None => ()
    }
    table
  })
  value
}

///|
fn new_module_async_callback(path : String, is_reject : Bool) -> Value {
  let func = if is_reject {
    new_builtin_value(BuiltinFunction::ModuleAsyncRejected)
  } else {
    new_builtin_value(BuiltinFunction::ModuleAsyncFulfilled)
  }
  match func {
    Builtin(builtin) => module_async_callback_data_set(builtin.id, path)
    _ => ()
  }
  func
}

///|
fn module_execute_async(path : String) -> Unit raise {
  let info = match module_eval_info_get(path) {
    Some(value) => value
    None => return
  }
  let env = match module_env_get(info.env_id) {
    Some(value) => value
    None => return
  }
  let exports_obj = match module_record_get(path) {
    Some(record) => record.exports
    None => new_object_struct(None)
  }
  let promise = with_source_path(path, fn() raise {
    with_source_value(info.script.source, fn() raise {
      module_async_eval(
        env,
        info.script.body,
        Undefined,
        path,
        info.script.source,
        exports_obj,
      )
    })
  })
  let on_fulfilled = new_module_async_callback(path, false)
  let on_rejected = new_module_async_callback(path, true)
  let _ = promise_invoke_then(promise, on_fulfilled, on_rejected)

}

///|
fn module_exec_list_contains(list : Array[String], path : String) -> Bool {
  for entry in list {
    if entry == path {
      return true
    }
  }
  false
}

///|
fn module_exec_list_sort(list : Array[String]) -> Unit {
  let len = list.length()
  let mut i = 0
  while i < len {
    let mut j = i + 1
    while j < len {
      let mut ts_i : Int64 = 0
      let mut ts_j : Int64 = 0
      match module_eval_info_get(list[i]) {
        Some(info) => ts_i = info.async_timestamp
        None => ()
      }
      match module_eval_info_get(list[j]) {
        Some(info) => ts_j = info.async_timestamp
        None => ()
      }
      if ts_j < ts_i {
        let tmp = list[i]
        list[i] = list[j]
        list[j] = tmp
      }
      j = j + 1
    }
    i = i + 1
  }
}

///|
fn module_gather_available_ancestors(
  path : String,
  exec_list : Array[String],
) -> Unit raise {
  let info = match module_eval_info_get(path) {
    Some(value) => value
    None => return
  }
  for parent in info.async_parents {
    let parent_info = match module_eval_info_get(parent) {
      Some(value) => value
      None => continue
    }
    if !(parent_info.status is ModuleEvalStatus::EvaluatingAsync) {
      continue
    }
    if parent_info.eval_has_exception {
      continue
    }
    parent_info.pending_async_deps = parent_info.pending_async_deps - 1
    if parent_info.pending_async_deps == 0 {
      if !module_exec_list_contains(exec_list, parent) {
        exec_list.push(parent)
      }
      if !parent_info.has_tla {
        module_eval_info_set(parent, parent_info)
        module_gather_available_ancestors(parent, exec_list)
        continue
      }
    }
    module_eval_info_set(parent, parent_info)
  }
}

///|
fn module_async_evaluation_rejected(path : String, error : Value) -> Unit raise {
  let info = match module_eval_info_get(path) {
    Some(value) => value
    None => return
  }
  if info.status is ModuleEvalStatus::Evaluated {
    return
  }
  info.eval_has_exception = true
  info.eval_exception = Some(error)
  info.status = ModuleEvalStatus::Evaluated
  info.async_evaluation = false
  module_eval_info_set(path, info)
  module_eval_reject(path, error)
  for parent in info.async_parents {
    module_async_evaluation_rejected(parent, error)
  }
}

///|
fn module_async_evaluation_fulfilled(path : String) -> Unit raise {
  let info = match module_eval_info_get(path) {
    Some(value) => value
    None => return
  }
  if info.status is ModuleEvalStatus::Evaluated {
    return
  }
  info.async_evaluation = false
  info.status = ModuleEvalStatus::Evaluated
  module_eval_info_set(path, info)
  module_eval_resolve(path)
  let exec_list : Array[String] = []
  module_gather_available_ancestors(path, exec_list)
  module_exec_list_sort(exec_list)
  for entry in exec_list {
    let info = match module_eval_info_get(entry) {
      Some(value) => value
      None => continue
    }
    if info.status is ModuleEvalStatus::Evaluated && info.eval_has_exception {
      continue
    }
    if info.has_tla {
      module_execute_async(entry) catch {
        ThrowSignal(err) => module_async_evaluation_rejected(entry, err)
        err => raise err
      }
    } else {
      try {
        module_execute_sync(entry)
        let updated = info
        updated.async_evaluation = false
        updated.status = ModuleEvalStatus::Evaluated
        module_eval_info_set(entry, updated)
        module_eval_resolve(entry)
      } catch {
        ThrowSignal(err) => module_async_evaluation_rejected(entry, err)
        err => raise err
      }
    }
  }
}

///|
fn module_inner_evaluation(
  path : String,
  index : Int,
  stack : Array[String],
) -> Int raise {
  let mut info = match module_eval_info_get(path) {
    Some(value) => value
    None => return index
  }
  match info.status {
    ModuleEvalStatus::EvaluatingAsync | ModuleEvalStatus::Evaluated =>
      if info.eval_has_exception {
        match info.eval_exception {
          Some(value) => raise ThrowSignal(value)
          None => raise ThrowSignal(type_error_value("module failed"))
        }
      } else {
        return index
      }
    ModuleEvalStatus::Evaluating => return index
    ModuleEvalStatus::NotEvaluated => ()
  }
  info.status = ModuleEvalStatus::Evaluating
  info.dfs_index = index
  info.dfs_ancestor_index = index
  info.pending_async_deps = 0
  let mut next_index = index + 1
  stack.push(path)
  module_eval_info_set(path, info)
  for dep in info.deps {
    next_index = module_inner_evaluation(dep, next_index, stack)
    let dep_info = match module_eval_info_get(dep) {
      Some(value) => value
      None => continue
    }
    let mut dep_root = dep
    if dep_info.status is ModuleEvalStatus::Evaluating {
      let updated = match module_eval_info_get(path) {
        Some(value) => value
        None => continue
      }
      updated.dfs_ancestor_index = if updated.dfs_ancestor_index <
        dep_info.dfs_ancestor_index {
        updated.dfs_ancestor_index
      } else {
        dep_info.dfs_ancestor_index
      }
      module_eval_info_set(path, updated)
    } else {
      dep_root = match dep_info.cycle_root {
        Some(value) => value
        None => dep
      }
      match module_eval_info_get(dep_root) {
        Some(root_info) =>
          if root_info.eval_has_exception {
            match root_info.eval_exception {
              Some(value) => raise ThrowSignal(value)
              None => raise ThrowSignal(type_error_value("module failed"))
            }
          }
        None => ()
      }
    }
    let dep_root_info = match module_eval_info_get(dep_root) {
      Some(value) => value
      None => continue
    }
    if dep_root_info.async_evaluation {
      let updated = match module_eval_info_get(path) {
        Some(value) => value
        None => continue
      }
      updated.pending_async_deps = updated.pending_async_deps + 1
      module_eval_info_set(path, updated)
      dep_root_info.async_parents.push(path)
      module_eval_info_set(dep_root, dep_root_info)
    }
  }
  info = match module_eval_info_get(path) {
    Some(value) => value
    None => return next_index
  }
  if info.pending_async_deps > 0 {
    info.async_evaluation = true
    info.async_timestamp = module_eval_next_timestamp()
    module_eval_info_set(path, info)
  } else if info.has_tla {
    info.async_evaluation = true
    info.async_timestamp = module_eval_next_timestamp()
    module_eval_info_set(path, info)
    module_execute_async(path)
  } else {
    module_eval_info_set(path, info)
    module_execute_sync(path)
  }
  info = match module_eval_info_get(path) {
    Some(value) => value
    None => return next_index
  }
  if info.dfs_index == info.dfs_ancestor_index {
    while true {
      if stack.is_empty() {
        break
      }
      let current = stack.pop().unwrap_or(path)
      let entry_info = match module_eval_info_get(current) {
        Some(value) => value
        None => continue
      }
      if !entry_info.async_evaluation {
        entry_info.status = ModuleEvalStatus::Evaluated
      } else {
        entry_info.status = ModuleEvalStatus::EvaluatingAsync
      }
      entry_info.cycle_root = Some(path)
      module_eval_info_set(current, entry_info)
      match module_eval_promise_get(path) {
        Some(promise) => module_eval_promise_set(current, Some(promise))
        None => ()
      }
      if current == path {
        break
      }
    }
  }
  next_index
}

///|
fn module_evaluate(path : String) -> Value raise {
  let info = module_eval_info_get(path)
  match info {
    None => {
      let (promise, resolve, _) = new_promise_capability(Undefined)
      module_eval_promise_set(path, Some(promise))
      let _ = call_value_with_this(resolve, [Undefined], Undefined)
      promise
    }
    Some(info) => {
      let root_path = if info.status is ModuleEvalStatus::EvaluatingAsync ||
        info.status is ModuleEvalStatus::Evaluated {
        match info.cycle_root {
          Some(value) => value
          None => path
        }
      } else {
        path
      }
      let promise = module_eval_promise_init(root_path)
      let stack : Array[String] = []
      try {
        let _ = module_inner_evaluation(root_path, 0, stack)

      } catch {
        ThrowSignal(err) => {
          for entry in stack {
            let entry_info = match module_eval_info_get(entry) {
              Some(value) => value
              None => continue
            }
            entry_info.status = ModuleEvalStatus::Evaluated
            entry_info.eval_has_exception = true
            entry_info.eval_exception = Some(err)
            entry_info.cycle_root = Some(root_path)
            module_eval_info_set(entry, entry_info)
            match module_eval_promise_get(root_path) {
              Some(promise) => module_eval_promise_set(entry, Some(promise))
              None => ()
            }
          }
          module_eval_reject(root_path, err)
          return promise
        }
        err => raise err
      }
      match module_eval_info_get(root_path) {
        Some(root_info) =>
          if !root_info.async_evaluation && !root_info.eval_has_exception {
            module_eval_resolve(root_path)
          }
        None => ()
      }
      promise
    }
  }
}

///|
fn await_promise_completion(promise : Value) -> Value raise {
  while true {
    match promise_data_from_value(promise) {
      Some(data) =>
        match data.state {
          PromiseState::Fulfilled => return data.value
          PromiseState::Rejected => raise ThrowSignal(data.value)
          PromiseState::Pending => {
            let mut did_work = false
            if has_pending_jobs() {
              run_pending_jobs()
              did_work = true
            }
            if has_pending_timers() {
              run_pending_timers()
              did_work = true
            }
            if has_pending_jobs() {
              run_pending_jobs()
              did_work = true
            }
            if has_pending_workers() {
              run_pending_workers()
              did_work = true
            }
            if has_pending_jobs() {
              run_pending_jobs()
              did_work = true
            }
            if !did_work {
              let _ = throw_type_error("promise is pending")
              return promise
            }
          }
        }
      None => return promise
    }
  }
  promise
}

///|
fn eval_module_script(
  script : @engine.Script,
  full_path : String,
) -> ObjectValue raise {
  validate_context_in_script(script, false, false, false)
  let is_main = match current_module_env_id() {
    Some(_) => false
    None => true
  }
  let meta_obj = module_meta_object(full_path, is_main)
  let exports_value = new_object_value()
  let exports_obj = match exports_value {
    Object(obj) => obj
    _ => new_object_struct(None)
  }
  module_record_set(full_path, ModuleRecord::{
    exports: exports_obj,
    state: ModuleState::Loading,
    module_ns: None,
    meta_obj: Some(meta_obj),
    eval_promise: None,
  })
  module_export_info_set(full_path, module_export_info_from_script(script))
  let module_env = match root_env() {
    Some(env) => Env::new(Some(env))
    None => Env::new(None)
  }
  module_env.strict = true
  module_env.bindings.set("this", Undefined)
  module_env.var_env = Some(module_env)
  module_env_exports_set(module_env.id, exports_obj)
  module_env_set(module_env)
  let mut deps : Array[String] = []
  let has_tla = module_has_top_level_await(script)
  let result = try {
    let _ = with_source_path(full_path, fn() raise {
      with_module_exports(exports_obj, fn() raise {
        with_module_env_id(module_env.id, fn() raise {
          predeclare_module_exports(module_env.id, exports_obj, script)
          push_module_imports()
          try {
            preload_module_imports(module_env, script)
            deps = pop_module_imports()
          } catch {
            err => {
              let _ = pop_module_imports()
              raise err
            }
          }
          with_source_value(script.source, fn() raise {
            hoist_decls(module_env, script.body, false, false)
            if eval_body_has_lexical_decls(script.body) {
              eval_predeclare_lexical_decls(module_env, script.body)
            }
            Undefined
          })
        })
      })
    })
    match module_env_export_names_all(module_env.id) {
      Some(names) =>
        for binding, _ in names {
          match module_env.bindings.get(binding) {
            Some(_) => ()
            None => {
              let _ = throw_syntax_error(
                "exported variable '\{binding}' does not exist",
              )

            }
          }
        }
      None => ()
    }
    exports_obj.extensible = false
    let mut module_ns : ObjectValue? = None
    match module_namespace_from_value(Object(exports_obj)) {
      Some(namespace_obj) => module_ns = Some(namespace_obj)
      None => ()
    }
    module_record_set(full_path, ModuleRecord::{
      exports: exports_obj,
      state: ModuleState::Loaded,
      module_ns,
      meta_obj: Some(meta_obj),
      eval_promise: None,
    })
    module_eval_info_set(full_path, ModuleEvalInfo::{
      script,
      env_id: module_env.id,
      deps,
      has_tla,
      status: ModuleEvalStatus::NotEvaluated,
      dfs_index: 0,
      dfs_ancestor_index: 0,
      pending_async_deps: 0,
      async_parents: [],
      async_timestamp: 0,
      async_evaluation: false,
      cycle_root: None,
      eval_has_exception: false,
      eval_exception: None,
      resolve: None,
      reject: None,
    })
    exports_obj
  } catch {
    err => {
      module_record_remove(full_path)
      module_eval_info_remove(full_path)
      module_env_exports_remove(module_env.id)
      module_env_export_names_remove(module_env.id)
      module_env_remove(module_env.id)
      raise err
    }
  }
  result
}

///|
fn module_import_from_specifier(
  specifier : String,
  attributes : Value,
  record_import : Bool,
) -> Value raise {
  match module_builtin_value(specifier) {
    Some(value) => value
    None => {
      let full_path = resolve_path_from_source(specifier)
      let mut json_kind = module_test_json(attributes)
      if json_kind == 0 && full_path.has_suffix(".json") {
        json_kind = 1
      }
      let cache_key = if json_kind == 0 {
        full_path
      } else if json_kind == 1 {
        full_path + "|json"
      } else {
        full_path + "|json5"
      }
      if record_import {
        record_module_import(cache_key)
      }
      match module_record_get(cache_key) {
        Some(record) =>
          match record.state {
            ModuleState::Loaded =>
              match record.module_ns {
                Some(namespace_obj) => Object(namespace_obj)
                None =>
                  match module_namespace_from_value(Object(record.exports)) {
                    Some(namespace_obj) => {
                      module_record_set(cache_key, ModuleRecord::{
                        exports: record.exports,
                        state: record.state,
                        module_ns: Some(namespace_obj),
                        meta_obj: record.meta_obj,
                        eval_promise: record.eval_promise,
                      })
                      Object(namespace_obj)
                    }
                    None => Object(record.exports)
                  }
              }
            ModuleState::Loading =>
              match record.module_ns {
                Some(namespace_obj) => Object(namespace_obj)
                None =>
                  match module_namespace_from_value(Object(record.exports)) {
                    Some(namespace_obj) => {
                      module_record_set(cache_key, ModuleRecord::{
                        exports: record.exports,
                        state: record.state,
                        module_ns: Some(namespace_obj),
                        meta_obj: record.meta_obj,
                        eval_promise: record.eval_promise,
                      })
                      Object(namespace_obj)
                    }
                    None => Object(record.exports)
                  }
              }
          }
        None =>
          if json_kind > 0 {
            let source = @fs.read_file_to_string(full_path) catch {
              _ => {
                let _ = throw_reference_error("could not load '\{specifier}'")
                ""
              }
            }
            let json_value = if json_kind == 2 {
              std_parse_ext_json(source)
            } else {
              json_parse_value(source)
            }
            let exports_value = new_object_value()
            let exports_obj = match exports_value {
              Object(obj) => obj
              _ => new_object_struct(None)
            }
            exports_obj.props.set("default", property_data(json_value))
            exports_obj.extensible = false
            let mut module_ns : ObjectValue? = None
            match module_namespace_from_value(Object(exports_obj)) {
              Some(namespace_obj) => module_ns = Some(namespace_obj)
              None => ()
            }
            module_record_set(cache_key, ModuleRecord::{
              exports: exports_obj,
              state: ModuleState::Loaded,
              module_ns,
              meta_obj: None,
              eval_promise: None,
            })
            match module_ns {
              Some(namespace_obj) => Object(namespace_obj)
              None => Object(exports_obj)
            }
          } else {
            let source = @fs.read_file_to_string(full_path) catch {
              _ => {
                let _ = throw_reference_error("could not load '\{specifier}'")
                ""
              }
            }
            let exports_obj = eval_module_source(source, full_path)
            match module_namespace_from_value(Object(exports_obj)) {
              Some(namespace_obj) => {
                match module_record_get(cache_key) {
                  Some(record) =>
                    module_record_set(cache_key, ModuleRecord::{
                      exports: record.exports,
                      state: record.state,
                      module_ns: Some(namespace_obj),
                      meta_obj: record.meta_obj,
                      eval_promise: record.eval_promise,
                    })
                  None => ()
                }
                Object(namespace_obj)
              }
              None => Object(exports_obj)
            }
          }
      }
    }
  }
}

///|
fn json_to_value(value : Json) -> Value {
  match value {
    Json::Null => Null
    Json::True => Bool(true)
    Json::False => Bool(false)
    Json::Number(num, ..) => Number(num)
    Json::String(text) => String(text)
    Json::Array(items) => {
      let elements : Array[Value?] = []
      for item in items {
        elements.push(Some(json_to_value(item)))
      }
      new_array_value(elements)
    }
    Json::Object(entries) => {
      let obj = new_object_value()
      match obj {
        Object(object) =>
          for key, entry in entries {
            object.props.set(key, property_data(json_to_value(entry)))
          }
        _ => ()
      }
      obj
    }
  }
}

///|
fn json_parse_error_pos(err : @json.ParseError) -> (Int, Int) {
  match err {
    @json.ParseError::InvalidChar(pos, _) => (pos.line, pos.column)
    @json.ParseError::InvalidNumber(pos, _) => (pos.line, pos.column)
    @json.ParseError::InvalidIdentEscape(pos) => (pos.line, pos.column)
    @json.ParseError::InvalidEof => (1, 0)
    @json.ParseError::DepthLimitExceeded => (1, 0)
  }
}

///|
fn offset_to_line_column(source : String, offset : Int) -> (Int, Int) {
  let len = source.length()
  let end = if offset < len { offset } else { len }
  let mut line = 1
  let mut column = 1
  let mut i = 0
  while i < end {
    let unit = UInt16::to_int(source.code_unit_at(i))
    if unit == Char::to_int('\n') {
      line = line + 1
      column = 1
    } else {
      column = column + 1
    }
    i = i + 1
  }
  (line, column)
}

///|
fn syntax_error_proto_for_parse() -> ObjectValue? {
  match current_env() {
    Some(env) =>
      match syntax_error_proto_for_env(env) {
        Some(proto) => Some(proto)
        None => syntax_error_proto()
      }
    None => syntax_error_proto()
  }
}

///|
fn parse_script_with_pos(source : String) -> @engine.Script raise {
  try @engine.parse(source) catch {
    err =>
      match err {
        @engine.ParseError::At(offset~, message~) => {
          let (line, column) = offset_to_line_column(source, offset)
          raise ThrowSignal(
            new_error_value_with_pos(
              syntax_error_proto_for_parse(),
              message,
              line,
              column,
            ),
          )
        }
        _ => raise err
      }
  } noraise {
    script => {
      validate_regexp_in_script(script)
      validate_context_in_script(script, false, false, false)
      script
    }
  }
}

///|
fn parse_script_with_pos_mode(
  source : String,
  force_module : Bool,
  force_strict : Bool,
) -> @engine.Script raise {
  try @engine.parse_with_mode(source, force_module, force_strict) catch {
    err =>
      match err {
        @engine.ParseError::At(offset~, message~) => {
          let (line, column) = offset_to_line_column(source, offset)
          raise ThrowSignal(
            new_error_value_with_pos(
              syntax_error_proto_for_parse(),
              message,
              line,
              column,
            ),
          )
        }
        _ => raise err
      }
  } noraise {
    script => {
      validate_regexp_in_script(script)
      if !force_module && script.is_module {
        let _ = throw_syntax_error("unexpected token")

      }
      script
    }
  }
}

///|
fn parse_script_with_pos_mode_private(
  source : String,
  force_module : Bool,
  force_strict : Bool,
  private_names : Array[String],
) -> @engine.Script raise {
  try
    @engine.parse_with_mode_private(
      source, force_module, force_strict, private_names,
    )
  catch {
    err =>
      match err {
        @engine.ParseError::At(offset~, message~) => {
          let (line, column) = offset_to_line_column(source, offset)
          raise ThrowSignal(
            new_error_value_with_pos(
              syntax_error_proto_for_parse(),
              message,
              line,
              column,
            ),
          )
        }
        _ => raise err
      }
  } noraise {
    script => {
      validate_regexp_in_script(script)
      if !force_module && script.is_module {
        let _ = throw_syntax_error("unexpected token")

      }
      script
    }
  }
}

///|
fn validate_regexp_literal(pattern : String, flags : String) -> Unit raise {
  let _ = regexp_data_from_pattern(pattern, flags)

}

///|
fn validate_regexp_in_script(script : @engine.Script) -> Unit raise {
  for stmt in script.body {
    validate_regexp_in_stmt(stmt)
  }
}

///|
fn validate_regexp_in_stmt(stmt : @engine.Stmt) -> Unit raise {
  match stmt {
    Empty => ()
    ExprStmt(expr) => validate_regexp_in_expr(expr)
    VarDecl(_, decls) =>
      for entry in decls {
        let (binding, init) = entry
        validate_regexp_in_binding(binding)
        match init {
          Some(value) => validate_regexp_in_expr(value)
          None => ()
        }
      }
    Block(body) =>
      for entry in body {
        validate_regexp_in_stmt(entry)
      }
    Label(_, body) => validate_regexp_in_stmt(body)
    FunctionDecl(def) => validate_regexp_in_function(def)
    ClassDecl(def) => validate_regexp_in_class(def)
    Return(value) =>
      match value {
        Some(expr) => validate_regexp_in_expr(expr)
        None => ()
      }
    If(cond, then_branch, else_branch) => {
      validate_regexp_in_expr(cond)
      validate_regexp_in_stmt(then_branch)
      match else_branch {
        Some(value) => validate_regexp_in_stmt(value)
        None => ()
      }
    }
    With(expr, body) => {
      validate_regexp_in_expr(expr)
      validate_regexp_in_stmt(body)
    }
    While(cond, body) => {
      validate_regexp_in_expr(cond)
      validate_regexp_in_stmt(body)
    }
    For(init, test_expr, update_expr, body) => {
      validate_regexp_in_for_init(init)
      match test_expr {
        Some(value) => validate_regexp_in_expr(value)
        None => ()
      }
      match update_expr {
        Some(value) => validate_regexp_in_expr(value)
        None => ()
      }
      validate_regexp_in_stmt(body)
    }
    ForIn(init, right, body) => {
      validate_regexp_in_for_init(init)
      validate_regexp_in_expr(right)
      validate_regexp_in_stmt(body)
    }
    ForOf(init, right, body) => {
      validate_regexp_in_for_init(init)
      validate_regexp_in_expr(right)
      validate_regexp_in_stmt(body)
    }
    ForAwaitOf(init, right, body) => {
      validate_regexp_in_for_init(init)
      validate_regexp_in_expr(right)
      validate_regexp_in_stmt(body)
    }
    DoWhile(body, cond) => {
      validate_regexp_in_stmt(body)
      validate_regexp_in_expr(cond)
    }
    Switch(discriminant, cases) => {
      validate_regexp_in_expr(discriminant)
      for entry in cases {
        validate_regexp_in_switch_case(entry)
      }
    }
    Throw(expr) => validate_regexp_in_expr(expr)
    Try(body, catch_clause, finally_clause) => {
      validate_regexp_in_stmt(body)
      match catch_clause {
        Some(value) => validate_regexp_in_stmt(value.body)
        None => ()
      }
      match finally_clause {
        Some(value) => validate_regexp_in_stmt(value)
        None => ()
      }
    }
    Break(_) => ()
    Continue(_) => ()
  }
}

///|
fn validate_regexp_in_for_init(init : @engine.ForInit) -> Unit raise {
  match init {
    None => ()
    Var(_, decls) =>
      for entry in decls {
        let (binding, init_expr) = entry
        validate_regexp_in_binding(binding)
        match init_expr {
          Some(value) => validate_regexp_in_expr(value)
          None => ()
        }
      }
    Expr(expr) => validate_regexp_in_expr(expr)
  }
}

///|
fn validate_regexp_in_switch_case(
  case_entry : @engine.SwitchCase,
) -> Unit raise {
  match case_entry {
    Case(test_expr, body) => {
      validate_regexp_in_expr(test_expr)
      for stmt in body {
        validate_regexp_in_stmt(stmt)
      }
    }
    Default(body) =>
      for stmt in body {
        validate_regexp_in_stmt(stmt)
      }
  }
}

///|
fn validate_regexp_in_function(def : @engine.FunctionDef) -> Unit raise {
  for param in def.params {
    validate_regexp_in_binding(param.binding)
  }
  for init in def.param_inits {
    match init {
      Some(value) => validate_regexp_in_expr(value)
      None => ()
    }
  }
  for stmt in def.body {
    validate_regexp_in_stmt(stmt)
  }
}

///|
fn validate_regexp_in_class(def : @engine.ClassDef) -> Unit raise {
  match def.super_class {
    Some(value) => validate_regexp_in_expr(value)
    None => ()
  }
  for member_ in def.body {
    validate_regexp_in_class_member(member_)
  }
}

///|
fn validate_regexp_in_class_member(member_ : @engine.ClassMember) -> Unit raise {
  match member_ {
    Method(key, def, _) => {
      validate_regexp_in_obj_key(key)
      validate_regexp_in_function(def)
    }
    Getter(key, def, _) => {
      validate_regexp_in_obj_key(key)
      validate_regexp_in_function(def)
    }
    Setter(key, def, _) => {
      validate_regexp_in_obj_key(key)
      validate_regexp_in_function(def)
    }
    Field(key, init, _) => {
      validate_regexp_in_obj_key(key)
      match init {
        Some(value) => validate_regexp_in_expr(value)
        None => ()
      }
    }
    StaticBlock(stmts) =>
      for stmt in stmts {
        validate_regexp_in_stmt(stmt)
      }
  }
}

///|
fn validate_regexp_in_binding(binding : @engine.VarBinding) -> Unit raise {
  match binding {
    Name(_) => ()
    ArrayPattern(items) =>
      for entry in items {
        validate_regexp_in_array_pattern_elem(entry)
      }
    ObjectPattern(items) =>
      for entry in items {
        validate_regexp_in_object_pattern_elem(entry)
      }
    Target(expr) => validate_regexp_in_expr(expr)
  }
}

///|
fn validate_regexp_in_array_pattern_elem(
  elem : @engine.ArrayPatternElem,
) -> Unit raise {
  match elem {
    Bind(binding, init) => {
      validate_regexp_in_binding(binding)
      match init {
        Some(value) => validate_regexp_in_expr(value)
        None => ()
      }
    }
    Rest(binding) => validate_regexp_in_binding(binding)
    Hole => ()
  }
}

///|
fn validate_regexp_in_object_pattern_elem(
  elem : @engine.ObjectPatternElem,
) -> Unit raise {
  match elem {
    Bind(key, binding, init) => {
      validate_regexp_in_obj_key(key)
      validate_regexp_in_binding(binding)
      match init {
        Some(value) => validate_regexp_in_expr(value)
        None => ()
      }
    }
    Rest(binding) => validate_regexp_in_binding(binding)
  }
}

///|
fn validate_regexp_in_obj_key(key : @engine.ObjKey) -> Unit raise {
  match key {
    Ident(_) => ()
    String(_) => ()
    Number(_) => ()
    Private(_) => ()
    Computed(expr) => validate_regexp_in_expr(expr)
  }
}

///|
fn validate_regexp_in_member_key(key : @engine.MemberKey) -> Unit raise {
  match key {
    Ident(_) => ()
    Private(_) => ()
    Computed(expr) => validate_regexp_in_expr(expr)
  }
}

///|
fn validate_regexp_in_chain_segment(
  segment : @engine.ChainSegment,
) -> Unit raise {
  match segment {
    Member(key, _, _) => validate_regexp_in_member_key(key)
    Call(args, _, _) =>
      for arg in args {
        validate_regexp_in_expr(arg)
      }
  }
}

///|
fn validate_regexp_in_object_prop(prop : @engine.ObjectProp) -> Unit raise {
  match prop {
    KeyValue(key, value) => {
      validate_regexp_in_obj_key(key)
      validate_regexp_in_expr(value)
    }
    Method(key, def) => {
      validate_regexp_in_obj_key(key)
      validate_regexp_in_function(def)
    }
    Shorthand(_) => ()
    Getter(key, def) => {
      validate_regexp_in_obj_key(key)
      validate_regexp_in_function(def)
    }
    Setter(key, def) => {
      validate_regexp_in_obj_key(key)
      validate_regexp_in_function(def)
    }
    Spread(expr) => validate_regexp_in_expr(expr)
  }
}

///|
fn validate_regexp_in_expr(expr : @engine.Expr) -> Unit raise {
  match expr {
    Number(_, _, _) => ()
    Bool(_) => ()
    Null => ()
    String(_, _, _) => ()
    TemplateLiteral(_, exprs) =>
      for entry in exprs {
        validate_regexp_in_expr(entry)
      }
    TaggedTemplate(tag, _, exprs) => {
      validate_regexp_in_expr(tag)
      for entry in exprs {
        validate_regexp_in_expr(entry)
      }
    }
    Regexp(pattern, flags, _) => validate_regexp_literal(pattern, flags)
    BigInt(_) => ()
    Ident(_, _) => ()
    This => ()
    Super => ()
    Yield(value, _) =>
      match value {
        Some(expr) => validate_regexp_in_expr(expr)
        None => ()
      }
    Await(value, _) => validate_regexp_in_expr(value)
    Unary(_, value, _) => validate_regexp_in_expr(value)
    Update(_, value, _, _) => validate_regexp_in_expr(value)
    NewTarget(_) => ()
    ImportMeta(_) => ()
    New(callee, args) => {
      validate_regexp_in_expr(callee)
      for arg in args {
        validate_regexp_in_expr(arg)
      }
    }
    Binary(_, left, right, _) => {
      validate_regexp_in_expr(left)
      validate_regexp_in_expr(right)
    }
    PrivateIn(_, rhs, _) => validate_regexp_in_expr(rhs)
    Conditional(test_expr, consequent, alternate) => {
      validate_regexp_in_expr(test_expr)
      validate_regexp_in_expr(consequent)
      validate_regexp_in_expr(alternate)
    }
    Sequence(items) =>
      for entry in items {
        validate_regexp_in_expr(entry)
      }
    Paren(inner) => validate_regexp_in_expr(inner)
    Assign(_, value, _, _) => validate_regexp_in_expr(value)
    AssignInvalid(lhs, rhs, _) => {
      validate_regexp_in_expr(lhs)
      validate_regexp_in_expr(rhs)
    }
    AssignArray(items, value) => {
      for entry in items {
        validate_regexp_in_array_pattern_elem(entry)
      }
      validate_regexp_in_expr(value)
    }
    AssignObject(items, value) => {
      for entry in items {
        validate_regexp_in_object_pattern_elem(entry)
      }
      validate_regexp_in_expr(value)
    }
    AssignOp(_, left, right, _) => {
      validate_regexp_in_expr(left)
      validate_regexp_in_expr(right)
    }
    AssignMember(obj, key, value, _) => {
      validate_regexp_in_expr(obj)
      validate_regexp_in_member_key(key)
      validate_regexp_in_expr(value)
    }
    Call(callee, args, _) => {
      validate_regexp_in_expr(callee)
      for arg in args {
        validate_regexp_in_expr(arg)
      }
    }
    Member(obj, key, _) => {
      validate_regexp_in_expr(obj)
      validate_regexp_in_member_key(key)
    }
    OptionalChain(base, segments) => {
      validate_regexp_in_expr(base)
      for entry in segments {
        validate_regexp_in_chain_segment(entry)
      }
    }
    FunctionExpr(def) => validate_regexp_in_function(def)
    ClassExpr(def) => validate_regexp_in_class(def)
    ObjectLiteral(props) =>
      for entry in props {
        validate_regexp_in_object_prop(entry)
      }
    ArrayLiteral(items) =>
      for entry in items {
        match entry {
          Some(value) => validate_regexp_in_expr(value)
          None => ()
        }
      }
    Spread(value) => validate_regexp_in_expr(value)
  }
}

///|
fn is_json_whitespace(code : Int) -> Bool {
  code == 0x0009 || code == 0x000A || code == 0x000D || code == 0x0020
}

///|
fn json_throw_syntax_error_at(
  text : String,
  index : Int,
  message : String,
) -> Unit raise {
  let (line, column) = offset_to_line_column(text, index)
  raise ThrowSignal(
    new_error_value_with_pos(syntax_error_proto(), message, line, column + 1),
  )
}

///|
fn json_validate_whitespace(text : String) -> Unit raise {
  let len = text.length()
  let mut i = 0
  let mut in_string = false
  let mut escaped = false
  let quote = Char::to_int('"')
  let backslash = Char::to_int('\\')
  while i < len {
    let unit = UInt16::to_int(text.code_unit_at(i))
    if in_string {
      if escaped {
        escaped = false
      } else if unit == backslash {
        escaped = true
      } else if unit == quote {
        in_string = false
      }
    } else if unit == quote {
      in_string = true
    } else if is_js_whitespace(unit) && !is_json_whitespace(unit) {
      json_throw_syntax_error_at(text, i, "invalid JSON whitespace")
    }
    i = i + 1
  }
}

///|
fn json_number_negative_zero_flags(text : String) -> Array[Bool] {
  let flags : Array[Bool] = []
  let len = text.length()
  let mut i = 0
  let mut in_string = false
  let mut escaped = false
  let quote = Char::to_int('"')
  let backslash = Char::to_int('\\')
  let minus = Char::to_int('-')
  let dot = Char::to_int('.')
  let zero = Char::to_int('0')
  let nine = Char::to_int('9')
  let lower_e = Char::to_int('e')
  let upper_e = Char::to_int('E')
  let plus = Char::to_int('+')
  while i < len {
    let unit = UInt16::to_int(text.code_unit_at(i))
    if in_string {
      if escaped {
        escaped = false
      } else if unit == backslash {
        escaped = true
      } else if unit == quote {
        in_string = false
      }
      i = i + 1
      continue
    }
    if unit == quote {
      in_string = true
      i = i + 1
      continue
    }
    if unit == minus || (unit >= zero && unit <= nine) {
      let mut negative = false
      let mut has_non_zero = false
      if unit == minus {
        negative = true
        i = i + 1
      }
      if i >= len {
        flags.push(false)
        break
      }
      let int_unit = UInt16::to_int(text.code_unit_at(i))
      if int_unit == zero {
        i = i + 1
      } else {
        let mut digit_unit = int_unit
        while digit_unit >= zero && digit_unit <= nine {
          if digit_unit != zero {
            has_non_zero = true
          }
          i = i + 1
          if i >= len {
            break
          }
          digit_unit = UInt16::to_int(text.code_unit_at(i))
        }
      }
      if i < len && UInt16::to_int(text.code_unit_at(i)) == dot {
        i = i + 1
        while i < len {
          let frac_unit = UInt16::to_int(text.code_unit_at(i))
          if frac_unit < zero || frac_unit > nine {
            break
          }
          if frac_unit != zero {
            has_non_zero = true
          }
          i = i + 1
        }
      }
      if i < len {
        let exp_unit = UInt16::to_int(text.code_unit_at(i))
        if exp_unit == lower_e || exp_unit == upper_e {
          i = i + 1
          if i < len {
            let sign_unit = UInt16::to_int(text.code_unit_at(i))
            if sign_unit == plus || sign_unit == minus {
              i = i + 1
            }
          }
          while i < len {
            let exp_digit = UInt16::to_int(text.code_unit_at(i))
            if exp_digit < zero || exp_digit > nine {
              break
            }
            i = i + 1
          }
        }
      }
      flags.push(negative && !has_non_zero)
      continue
    }
    i = i + 1
  }
  flags
}

///|
fn json_to_value_with_number_flags(
  value : Json,
  flags : Array[Bool],
  index : Int,
) -> (Value, Int) {
  match value {
    Json::Null => (Null, index)
    Json::True => (Bool(true), index)
    Json::False => (Bool(false), index)
    Json::Number(num, ..) => {
      let use_negative_zero = index < flags.length() && flags[index]
      let number_value = if use_negative_zero { negative_zero() } else { num }
      (Number(number_value), index + 1)
    }
    Json::String(text) => (String(text), index)
    Json::Array(items) => {
      let elements : Array[Value?] = []
      let mut current = index
      for item in items {
        let (value_item, next) = json_to_value_with_number_flags(
          item, flags, current,
        )
        current = next
        elements.push(Some(value_item))
      }
      (new_array_value(elements), current)
    }
    Json::Object(entries) => {
      let obj = new_object_value()
      let mut current = index
      match obj {
        Object(object) =>
          for key, entry in entries {
            let (value_entry, next) = json_to_value_with_number_flags(
              entry, flags, current,
            )
            current = next
            object.props.set(key, property_data(value_entry))
          }
        _ => ()
      }
      (obj, current)
    }
  }
}

///|
fn json_parse_text(text : String) -> Value raise {
  json_validate_whitespace(text)
  let json = @json.parse(text[:]) catch {
    err => {
      let (line, column) = json_parse_error_pos(err)
      raise ThrowSignal(
        new_error_value_with_pos(
          syntax_error_proto(),
          err.to_string(),
          line,
          column + 1,
        ),
      )
      Json::null()
    }
  }
  let flags = json_number_negative_zero_flags(text)
  let (value, _) = json_to_value_with_number_flags(json, flags, 0)
  value
}

///|
fn json_internalize_property(
  holder : Value,
  name : String,
  reviver : Value,
) -> Value raise {
  let val = property_get(holder, name)
  if is_object_like(val) {
    let is_array = is_array_value(val)
    if is_array {
      let len_value = property_get(val, "length")
      let len = to_length_int64(to_number(len_value))
      let mut i : Int64 = 0
      while i < len {
        let key = Int64::to_string(i)
        let new_element = json_internalize_property(val, key, reviver)
        if new_element is Undefined {
          let _ = delete_property_value(val, key)

        } else {
          let _ = create_data_property(val, key, new_element)

        }
        i = i + 1
      }
    } else {
      let keys = own_enumerable_string_keys(val)
      for key in keys {
        let new_element = json_internalize_property(val, key, reviver)
        if new_element is Undefined {
          let _ = delete_property_value(val, key)

        } else {
          let _ = create_data_property(val, key, new_element)

        }
      }
    }
  }
  call_value_with_this(reviver, [String(name), val], holder)
}

///|
fn json_parse_with_reviver(text_value : Value, reviver : Value) -> Value raise {
  let text = to_string_strict(text_value)
  let parsed = json_parse_text(text)
  if is_callable(reviver) {
    let root = new_object_value()
    create_data_property_or_throw(root, "", parsed)
    return json_internalize_property(root, "", reviver)
  }
  parsed
}

///|
fn json_parse_value(text : String) -> Value raise {
  json_parse_text(text)
}

///|
fn string_array_value(items : Array[String]) -> Value {
  let elements : Array[Value?] = []
  for item in items {
    elements.push(Some(String(item)))
  }
  new_array_value(elements)
}

///|
fn value_array_to_strings(value : Value) -> Array[String] raise {
  let arr = require_array_buffer_array(value)
  let items : Array[String] = []
  let mut i = 0
  while i < arr.elements.length() {
    let text = match arr.elements[i] {
      Some(v) => to_string_value(v)
      None => ""
    }
    items.push(text)
    i = i + 1
  }
  items
}

///|
fn std_load_file(path : String) -> Value {
  let full_path = resolve_path(path)
  try {
    let text = @fs.read_file_to_string(full_path)
    String(text)
  } catch {
    _ => Null
  }
}

///|
fn std_load_script(path : String) -> Value raise {
  let full_path = resolve_path(path)
  let source = @fs.read_file_to_string(full_path) catch {
    _ => {
      let _ = throw_reference_error("could not load '\{path}'")
      ""
    }
  }
  let script = parse_script_with_pos(source)
  match root_env() {
    Some(env) =>
      with_source_path(full_path, fn() raise { eval_script(env, script) })
    None => Undefined
  }
}

///|
fn std_open_file(path : String, mode : String) -> Value {
  let readable = mode.contains("r") || mode.contains("+")
  let writable = mode.contains("w") || mode.contains("a") || mode.contains("+")
  let truncate = mode.contains("w")
  let create = writable
  let full_path = resolve_path(path)
  match open_file_handle(full_path, readable, writable, truncate, create) {
    Some(fd) => new_file_object(fd)
    None => Null
  }
}

///|
fn std_tmpfile() -> Value {
  new_file_object(tmp_file_handle())
}

///|
fn std_popen(command : String, mode : String) -> Value {
  if !mode.contains("r") {
    return Null
  }
  let mut output = ""
  if command.has_prefix("cat ") && command.length() > 4 {
    let name = command.unsafe_substring(start=4, end=command.length())
    match std_load_file(name) {
      String(text) => output = text
      _ => output = ""
    }
  }
  let fd = tmp_file_handle()
  let bytes = bytes_from_string(output)
  let _ = fd_write_bytes(fd, bytes, 0, bytes.length())
  let _ = fd_seek(fd, 0, seek_set)
  new_file_object(fd)
}

///|
fn std_fdopen(fd : Int, _mode : String) -> Value {
  match get_fd_handle(fd) {
    Some(_) => new_file_object(fd)
    None => Null
  }
}

///|
fn std_parse_ext_json(text : String) -> Value raise {
  let normalized = normalize_ext_json(text)
  let json = @json5.parse(normalized) catch {
    err => {
      let _ = throw_syntax_error(err.to_string())
      Json::null()
    }
  }
  json_to_value(json)
}

///|
fn is_octal_digit(ch : Char) -> Bool {
  ch >= '0' && ch <= '7'
}

///|
fn normalize_ext_json(text : String) -> String {
  let chars : Array[Char] = []
  for ch in text {
    chars.push(ch)
  }
  let sb = StringBuilder::new()
  let len = chars.length()
  let mut i = 0
  let mut in_single = false
  let mut in_double = false
  let mut in_line_comment = false
  let mut in_block_comment = false
  let mut escape = false
  while i < len {
    let ch = chars[i]
    if ch == '\\' && i + 1 < len {
      let next = chars[i + 1]
      if next == '\n' || next == '\r' {
        i = i + 2
        if next == '\r' && i < len && chars[i] == '\n' {
          i = i + 1
        }
        while i < len && (chars[i] == ' ' || chars[i] == '\t') {
          i = i + 1
        }
        continue
      }
    }
    if in_line_comment {
      sb.write_char(ch)
      if ch == '\n' {
        in_line_comment = false
      }
      i = i + 1
      continue
    }
    if in_block_comment {
      sb.write_char(ch)
      if ch == '*' && i + 1 < len && chars[i + 1] == '/' {
        sb.write_char('/')
        i = i + 2
        in_block_comment = false
        continue
      }
      i = i + 1
      continue
    }
    if in_single || in_double {
      if ch == '\n' || ch == '\r' {
        i = i + 1
        if ch == '\r' && i < len && chars[i] == '\n' {
          i = i + 1
        }
        while i < len && (chars[i] == ' ' || chars[i] == '\t') {
          i = i + 1
        }
        continue
      }
      if ch == '\\' && i + 1 < len {
        let next = chars[i + 1]
        if next == '\n' || next == '\r' {
          i = i + 2
          if next == '\r' && i < len && chars[i] == '\n' {
            i = i + 1
          }
          while i < len && (chars[i] == ' ' || chars[i] == '\t') {
            i = i + 1
          }
          continue
        }
      }
      sb.write_char(ch)
      if escape {
        escape = false
        i = i + 1
        continue
      }
      if ch == '\\' {
        escape = true
        i = i + 1
        continue
      }
      if in_single && ch == '\'' {
        in_single = false
      } else if in_double && ch == '"' {
        in_double = false
      }
      i = i + 1
      continue
    }
    if ch == '/' && i + 1 < len {
      let next = chars[i + 1]
      if next == '/' {
        in_line_comment = true
        sb.write_char(ch)
        sb.write_char(next)
        i = i + 2
        continue
      }
      if next == '*' {
        in_block_comment = true
        sb.write_char(ch)
        sb.write_char(next)
        i = i + 2
        continue
      }
    }
    if ch == '\'' {
      in_single = true
      sb.write_char(ch)
      i = i + 1
      continue
    }
    if ch == '"' {
      in_double = true
      sb.write_char(ch)
      i = i + 1
      continue
    }
    if ch == '0' && i + 1 < len && (chars[i + 1] == 'o' || chars[i + 1] == 'O') {
      let mut j = i + 2
      if j < len && is_octal_digit(chars[j]) {
        let mut value = 0L
        while j < len && is_octal_digit(chars[j]) {
          let digit = Int64::from_int(chars[j].to_int() - '0'.to_int())
          value = value * 8L + digit
          j = j + 1
        }
        sb.write_string(Int64::to_string(value))
        i = j
        continue
      }
    }
    sb.write_char(ch)
    i = i + 1
  }
  sb.to_string()
}

///|
fn repeat_char(ch : Char, count : Int) -> String {
  let sb = StringBuilder::new()
  let mut i = 0
  while i < count {
    sb.write_char(ch)
    i = i + 1
  }
  sb.to_string()
}

///|
fn pad_left(text : String, width : Int, pad : Char) -> String {
  if text.length() >= width {
    return text
  }
  let needed = width - text.length()
  if pad == '0' && text.has_prefix("-") {
    "-" +
    repeat_char(pad, needed) +
    text.unsafe_substring(start=1, end=text.length())
  } else {
    repeat_char(pad, needed) + text
  }
}

///|
fn hex_digit(value : Int) -> Char {
  let code = if value < 10 { 48 + value } else { 87 + value }
  match Int::to_char(code) {
    Some(ch) => ch
    None => '0'
  }
}

///|
fn format_hex_uint64(value : UInt64) -> String {
  if value == 0UL {
    return "0"
  }
  let mut v = value
  let digits : Array[Char] = []
  while v > 0UL {
    let digit = UInt64::to_int(v & 15UL)
    digits.push(hex_digit(digit))
    v = v >> 4
  }
  let sb = StringBuilder::new()
  let mut i = digits.length()
  while i > 0 {
    i = i - 1
    sb.write_char(digits[i])
  }
  sb.to_string()
}

///|
fn format_hex_uint(value : UInt) -> String {
  format_hex_uint64(UInt::to_uint64(value))
}

///|
fn pow10_int(exp : Int) -> Int64 {
  let mut value = 1L
  let mut i = 0
  while i < exp {
    value = value * 10L
    i = i + 1
  }
  value
}

///|
fn format_float_fixed(value : Double, precision : Int) -> String {
  let negative = value < 0.0
  let abs_value = Double::abs(value)
  let scale = pow10_int(precision)
  let scaled = abs_value * scale.to_double()
  let rounded = Double::floor(scaled + 0.5)
  let scaled_int = Double::to_int64(rounded)
  let int_part = scaled_int / scale
  let frac_part = scaled_int % scale
  let int_str = int_part.to_string()
  if precision == 0 {
    if negative {
      "-" + int_str
    } else {
      int_str
    }
  } else {
    let frac_str = pad_left(frac_part.to_string(), precision, '0')
    let result = "\{int_str}.\{frac_str}"
    if negative {
      "-" + result
    } else {
      result
    }
  }
}

///|
fn std_sprintf(args : Array[Value]) -> Value raise {
  if args.is_empty() {
    return String("")
  }
  let format = to_string_value(args[0])
  let chars : Array[Char] = []
  for ch in format {
    chars.push(ch)
  }
  let sb = StringBuilder::new()
  let mut i = 0
  let mut arg_index = 1
  while i < chars.length() {
    let ch = chars[i]
    if ch != '%' {
      sb.write_char(ch)
      i = i + 1
      continue
    }
    if i + 1 < chars.length() && chars[i + 1] == '%' {
      sb.write_char('%')
      i = i + 2
      continue
    }
    i = i + 1
    let mut zero_pad = false
    let mut alt = false
    while i < chars.length() {
      match chars[i] {
        '0' => {
          zero_pad = true
          i = i + 1
        }
        '#' => {
          alt = true
          i = i + 1
        }
        _ => break
      }
    }
    let mut width = 0
    if i < chars.length() && chars[i] == '*' {
      if arg_index < args.length() {
        width = to_int32(to_number(args[arg_index]))
      }
      arg_index = arg_index + 1
      i = i + 1
    } else {
      while i < chars.length() && chars[i] >= '0' && chars[i] <= '9' {
        width = width * 10 + (chars[i].to_int() - '0'.to_int())
        i = i + 1
      }
    }
    let mut precision : Int? = None
    if i < chars.length() && chars[i] == '.' {
      i = i + 1
      if i < chars.length() && chars[i] == '*' {
        if arg_index < args.length() {
          precision = Some(to_int32(to_number(args[arg_index])))
        } else {
          precision = Some(0)
        }
        arg_index = arg_index + 1
        i = i + 1
      } else {
        let mut prec = 0
        while i < chars.length() && chars[i] >= '0' && chars[i] <= '9' {
          prec = prec * 10 + (chars[i].to_int() - '0'.to_int())
          i = i + 1
        }
        precision = Some(prec)
      }
    }
    let mut long = false
    if i < chars.length() && chars[i] == 'l' {
      long = true
      i = i + 1
    }
    if i >= chars.length() {
      break
    }
    let spec = chars[i]
    i = i + 1
    let value = if arg_index < args.length() {
      args[arg_index]
    } else {
      Undefined
    }
    arg_index = arg_index + 1
    let mut rendered = ""
    match spec {
      's' => rendered = to_string_value(value)
      'd' => {
        let num = to_int32(to_number(value))
        rendered = num.to_string()
      }
      'x' => {
        let num = to_uint32(to_number(value))
        rendered = format_hex_uint(num)
      }
      'f' => {
        let prec = match precision {
          Some(p) => p
          None => 6
        }
        rendered = format_float_fixed(to_number(value), prec)
      }
      _ => if spec == 'x' && long { rendered = "0" }
    }
    if long && spec == 'x' {
      match value {
        BigInt(big) => rendered = bigint_to_string_radix(big, 16)
        _ => {
          let num = Double::to_int64(Double::trunc(to_number(value)))
          let bits = Int64::reinterpret_as_uint64(num)
          rendered = format_hex_uint64(bits)
        }
      }
    }
    if alt && spec == 'x' {
      rendered = "0x" + rendered
    }
    if width > 0 {
      let pad = if zero_pad { '0' } else { ' ' }
      rendered = pad_left(rendered, width, pad)
    }
    sb.write_string(rendered)
  }
  String(sb.to_string())
}

///|
fn generator_next_object(obj : ObjectValue, arg : Value) -> Value raise {
  let (value, done) = generator_step_result(obj, GenResume::Next(arg))
  let raw = take_yield_star_raw()
  if !done && raw {
    return value
  }
  generator_result_object(value, done)
}

///|
fn generator_return_object(obj : ObjectValue, arg : Value) -> Value raise {
  let (value, done) = generator_step_result(obj, GenResume::Return(arg))
  let raw = take_yield_star_raw()
  if !done && raw {
    return value
  }
  generator_result_object(value, done)
}

///|
fn generator_throw_object(obj : ObjectValue, arg : Value) -> Value raise {
  let (value, done) = generator_step_result(obj, GenResume::Throw(arg))
  let raw = take_yield_star_raw()
  if !done && raw {
    return value
  }
  generator_result_object(value, done)
}

///|
fn async_generator_request(
  this_value : Value?,
  resume_state : GenResume,
) -> Value raise {
  let (promise, resolve, reject) = new_promise_capability(Undefined)
  match this_value {
    Some(Object(obj)) =>
      match obj.async_generator_data {
        Some(data) =>
          async_generator_enqueue_request(
            obj, data, resume_state, promise, resolve, reject,
          )
        None => {
          let err = type_error_value("not an AsyncGenerator object")
          let _ = call_value_with_this(reject, [err], Undefined)

        }
      }
    _ => {
      let err = type_error_value("not an AsyncGenerator object")
      let _ = call_value_with_this(reject, [err], Undefined)

    }
  }
  promise
}

///|
fn async_generator_enqueue_request(
  obj : ObjectValue,
  data : AsyncGeneratorData,
  resume_state : GenResume,
  promise : Value,
  resolve : Value,
  reject : Value,
) -> Unit raise {
  data.queue.push(AsyncGeneratorRequest::{
    resume_state,
    promise,
    resolve,
    reject,
  })
  if !(data.state is AsyncGeneratorState::Executing) {
    async_generator_resume_next(obj, None)
  }
}

///|
fn async_generator_queue_empty(data : AsyncGeneratorData) -> Bool {
  data.queue_index >= data.queue.length()
}

///|
fn async_generator_queue_peek(
  data : AsyncGeneratorData,
) -> AsyncGeneratorRequest? {
  if async_generator_queue_empty(data) {
    None
  } else {
    Some(data.queue[data.queue_index])
  }
}

///|
fn async_generator_queue_pop(
  data : AsyncGeneratorData,
) -> AsyncGeneratorRequest? {
  if async_generator_queue_empty(data) {
    None
  } else {
    let request = data.queue[data.queue_index]
    data.queue_index = data.queue_index + 1
    Some(request)
  }
}

///|
fn async_generator_resolve_or_reject(
  data : AsyncGeneratorData,
  result : Value,
  is_reject : Bool,
) -> Unit raise {
  match async_generator_queue_pop(data) {
    Some(request) => {
      let handler = if is_reject { request.reject } else { request.resolve }
      let _ = call_value_with_this(handler, [result], Undefined)

    }
    None => ()
  }
}

///|
fn async_generator_resolve(
  data : AsyncGeneratorData,
  value : Value,
  done : Bool,
) -> Unit raise {
  let result = generator_result_object(value, done)
  async_generator_resolve_or_reject(data, result, false)
}

///|
fn async_generator_reject(
  data : AsyncGeneratorData,
  exception : Value,
) -> Unit raise {
  async_generator_resolve_or_reject(data, exception, true)
}

///|
fn async_generator_complete(
  obj : ObjectValue,
  data : AsyncGeneratorData,
) -> Unit {
  match data.state {
    AsyncGeneratorState::Completed => ()
    _ => data.state = AsyncGeneratorState::Completed
  }
  match obj.generator_data {
    Some(gen_data) => gen_data.state = GeneratorState::Completed
    None => ()
  }
}

///|
fn new_async_generator_resolve_function(
  generator : ObjectValue,
  resume_next : Bool,
  is_reject : Bool,
) -> Value {
  let func = new_builtin_value(BuiltinFunction::AsyncGeneratorResolveFunction)
  match func {
    Builtin(builtin) =>
      async_generator_resolve_func_data_set(builtin.id, AsyncGeneratorResolveFunctionData::{
        generator: Object(generator),
        resume_next,
        is_reject,
      })
    _ => ()
  }
  func
}

///|
fn new_async_generator_resolve_functions(
  generator : ObjectValue,
  resume_next : Bool,
) -> (Value, Value) {
  let resolve = new_async_generator_resolve_function(
    generator, resume_next, false,
  )
  let reject = new_async_generator_resolve_function(
    generator, resume_next, true,
  )
  (resolve, reject)
}

///|
fn async_generator_completed_return(
  obj : ObjectValue,
  data : AsyncGeneratorData,
  value : Value,
) -> Unit raise {
  let promise_ctor = promise_ctor_value_for_current_env()
  let mut promise = Undefined
  try {
    promise = promise_resolve_value(promise_ctor, value, false)
  } catch {
    ThrowSignal(err) => promise = promise_resolve_value(promise_ctor, err, true)
    err => raise err
  }
  match promise_data_from_value(promise) {
    Some(promise_data) => {
      let (resolve, reject) = new_async_generator_resolve_functions(obj, true)
      perform_promise_then(
        promise,
        promise_data,
        resolve,
        reject,
        Undefined,
        Undefined,
      )
    }
    None => {
      let _ = throw_type_error("not a Promise")

    }
  }
  let _ = data

}

///|
fn async_generator_await(obj : ObjectValue, value : Value) -> Unit raise {
  let promise_ctor = promise_ctor_value_for_current_env()
  let promise = promise_resolve_value(promise_ctor, value, false)
  match promise_data_from_value(promise) {
    Some(promise_data) => {
      let (resolve, reject) = new_async_generator_resolve_functions(obj, false)
      perform_promise_then(
        promise,
        promise_data,
        resolve,
        reject,
        Undefined,
        Undefined,
      )
    }
    None => {
      let _ = throw_type_error("not a Promise")

    }
  }
}

///|
fn async_generator_resume_next(
  obj : ObjectValue,
  resume_override : GenResume?,
) -> Unit raise {
  let data = match obj.async_generator_data {
    Some(data) => data
    None => return
  }
  let gen_data = match obj.generator_data {
    Some(gen_data) => gen_data
    None => return
  }
  let mut resume_from_await = resume_override
  while !async_generator_queue_empty(data) {
    match data.state {
      AsyncGeneratorState::Executing =>
        match resume_from_await {
          Some(resume_state) => {
            resume_from_await = None
            let step = generator_step_exec_raw(gen_data, resume_state) catch {
              ThrowSignal(value) => {
                data.state = AsyncGeneratorState::Completed
                async_generator_reject(data, value)
                continue
              }
              err => raise err
            }
            match step {
              Yield(value, _) => {
                data.state = AsyncGeneratorState::SuspendedYield
                async_generator_resolve(data, value, false)
              }
              Await(value, _) =>
                try {
                  async_generator_await(obj, value)
                  return
                } catch {
                  ThrowSignal(err) => {
                    resume_from_await = Some(GenResume::Throw(err))
                    continue
                  }
                  err => raise err
                }
              Done(control) => {
                data.state = AsyncGeneratorState::Completed
                match control {
                  Normal(value) => async_generator_resolve(data, value, true)
                  Return(value) => async_generator_resolve(data, value, true)
                  Throw(value) => async_generator_reject(data, value)
                  Break(_, _) =>
                    async_generator_reject(
                      data,
                      type_error_value("invalid break in generator"),
                    )
                  Continue(_, _) =>
                    async_generator_reject(
                      data,
                      type_error_value("invalid continue in generator"),
                    )
                }
              }
            }
            continue
          }
          None => return
        }
      AsyncGeneratorState::AwaitingReturn => return
      AsyncGeneratorState::SuspendedStart => {
        let request = match async_generator_queue_peek(data) {
          Some(request) => request
          None => return
        }
        match request.resume_state {
          GenResume::Next(_) => ()
          _ => {
            async_generator_complete(obj, data)
            continue
          }
        }
      }
      AsyncGeneratorState::Completed => {
        let request = match async_generator_queue_peek(data) {
          Some(request) => request
          None => return
        }
        match request.resume_state {
          GenResume::Next(_) => async_generator_resolve(data, Undefined, true)
          GenResume::Return(value) => {
            data.state = AsyncGeneratorState::AwaitingReturn
            async_generator_completed_return(obj, data, value) catch {
              ThrowSignal(err) => {
                data.state = AsyncGeneratorState::Completed
                async_generator_reject(data, err)
              }
              err => raise err
            }
          }
          GenResume::Throw(value) => async_generator_reject(data, value)
        }
        return
      }
      AsyncGeneratorState::SuspendedYield => ()
    }
    let request = match async_generator_queue_peek(data) {
      Some(request) => request
      None => return
    }
    data.state = AsyncGeneratorState::Executing
    let step = generator_step_exec_raw(gen_data, request.resume_state) catch {
      ThrowSignal(value) => {
        data.state = AsyncGeneratorState::Completed
        async_generator_reject(data, value)
        continue
      }
      err => raise err
    }
    match step {
      Yield(value, _) => {
        data.state = AsyncGeneratorState::SuspendedYield
        async_generator_resolve(data, value, false)
      }
      Await(value, _) =>
        try {
          async_generator_await(obj, value)
          return
        } catch {
          ThrowSignal(err) => {
            resume_from_await = Some(GenResume::Throw(err))
            continue
          }
          err => raise err
        }
      Done(control) => {
        data.state = AsyncGeneratorState::Completed
        match control {
          Normal(value) => async_generator_resolve(data, value, true)
          Return(value) => async_generator_resolve(data, value, true)
          Throw(value) => async_generator_reject(data, value)
          Break(_, _) =>
            async_generator_reject(
              data,
              type_error_value("invalid break in generator"),
            )
          Continue(_, _) =>
            async_generator_reject(
              data,
              type_error_value("invalid continue in generator"),
            )
        }
      }
    }
  }
}

///|
fn new_async_function_resolve_function(
  generator : ObjectValue,
  is_reject : Bool,
) -> Value {
  let func = new_builtin_value(BuiltinFunction::AsyncFunctionResolveFunction)
  match func {
    Builtin(builtin) =>
      async_function_resolve_func_data_set(builtin.id, AsyncFunctionResolveFunctionData::{
        generator: Object(generator),
        is_reject,
      })
    _ => ()
  }
  func
}

///|
fn new_async_function_resolve_functions(
  generator : ObjectValue,
) -> (Value, Value) {
  let resolve = new_async_function_resolve_function(generator, false)
  let reject = new_async_function_resolve_function(generator, true)
  (resolve, reject)
}

///|
fn async_function_await(obj : ObjectValue, value : Value) -> Unit raise {
  let promise_ctor = promise_ctor_value_for_current_env()
  let promise = promise_resolve_value(promise_ctor, value, false)
  match promise_data_from_value(promise) {
    Some(promise_data) => {
      let (resolve, reject) = new_async_function_resolve_functions(obj)
      perform_promise_then(
        promise,
        promise_data,
        resolve,
        reject,
        Undefined,
        Undefined,
      )
    }
    None => {
      let _ = throw_type_error("not a Promise")

    }
  }
}

///|
fn async_function_resume(
  obj : ObjectValue,
  resume_state : GenResume,
) -> Unit raise {
  let gen_data = match obj.generator_data {
    Some(data) => data
    None => return
  }
  let async_data = match async_function_data_get(obj.id) {
    Some(data) => data
    None => return
  }
  let step = generator_step_exec_raw(gen_data, resume_state) catch {
    ThrowSignal(err) => {
      async_function_data_clear(obj.id)
      let _ = call_value_with_this(async_data.reject, [err], Undefined)
      return
    }
    err => raise err
  }
  match step {
    Yield(_, _) => {
      async_function_data_clear(obj.id)
      let _ = call_value_with_this(
        async_data.reject,
        [type_error_value("yield in async function")],
        Undefined,
      )

    }
    Await(value, _) =>
      async_function_await(obj, value) catch {
        ThrowSignal(err) => {
          async_function_data_clear(obj.id)
          let _ = call_value_with_this(async_data.reject, [err], Undefined)

        }
        err => raise err
      }
    Done(control) => {
      async_function_data_clear(obj.id)
      match control {
        Normal(value) => {
          let _ = call_value_with_this(async_data.resolve, [value], Undefined)

        }
        Return(value) => {
          let _ = call_value_with_this(async_data.resolve, [value], Undefined)

        }
        Throw(value) => {
          let _ = call_value_with_this(async_data.reject, [value], Undefined)

        }
        Break(_, _) => fail("illegal break")
        Continue(_, _) => fail("illegal continue")
      }
    }
  }
}

///|
fn generator_step_result(
  obj : ObjectValue,
  resume_state : GenResume,
) -> (Value, Bool) raise {
  match obj.generator_data {
    Some(data) =>
      match data.state {
        GeneratorState::Executing => {
          let _ = throw_type_error("cannot invoke a running generator")
          (Undefined, true)
        }
        GeneratorState::Completed =>
          match resume_state {
            GenResume::Next(_) => (Undefined, true)
            GenResume::Return(value) => (value, true)
            GenResume::Throw(value) => raise ThrowSignal(value)
          }
        GeneratorState::SuspendedStart =>
          match resume_state {
            GenResume::Next(_) =>
              generator_step_exec(data, GenResume::Next(Undefined))
            GenResume::Return(value) => {
              data.state = GeneratorState::Completed
              (value, true)
            }
            GenResume::Throw(value) => {
              data.state = GeneratorState::Completed
              raise ThrowSignal(value)
            }
          }
        _ => generator_step_exec(data, resume_state)
      }
    None => {
      let _ = throw_type_error("not a generator")
      (Undefined, true)
    }
  }
}

///|
fn generator_step_exec_raw(
  data : GeneratorData,
  resume_state : GenResume,
) -> GenStep raise {
  data.state = GeneratorState::Executing
  try {
    let func_var_names = compute_annex_b_var_func_decls(
      data.func.body,
      data.func.is_strict,
      annex_b_param_names_for_func(data.func),
      !data.func.is_arrow,
    )
    let step = with_function_source_step(data.func, fn() raise {
      with_annex_b_var_func_decls(func_var_names, fn() raise {
        with_current_function_step(data.func, fn() raise {
          with_current_generator_data_step(data, fn() raise {
            with_env_step(data.env, fn() raise {
              (data.next_step)(resume_state)
            })
          })
        })
      })
    })
    match step {
      Yield(value, next_step) => {
        data.next_step = next_step
        data.state = GeneratorState::SuspendedYield
        Yield(value, next_step)
      }
      Await(value, next_step) => {
        data.next_step = next_step
        Await(value, next_step)
      }
      Done(control) => {
        data.state = GeneratorState::Completed
        Done(control)
      }
    }
  } catch {
    ThrowSignal(value) => {
      data.state = GeneratorState::Completed
      raise ThrowSignal(value)
    }
    err => raise err
  }
}

///|
fn generator_step_exec(
  data : GeneratorData,
  resume_state : GenResume,
) -> (Value, Bool) raise {
  let step = generator_step_exec_raw(data, resume_state)
  match step {
    Yield(value, _) => (value, false)
    Await(_, _) => {
      data.state = GeneratorState::Completed
      let _ = throw_type_error("await not supported")
      (Undefined, true)
    }
    Done(control) =>
      match control {
        Normal(value) => (value, true)
        Return(value) => (value, true)
        Throw(value) => raise ThrowSignal(value)
        Break(_, _) => {
          let _ = throw_type_error("invalid break in generator")
          (Undefined, true)
        }
        Continue(_, _) => {
          let _ = throw_type_error("invalid continue in generator")
          (Undefined, true)
        }
      }
  }
}

///|
fn generator_result_object(value : Value, done : Bool) -> Value {
  let result = new_object_value()
  match result {
    Object(obj) => {
      obj.props.set("value", property_data(value))
      obj.props.set("done", property_data(Bool(done)))
    }
    _ => ()
  }
  result
}

///|
fn same_value_zero(a : Value, b : Value) -> Bool {
  match (a, b) {
    (Number(x), Number(y)) =>
      if Double::is_nan(x) && Double::is_nan(y) {
        true
      } else {
        Double::equal(x, y)
      }
    _ => strict_eq(a, b)
  }
}

///|
fn is_negative_zero(value : Double) -> Bool {
  value == 0.0 && Double::reinterpret_as_uint64(value) == 0x8000000000000000UL
}

///|
fn map_normalize_key(key : Value) -> Value {
  match key {
    Number(num) => if is_negative_zero(num) { Number(0.0) } else { key }
    _ => key
  }
}

///|
fn same_value(a : Value, b : Value) -> Bool {
  match (a, b) {
    (Number(x), Number(y)) =>
      if Double::is_nan(x) && Double::is_nan(y) {
        true
      } else if x == 0.0 && y == 0.0 {
        is_negative_zero(x) == is_negative_zero(y)
      } else {
        Double::equal(x, y)
      }
    _ => strict_eq(a, b)
  }
}

///|
fn is_weakref_target(value : Value) -> Bool {
  match value {
    Symbol(symbol) => symbol.key is None
    _ => is_object_like(value)
  }
}

///|
fn map_find_index(entries : Array[(Value, Value)?], key : Value) -> Int? {
  let mut index = 0
  for entry in entries {
    match entry {
      Some((k, _)) => if same_value_zero(k, key) { return Some(index) }
      None => ()
    }
    index = index + 1
  }
  None
}

///|
fn set_find_index(entries : Array[Value?], key : Value) -> Int? {
  let mut index = 0
  for entry in entries {
    match entry {
      Some(value) => if same_value_zero(value, key) { return Some(index) }
      None => ()
    }
    index = index + 1
  }
  None
}

///|
fn map_get_value(data : MapData, key : Value) -> Value {
  let normalized = map_normalize_key(key)
  match map_find_index(data.entries, normalized) {
    Some(index) =>
      match data.entries[index] {
        Some((_, value)) => value
        None => Undefined
      }
    None => Undefined
  }
}

///|
fn map_has_key(data : MapData, key : Value) -> Bool {
  let normalized = map_normalize_key(key)
  match map_find_index(data.entries, normalized) {
    Some(_) => true
    None => false
  }
}

///|
fn map_set_value(data : MapData, key : Value, value : Value) -> Unit {
  let normalized = map_normalize_key(key)
  match map_find_index(data.entries, normalized) {
    Some(index) => data.entries[index] = Some((normalized, value))
    None => data.entries.push(Some((normalized, value)))
  }
}

///|
fn map_delete_key(data : MapData, key : Value) -> Bool {
  let normalized = map_normalize_key(key)
  match map_find_index(data.entries, normalized) {
    Some(index) => {
      data.entries[index] = None
      true
    }
    None => false
  }
}

///|
fn map_get_or_insert(
  data : MapData,
  key : Value,
  value_or_callback : Value,
  computed : Bool,
) -> Value raise {
  if computed && !is_callable(value_or_callback) {
    return throw_type_error("not a function")
  }
  let normalized = map_normalize_key(key)
  match map_find_index(data.entries, normalized) {
    Some(index) =>
      match data.entries[index] {
        Some((_, value)) => value
        None => Undefined
      }
    None => {
      let value = if computed {
        let result = call_value_with_this(
          value_or_callback,
          [normalized],
          Undefined,
        )
        let _ = map_delete_key(data, normalized)
        result
      } else {
        value_or_callback
      }
      map_set_value(data, normalized, value)
      value
    }
  }
}

///|
fn map_entry_count(data : MapData) -> Int {
  let mut count = 0
  for entry in data.entries {
    match entry {
      Some(_) => count = count + 1
      None => ()
    }
  }
  count
}

///|
fn set_has_value(data : SetData, value : Value) -> Bool {
  let normalized = map_normalize_key(value)
  match set_find_index(data.entries, normalized) {
    Some(_) => true
    None => false
  }
}

///|
fn set_add_value(data : SetData, value : Value) -> Unit {
  let normalized = map_normalize_key(value)
  match set_find_index(data.entries, normalized) {
    Some(_) => ()
    None => data.entries.push(Some(normalized))
  }
}

///|
fn set_delete_value(data : SetData, value : Value) -> Bool {
  let normalized = map_normalize_key(value)
  match set_find_index(data.entries, normalized) {
    Some(index) => {
      data.entries[index] = None
      true
    }
    None => false
  }
}

///|
fn set_entry_count(data : SetData) -> Int {
  let mut count = 0
  for entry in data.entries {
    match entry {
      Some(_) => count = count + 1
      None => ()
    }
  }
  count
}

///|
fn init_map_or_set_from_iterable(
  obj : Value,
  iterable : Value,
  is_set : Bool,
) -> Unit raise {
  if is_nullish(iterable) {
    return
  }
  let adder_name = if is_set { "add" } else { "set" }
  let adder = property_get(obj, adder_name)
  if !is_callable(adder) {
    let _ = throw_type_error("set/add is not a function")
    return
  }
  let (iterator, next_method) = get_iterator_from_value(iterable)
  while true {
    let (done, item) = iterator_step_value(iterator, next_method)
    if done {
      break
    }
    try {
      if is_set {
        let _ = call_value_with_this(adder, [item], obj)

      } else {
        if !is_object_like(item) {
          let _ = throw_type_error("not an object")

        }
        let key = property_get(item, "0")
        let value = property_get(item, "1")
        let _ = call_value_with_this(adder, [key, value], obj)

      }
    } catch {
      err => {
        iterator_close_on_error(iterator)
        raise err
      }
    }
  }
}

///|
fn get_set_record(obj : Value) -> (Int64, Value, Value) raise {
  let obj_value = to_object(obj)
  let mut size_value : Int64? = None
  match obj_value {
    Object(set_obj) =>
      match set_obj.set_data {
        Some(data) => size_value = Some(Int64::from_int(set_entry_count(data)))
        None => ()
      }
    _ => ()
  }
  let size = match size_value {
    Some(value) => value
    None => {
      let size_prop = property_get(obj_value, "size")
      let size_prim = if is_object_like(size_prop) {
        to_primitive(size_prop, false)
      } else {
        size_prop
      }
      let size_num = match size_prim {
        BigInt(_) => {
          let _ = throw_type_error("cannot convert a BigInt value to a number")
          0.0
        }
        _ => to_number(size_prim)
      }
      if Double::is_nan(size_num) {
        let _ = throw_type_error(".size is not a number")

      }
      if size_num < 0.0 {
        let _ = throw_range_error(".size must be positive")

      }
      let max_double = 9.223372036854776e18
      let max_value : Int64 = 9223372036854775807
      if size_num >= max_double {
        max_value
      } else {
        Double::to_int64(Double::trunc(size_num))
      }
    }
  }
  let has = property_get(obj_value, "has")
  match has {
    Undefined => {
      let _ = throw_type_error(".has is undefined")
      return (0L, Undefined, Undefined)
    }
    _ => ()
  }
  if !is_callable(has) {
    let _ = throw_type_error(".has is not a function")
    return (0L, Undefined, Undefined)
  }
  let keys = property_get(obj_value, "keys")
  match keys {
    Undefined => {
      let _ = throw_type_error(".keys is undefined")
      return (0L, Undefined, Undefined)
    }
    _ => ()
  }
  if !is_callable(keys) {
    let _ = throw_type_error(".keys is not a function")
    return (0L, Undefined, Undefined)
  }
  (size, has, keys)
}

///|
fn iterator_from_keys(obj : Value, keys : Value) -> (Value, Value) raise {
  let iterator = call_value_with_this(keys, [], obj)
  let next_method = property_get(iterator, "next")
  if !is_callable(next_method) {
    let _ = throw_type_error("not a function")

  }
  (iterator, next_method)
}

///|
fn set_copy_value(this_value : Value?) -> Value raise {
  let (_, data) = require_set(this_value)
  let new_value = new_set_value()
  match new_value {
    Object(obj) =>
      match obj.set_data {
        Some(new_data) =>
          for entry in data.entries {
            match entry {
              Some(value) => new_data.entries.push(Some(value))
              None => ()
            }
          }
        None => ()
      }
    _ => ()
  }
  new_value
}

///|
fn set_is_disjoint_from(this_value : Value?, other : Value) -> Value raise {
  let (_, data) = require_set(this_value)
  let (size, has, keys) = get_set_record(other)
  let this_size = Int64::from_int(set_entry_count(data))
  let mut found = false
  if this_size <= size {
    let mut index = 0
    while index < data.entries.length() {
      match data.entries[index] {
        Some(value) => {
          let result = call_value_with_this(has, [value], other)
          if is_truthy(result) {
            found = true
            break
          }
        }
        None => ()
      }
      index = index + 1
    }
  } else {
    let (iterator, next_method) = iterator_from_keys(other, keys)
    let mut should_close = false
    while true {
      let (done, item) = iterator_step_value(iterator, next_method)
      if done {
        break
      }
      if set_has_value(data, item) {
        found = true
        should_close = true
        break
      }
    }
    if should_close {
      iterator_close(iterator)
    }
  }
  Bool(!found)
}

///|
fn set_is_subset_of(this_value : Value?, other : Value) -> Value raise {
  let (_, data) = require_set(this_value)
  let (size, has, _) = get_set_record(other)
  let this_size = Int64::from_int(set_entry_count(data))
  if this_size > size {
    return Bool(false)
  }
  let mut ok = true
  let mut index = 0
  while index < data.entries.length() {
    match data.entries[index] {
      Some(value) => {
        let result = call_value_with_this(has, [value], other)
        if !is_truthy(result) {
          ok = false
          break
        }
      }
      None => ()
    }
    index = index + 1
  }
  Bool(ok)
}

///|
fn set_is_superset_of(this_value : Value?, other : Value) -> Value raise {
  let (_, data) = require_set(this_value)
  let (size, _, keys) = get_set_record(other)
  let this_size = Int64::from_int(set_entry_count(data))
  if this_size < size {
    return Bool(false)
  }
  let (iterator, next_method) = iterator_from_keys(other, keys)
  let mut ok = true
  let mut should_close = false
  while true {
    let (done, item) = iterator_step_value(iterator, next_method)
    if done {
      break
    }
    if !set_has_value(data, item) {
      ok = false
      should_close = true
      break
    }
  }
  if should_close {
    iterator_close(iterator)
  }
  Bool(ok)
}

///|
fn set_intersection(this_value : Value?, other : Value) -> Value raise {
  let (_, data) = require_set(this_value)
  let (size, has, keys) = get_set_record(other)
  let this_size = Int64::from_int(set_entry_count(data))
  let new_value = new_set_value()
  let (_, new_data) = require_set(Some(new_value))
  if this_size > size {
    let (iterator, next_method) = iterator_from_keys(other, keys)
    while true {
      let (done, item) = iterator_step_value(iterator, next_method)
      if done {
        break
      }
      if set_has_value(data, item) {
        set_add_value(new_data, item)
      }
    }
  } else {
    let mut index = 0
    while index < data.entries.length() {
      match data.entries[index] {
        Some(value) => {
          let result = call_value_with_this(has, [value], other)
          if is_truthy(result) {
            set_add_value(new_data, value)
          }
        }
        None => ()
      }
      index = index + 1
    }
  }
  new_value
}

///|
fn set_difference(this_value : Value?, other : Value) -> Value raise {
  let (_, data) = require_set(this_value)
  let (size, has, keys) = get_set_record(other)
  let this_size = Int64::from_int(set_entry_count(data))
  let new_value = set_copy_value(this_value)
  let (_, new_data) = require_set(Some(new_value))
  if this_size <= size {
    let mut index = 0
    while index < new_data.entries.length() {
      match new_data.entries[index] {
        Some(value) => {
          let result = call_value_with_this(has, [value], other)
          if is_truthy(result) {
            let _ = set_delete_value(new_data, value)

          }
        }
        None => ()
      }
      index = index + 1
    }
  } else {
    let (iterator, next_method) = iterator_from_keys(other, keys)
    while true {
      let (done, item) = iterator_step_value(iterator, next_method)
      if done {
        break
      }
      let _ = set_delete_value(new_data, item)

    }
  }
  new_value
}

///|
fn set_symmetric_difference(this_value : Value?, other : Value) -> Value raise {
  let (_, data) = require_set(this_value)
  let (_, _, keys) = get_set_record(other)
  let (iterator, next_method) = iterator_from_keys(other, keys)
  let new_value = set_copy_value(this_value)
  let (_, new_data) = require_set(Some(new_value))
  while true {
    let (done, item) = iterator_step_value(iterator, next_method)
    if done {
      break
    }
    let present_in_this = set_has_value(data, item)
    let present_in_new = set_has_value(new_data, item)
    if present_in_this {
      let _ = set_delete_value(new_data, item)

    } else if present_in_new {
      ()
    } else {
      set_add_value(new_data, item)
    }
  }
  new_value
}

///|
fn set_union(this_value : Value?, other : Value) -> Value raise {
  let (_, _, keys) = get_set_record(other)
  let (iterator, next_method) = iterator_from_keys(other, keys)
  let new_value = set_copy_value(this_value)
  let (_, new_data) = require_set(Some(new_value))
  while true {
    let (done, item) = iterator_step_value(iterator, next_method)
    if done {
      break
    }
    set_add_value(new_data, item)
  }
  new_value
}

///|
fn weakmap_find_index(entries : Array[(Value, Value)], key : Value) -> Int? {
  let mut index = 0
  for entry in entries {
    let (k, _) = entry
    if same_value_zero(k, key) {
      return Some(index)
    }
    index = index + 1
  }
  None
}

///|
fn weakmap_get_value(data : WeakMapData, key : Value) -> Value {
  match weakmap_find_index(data.entries, key) {
    Some(index) => {
      let (_, value) = data.entries[index]
      value
    }
    None => Undefined
  }
}

///|
fn weakmap_has_key(data : WeakMapData, key : Value) -> Bool {
  match weakmap_find_index(data.entries, key) {
    Some(_) => true
    None => false
  }
}

///|
fn weakset_find_index(entries : Array[Value], key : Value) -> Int? {
  let mut index = 0
  for entry in entries {
    if same_value_zero(entry, key) {
      return Some(index)
    }
    index = index + 1
  }
  None
}

///|
fn weakmap_set_value(data : WeakMapData, key : Value, value : Value) -> Unit {
  match weakmap_find_index(data.entries, key) {
    Some(index) => data.entries[index] = (key, value)
    None => data.entries.push((key, value))
  }
}

///|
fn weakmap_get_or_insert(
  data : WeakMapData,
  key : Value,
  value_or_callback : Value,
  computed : Bool,
) -> Value raise {
  if computed && !is_callable(value_or_callback) {
    return throw_type_error("not a function")
  }
  match weakmap_find_index(data.entries, key) {
    Some(index) => {
      let (_, value) = data.entries[index]
      value
    }
    None => {
      let value = if computed {
        let result = call_value_with_this(value_or_callback, [key], Undefined)
        let _ = weakmap_delete_key(data, key)
        result
      } else {
        value_or_callback
      }
      weakmap_set_value(data, key, value)
      value
    }
  }
}

///|
fn weakmap_delete_key(data : WeakMapData, key : Value) -> Bool {
  match weakmap_find_index(data.entries, key) {
    Some(index) => {
      let _ = data.entries.remove(index)
      true
    }
    None => false
  }
}

///|
fn weakset_has_value(data : WeakSetData, value : Value) -> Bool {
  match weakset_find_index(data.entries, value) {
    Some(_) => true
    None => false
  }
}

///|
fn weakset_add_value(data : WeakSetData, value : Value) -> Unit {
  match weakset_find_index(data.entries, value) {
    Some(_) => ()
    None => data.entries.push(value)
  }
}

///|
fn weakset_delete_value(data : WeakSetData, value : Value) -> Bool {
  match weakset_find_index(data.entries, value) {
    Some(index) => {
      let _ = data.entries.remove(index)
      true
    }
    None => false
  }
}

///|
fn iterator_result(value : Value, done : Bool) -> Value {
  let obj = new_object_value()
  match obj {
    Object(result) => {
      result.props.set("value", property_data(value))
      result.props.set("done", property_data(Bool(done)))
    }
    _ => ()
  }
  obj
}

///|
let iterator_helper_kind_drop = 0

///|
let iterator_helper_kind_filter = 1

///|
let iterator_helper_kind_flat_map = 2

///|
let iterator_helper_kind_map = 3

///|
let iterator_helper_kind_take = 4

///|
let iterator_proto_kind_every = 0

///|
let iterator_proto_kind_find = 1

///|
let iterator_proto_kind_for_each = 2

///|
let iterator_proto_kind_some = 3

///|
let async_from_sync_iter_kind_next = 0

///|
let async_from_sync_iter_kind_return = 1

///|
let async_from_sync_iter_kind_throw = 2

///|
fn iterator_return_self(this_value : Value?) -> Value {
  match this_value {
    Some(value) => value
    None => Undefined
  }
}

///|
fn iterator_wrap_next(this_value : Value?) -> Value raise {
  let (_, data) = require_iterator_wrap(this_value)
  let result = call_value_with_this(data.wrapped_next, [], data.wrapped_iter)
  if !is_object_like(result) {
    let _ = throw_type_error("iterator must return an object")
    return iterator_result(Undefined, true)
  }
  result
}

///|
fn iterator_wrap_return(this_value : Value?) -> Value raise {
  let (_, data) = require_iterator_wrap(this_value)
  let iter = data.wrapped_iter
  let return_method = property_get(iter, "return")
  match return_method {
    Undefined | Null => iterator_result(Undefined, true)
    _ => {
      if !is_callable(return_method) {
        return throw_type_error("not a function")
      }
      let result = call_value_with_this(return_method, [], iter)
      if !is_object_like(result) {
        return throw_type_error("iterator must return an object")
      }
      result
    }
  }
}

///|
fn iterator_concat_next(this_value : Value?) -> Value raise {
  let (_, data) = require_iterator_concat(this_value)
  if data.running {
    return throw_type_error("cannot invoke a running iterator")
  }
  data.running = true
  try {
    for {
      if data.index >= data.count {
        data.running = false
        return iterator_result(Undefined, true)
      }
      if data.next is Undefined {
        let (iterable, iter_method) = data.values[data.index]
        let iter = call_value_with_this(iter_method, [], iterable)
        if !is_object_like(iter) {
          let _ = throw_type_error("not an object")
          data.running = false
          return iterator_result(Undefined, true)
        }
        let next_method = property_get(iter, "next")
        if !is_callable(next_method) {
          let _ = throw_type_error("not a function")
          data.running = false
          return iterator_result(Undefined, true)
        }
        data.iter = iter
        data.next = next_method
      }
      let (done, value) = iterator_step_value(data.iter, data.next)
      if done {
        data.index = data.index + 1
        data.iter = Undefined
        data.next = Undefined
        continue
      }
      data.running = false
      return iterator_result(value, false)
    }
    data.running = false
    iterator_result(Undefined, true)
  } catch {
    err => {
      data.running = false
      raise err
    }
  }
}

///|
fn iterator_concat_return(this_value : Value?) -> Value raise {
  let (_, data) = require_iterator_concat(this_value)
  if data.running {
    return throw_type_error("cannot invoke a running iterator")
  }
  data.running = true
  try {
    let iter = data.iter
    data.index = data.count
    data.iter = Undefined
    data.next = Undefined
    if iter is Undefined {
      data.running = false
      return iterator_result(Undefined, true)
    }
    let return_method = property_get(iter, "return")
    match return_method {
      Undefined | Null => {
        data.running = false
        iterator_result(Undefined, true)
      }
      _ => {
        if !is_callable(return_method) {
          data.running = false
          return throw_type_error("not a function")
        }
        let result = call_value_with_this(return_method, [], iter)
        if !is_object_like(result) {
          data.running = false
          return throw_type_error("iterator must return an object")
        }
        data.running = false
        result
      }
    }
  } catch {
    err => {
      data.running = false
      raise err
    }
  }
}

///|
fn iterator_constructor_value() -> Value raise {
  match current_env() {
    Some(env) =>
      match global_object(env) {
        Some(obj) => property_get(Object(obj), "Iterator")
        None => Undefined
      }
    None =>
      match root_env() {
        Some(env) =>
          match global_object(env) {
            Some(obj) => property_get(Object(obj), "Iterator")
            None => Undefined
          }
        None => Undefined
      }
  }
}

///|
fn iterator_from_value(value : Value) -> Value raise {
  let obj = match value {
    String(_) => value
    _ =>
      if is_object_like(value) {
        value
      } else {
        return throw_type_error("Iterator.from called on non-object")
      }
  }
  let iter_method = match symbol_iterator_key() {
    Some(key) => property_get(obj, key)
    None => Undefined
  }
  let iterator = match iter_method {
    Undefined | Null => obj
    _ => {
      if !is_callable(iter_method) {
        return throw_type_error("not a function")
      }
      call_value_with_this(iter_method, [], obj)
    }
  }
  if !is_object_like(iterator) {
    return throw_type_error("not an object")
  }
  let next_method = property_get(iterator, "next")
  let iterator_ctor = iterator_constructor_value()
  if is_object_like(iterator_ctor) &&
    ordinary_instanceof(iterator, iterator_ctor) {
    return iterator
  }
  let wrapper = new_object_value_with_proto(
    value_from_object(iterator_wrap_proto()),
  )
  match wrapper {
    Object(obj) =>
      obj.iterator_wrap_data = Some(IteratorWrapData::{
        wrapped_iter: iterator,
        wrapped_next: next_method,
      })
    _ => ()
  }
  wrapper
}

///|
fn iterator_concat_value(args : Array[Value]) -> Value raise {
  let values : Array[(Value, Value)] = []
  for value in args {
    if !is_object_like(value) {
      return throw_type_error("not an object")
    }
    let iter_method = match symbol_iterator_key() {
      Some(key) => property_get(value, key)
      None => Undefined
    }
    match iter_method {
      Undefined | Null => return throw_type_error("not iterable")
      _ =>
        if !is_callable(iter_method) {
          return throw_type_error("not a function")
        }
    }
    values.push((value, iter_method))
  }
  let iterator = new_object_value_with_proto(
    value_from_object(iterator_concat_proto()),
  )
  match iterator {
    Object(obj) =>
      obj.iterator_concat_data = Some(IteratorConcatData::{
        index: 0,
        count: values.length(),
        running: false,
        iter: Undefined,
        next: Undefined,
        values,
      })
    _ => ()
  }
  iterator
}

///|
fn iterator_helper_create(
  kind : Int,
  this_value : Value?,
  args : Array[Value],
) -> Value raise {
  let target = match this_value {
    Some(value) => value
    None => Undefined
  }
  if !is_object_like(target) {
    return throw_type_error("not an object")
  }
  let mut func = Undefined
  let mut count = 0L
  match kind {
    _ if kind == iterator_helper_kind_drop || kind == iterator_helper_kind_take => {
      let limit_value = if args.is_empty() { Undefined } else { args[0] }
      let num = to_number(limit_value) catch {
        err => {
          iterator_close_on_error(target)
          raise err
        }
      }
      if Double::is_nan(num) {
        iterator_close_on_error(target)
        return throw_range_error("must be positive")
      }
      let integer = if Double::is_inf(num) { num } else { Double::trunc(num) }
      if integer < 0.0 {
        iterator_close_on_error(target)
        return throw_range_error("must be positive")
      }
      count = to_length_int64(integer)
    }
    _ => {
      func = if args.is_empty() { Undefined } else { args[0] }
      if !is_callable(func) {
        iterator_close_on_error(target)
        return throw_type_error("not a function")
      }
    }
  }
  let next_method = property_get(target, "next")
  let iterator = new_object_value_with_proto(
    value_from_object(iterator_helper_proto()),
  )
  match iterator {
    Object(obj) =>
      obj.iterator_helper_data = Some(IteratorHelperData::{
        obj: target,
        next: next_method,
        func,
        inner: Undefined,
        inner_next: Undefined,
        count,
        kind,
        executing: false,
        done: false,
      })
    _ => ()
  }
  iterator
}

///|
fn iterator_helper_next(this_value : Value?) -> Value raise {
  let (_, data) = require_iterator_helper(this_value)
  if data.executing {
    return throw_type_error("cannot invoke a running iterator")
  }
  if data.done {
    return iterator_result(Undefined, true)
  }
  data.executing = true
  if !is_callable(data.next) {
    data.executing = false
    return throw_type_error("not a function")
  }
  try {
    match data.kind {
      _ if data.kind == iterator_helper_kind_drop => {
        while data.count > 0L {
          let (done, _) = iterator_step_value(data.obj, data.next)
          if done {
            data.done = true
            data.executing = false
            return iterator_result(Undefined, true)
          }
          data.count = data.count - 1L
        }
        let (done, value) = iterator_step_value(data.obj, data.next)
        if done {
          data.done = true
          data.executing = false
          return iterator_result(Undefined, true)
        }
        data.executing = false
        return iterator_result(value, false)
      }
      _ if data.kind == iterator_helper_kind_take => {
        if data.count <= 0L {
          data.done = true
          iterator_close(data.obj)
          data.executing = false
          return iterator_result(Undefined, true)
        }
        let (done, value) = iterator_step_value(data.obj, data.next)
        if done {
          data.done = true
          data.executing = false
          return iterator_result(Undefined, true)
        }
        data.count = data.count - 1L
        data.executing = false
        return iterator_result(value, false)
      }
      _ if data.kind == iterator_helper_kind_filter => {
        for {
          let (done, value) = iterator_step_value(data.obj, data.next)
          if done {
            data.done = true
            data.executing = false
            return iterator_result(Undefined, true)
          }
          let index = data.count
          data.count = data.count + 1L
          let selected = call_value_with_this(
            data.func,
            [value, Number(Int64::to_double(index))],
            Undefined,
          ) catch {
            err => {
              iterator_close_on_error(data.obj)
              raise err
            }
          }
          if is_truthy(selected) {
            data.executing = false
            return iterator_result(value, false)
          }
        }
        data.executing = false
        iterator_result(Undefined, true)
      }
      _ if data.kind == iterator_helper_kind_map => {
        let (done, value) = iterator_step_value(data.obj, data.next)
        if done {
          data.done = true
          data.executing = false
          return iterator_result(Undefined, true)
        }
        let index = data.count
        data.count = data.count + 1L
        let mapped = call_value_with_this(
          data.func,
          [value, Number(Int64::to_double(index))],
          Undefined,
        ) catch {
          err => {
            iterator_close_on_error(data.obj)
            raise err
          }
        }
        data.executing = false
        return iterator_result(mapped, false)
      }
      _ if data.kind == iterator_helper_kind_flat_map => {
        for {
          if !(data.inner is Undefined) {
            let (done, value) = iterator_step_value(data.inner, data.inner_next) catch {
              err => {
                iterator_close_on_error(data.obj)
                raise err
              }
            }
            if done {
              data.inner = Undefined
              data.inner_next = Undefined
              continue
            }
            data.executing = false
            return iterator_result(value, false)
          }
          let (done, value) = iterator_step_value(data.obj, data.next)
          if done {
            data.done = true
            data.executing = false
            return iterator_result(Undefined, true)
          }
          let index = data.count
          data.count = data.count + 1L
          let mapped = call_value_with_this(
            data.func,
            [value, Number(Int64::to_double(index))],
            Undefined,
          ) catch {
            err => {
              iterator_close_on_error(data.obj)
              raise err
            }
          }
          let (inner_iter, inner_next) = get_iterator_flattenable(mapped) catch {
            err => {
              iterator_close_on_error(data.obj)
              raise err
            }
          }
          data.inner = inner_iter
          data.inner_next = inner_next
        }
        data.executing = false
        iterator_result(Undefined, true)
      }
      _ => {
        data.executing = false
        iterator_result(Undefined, true)
      }
    }
  } catch {
    err => {
      data.executing = false
      raise err
    }
  }
}

///|
fn iterator_helper_return(this_value : Value?) -> Value raise {
  let (_, data) = require_iterator_helper(this_value)
  if data.executing {
    return throw_type_error("cannot invoke a running iterator")
  }
  data.executing = true
  try {
    if data.done {
      data.executing = false
      return iterator_result(Undefined, true)
    }
    data.done = true
    let inner = data.inner
    data.inner = Undefined
    data.inner_next = Undefined
    if is_object_like(inner) {
      iterator_close(inner)
    }
    iterator_close(data.obj)
    data.executing = false
    iterator_result(Undefined, true)
  } catch {
    err => {
      data.executing = false
      raise err
    }
  }
}

///|
fn iterator_proto_iterate(
  kind : Int,
  this_value : Value?,
  args : Array[Value],
) -> Value raise {
  let iter = match this_value {
    Some(value) => value
    None => Undefined
  }
  if !is_object_like(iter) {
    return throw_type_error("not an object")
  }
  let callback = if args.is_empty() { Undefined } else { args[0] }
  if !is_callable(callback) {
    iterator_close_on_error(iter)
    return throw_type_error("not a function")
  }
  let next_method = property_get(iter, "next")
  if !is_callable(next_method) {
    return throw_type_error("not a function")
  }
  let mut index = 0L
  for {
    let (done, value) = iterator_step_value(iter, next_method)
    if done {
      return match kind {
        _ if kind == iterator_proto_kind_every => Bool(true)
        _ if kind == iterator_proto_kind_some => Bool(false)
        _ if kind == iterator_proto_kind_find => Undefined
        _ => Undefined
      }
    }
    let result = call_value_with_this(
      callback,
      [value, Number(Int64::to_double(index))],
      Undefined,
    ) catch {
      err => {
        iterator_close_on_error(iter)
        raise err
      }
    }
    index = index + 1L
    match kind {
      _ if kind == iterator_proto_kind_every =>
        if !is_truthy(result) {
          iterator_close(iter)
          return Bool(false)
        }
      _ if kind == iterator_proto_kind_some =>
        if is_truthy(result) {
          iterator_close(iter)
          return Bool(true)
        }
      _ if kind == iterator_proto_kind_find =>
        if is_truthy(result) {
          iterator_close(iter)
          return value
        }
      _ => ()
    }
  }
  Undefined
}

///|
fn iterator_proto_reduce(
  this_value : Value?,
  args : Array[Value],
) -> Value raise {
  let iter = match this_value {
    Some(value) => value
    None => Undefined
  }
  if !is_object_like(iter) {
    return throw_type_error("not an object")
  }
  let reducer = if args.is_empty() { Undefined } else { args[0] }
  if !is_callable(reducer) {
    iterator_close_on_error(iter)
    return throw_type_error("not a function")
  }
  let next_method = property_get(iter, "next")
  if !is_callable(next_method) {
    return throw_type_error("not a function")
  }
  let mut index = 0L
  let mut accumulator = Undefined
  if args.length() > 1 {
    accumulator = args[1]
  } else {
    let (done, value) = iterator_step_value(iter, next_method)
    if done {
      return throw_type_error("empty iterator")
    }
    accumulator = value
    index = 1L
  }
  for {
    let (done, value) = iterator_step_value(iter, next_method)
    if done {
      return accumulator
    }
    let result = call_value_with_this(
      reducer,
      [accumulator, value, Number(Int64::to_double(index))],
      Undefined,
    ) catch {
      err => {
        iterator_close_on_error(iter)
        raise err
      }
    }
    accumulator = result
    index = index + 1L
  }
  accumulator
}

///|
fn iterator_proto_to_array(this_value : Value?) -> Value raise {
  let iter = match this_value {
    Some(value) => value
    None => Undefined
  }
  if !is_object_like(iter) {
    return throw_type_error("not an object")
  }
  let next_method = property_get(iter, "next")
  if !is_callable(next_method) {
    return throw_type_error("not a function")
  }
  let array_proto_value = match current_env() {
    Some(env) =>
      match value_from_object(array_proto_for_env(env)) {
        Some(value) => Some(value)
        None => value_from_object(array_proto())
      }
    None => value_from_object(array_proto())
  }
  let values : Array[Value?] = []
  for {
    let (done, value) = iterator_step_value(iter, next_method)
    if done {
      return new_array_value_with_proto(values, proto=array_proto_value)
    }
    values.push(Some(value))
  }
  new_array_value_with_proto(values, proto=array_proto_value)
}

///|
fn iterator_constructor_getter(this_value : Value?) -> Value raise {
  let _ = this_value
  iterator_constructor_value()
}

///|
fn iterator_constructor_setter(
  this_value : Value?,
  value : Value,
) -> Value raise {
  let target = match this_value {
    Some(value) => to_object(value)
    None => {
      let _ = throw_type_error("not an object")
      return Undefined
    }
  }
  if !is_object_like(value) {
    return throw_type_error("not an object")
  }
  let desc = new_object_value()
  match desc {
    Object(obj) => {
      obj.props.set("value", property_data(value))
      obj.props.set("writable", property_data(Bool(true)))
      obj.props.set("enumerable", property_data(Bool(false)))
      obj.props.set("configurable", property_data(Bool(true)))
    }
    _ => ()
  }
  let _ = define_property_value(target, String("constructor"), desc, true)
  value
}

///|
fn iterator_to_string_tag_getter(this_value : Value?) -> Value {
  let _ = this_value
  String("Iterator")
}

///|
fn iterator_to_string_tag_setter(
  this_value : Value?,
  value : Value,
) -> Value raise {
  let target = match this_value {
    Some(value) => value
    None => Undefined
  }
  if !is_object_like(target) {
    return throw_type_error("not an object")
  }
  match iterator_proto() {
    Some(proto) =>
      match target {
        Object(obj) =>
          if obj.id == proto.id {
            return throw_type_error("invalid receiver")
          }
        _ => ()
      }
    None => ()
  }
  match symbol_to_string_tag_key() {
    Some(key) => {
      let desc = get_own_property_descriptor(target, key)
      match desc {
        Undefined => {
          let _ = create_data_property_or_throw(target, key, value)

        }
        _ => {
          let _ = property_set(target, key, value, true)

        }
      }
    }
    None => ()
  }
  Undefined
}

///|
fn new_array_iterator(obj : Value, kind : Int) -> Value {
  let iterator = new_object_value_with_proto(
    value_from_object(array_iterator_proto()),
  )
  match iterator {
    Object(iter_obj) => {
      iter_obj.props.set(array_iter_target_key, property_data_non_enum(obj))
      iter_obj.props.set(
        array_iter_index_key,
        property_data_non_enum(Number(0.0)),
      )
      iter_obj.props.set(
        array_iter_kind_key,
        property_data_non_enum(Number(Double::from_int(kind))),
      )
    }
    _ => ()
  }
  iterator
}

///|
fn iterator_internal_value(
  iter_obj : ObjectValue,
  key : String,
  error_msg : String,
) -> (Value, Bool) raise {
  let desc = get_own_property_descriptor(Value::Object(iter_obj), key)
  match desc {
    Undefined => {
      let _ = throw_type_error(error_msg)
      (Undefined, false)
    }
    _ =>
      if descriptor_is_accessor(desc) {
        let _ = throw_type_error(error_msg)
        (Undefined, false)
      } else {
        (property_get(desc, "value"), true)
      }
  }
}

///|
fn array_iterator_next(this_value : Value?) -> Value raise {
  let iter_obj = match this_value {
    Some(Object(obj)) => obj
    _ => {
      let _ = throw_type_error("not an array iterator")
      return iterator_result(Undefined, true)
    }
  }
  let (target, ok) = iterator_internal_value(
    iter_obj, array_iter_target_key, "not an array iterator",
  )
  if !ok {
    return iterator_result(Undefined, true)
  }
  let (index_value, ok) = iterator_internal_value(
    iter_obj, array_iter_index_key, "not an array iterator",
  )
  if !ok {
    return iterator_result(Undefined, true)
  }
  let (kind_value, ok) = iterator_internal_value(
    iter_obj, array_iter_kind_key, "not an array iterator",
  )
  if !ok {
    return iterator_result(Undefined, true)
  }
  if is_nullish(target) {
    return iterator_result(Undefined, true)
  }
  let index = to_int32(to_number(index_value))
  let kind = to_int32(to_number(kind_value))
  let obj = to_object(target)
  let mut typed_len : Int? = None
  match obj {
    Array(arr) =>
      match arr.typed_array_data {
        Some(data) => {
          if typed_array_is_oob(data) {
            return throw_type_error("ArrayBuffer is detached or resized")
          }
          typed_len = Some(typed_array_effective_length(data))
        }
        None => ()
      }
    _ => ()
  }
  let len = match typed_len {
    Some(value) => value
    None => array_like_length(obj)
  }
  if index < 0 || index >= len {
    iter_obj.props.set(array_iter_target_key, property_data_non_enum(Undefined))
    return iterator_result(Undefined, true)
  }
  let key = Number(Double::from_int(index))
  let value = property_get(obj, Int::to_string(index))
  let result = if kind == 0 {
    key
  } else if kind == 1 {
    value
  } else {
    new_array_value([Some(key), Some(value)])
  }
  iter_obj.props.set(
    array_iter_index_key,
    property_data_non_enum(Number(Double::from_int(index + 1))),
  )
  iterator_result(result, false)
}

///|
fn new_string_iterator(value : Value) -> Value {
  let iterator = new_object_value_with_proto(
    value_from_object(string_iterator_proto()),
  )
  match iterator {
    Object(iter_obj) => {
      iter_obj.props.set(string_iter_target_key, property_data_non_enum(value))
      iter_obj.props.set(
        string_iter_index_key,
        property_data_non_enum(Number(0.0)),
      )
    }
    _ => ()
  }
  iterator
}

///|
fn string_iterator_next(this_value : Value?) -> Value raise {
  let iter_obj = match this_value {
    Some(Object(obj)) => obj
    _ => {
      let _ = throw_type_error("not a string iterator")
      return iterator_result(Undefined, true)
    }
  }
  let (target, ok) = iterator_internal_value(
    iter_obj, string_iter_target_key, "not a string iterator",
  )
  if !ok {
    return iterator_result(Undefined, true)
  }
  if is_nullish(target) {
    return iterator_result(Undefined, true)
  }
  let (index_value, ok) = iterator_internal_value(
    iter_obj, string_iter_index_key, "not a string iterator",
  )
  if !ok {
    return iterator_result(Undefined, true)
  }
  let index = to_int32(to_number(index_value))
  let text = match target {
    String(value) => value
    _ => to_string_value(target)
  }
  let len = text.length()
  if index < 0 || index >= len {
    iter_obj.props.set(
      string_iter_target_key,
      property_data_non_enum(Undefined),
    )
    return iterator_result(Undefined, true)
  }
  match text.get_char(index) {
    Some(ch) => {
      let next_index = index + ch.utf16_len()
      iter_obj.props.set(
        string_iter_index_key,
        property_data_non_enum(Number(Double::from_int(next_index))),
      )
      iterator_result(String(ch.to_string()), false)
    }
    None => {
      let next_index = if index + 1 <= len { index + 1 } else { len }
      let part = text.unsafe_substring(start=index, end=next_index)
      iter_obj.props.set(
        string_iter_index_key,
        property_data_non_enum(Number(Double::from_int(next_index))),
      )
      iterator_result(String(part), false)
    }
  }
}

///|
fn new_regexp_string_iterator(
  regexp : Value,
  input : String,
  global : Bool,
  unicode : Bool,
) -> Value {
  let iterator = new_object_value_with_proto(
    value_from_object(regexp_string_iterator_proto()),
  )
  match iterator {
    Object(iter_obj) => {
      iter_obj.props.set(regexp_iter_regexp_key, property_data_non_enum(regexp))
      iter_obj.props.set(
        regexp_iter_string_key,
        property_data_non_enum(String(input)),
      )
      iter_obj.props.set(
        regexp_iter_global_key,
        property_data_non_enum(Bool(global)),
      )
      iter_obj.props.set(
        regexp_iter_unicode_key,
        property_data_non_enum(Bool(unicode)),
      )
      iter_obj.props.set(
        regexp_iter_done_key,
        property_data_non_enum(Bool(false)),
      )
    }
    _ => ()
  }
  iterator
}

///|
fn regexp_string_iterator_next(this_value : Value?) -> Value raise {
  let iter_obj = match this_value {
    Some(Object(obj)) => obj
    _ => {
      let _ = throw_type_error("not a regexp string iterator")
      return iterator_result(Undefined, true)
    }
  }
  let (done_value, ok) = iterator_internal_value(
    iter_obj, regexp_iter_done_key, "not a regexp string iterator",
  )
  if !ok {
    return iterator_result(Undefined, true)
  }
  if is_truthy(done_value) {
    return iterator_result(Undefined, true)
  }
  let (regexp_value, ok) = iterator_internal_value(
    iter_obj, regexp_iter_regexp_key, "not a regexp string iterator",
  )
  if !ok {
    return iterator_result(Undefined, true)
  }
  let (input_value, ok) = iterator_internal_value(
    iter_obj, regexp_iter_string_key, "not a regexp string iterator",
  )
  if !ok {
    return iterator_result(Undefined, true)
  }
  let (global_value, ok) = iterator_internal_value(
    iter_obj, regexp_iter_global_key, "not a regexp string iterator",
  )
  if !ok {
    return iterator_result(Undefined, true)
  }
  let (unicode_value, ok) = iterator_internal_value(
    iter_obj, regexp_iter_unicode_key, "not a regexp string iterator",
  )
  if !ok {
    return iterator_result(Undefined, true)
  }
  let global = is_truthy(global_value)
  let unicode = is_truthy(unicode_value)
  let input = to_string_strict(input_value)
  let match_value = regexp_exec_method(regexp_value, String(input))
  match match_value {
    Null => {
      iter_obj.props.set(
        regexp_iter_done_key,
        property_data_non_enum(Bool(true)),
      )
      iterator_result(Undefined, true)
    }
    _ => {
      if global {
        let matched = to_string_strict(property_get(match_value, "0"))
        if matched.is_empty() {
          let last_index_value = property_get(regexp_value, "lastIndex")
          let last_index = to_length_int64(to_number(last_index_value))
          let next_index = advance_string_index_int64(
            input, last_index, unicode,
          )
          let _ = property_set(
            regexp_value,
            "lastIndex",
            Number(Int64::to_double(next_index)),
            true,
          )

        }
      } else {
        iter_obj.props.set(
          regexp_iter_done_key,
          property_data_non_enum(Bool(true)),
        )
      }
      iterator_result(match_value, false)
    }
  }
}

///|
fn new_async_from_sync_iterator(
  sync_iter : Value,
  next_method : Value,
) -> Value {
  let iterator = new_object_value_with_proto(
    value_from_object(async_from_sync_iterator_proto()),
  )
  match iterator {
    Object(iter_obj) => {
      iter_obj.props.set(
        async_from_sync_iter_target_key,
        property_data_non_enum(sync_iter),
      )
      iter_obj.props.set(
        async_from_sync_iter_next_key,
        property_data_non_enum(next_method),
      )
    }
    _ => ()
  }
  iterator
}

///|
fn require_async_from_sync_iterator(
  this_value : Value?,
) -> (ObjectValue, Value, Value) raise {
  match this_value {
    Some(Object(obj)) => {
      let (sync_iter, ok) = iterator_internal_value(
        obj, async_from_sync_iter_target_key, "not an Async-from-Sync Iterator",
      )
      if !ok {
        return (obj, Undefined, Undefined)
      }
      let (next_method, ok) = iterator_internal_value(
        obj, async_from_sync_iter_next_key, "not an Async-from-Sync Iterator",
      )
      if !ok {
        return (obj, Undefined, Undefined)
      }
      (obj, sync_iter, next_method)
    }
    _ => {
      let _ = throw_type_error("not an Async-from-Sync Iterator")
      (new_object_struct(None), Undefined, Undefined)
    }
  }
}

///|
fn new_async_from_sync_iterator_unwrap(done : Bool) -> Value {
  let func = new_builtin_value(BuiltinFunction::AsyncFromSyncIteratorUnwrap)
  match func {
    Builtin(builtin) =>
      async_from_sync_unwrap_data_set(builtin.id, AsyncFromSyncIteratorUnwrapData::{
        done,
      })
    _ => ()
  }
  func
}

///|
fn new_async_from_sync_iterator_close_wrap(sync_iter : Value) -> Value {
  let func = new_builtin_value(BuiltinFunction::AsyncFromSyncIteratorCloseWrap)
  match func {
    Builtin(builtin) =>
      async_from_sync_close_wrap_data_set(builtin.id, AsyncFromSyncIteratorCloseWrapData::{
        sync_iter,
      })
    _ => ()
  }
  func
}

///|
fn async_from_sync_iterator_unwrap(
  builtin : BuiltinValue,
  args : Array[Value],
) -> Value {
  match async_from_sync_unwrap_data_get(builtin.id) {
    Some(data) => {
      let value = if args.is_empty() { Undefined } else { args[0] }
      iterator_result(value, data.done)
    }
    None => Undefined
  }
}

///|
fn async_from_sync_iterator_close_wrap(
  builtin : BuiltinValue,
  args : Array[Value],
) -> Value raise {
  match async_from_sync_close_wrap_data_get(builtin.id) {
    Some(data) => {
      let reason = if args.is_empty() { Undefined } else { args[0] }
      iterator_close_on_error(data.sync_iter)
      raise ThrowSignal(reason)
    }
    None => throw_type_error("not an Async-from-Sync Iterator")
  }
}

///|
fn async_from_sync_iterator_step(
  this_value : Value?,
  args : Array[Value],
  kind : Int,
) -> Value raise {
  let (promise, resolve, reject) = new_promise_capability(Undefined)
  try {
    let (_, sync_iter, next_method) = require_async_from_sync_iterator(
      this_value,
    )
    let arg = if args.is_empty() { Undefined } else { args[0] }
    let mut method_value = Undefined
    if kind == async_from_sync_iter_kind_next {
      method_value = next_method
    } else if kind == async_from_sync_iter_kind_return {
      method_value = property_get(sync_iter, "return")
      if method_value is Undefined || method_value is Null {
        let result = iterator_result(arg, true)
        let _ = call_value_with_this(resolve, [result], Undefined)
        return promise
      }
    } else {
      method_value = property_get(sync_iter, "throw")
      if method_value is Undefined || method_value is Null {
        iterator_close(sync_iter)
        let err = type_error_value("throw is not a method")
        let _ = call_value_with_this(reject, [err], Undefined)
        return promise
      }
    }
    if !is_callable(method_value) {
      let _ = throw_type_error("not a function")
      return promise
    }
    let argv = if args.is_empty() { [] } else { [arg] }
    let result = call_value_with_this(method_value, argv, sync_iter)
    if !is_object_like(result) {
      let _ = throw_type_error("iterator must return an object")
      return promise
    }
    let done = is_truthy(property_get(result, "done"))
    let value = property_get(result, "value")
    let promise_ctor = promise_ctor_value_for_current_env()
    let value_promise = promise_resolve_value(promise_ctor, value, false) catch {
      ThrowSignal(err) => {
        if !done && kind != async_from_sync_iter_kind_return {
          iterator_close_on_error(sync_iter)
        }
        let _ = call_value_with_this(reject, [err], Undefined)
        return promise
      }
      err => raise err
    }
    match promise_data_from_value(value_promise) {
      Some(data) => {
        let on_fulfilled = new_async_from_sync_iterator_unwrap(done)
        let on_rejected = if done || kind == async_from_sync_iter_kind_return {
          Undefined
        } else {
          new_async_from_sync_iterator_close_wrap(sync_iter)
        }
        perform_promise_then(
          value_promise, data, on_fulfilled, on_rejected, resolve, reject,
        )
      }
      None => {
        let _ = throw_type_error("not a Promise")

      }
    }
    promise
  } catch {
    ThrowSignal(err) => {
      let _ = call_value_with_this(reject, [err], Undefined)
      promise
    }
    err => raise err
  }
}

///|
fn new_map_iterator(data : MapData, kind : Int) -> Value {
  let iter_value = new_object_value_with_proto(
    value_from_object(map_iterator_proto()),
  )
  match iter_value {
    Object(obj) =>
      obj.map_iter_data = Some(MapIteratorData::{
        entries: data.entries,
        index: 0,
        kind,
        done: false,
      })
    _ => ()
  }
  iter_value
}

///|
fn new_set_iterator(data : SetData, kind : Int) -> Value {
  let iter_value = new_object_value_with_proto(
    value_from_object(set_iterator_proto()),
  )
  match iter_value {
    Object(obj) =>
      obj.set_iter_data = Some(SetIteratorData::{
        entries: data.entries,
        index: 0,
        kind,
        done: false,
      })
    _ => ()
  }
  iter_value
}

///|
fn require_map_iterator(
  this_value : Value?,
) -> (ObjectValue, MapIteratorData) raise {
  match this_value {
    Some(Object(obj)) =>
      match obj.map_iter_data {
        Some(data) => (obj, data)
        None => {
          let _ = throw_type_error("not a map iterator")
          (obj, MapIteratorData::{ entries: [], index: 0, kind: 0, done: true })
        }
      }
    _ => {
      let _ = throw_type_error("not a map iterator")
      (
        new_object_struct(None),
        MapIteratorData::{ entries: [], index: 0, kind: 0, done: true },
      )
    }
  }
}

///|
fn require_set_iterator(
  this_value : Value?,
) -> (ObjectValue, SetIteratorData) raise {
  match this_value {
    Some(Object(obj)) =>
      match obj.set_iter_data {
        Some(data) => (obj, data)
        None => {
          let _ = throw_type_error("not a set iterator")
          (obj, SetIteratorData::{ entries: [], index: 0, kind: 0, done: true })
        }
      }
    _ => {
      let _ = throw_type_error("not a set iterator")
      (
        new_object_struct(None),
        SetIteratorData::{ entries: [], index: 0, kind: 0, done: true },
      )
    }
  }
}

///|
fn require_iterator_wrap(
  this_value : Value?,
) -> (ObjectValue, IteratorWrapData) raise {
  match this_value {
    Some(Object(obj)) =>
      match obj.iterator_wrap_data {
        Some(data) => (obj, data)
        None => {
          let _ = throw_type_error("not an iterator")
          (
            obj,
            IteratorWrapData::{
              wrapped_iter: Undefined,
              wrapped_next: Undefined,
            },
          )
        }
      }
    _ => {
      let _ = throw_type_error("not an iterator")
      (
        new_object_struct(None),
        IteratorWrapData::{ wrapped_iter: Undefined, wrapped_next: Undefined },
      )
    }
  }
}

///|
fn require_iterator_concat(
  this_value : Value?,
) -> (ObjectValue, IteratorConcatData) raise {
  match this_value {
    Some(Object(obj)) =>
      match obj.iterator_concat_data {
        Some(data) => (obj, data)
        None => {
          let _ = throw_type_error("not an iterator")
          (
            obj,
            IteratorConcatData::{
              index: 0,
              count: 0,
              running: false,
              iter: Undefined,
              next: Undefined,
              values: [],
            },
          )
        }
      }
    _ => {
      let _ = throw_type_error("not an iterator")
      (
        new_object_struct(None),
        IteratorConcatData::{
          index: 0,
          count: 0,
          running: false,
          iter: Undefined,
          next: Undefined,
          values: [],
        },
      )
    }
  }
}

///|
fn require_iterator_helper(
  this_value : Value?,
) -> (ObjectValue, IteratorHelperData) raise {
  match this_value {
    Some(Object(obj)) =>
      match obj.iterator_helper_data {
        Some(data) => (obj, data)
        None => {
          let _ = throw_type_error("not an iterator")
          (
            obj,
            IteratorHelperData::{
              obj: Undefined,
              next: Undefined,
              func: Undefined,
              inner: Undefined,
              inner_next: Undefined,
              count: 0L,
              kind: 0,
              executing: false,
              done: true,
            },
          )
        }
      }
    _ => {
      let _ = throw_type_error("not an iterator")
      (
        new_object_struct(None),
        IteratorHelperData::{
          obj: Undefined,
          next: Undefined,
          func: Undefined,
          inner: Undefined,
          inner_next: Undefined,
          count: 0L,
          kind: 0,
          executing: false,
          done: true,
        },
      )
    }
  }
}

///|
fn map_iterator_next(this_value : Value?) -> Value raise {
  let (_, data) = require_map_iterator(this_value)
  if data.done {
    return iterator_result(Undefined, true)
  }
  let mut index = data.index
  while index < data.entries.length() {
    match data.entries[index] {
      Some((key, value)) => {
        data.index = index + 1
        return match data.kind {
          0 => iterator_result(key, false)
          1 => iterator_result(value, false)
          _ => {
            let pair = new_array_value([Some(key), Some(value)])
            iterator_result(pair, false)
          }
        }
      }
      None => index = index + 1
    }
  }
  data.index = index
  data.done = true
  iterator_result(Undefined, true)
}

///|
fn set_iterator_next(this_value : Value?) -> Value raise {
  let (_, data) = require_set_iterator(this_value)
  if data.done {
    return iterator_result(Undefined, true)
  }
  let mut index = data.index
  while index < data.entries.length() {
    match data.entries[index] {
      Some(value) => {
        data.index = index + 1
        return match data.kind {
          1 => {
            let pair = new_array_value([Some(value), Some(value)])
            iterator_result(pair, false)
          }
          _ => iterator_result(value, false)
        }
      }
      None => index = index + 1
    }
  }
  data.index = index
  data.done = true
  iterator_result(Undefined, true)
}

///|
fn eval_assign_op(
  env : Env,
  op : @engine.BinaryOp,
  lhs : @engine.Expr,
  rhs : @engine.Expr,
) -> Value raise {
  with_gc_frame(fn() raise {
    let (target, is_cover) = unwrap_paren_with_cover(lhs)
    match target {
      Ident(name, ident_offset) => {
        let target = resolve_binding_target(env, name)
        let current = with_expr_pos(ident_offset, fn() raise {
          get_binding_value_from_target(env, name, target, env.strict)
        })
        let _ = gc_root_push(current)
        match op {
          @engine.BinaryOp::LogicalAnd =>
            if is_truthy(current) {
              let value = eval_expr(env, rhs)
              let _ = gc_root_push(value)
              if is_anonymous_function_definition(rhs) && !is_cover {
                set_anonymous_function_name(value, name, None)
              }
              with_expr_pos(ident_offset, fn() raise {
                assign_binding_value_to_target(
                  env,
                  name,
                  target,
                  value,
                  env.strict,
                )
                value
              })
            } else {
              current
            }
          @engine.BinaryOp::LogicalOr =>
            if is_truthy(current) {
              current
            } else {
              let value = eval_expr(env, rhs)
              let _ = gc_root_push(value)
              if is_anonymous_function_definition(rhs) && !is_cover {
                set_anonymous_function_name(value, name, None)
              }
              with_expr_pos(ident_offset, fn() raise {
                assign_binding_value_to_target(
                  env,
                  name,
                  target,
                  value,
                  env.strict,
                )
                value
              })
            }
          @engine.BinaryOp::Coalesce =>
            if is_nullish(current) {
              let value = eval_expr(env, rhs)
              let _ = gc_root_push(value)
              if is_anonymous_function_definition(rhs) && !is_cover {
                set_anonymous_function_name(value, name, None)
              }
              with_expr_pos(ident_offset, fn() raise {
                assign_binding_value_to_target(
                  env,
                  name,
                  target,
                  value,
                  env.strict,
                )
                value
              })
            } else {
              current
            }
          _ => {
            let value = eval_expr(env, rhs)
            let _ = gc_root_push(value)
            let result = eval_binary(op, current, value)
            let _ = gc_root_push(result)
            with_expr_pos(ident_offset, fn() raise {
              assign_binding_value_to_target(
                env,
                name,
                target,
                result,
                env.strict,
              )
              result
            })
          }
        }
      }
      Member(obj_expr, key, member_offset) =>
        match obj_expr {
          @engine.Expr::Super =>
            match key {
              @engine.MemberKey::Private(_) =>
                throw_syntax_error("private class field forbidden after super")
              @engine.MemberKey::Computed(expr) => {
                let (base, receiver) = super_base_and_receiver(env)
                let key_value = eval_expr(env, expr)
                let _ = gc_root_push(base)
                let _ = gc_root_push(receiver)
                let _ = gc_root_push(key_value)
                let name = property_key_name(key_value)
                let base_obj = with_expr_pos(member_offset, fn() raise {
                  to_object(base)
                })
                let _ = gc_root_push(base_obj)
                let current = with_expr_pos(member_offset, fn() raise {
                  property_get_with_receiver(base_obj, name, receiver)
                })
                let _ = gc_root_push(current)
                match op {
                  @engine.BinaryOp::LogicalAnd =>
                    if is_truthy(current) {
                      let value = eval_expr(env, rhs)
                      let _ = gc_root_push(value)
                      with_expr_pos(member_offset, fn() raise {
                        super_set_property(env, base, receiver, name, value)
                        value
                      })
                    } else {
                      current
                    }
                  @engine.BinaryOp::LogicalOr =>
                    if is_truthy(current) {
                      current
                    } else {
                      let value = eval_expr(env, rhs)
                      let _ = gc_root_push(value)
                      with_expr_pos(member_offset, fn() raise {
                        super_set_property(env, base, receiver, name, value)
                        value
                      })
                    }
                  @engine.BinaryOp::Coalesce =>
                    if is_nullish(current) {
                      let value = eval_expr(env, rhs)
                      let _ = gc_root_push(value)
                      with_expr_pos(member_offset, fn() raise {
                        super_set_property(env, base, receiver, name, value)
                        value
                      })
                    } else {
                      current
                    }
                  _ => {
                    let value = eval_expr(env, rhs)
                    let _ = gc_root_push(value)
                    let result = eval_binary(op, current, value)
                    let _ = gc_root_push(result)
                    with_expr_pos(member_offset, fn() raise {
                      super_set_property(env, base, receiver, name, result)
                      result
                    })
                  }
                }
              }
              _ => {
                let (base, receiver) = super_base_and_receiver(env)
                let name = member_key_name(env, key)
                let _ = gc_root_push(base)
                let _ = gc_root_push(receiver)
                let base_obj = with_expr_pos(member_offset, fn() raise {
                  to_object(base)
                })
                let _ = gc_root_push(base_obj)
                let current = with_expr_pos(member_offset, fn() raise {
                  property_get_with_receiver(base_obj, name, receiver)
                })
                let _ = gc_root_push(current)
                match op {
                  @engine.BinaryOp::LogicalAnd =>
                    if is_truthy(current) {
                      let value = eval_expr(env, rhs)
                      let _ = gc_root_push(value)
                      with_expr_pos(member_offset, fn() raise {
                        super_set_property(env, base, receiver, name, value)
                        value
                      })
                    } else {
                      current
                    }
                  @engine.BinaryOp::LogicalOr =>
                    if is_truthy(current) {
                      current
                    } else {
                      let value = eval_expr(env, rhs)
                      let _ = gc_root_push(value)
                      with_expr_pos(member_offset, fn() raise {
                        super_set_property(env, base, receiver, name, value)
                        value
                      })
                    }
                  @engine.BinaryOp::Coalesce =>
                    if is_nullish(current) {
                      let value = eval_expr(env, rhs)
                      let _ = gc_root_push(value)
                      with_expr_pos(member_offset, fn() raise {
                        super_set_property(env, base, receiver, name, value)
                        value
                      })
                    } else {
                      current
                    }
                  _ => {
                    let value = eval_expr(env, rhs)
                    let _ = gc_root_push(value)
                    let result = eval_binary(op, current, value)
                    let _ = gc_root_push(result)
                    with_expr_pos(member_offset, fn() raise {
                      super_set_property(env, base, receiver, name, result)
                      result
                    })
                  }
                }
              }
            }
          _ =>
            match key {
              @engine.MemberKey::Private(name) => {
                let target = with_expr_pos(member_offset, fn() raise {
                  eval_expr(env, obj_expr)
                })
                let key_name = env_private_key_checked(env, name)
                let _ = gc_root_push(target)
                let current = with_expr_pos(member_offset, fn() raise {
                  private_property_get(target, key_name, name)
                })
                let _ = gc_root_push(current)
                match op {
                  @engine.BinaryOp::LogicalAnd =>
                    if is_truthy(current) {
                      let value = eval_expr(env, rhs)
                      let _ = gc_root_push(value)
                      with_expr_pos(member_offset, fn() raise {
                        private_property_set(target, key_name, name, value)
                        value
                      })
                    } else {
                      current
                    }
                  @engine.BinaryOp::LogicalOr =>
                    if is_truthy(current) {
                      current
                    } else {
                      let value = eval_expr(env, rhs)
                      let _ = gc_root_push(value)
                      with_expr_pos(member_offset, fn() raise {
                        private_property_set(target, key_name, name, value)
                        value
                      })
                    }
                  @engine.BinaryOp::Coalesce =>
                    if is_nullish(current) {
                      let value = eval_expr(env, rhs)
                      let _ = gc_root_push(value)
                      with_expr_pos(member_offset, fn() raise {
                        private_property_set(target, key_name, name, value)
                        value
                      })
                    } else {
                      current
                    }
                  _ => {
                    let value = eval_expr(env, rhs)
                    let _ = gc_root_push(value)
                    let result = eval_binary(op, current, value)
                    let _ = gc_root_push(result)
                    with_expr_pos(member_offset, fn() raise {
                      private_property_set(target, key_name, name, result)
                      result
                    })
                  }
                }
              }
              @engine.MemberKey::Computed(expr) => {
                let target_value = with_expr_pos(member_offset, fn() raise {
                  eval_expr(env, obj_expr)
                })
                let key_value = eval_expr(env, expr)
                let _ = gc_root_push(target_value)
                let _ = gc_root_push(key_value)
                let target_obj = with_expr_pos(member_offset, fn() raise {
                  to_object(target_value)
                })
                let _ = gc_root_push(target_obj)
                let name = property_key_name(key_value)
                let current = with_expr_pos(member_offset, fn() raise {
                  property_get_with_receiver(target_obj, name, target_value)
                })
                let _ = gc_root_push(current)
                match op {
                  @engine.BinaryOp::LogicalAnd =>
                    if is_truthy(current) {
                      let value = eval_expr(env, rhs)
                      let _ = gc_root_push(value)
                      with_expr_pos(member_offset, fn() raise {
                        let _ = set_property_for_value(
                          target_value,
                          name,
                          value,
                          env.strict,
                        )
                        value
                      })
                    } else {
                      current
                    }
                  @engine.BinaryOp::LogicalOr =>
                    if is_truthy(current) {
                      current
                    } else {
                      let value = eval_expr(env, rhs)
                      let _ = gc_root_push(value)
                      with_expr_pos(member_offset, fn() raise {
                        let _ = set_property_for_value(
                          target_value,
                          name,
                          value,
                          env.strict,
                        )
                        value
                      })
                    }
                  @engine.BinaryOp::Coalesce =>
                    if is_nullish(current) {
                      let value = eval_expr(env, rhs)
                      let _ = gc_root_push(value)
                      with_expr_pos(member_offset, fn() raise {
                        let _ = set_property_for_value(
                          target_value,
                          name,
                          value,
                          env.strict,
                        )
                        value
                      })
                    } else {
                      current
                    }
                  _ => {
                    let value = eval_expr(env, rhs)
                    let _ = gc_root_push(value)
                    let result = eval_binary(op, current, value)
                    let _ = gc_root_push(result)
                    with_expr_pos(member_offset, fn() raise {
                      let _ = set_property_for_value(
                        target_value,
                        name,
                        result,
                        env.strict,
                      )
                      result
                    })
                  }
                }
              }
              _ => {
                let target_value = with_expr_pos(member_offset, fn() raise {
                  eval_expr(env, obj_expr)
                })
                let name = member_key_name(env, key)
                let _ = gc_root_push(target_value)
                let current = with_expr_pos(member_offset, fn() raise {
                  let target_obj = to_object(target_value)
                  let _ = gc_root_push(target_obj)
                  property_get_with_receiver(target_obj, name, target_value)
                })
                let _ = gc_root_push(current)
                match op {
                  @engine.BinaryOp::LogicalAnd =>
                    if is_truthy(current) {
                      let value = eval_expr(env, rhs)
                      let _ = gc_root_push(value)
                      with_expr_pos(member_offset, fn() raise {
                        let _ = set_property_for_value(
                          target_value,
                          name,
                          value,
                          env.strict,
                        )
                        value
                      })
                    } else {
                      current
                    }
                  @engine.BinaryOp::LogicalOr =>
                    if is_truthy(current) {
                      current
                    } else {
                      let value = eval_expr(env, rhs)
                      let _ = gc_root_push(value)
                      with_expr_pos(member_offset, fn() raise {
                        let _ = set_property_for_value(
                          target_value,
                          name,
                          value,
                          env.strict,
                        )
                        value
                      })
                    }
                  @engine.BinaryOp::Coalesce =>
                    if is_nullish(current) {
                      let value = eval_expr(env, rhs)
                      let _ = gc_root_push(value)
                      with_expr_pos(member_offset, fn() raise {
                        let _ = set_property_for_value(
                          target_value,
                          name,
                          value,
                          env.strict,
                        )
                        value
                      })
                    } else {
                      current
                    }
                  _ => {
                    let value = eval_expr(env, rhs)
                    let _ = gc_root_push(value)
                    let result = eval_binary(op, current, value)
                    let _ = gc_root_push(result)
                    with_expr_pos(member_offset, fn() raise {
                      let _ = set_property_for_value(
                        target_value,
                        name,
                        result,
                        env.strict,
                      )
                      result
                    })
                  }
                }
              }
            }
        }
      _ =>
        match target {
          Call(_, _, _) =>
            if !env.strict {
              let _ = eval_expr(env, lhs)
              throw_reference_error("invalid assignment target")
            } else {
              fail("invalid assignment target")
            }
          _ => fail("invalid assignment target")
        }
    }
  })
}

///|
fn unwrap_paren(expr : @engine.Expr) -> @engine.Expr {
  match expr {
    Paren(inner) => unwrap_paren(inner)
    _ => expr
  }
}

///|
fn unwrap_paren_with_cover(expr : @engine.Expr) -> (@engine.Expr, Bool) {
  let mut target = expr
  let mut is_cover = false
  let mut keep_unwrap = true
  while keep_unwrap {
    match target {
      Paren(inner) => {
        is_cover = true
        target = inner
      }
      _ => keep_unwrap = false
    }
  }
  (target, is_cover)
}

///|
fn eval_call(
  env : Env,
  callee : @engine.Expr,
  args : Array[@engine.Expr],
) -> Value raise {
  with_gc_frame(fn() raise {
    match unwrap_paren(callee) {
      @engine.Expr::Ident(name, offset) => {
        let (callee_value, this_value) = with_expr_pos_call_ref(offset, fn() raise {
          env_get_call_reference(env, name)
        })
        let _ = gc_root_push(callee_value)
        let _ = gc_root_push(this_value)
        let argv = if name == "__export" {
          eval_export_args(env, args)
        } else {
          eval_args(env, args)
        }
        for value in argv {
          let _ = gc_root_push(value)

        }
        if name == "eval" {
          match callee_value {
            Builtin(builtin) if builtin.kind == BuiltinFunction::Eval =>
              match function_realm_env(callee_value) {
                Some(realm_env) =>
                  if realm_env_from_env(realm_env).id ==
                    realm_env_from_env(env).id {
                    return eval_with_env(env, argv)
                  }
                None => ()
              }
            _ => ()
          }
        }
        call_value_with_this(callee_value, argv, this_value)
      }
      @engine.Expr::Member(obj_expr, key, _) => {
        let target = eval_expr(env, obj_expr)
        let _ = gc_root_push(target)
        let callee_value = match key {
          @engine.MemberKey::Private(name) => {
            let key_name = env_private_key_checked(env, name)
            private_property_get(target, key_name, name)
          }
          _ => {
            let name = member_key_name(env, key)
            let target_obj = to_object(target)
            property_get_with_receiver(target_obj, name, target)
          }
        }
        let _ = gc_root_push(callee_value)
        let argv = eval_args(env, args)
        for value in argv {
          let _ = gc_root_push(value)

        }
        call_value_with_this(callee_value, argv, target)
      }
      @engine.Expr::OptionalChain(base, segments) => {
        let (callee_value, this_value) = eval_optional_chain_with_this(
          env, base, segments,
        )
        let _ = gc_root_push(callee_value)
        match this_value {
          Some(this_obj) => {
            let _ = gc_root_push(this_obj)

          }
          None => ()
        }
        let argv = eval_args(env, args)
        for value in argv {
          let _ = gc_root_push(value)

        }
        match this_value {
          Some(this_obj) => call_value_with_this(callee_value, argv, this_obj)
          None => call_value(callee_value, argv)
        }
      }
      other => {
        let callee_value = eval_expr(env, other)
        let _ = gc_root_push(callee_value)
        let argv = eval_args(env, args)
        for value in argv {
          let _ = gc_root_push(value)

        }
        call_value(callee_value, argv)
      }
    }
  })
}

///|
fn eval_export_args(
  env : Env,
  args : Array[@engine.Expr],
) -> Array[Value] raise {
  with_gc_frame_values(fn() raise {
    let values : Array[Value] = []
    if args.is_empty() {
      return values
    }
    let mut export_name : String? = None
    match args[0] {
      @engine.Expr::String(name, _, _) => export_name = Some(name)
      _ => ()
    }
    let first = eval_expr(env, args[0])
    values.push(first)
    let _ = gc_root_push(first)
    let mut i = 1
    while i < args.length() {
      let expr = args[i]
      match expr {
        @engine.Expr::Spread(inner) => {
          let spread_value = eval_expr(env, inner)
          let _ = gc_root_push(spread_value)
          for value in build_spread_list(spread_value) {
            values.push(value)
            let _ = gc_root_push(value)

          }
        }
        _ =>
          if i == 1 {
            match export_name {
              Some(name) => {
                let value = eval_named_expr(env, expr, name, None)
                values.push(value)
                let _ = gc_root_push(value)

              }
              None => {
                let value = eval_expr(env, expr)
                values.push(value)
                let _ = gc_root_push(value)

              }
            }
          } else {
            let value = eval_expr(env, expr)
            values.push(value)
            let _ = gc_root_push(value)

          }
      }
      i = i + 1
    }
    values
  })
}

///|
fn eval_args(env : Env, args : Array[@engine.Expr]) -> Array[Value] raise {
  with_gc_frame_values(fn() raise {
    let values : Array[Value] = []
    for expr in args {
      match expr {
        @engine.Expr::Spread(inner) => {
          let spread_value = eval_expr(env, inner)
          let _ = gc_root_push(spread_value)
          for value in build_spread_list(spread_value) {
            values.push(value)
            let _ = gc_root_push(value)

          }
        }
        _ => {
          let value = eval_expr(env, expr)
          values.push(value)
          let _ = gc_root_push(value)

        }
      }
    }
    values
  })
}

///|
fn new_object_value_with_proto(proto : Value?) -> Value {
  let obj = register_object_value(ObjectValue::{
    id: alloc_id(),
    props: Map::new(),
    proto,
    string_data: None,
    number_data: None,
    bool_data: None,
    bigint_data: None,
    symbol_data: None,
    regexp_data: None,
    generator_data: None,
    async_generator_data: None,
    proxy_data: None,
    map_data: None,
    set_data: None,
    map_iter_data: None,
    set_iter_data: None,
    iterator_wrap_data: None,
    iterator_concat_data: None,
    iterator_helper_data: None,
    weakmap_data: None,
    weakset_data: None,
    weakref_data: None,
    finreg_data: None,
    date_data: None,
    array_buffer_data: None,
    dataview_data: None,
    is_html_dda: false,
    is_error: false,
    is_module_namespace: false,
    realm_env: None,
    immutable_proto: false,
    extensible: true,
  })
  Object(obj)
}

///|
fn new_object_struct(proto : Value?) -> ObjectValue {
  let obj = register_object_value(ObjectValue::{
    id: alloc_id(),
    props: Map::new(),
    proto,
    string_data: None,
    number_data: None,
    bool_data: None,
    bigint_data: None,
    symbol_data: None,
    regexp_data: None,
    generator_data: None,
    async_generator_data: None,
    proxy_data: None,
    map_data: None,
    set_data: None,
    map_iter_data: None,
    set_iter_data: None,
    iterator_wrap_data: None,
    iterator_concat_data: None,
    iterator_helper_data: None,
    weakmap_data: None,
    weakset_data: None,
    weakref_data: None,
    finreg_data: None,
    date_data: None,
    array_buffer_data: None,
    dataview_data: None,
    is_html_dda: false,
    is_error: false,
    is_module_namespace: false,
    realm_env: None,
    immutable_proto: false,
    extensible: true,
  })
  obj
}

///|
fn new_object_value() -> Value {
  new_object_value_with_proto(value_from_object(object_proto()))
}

///|
fn new_proxy_value(target : Value, handler : Value) -> Value raise {
  if !is_object_like(target) {
    return throw_type_error("proxy target must be an object")
  }
  if !is_object_like(handler) {
    return throw_type_error("proxy handler must be an object")
  }
  let callable = is_callable(target)
  let constructable = is_constructor_value(target)
  let obj = register_object_value(ObjectValue::{
    id: alloc_id(),
    props: Map::new(),
    proto: None,
    string_data: None,
    number_data: None,
    bool_data: None,
    bigint_data: None,
    symbol_data: None,
    regexp_data: None,
    generator_data: None,
    async_generator_data: None,
    proxy_data: Some(ProxyData::{ target, handler, callable, constructable }),
    map_data: None,
    set_data: None,
    map_iter_data: None,
    set_iter_data: None,
    iterator_wrap_data: None,
    iterator_concat_data: None,
    iterator_helper_data: None,
    weakmap_data: None,
    weakset_data: None,
    weakref_data: None,
    finreg_data: None,
    date_data: None,
    array_buffer_data: None,
    dataview_data: None,
    is_html_dda: false,
    is_error: false,
    is_module_namespace: false,
    realm_env: None,
    immutable_proto: false,
    extensible: true,
  })
  Object(obj)
}

///|
fn new_proxy_revoke_function(proxy : Value) -> Value {
  match new_builtin_value_with_this(BuiltinFunction::ProxyRevoke, proxy) {
    Builtin(builtin) => {
      builtin.props.set("name", property_data_readonly(String("")))
      Builtin(builtin)
    }
    value => value
  }
}

///|
fn new_string_object(
  value : String,
  proto? : Value? = value_from_object(string_proto()),
) -> Value {
  let obj = register_object_value(ObjectValue::{
    id: alloc_id(),
    props: Map::new(),
    proto,
    string_data: Some(value),
    number_data: None,
    bool_data: None,
    bigint_data: None,
    symbol_data: None,
    regexp_data: None,
    generator_data: None,
    async_generator_data: None,
    proxy_data: None,
    map_data: None,
    set_data: None,
    map_iter_data: None,
    set_iter_data: None,
    iterator_wrap_data: None,
    iterator_concat_data: None,
    iterator_helper_data: None,
    weakmap_data: None,
    weakset_data: None,
    weakref_data: None,
    finreg_data: None,
    date_data: None,
    array_buffer_data: None,
    dataview_data: None,
    is_html_dda: false,
    is_error: false,
    is_module_namespace: false,
    realm_env: None,
    immutable_proto: false,
    extensible: true,
  })
  Object(obj)
}

///|
fn new_number_object(
  value : Double,
  proto? : Value? = value_from_object(number_proto()),
) -> Value {
  let obj = register_object_value(ObjectValue::{
    id: alloc_id(),
    props: Map::new(),
    proto,
    string_data: None,
    number_data: Some(value),
    bool_data: None,
    bigint_data: None,
    symbol_data: None,
    regexp_data: None,
    generator_data: None,
    async_generator_data: None,
    proxy_data: None,
    map_data: None,
    set_data: None,
    map_iter_data: None,
    set_iter_data: None,
    iterator_wrap_data: None,
    iterator_concat_data: None,
    iterator_helper_data: None,
    weakmap_data: None,
    weakset_data: None,
    weakref_data: None,
    finreg_data: None,
    date_data: None,
    array_buffer_data: None,
    dataview_data: None,
    is_html_dda: false,
    is_error: false,
    is_module_namespace: false,
    realm_env: None,
    immutable_proto: false,
    extensible: true,
  })
  Object(obj)
}

///|
fn new_date_value(
  value : Double,
  proto? : Value? = value_from_object(date_proto()),
) -> Value {
  let obj = new_object_value_with_proto(proto)
  match obj {
    Object(value_obj) => value_obj.date_data = Some(value)
    _ => ()
  }
  obj
}

///|
fn new_bool_object(
  value : Bool,
  proto? : Value? = value_from_object(bool_proto()),
) -> Value {
  let obj = register_object_value(ObjectValue::{
    id: alloc_id(),
    props: Map::new(),
    proto,
    string_data: None,
    number_data: None,
    bool_data: Some(value),
    bigint_data: None,
    symbol_data: None,
    regexp_data: None,
    generator_data: None,
    async_generator_data: None,
    proxy_data: None,
    map_data: None,
    set_data: None,
    map_iter_data: None,
    set_iter_data: None,
    iterator_wrap_data: None,
    iterator_concat_data: None,
    iterator_helper_data: None,
    weakmap_data: None,
    weakset_data: None,
    weakref_data: None,
    finreg_data: None,
    date_data: None,
    array_buffer_data: None,
    dataview_data: None,
    is_html_dda: false,
    is_error: false,
    is_module_namespace: false,
    realm_env: None,
    immutable_proto: false,
    extensible: true,
  })
  Object(obj)
}

///|
fn new_bigint_object(
  value : @bigint.BigInt,
  proto? : Value? = value_from_object(bigint_proto()),
) -> Value {
  let obj = register_object_value(ObjectValue::{
    id: alloc_id(),
    props: Map::new(),
    proto,
    string_data: None,
    number_data: None,
    bool_data: None,
    bigint_data: Some(value),
    symbol_data: None,
    regexp_data: None,
    generator_data: None,
    async_generator_data: None,
    proxy_data: None,
    map_data: None,
    set_data: None,
    map_iter_data: None,
    set_iter_data: None,
    iterator_wrap_data: None,
    iterator_concat_data: None,
    iterator_helper_data: None,
    weakmap_data: None,
    weakset_data: None,
    weakref_data: None,
    finreg_data: None,
    date_data: None,
    array_buffer_data: None,
    dataview_data: None,
    is_html_dda: false,
    is_error: false,
    is_module_namespace: false,
    realm_env: None,
    immutable_proto: false,
    extensible: true,
  })
  Object(obj)
}

///|
fn new_symbol_object(
  value : SymbolValue,
  proto? : Value? = value_from_object(symbol_proto()),
) -> Value {
  let obj = register_object_value(ObjectValue::{
    id: alloc_id(),
    props: Map::new(),
    proto,
    string_data: None,
    number_data: None,
    bool_data: None,
    bigint_data: None,
    symbol_data: Some(value),
    regexp_data: None,
    generator_data: None,
    async_generator_data: None,
    proxy_data: None,
    map_data: None,
    set_data: None,
    map_iter_data: None,
    set_iter_data: None,
    iterator_wrap_data: None,
    iterator_concat_data: None,
    iterator_helper_data: None,
    weakmap_data: None,
    weakset_data: None,
    weakref_data: None,
    finreg_data: None,
    date_data: None,
    array_buffer_data: None,
    dataview_data: None,
    is_html_dda: false,
    is_error: false,
    is_module_namespace: false,
    realm_env: None,
    immutable_proto: false,
    extensible: true,
  })
  Object(obj)
}

///|
fn require_date_object(value : Value) -> ObjectValue raise {
  match value {
    Object(obj) =>
      match obj.date_data {
        Some(_) => obj
        None => {
          let _ = throw_type_error("not a Date object")
          new_object_struct(None)
        }
      }
    _ => {
      let _ = throw_type_error("not a Date object")
      new_object_struct(None)
    }
  }
}

///|
fn date_value_of(value : Value) -> Double raise {
  let obj = require_date_object(value)
  match obj.date_data {
    Some(v) => v
    None => nan()
  }
}

///|
fn date_is_valid(ms : Double) -> Bool {
  !(Double::is_nan(ms) || Double::is_inf(ms))
}

///|
fn date_day_of_week(ms : Double) -> Int {
  let d = Double::to_int64(Double::trunc(ms))
  let days = floor_div(d, 86400000)
  Int64::to_int(math_mod(days + 4, 7))
}

///|
fn date_fields_or_none(ms : Double) -> (Int, Int, Int, Int, Int, Int, Int)? {
  if !date_is_valid(ms) {
    None
  } else {
    Some(date_fields_from_ms(ms))
  }
}

///|
fn date_set_field_value(
  obj : ObjectValue,
  args : Array[Value],
  first_field : Int,
  end_field : Int,
  force : Bool,
) -> Double raise {
  let current = match obj.date_data {
    Some(value) => value
    None => nan()
  }
  let mut base = current
  let mut res1 = date_is_valid(current)
  if !res1 && force {
    res1 = true
    base = 0.0
  }
  let (year, month, day, hour, min, sec, milli) = if res1 {
    date_fields_from_ms(base)
  } else {
    (1970, 0, 1, 0, 0, 0, 0)
  }
  let fields : Array[Double] = [
    Double::from_int(year),
    Double::from_int(month),
    Double::from_int(day),
    Double::from_int(hour),
    Double::from_int(min),
    Double::from_int(sec),
    Double::from_int(milli),
  ]
  let mut res = true
  let mut i = 0
  let limit = end_field - first_field
  let count = if args.length() < limit { args.length() } else { limit }
  while i < count {
    let num = to_number(args[i])
    if !date_is_valid(num) {
      res = false
    }
    fields[first_field + i] = Double::trunc(num)
    i = i + 1
  }
  if !res1 {
    return nan()
  }
  let mut result = nan()
  if res && !args.is_empty() {
    result = date_make_utc_from_fields(
      fields[0],
      fields[1],
      fields[2],
      fields[3],
      fields[4],
      fields[5],
      fields[6],
    )
  }
  obj.date_data = Some(result)
  result
}

///|
fn new_regexp_value(
  pattern : String,
  flags : String,
  proto : Value?,
  offset? : Int = -1,
) -> Value raise {
  let data = try regexp_data_from_pattern(pattern, flags) catch {
    ThrowSignal(value) => {
      if offset >= 0 {
        match current_source() {
          Some(source) => {
            let (line, column) = offset_to_line_column(source, offset)
            raise ThrowSignal(
              new_error_value_with_pos(
                syntax_error_proto(),
                "invalid regular expression",
                line,
                column,
              ),
            )
          }
          None => raise ThrowSignal(value)
        }
      } else {
        raise ThrowSignal(value)
      }
      fail("unreachable")
    }
    err => raise err
  } noraise {
    value => value
  }
  let props = Map::new()
  props.set("lastIndex", property_data_non_enum_non_config(Number(0.0)))
  let obj = register_object_value(ObjectValue::{
    id: alloc_id(),
    props,
    proto,
    string_data: None,
    number_data: None,
    bool_data: None,
    bigint_data: None,
    symbol_data: None,
    regexp_data: Some(data),
    generator_data: None,
    async_generator_data: None,
    proxy_data: None,
    map_data: None,
    set_data: None,
    map_iter_data: None,
    set_iter_data: None,
    iterator_wrap_data: None,
    iterator_concat_data: None,
    iterator_helper_data: None,
    weakmap_data: None,
    weakset_data: None,
    weakref_data: None,
    finreg_data: None,
    date_data: None,
    array_buffer_data: None,
    dataview_data: None,
    is_html_dda: false,
    is_error: false,
    is_module_namespace: false,
    realm_env: None,
    immutable_proto: false,
    extensible: true,
  })
  Object(obj)
}

///|
fn new_map_value_with_proto(proto : Value?) -> Value {
  let final_proto = match proto {
    Some(value) => Some(value)
    None => value_from_object(map_proto())
  }
  let obj = register_object_value(ObjectValue::{
    id: alloc_id(),
    props: Map::new(),
    proto: final_proto,
    string_data: None,
    number_data: None,
    bool_data: None,
    bigint_data: None,
    symbol_data: None,
    regexp_data: None,
    generator_data: None,
    async_generator_data: None,
    proxy_data: None,
    map_data: Some(MapData::{ entries: [] }),
    set_data: None,
    map_iter_data: None,
    set_iter_data: None,
    iterator_wrap_data: None,
    iterator_concat_data: None,
    iterator_helper_data: None,
    weakmap_data: None,
    weakset_data: None,
    weakref_data: None,
    finreg_data: None,
    date_data: None,
    array_buffer_data: None,
    dataview_data: None,
    is_html_dda: false,
    is_error: false,
    is_module_namespace: false,
    realm_env: None,
    immutable_proto: false,
    extensible: true,
  })
  Object(obj)
}

///|
fn new_set_value_with_proto(proto : Value?) -> Value {
  let final_proto = match proto {
    Some(value) => Some(value)
    None => value_from_object(set_proto())
  }
  let obj = register_object_value(ObjectValue::{
    id: alloc_id(),
    props: Map::new(),
    proto: final_proto,
    string_data: None,
    number_data: None,
    bool_data: None,
    bigint_data: None,
    symbol_data: None,
    regexp_data: None,
    generator_data: None,
    async_generator_data: None,
    proxy_data: None,
    map_data: None,
    set_data: Some(SetData::{ entries: [] }),
    map_iter_data: None,
    set_iter_data: None,
    iterator_wrap_data: None,
    iterator_concat_data: None,
    iterator_helper_data: None,
    weakmap_data: None,
    weakset_data: None,
    weakref_data: None,
    finreg_data: None,
    date_data: None,
    array_buffer_data: None,
    dataview_data: None,
    is_html_dda: false,
    is_error: false,
    is_module_namespace: false,
    realm_env: None,
    immutable_proto: false,
    extensible: true,
  })
  Object(obj)
}

///|
fn new_set_value() -> Value {
  new_set_value_with_proto(None)
}

///|
fn new_weakmap_value_with_proto(proto : Value?) -> Value {
  let final_proto = match proto {
    Some(value) => Some(value)
    None => value_from_object(weakmap_proto())
  }
  let obj = register_object_value(ObjectValue::{
    id: alloc_id(),
    props: Map::new(),
    proto: final_proto,
    string_data: None,
    number_data: None,
    bool_data: None,
    bigint_data: None,
    symbol_data: None,
    regexp_data: None,
    generator_data: None,
    async_generator_data: None,
    proxy_data: None,
    map_data: None,
    set_data: None,
    map_iter_data: None,
    set_iter_data: None,
    iterator_wrap_data: None,
    iterator_concat_data: None,
    iterator_helper_data: None,
    weakmap_data: Some(WeakMapData::{ entries: [] }),
    weakset_data: None,
    weakref_data: None,
    finreg_data: None,
    date_data: None,
    array_buffer_data: None,
    dataview_data: None,
    is_html_dda: false,
    is_error: false,
    is_module_namespace: false,
    realm_env: None,
    immutable_proto: false,
    extensible: true,
  })
  Object(obj)
}

///|
fn new_weakset_value_with_proto(proto : Value?) -> Value {
  let final_proto = match proto {
    Some(value) => Some(value)
    None => value_from_object(weakset_proto())
  }
  let obj = register_object_value(ObjectValue::{
    id: alloc_id(),
    props: Map::new(),
    proto: final_proto,
    string_data: None,
    number_data: None,
    bool_data: None,
    bigint_data: None,
    symbol_data: None,
    regexp_data: None,
    generator_data: None,
    async_generator_data: None,
    proxy_data: None,
    map_data: None,
    set_data: None,
    map_iter_data: None,
    set_iter_data: None,
    iterator_wrap_data: None,
    iterator_concat_data: None,
    iterator_helper_data: None,
    weakmap_data: None,
    weakset_data: Some(WeakSetData::{ entries: [] }),
    weakref_data: None,
    finreg_data: None,
    date_data: None,
    array_buffer_data: None,
    dataview_data: None,
    is_html_dda: false,
    is_error: false,
    is_module_namespace: false,
    realm_env: None,
    immutable_proto: false,
    extensible: true,
  })
  Object(obj)
}

///|
fn new_weakref_value(target : Value, proto : Value?) -> Value {
  let proto_value = match proto {
    Some(value) => Some(value)
    None => value_from_object(weakref_proto())
  }
  let obj = register_object_value(ObjectValue::{
    id: alloc_id(),
    props: Map::new(),
    proto: proto_value,
    string_data: None,
    number_data: None,
    bool_data: None,
    bigint_data: None,
    symbol_data: None,
    regexp_data: None,
    generator_data: None,
    async_generator_data: None,
    proxy_data: None,
    map_data: None,
    set_data: None,
    map_iter_data: None,
    set_iter_data: None,
    iterator_wrap_data: None,
    iterator_concat_data: None,
    iterator_helper_data: None,
    weakmap_data: None,
    weakset_data: None,
    weakref_data: Some(WeakRefData::{ target, }),
    finreg_data: None,
    date_data: None,
    array_buffer_data: None,
    dataview_data: None,
    is_html_dda: false,
    is_error: false,
    is_module_namespace: false,
    realm_env: None,
    immutable_proto: false,
    extensible: true,
  })
  Object(obj)
}

///|
fn new_finreg_value(callback : Value, realm_env : Env, proto : Value?) -> Value {
  let proto_value = match proto {
    Some(value) => Some(value)
    None => value_from_object(finreg_proto())
  }
  let realm_root = realm_env_from_env(realm_env)
  let obj = register_object_value(ObjectValue::{
    id: alloc_id(),
    props: Map::new(),
    proto: proto_value,
    string_data: None,
    number_data: None,
    bool_data: None,
    bigint_data: None,
    symbol_data: None,
    regexp_data: None,
    generator_data: None,
    async_generator_data: None,
    proxy_data: None,
    map_data: None,
    set_data: None,
    map_iter_data: None,
    set_iter_data: None,
    iterator_wrap_data: None,
    iterator_concat_data: None,
    iterator_helper_data: None,
    weakmap_data: None,
    weakset_data: None,
    weakref_data: None,
    finreg_data: Some(FinalizationRegistryData::{
      callback,
      entries: [],
      realm_env: realm_root,
    }),
    date_data: None,
    array_buffer_data: None,
    dataview_data: None,
    is_html_dda: false,
    is_error: false,
    is_module_namespace: false,
    realm_env: None,
    immutable_proto: false,
    extensible: true,
  })
  Object(obj)
}

///|
fn build_stack_from_positions(
  message : String,
  source : String,
  positions : Array[Int],
) -> (String, Int, Int) {
  let lines : Array[String] = []
  let mut top_line = 1
  let mut top_column = 1
  let mut i = positions.length()
  while i > 0 {
    let pos = positions[i - 1]
    let (line, column) = offset_to_line_column(source, pos)
    if lines.is_empty() {
      top_line = line
      top_column = column
      lines.push("\{message}:\{line}:\{column}")
    } else {
      lines.push("at:\{line}:\{column}")
    }
    i = i - 1
  }
  let funcs = current_function_stack()
  let mut j = funcs.length()
  while j > 0 {
    j = j - 1
    let func = funcs[j]
    let name = match func.name {
      Some(value) => if value.is_empty() { "<anonymous>" } else { value }
      None => "<anonymous>"
    }
    lines.push("at " + name)
  }
  (lines.join("\n"), top_line, top_column)
}

///|
fn new_error_value(
  proto : ObjectValue?,
  message : String,
  set_message? : Bool = true,
) -> Value {
  let obj = new_object_value_with_proto(value_from_object(proto))
  match obj {
    Object(value) => {
      value.is_error = true
      if set_message {
        value.props.set("message", property_data_non_enum(String(message)))
      }
      match current_source() {
        Some(source) => {
          let positions = expr_pos_stack()
          if !positions.is_empty() {
            let (stack, line, column) = build_stack_from_positions(
              message, source, positions,
            )
            value.props.set(
              "lineNumber",
              property_data(Number(Double::from_int(line))),
            )
            value.props.set(
              "columnNumber",
              property_data(Number(Double::from_int(column))),
            )
            value.props.set("stack", property_data(String(stack)))
          }
        }
        None => ()
      }
    }
    _ => ()
  }
  obj
}

///|
fn error_proto_from_target(
  target : Value,
  fallback : ObjectValue?,
) -> ObjectValue? raise {
  let fallback_value = value_from_object(fallback)
  let proto_value = constructor_proto_from_target(target, fallback_value)
  match proto_value {
    Some(Object(obj)) => Some(obj)
    _ => fallback
  }
}

///|
fn new_error_value_with_pos(
  proto : ObjectValue?,
  message : String,
  line : Int,
  column : Int,
) -> Value {
  let obj = new_object_value_with_proto(value_from_object(proto))
  match obj {
    Object(value) => {
      value.is_error = true
      value.props.set("message", property_data_non_enum(String(message)))
      value.props.set(
        "lineNumber",
        property_data(Number(Double::from_int(line))),
      )
      value.props.set(
        "columnNumber",
        property_data(Number(Double::from_int(column))),
      )
      let stack = "\{message}:\{line}:\{column}"
      value.props.set("stack", property_data(String(stack)))
    }
    _ => ()
  }
  obj
}

///|
priv struct ErrorMessageInfo {
  message : String
  has_message : Bool
}

///|
fn error_message_from_args(
  args : Array[Value],
  index? : Int = 0,
) -> ErrorMessageInfo raise {
  if index >= args.length() {
    return ErrorMessageInfo::{ message: "", has_message: false }
  }
  let value = args[index]
  if value is Undefined {
    return ErrorMessageInfo::{ message: "", has_message: false }
  }
  ErrorMessageInfo::{ message: to_string_strict(value), has_message: true }
}

///|
fn install_error_cause(obj : ObjectValue, options : Value) -> Unit raise {
  if !is_object_like(options) {
    return
  }
  if has_property_value(options, "cause") {
    let cause = property_get(options, "cause")
    obj.props.set("cause", property_data_non_enum(cause))
  }
}

///|
fn new_aggregate_error_value(args : Array[Value]) -> Value raise {
  let errors_proto = match current_env() {
    Some(env) =>
      match value_from_object(array_proto_for_env(env)) {
        Some(value) => Some(value)
        None => value_from_object(array_proto())
      }
    None => value_from_object(array_proto())
  }
  new_aggregate_error_value_with_proto(
    args,
    aggregate_error_proto(),
    errors_proto,
  )
}

///|
fn new_aggregate_error_value_with_proto(
  args : Array[Value],
  proto : ObjectValue?,
  errors_proto : Value?,
) -> Value raise {
  let errors_value = if args.is_empty() { Undefined } else { args[0] }
  let message_info = error_message_from_args(args, index=1)
  let list = build_spread_list(errors_value)
  let elements : Array[Value?] = []
  for value in list {
    elements.push(Some(value))
  }
  let errors_array = new_array_value_with_proto(elements, proto=errors_proto)
  let obj = new_error_value(
    proto,
    message_info.message,
    set_message=message_info.has_message,
  )
  match obj {
    Object(value) =>
      value.props.set("errors", property_data_non_enum(errors_array))
    _ => ()
  }
  obj
}

///|
fn throw_type_error_for_env(env : Env?, message : String) -> Value raise {
  let proto = match env {
    Some(env) =>
      match type_error_proto_for_env(env) {
        Some(obj) => Some(obj)
        None => type_error_proto()
      }
    None => type_error_proto()
  }
  raise ThrowSignal(new_error_value(proto, message))
}

///|
fn throw_type_error(message : String) -> Value raise {
  throw_type_error_for_env(current_env(), message)
}

///|
fn type_error_value(message : String) -> Value {
  let proto = match current_env() {
    Some(env) =>
      match type_error_proto_for_env(env) {
        Some(obj) => Some(obj)
        None => type_error_proto()
      }
    None => type_error_proto()
  }
  new_error_value(proto, message)
}

///|
fn throw_reference_error(message : String) -> Value raise {
  let proto = match current_env() {
    Some(env) =>
      match reference_error_proto_for_env(env) {
        Some(obj) => Some(obj)
        None => reference_error_proto()
      }
    None => reference_error_proto()
  }
  raise ThrowSignal(new_error_value(proto, message))
}

///|
fn throw_syntax_error(message : String) -> Value raise {
  let proto = match current_env() {
    Some(env) =>
      match syntax_error_proto_for_env(env) {
        Some(obj) => Some(obj)
        None => syntax_error_proto()
      }
    None => syntax_error_proto()
  }
  raise ThrowSignal(new_error_value(proto, message))
}

///|
fn throw_range_error(message : String) -> Value raise {
  let proto = match current_env() {
    Some(env) =>
      match range_error_proto_for_env(env) {
        Some(obj) => Some(obj)
        None => range_error_proto()
      }
    None => range_error_proto()
  }
  raise ThrowSignal(new_error_value(proto, message))
}

///|
fn throw_uri_error(message : String) -> Value raise {
  let proto = match current_env() {
    Some(env) =>
      match uri_error_proto_for_env(env) {
        Some(obj) => Some(obj)
        None => uri_error_proto()
      }
    None => uri_error_proto()
  }
  raise ThrowSignal(new_error_value(proto, message))
}

///|
fn add_string_length(base : Int, extra : Int) -> Int raise {
  if extra < 0 || base > js_string_len_max - extra {
    let _ = throw_range_error("invalid string length")

  }
  base + extra
}

///|
fn new_builtin_value(kind : BuiltinFunction) -> Value {
  let props = Map::new()
  props.set(
    "length",
    property_data_readonly(Number(Double::from_int(builtin_length(kind)))),
  )
  props.set("name", property_data_readonly(String(builtin_name(kind))))
  let realm_env = match current_env() {
    Some(env) => Some(env)
    None => root_env()
  }
  let proto = match realm_env {
    Some(env) =>
      match function_proto_for_env(env) {
        Some(value) => Some(value)
        None => function_proto()
      }
    None => function_proto()
  }
  let builtin = register_builtin_value(BuiltinValue::{
    kind,
    id: alloc_id(),
    props,
    this_value: None,
    proto,
    extensible: true,
    is_html_dda: false,
    realm_env,
  })
  Builtin(builtin)
}

///|
fn new_builtin_value_with_this(
  kind : BuiltinFunction,
  this_value : Value,
) -> Value {
  match new_builtin_value(kind) {
    Builtin(builtin) => {
      let with_this = register_builtin_value(BuiltinValue::{
        kind: builtin.kind,
        id: builtin.id,
        props: builtin.props,
        this_value: Some(this_value),
        proto: builtin.proto,
        extensible: builtin.extensible,
        is_html_dda: builtin.is_html_dda,
        realm_env: builtin.realm_env,
      })
      Builtin(with_this)
    }
    value => value
  }
}

///|
fn new_html_dda_builtin(kind : BuiltinFunction) -> Value {
  match new_builtin_value(kind) {
    Builtin(builtin) => {
      builtin.is_html_dda = true
      Builtin(builtin)
    }
    value => value
  }
}

///|

///|
fn new_array_value_with_proto(
  elements : Array[Value?],
  proto? : Value? = None,
) -> Value {
  let props = Map::new()
  props.set(
    "length",
    property_data_non_enum_non_config(
      Number(Double::from_int(elements.length())),
    ),
  )
  let proto_value = match proto {
    Some(value) => Some(value)
    None => value_from_object(array_proto())
  }
  let arr = register_array_value(ArrayValue::{
    id: alloc_id(),
    elements,
    proto: proto_value,
    props,
    typed_array_data: None,
    extensible: true,
  })
  Array(arr)
}

///|
fn new_array_value(elements : Array[Value?]) -> Value {
  new_array_value_with_proto(elements)
}

///|
fn new_array_buffer_value_with_options(
  byte_length : Int,
  max_byte_length : Int,
  resizable : Bool,
  proto? : Value? = None,
) -> Value {
  let proto_value = match proto {
    Some(value) => Some(value)
    None => value_from_object(array_buffer_proto())
  }
  let value = new_object_value_with_proto(proto_value)
  match value {
    Object(obj) => {
      let bytes = Array::make(byte_length, Int::to_byte(0))
      obj.array_buffer_data = Some(ArrayBufferData::{
        bytes,
        detached: false,
        shared: false,
        max_byte_length,
        resizable,
      })
    }
    _ => ()
  }
  value
}

///|
fn new_array_buffer_value(byte_length : Int) -> Value {
  new_array_buffer_value_with_options(byte_length, byte_length, false)
}

///|
fn new_shared_array_buffer_value_with_options(
  byte_length : Int,
  max_byte_length : Int,
  resizable : Bool,
  proto : Value?,
) -> Value {
  let proto_value = match proto {
    Some(value) => Some(value)
    None => value_from_object(shared_array_buffer_proto())
  }
  let value = new_object_value_with_proto(proto_value)
  match value {
    Object(obj) => {
      let bytes = Array::make(byte_length, Int::to_byte(0))
      obj.array_buffer_data = Some(ArrayBufferData::{
        bytes,
        detached: false,
        shared: true,
        max_byte_length,
        resizable,
      })
    }
    _ => ()
  }
  value
}

///|
fn new_dataview_value_with_proto(
  buffer : ObjectValue,
  byte_offset : Int,
  byte_length : Int,
  length_tracking : Bool,
  proto : Value?,
) -> Value {
  let value = new_object_value_with_proto(proto)
  match value {
    Object(obj) =>
      obj.dataview_data = Some(DataViewData::{
        buffer,
        byte_offset,
        byte_length,
        length_tracking,
      })
    _ => ()
  }
  value
}

///|
fn new_dataview_from_args(
  args : Array[Value],
  target_value : Value,
) -> Value raise {
  let buffer_value = if args.is_empty() { Undefined } else { args[0] }
  let (buffer_obj, data) = require_array_buffer(Some(buffer_value))
  let offset64 = if args.length() > 1 { to_index_int64(args[1]) } else { 0L }
  if data.detached {
    return throw_type_error("ArrayBuffer is detached")
  }
  let max_len = array_buffer_data_length(data)
  if offset64 > Int64::from_int(max_len) {
    return throw_range_error("invalid byteOffset")
  }
  let offset = Int64::to_int(offset64)
  let mut len = max_len - offset
  let mut length_tracking = false
  if args.length() > 2 && !(args[2] is Undefined) {
    let len64 = to_index_int64(args[2])
    if len64 > Int64::from_int(len) {
      return throw_range_error("invalid byteLength")
    }
    len = Int64::to_int(len64)
  } else {
    length_tracking = data.resizable
  }
  let proto = constructor_proto_from_target(
    target_value,
    {
      let realm_env = function_realm_env_checked(target_value)
      match value_from_object(dataview_proto_for_env(realm_env)) {
        Some(value) => Some(value)
        None => value_from_object(dataview_proto())
      }
    },
  )
  match buffer_obj.array_buffer_data {
    Some(updated) => {
      if updated.detached {
        return throw_type_error("ArrayBuffer is detached")
      }
      let current_len = array_buffer_data_length(updated)
      if offset > current_len {
        return throw_range_error("invalid byteOffset or byteLength")
      }
      if length_tracking {
        len = current_len - offset
      } else if offset + len > current_len {
        return throw_range_error("invalid byteOffset or byteLength")
      }
    }
    None => return throw_type_error("ArrayBuffer is detached")
  }
  new_dataview_value_with_proto(buffer_obj, offset, len, length_tracking, proto)
}

///|
fn typed_array_bytes_per_element(kind : TypedArrayKind) -> Int {
  match kind {
    TypedArrayKind::Uint8 => 1
    TypedArrayKind::Int8 => 1
    TypedArrayKind::Uint8Clamped => 1
    TypedArrayKind::Uint16 => 2
    TypedArrayKind::Int16 => 2
    TypedArrayKind::Float16 => 2
    TypedArrayKind::Uint32 => 4
    TypedArrayKind::Int32 => 4
    TypedArrayKind::BigInt64 => 8
    TypedArrayKind::BigUint64 => 8
    TypedArrayKind::Float32 => 4
    TypedArrayKind::Float64 => 8
  }
}

///|
fn typed_array_constructor_name(kind : TypedArrayKind) -> String {
  match kind {
    TypedArrayKind::Uint8 => "Uint8Array"
    TypedArrayKind::Int8 => "Int8Array"
    TypedArrayKind::Uint8Clamped => "Uint8ClampedArray"
    TypedArrayKind::Uint16 => "Uint16Array"
    TypedArrayKind::Int16 => "Int16Array"
    TypedArrayKind::Uint32 => "Uint32Array"
    TypedArrayKind::Int32 => "Int32Array"
    TypedArrayKind::BigInt64 => "BigInt64Array"
    TypedArrayKind::BigUint64 => "BigUint64Array"
    TypedArrayKind::Float16 => "Float16Array"
    TypedArrayKind::Float32 => "Float32Array"
    TypedArrayKind::Float64 => "Float64Array"
  }
}

///|
fn new_typed_array_view(
  kind : TypedArrayKind,
  buffer : ObjectValue,
  byte_offset : Int,
  length : Int,
  length_tracking : Bool,
  proto? : Value? = None,
) -> Value {
  let elements : Array[Value?] = []
  let mut i = 0
  while i < length {
    elements.push(None)
    i = i + 1
  }
  let props = Map::new()
  let bpe = typed_array_bytes_per_element(kind)
  let proto_value = match proto {
    Some(value) => Some(value)
    None =>
      match value_from_object(typed_array_proto_for_kind(kind)) {
        Some(value) => Some(value)
        None => value_from_object(array_proto())
      }
  }
  let arr = register_array_value(ArrayValue::{
    id: alloc_id(),
    elements,
    proto: proto_value,
    props,
    typed_array_data: Some(TypedArrayData::{
      kind,
      buffer,
      byte_offset,
      length,
      length_tracking,
      bytes_per_element: bpe,
    }),
    extensible: true,
  })
  Array(arr)
}

///|
fn new_typed_array_value(
  kind : TypedArrayKind,
  length : Int,
  proto? : Value? = None,
  buffer_proto? : Value? = None,
) -> Value {
  let bpe = typed_array_bytes_per_element(kind)
  let byte_length = length * bpe
  let buffer_value = new_array_buffer_value_with_options(
    byte_length,
    byte_length,
    false,
    proto=buffer_proto,
  )
  match buffer_value {
    Object(buffer_obj) =>
      new_typed_array_view(kind, buffer_obj, 0, length, false, proto~)
    _ =>
      new_typed_array_view(
        kind,
        new_object_struct(None),
        0,
        length,
        false,
        proto~,
      )
  }
}

///|
fn new_typed_array_from_array(
  kind : TypedArrayKind,
  arr : ArrayValue,
  proto : Value?,
  buffer_proto : Value?,
) -> Value raise {
  let source_value = Array(arr)
  let length = match arr.typed_array_data {
    Some(src_data) =>
      if typed_array_is_oob(src_data) {
        let _ = throw_type_error("ArrayBuffer is detached")
        0
      } else {
        typed_array_effective_length(src_data)
      }
    None => array_like_length(source_value)
  }
  let value = new_typed_array_value(kind, length, proto~, buffer_proto~)
  match value {
    Array(target) =>
      match target.typed_array_data {
        Some(data) => {
          let mut i = 0
          while i < length {
            let element = match arr.typed_array_data {
              Some(src_data) => typed_array_get_index(src_data, i)
              None => property_get(source_value, Int::to_string(i))
            }
            let _ = typed_array_set_index(data, i, element)
            i = i + 1
          }
        }
        None => ()
      }
    _ => ()
  }
  value
}

///|
fn new_typed_array_from_buffer(
  kind : TypedArrayKind,
  buffer_value : Value,
  byte_offset_value : Value,
  length_value : Value?,
  target_value : Value,
) -> Value raise {
  let (buffer_obj, _) = require_array_buffer(Some(buffer_value))
  let offset64 = to_index_int64(byte_offset_value)
  let buf = match buffer_obj.array_buffer_data {
    Some(data) => data
    None => return throw_type_error("not an ArrayBuffer")
  }
  if buf.detached {
    return throw_type_error("ArrayBuffer is detached")
  }
  let bpe = typed_array_bytes_per_element(kind)
  let bpe64 = Int64::from_int(bpe)
  let mut max_len64 = Int64::from_int(array_buffer_data_length(buf))
  if offset64 > max_len64 || Int64::mod(offset64, bpe64) != 0L {
    return throw_range_error("invalid offset")
  }
  let mut track_rab = false
  let len64 = match length_value {
    None => {
      track_rab = buf.resizable
      if !track_rab && Int64::mod(max_len64, bpe64) != 0L {
        return throw_range_error("invalid length")
      }
      (max_len64 - offset64) / bpe64
    }
    Some(value) =>
      if value is Undefined {
        track_rab = buf.resizable
        if !track_rab && Int64::mod(max_len64, bpe64) != 0L {
          return throw_range_error("invalid length")
        }
        (max_len64 - offset64) / bpe64
      } else {
        let next_len64 = to_index_int64(value)
        let next_buf = match buffer_obj.array_buffer_data {
          Some(data) => data
          None => return throw_type_error("not an ArrayBuffer")
        }
        if next_buf.detached {
          return throw_type_error("ArrayBuffer is detached")
        }
        max_len64 = Int64::from_int(array_buffer_data_length(next_buf))
        if offset64 > max_len64 {
          return throw_range_error("invalid length")
        }
        let available = max_len64 - offset64
        if next_len64 > available / bpe64 {
          return throw_range_error("invalid length")
        }
        next_len64
      }
  }
  let max_int = 2147483647
  if len64 > Int64::from_int(max_int) {
    return throw_range_error("invalid array buffer length")
  }
  let offset = Int64::to_int(offset64)
  let len = Int64::to_int(len64)
  let proto = typed_array_proto_from_target(kind, target_value)
  new_typed_array_view(kind, buffer_obj, offset, len, track_rab, proto~)
}

///|
fn typed_array_proto_from_target(
  kind : TypedArrayKind,
  target_value : Value,
) -> Value? raise {
  match target_value {
    Undefined =>
      match value_from_object(typed_array_proto_for_kind(kind)) {
        Some(value) => Some(value)
        None => value_from_object(array_proto())
      }
    _ => {
      let realm_env = function_realm_env_checked(target_value)
      let default_proto = match
        value_from_object(typed_array_proto_for_kind_env(realm_env, kind)) {
        Some(value) => Some(value)
        None =>
          match value_from_object(typed_array_proto_for_kind(kind)) {
            Some(value) => Some(value)
            None => value_from_object(array_proto())
          }
      }
      constructor_proto_from_target(target_value, default_proto)
    }
  }
}

///|
fn typed_array_buffer_proto_from_target(target_value : Value) -> Value? raise {
  match target_value {
    Undefined =>
      match current_env() {
        Some(env) =>
          match value_from_object(array_buffer_proto_for_env(env)) {
            Some(value) => Some(value)
            None => value_from_object(array_buffer_proto())
          }
        None => value_from_object(array_buffer_proto())
      }
    _ => {
      let realm_env = function_realm_env_checked(target_value)
      match value_from_object(array_buffer_proto_for_env(realm_env)) {
        Some(value) => Some(value)
        None => value_from_object(array_buffer_proto())
      }
    }
  }
}

///|
fn new_typed_array_from_args(
  kind : TypedArrayKind,
  args : Array[Value],
  target_value : Value,
) -> Value raise {
  let buffer_proto = typed_array_buffer_proto_from_target(target_value)
  if args.is_empty() {
    let proto = typed_array_proto_from_target(kind, target_value)
    return new_typed_array_value(kind, 0, proto~, buffer_proto~)
  }
  match args[0] {
    Array(arr) => {
      let proto = typed_array_proto_from_target(kind, target_value)
      match arr.typed_array_data {
        Some(_) => new_typed_array_from_array(kind, arr, proto, buffer_proto)
        None => {
          let source = array_from_value(Undefined, [Array(arr)])
          match source {
            Array(source_arr) =>
              new_typed_array_from_array(kind, source_arr, proto, buffer_proto)
            _ => new_typed_array_value(kind, 0, proto~, buffer_proto~)
          }
        }
      }
    }
    Object(obj) =>
      match obj.array_buffer_data {
        Some(_) => {
          let offset_value = if args.length() > 1 { args[1] } else { Undefined }
          let length_value = if args.length() > 2 {
            Some(args[2])
          } else {
            None
          }
          new_typed_array_from_buffer(
            kind,
            Object(obj),
            offset_value,
            length_value,
            target_value,
          )
        }
        None => {
          let proto = typed_array_proto_from_target(kind, target_value)
          let source = array_from_value(Undefined, [Object(obj)])
          match source {
            Array(source_arr) =>
              new_typed_array_from_array(kind, source_arr, proto, buffer_proto)
            _ => new_typed_array_value(kind, 0, proto~, buffer_proto~)
          }
        }
      }
    _ if is_object_like(args[0]) => {
      let proto = typed_array_proto_from_target(kind, target_value)
      let source = array_from_value(Undefined, [args[0]])
      match source {
        Array(source_arr) =>
          new_typed_array_from_array(kind, source_arr, proto, buffer_proto)
        _ => new_typed_array_value(kind, 0, proto~, buffer_proto~)
      }
    }
    _ => {
      let len64 = to_index_int64(args[0])
      let bpe = typed_array_bytes_per_element(kind)
      let max_int = 2147483647
      let max_len = max_int / bpe
      if len64 > Int64::from_int(max_len) {
        return throw_range_error("invalid array buffer length")
      }
      let len = Int64::to_int(len64)
      let proto = typed_array_proto_from_target(kind, target_value)
      new_typed_array_value(kind, len, proto~, buffer_proto~)
    }
  }
}

///|
fn require_array_buffer(value : Value?) -> (ObjectValue, ArrayBufferData) raise {
  match value {
    Some(Object(obj)) =>
      match obj.array_buffer_data {
        Some(data) => (obj, data)
        None => {
          let _ = throw_type_error("not an ArrayBuffer")
          (
            obj,
            ArrayBufferData::{
              bytes: [],
              detached: true,
              shared: false,
              max_byte_length: 0,
              resizable: false,
            },
          )
        }
      }
    _ => {
      let _ = throw_type_error("not an ArrayBuffer")
      (
        new_object_struct(None),
        ArrayBufferData::{
          bytes: [],
          detached: true,
          shared: false,
          max_byte_length: 0,
          resizable: false,
        },
      )
    }
  }
}

///|
fn require_non_shared_array_buffer(
  value : Value?,
) -> (ObjectValue, ArrayBufferData) raise {
  let (obj, data) = require_array_buffer(value)
  if data.shared {
    let _ = throw_type_error("not an ArrayBuffer")

  }
  (obj, data)
}

///|
fn require_shared_array_buffer(
  value : Value?,
) -> (ObjectValue, ArrayBufferData) raise {
  let (obj, data) = require_array_buffer(value)
  if !data.shared {
    let _ = throw_type_error("not a SharedArrayBuffer")

  }
  (obj, data)
}

///|
fn array_buffer_data_length(data : ArrayBufferData) -> Int {
  if data.detached {
    0
  } else {
    data.bytes.length()
  }
}

///|
fn typed_array_is_detached(data : TypedArrayData) -> Bool {
  match data.buffer.array_buffer_data {
    Some(buf) => buf.detached
    None => true
  }
}

///|
fn typed_array_is_oob(data : TypedArrayData) -> Bool {
  match data.buffer.array_buffer_data {
    Some(buf) => {
      if buf.detached {
        return true
      }
      let len = buf.bytes.length()
      if data.byte_offset > len {
        return true
      }
      if data.length_tracking {
        return false
      }
      data.byte_offset + data.length * data.bytes_per_element > len
    }
    None => true
  }
}

///|
fn typed_array_is_valid_integer_index(
  data : TypedArrayData,
  index : Double,
) -> Bool {
  if Double::is_nan(index) || Double::is_inf(index) {
    return false
  }
  if is_negative_zero(index) {
    return false
  }
  if Double::trunc(index) != index || index < 0.0 {
    return false
  }
  if typed_array_is_oob(data) {
    return false
  }
  let len = typed_array_effective_length(data)
  index < Double::from_int(len)
}

///|
fn typed_array_effective_length(data : TypedArrayData) -> Int {
  if typed_array_is_detached(data) {
    return 0
  }
  match data.buffer.array_buffer_data {
    Some(buf) => {
      let available = buf.bytes.length() - data.byte_offset
      if available <= 0 {
        return 0
      }
      let max_len = available / data.bytes_per_element
      if data.length_tracking {
        max_len
      } else if data.length <= max_len {
        data.length
      } else {
        0
      }
    }
    None => 0
  }
}

///|
fn typed_array_effective_byte_length(data : TypedArrayData) -> Int {
  if typed_array_is_detached(data) {
    0
  } else {
    typed_array_effective_length(data) * data.bytes_per_element
  }
}

///|
fn dataview_is_detached(data : DataViewData) -> Bool {
  match data.buffer.array_buffer_data {
    Some(buf) => buf.detached
    None => true
  }
}

///|
fn dataview_is_oob(data : DataViewData) -> Bool {
  match data.buffer.array_buffer_data {
    Some(buf) => {
      if buf.detached {
        return true
      }
      let len = buf.bytes.length()
      if data.byte_offset > len {
        return true
      }
      if data.length_tracking {
        return false
      }
      data.byte_offset + data.byte_length > len
    }
    None => true
  }
}

///|
fn dataview_effective_length(data : DataViewData) -> Int {
  if dataview_is_detached(data) {
    return 0
  }
  match data.buffer.array_buffer_data {
    Some(buf) => {
      let available = buf.bytes.length() - data.byte_offset
      if available <= 0 {
        return 0
      }
      if data.length_tracking {
        available
      } else {
        data.byte_length
      }
    }
    None => 0
  }
}

///|
fn require_dataview_data(value : Value?) -> (ObjectValue, DataViewData) raise {
  match value {
    Some(Object(obj)) =>
      match obj.dataview_data {
        Some(data) => (obj, data)
        None => {
          let _ = throw_type_error("not a DataView")
          (
            obj,
            DataViewData::{
              buffer: obj,
              byte_offset: 0,
              byte_length: 0,
              length_tracking: false,
            },
          )
        }
      }
    _ => {
      let _ = throw_type_error("not a DataView")
      let fallback = new_object_struct(None)
      (
        fallback,
        DataViewData::{
          buffer: fallback,
          byte_offset: 0,
          byte_length: 0,
          length_tracking: false,
        },
      )
    }
  }
}

///|
fn byte_to_uint(value : Byte) -> UInt {
  Int::reinterpret_as_uint(Byte::to_int(value))
}

///|
fn buffer_read_u16_le(buf : ArrayBufferData, index : Int) -> Int {
  let b0 = Byte::to_int(buf.bytes[index])
  let b1 = Byte::to_int(buf.bytes[index + 1])
  b0 + (b1 << 8)
}

///|
fn buffer_read_u16_be(buf : ArrayBufferData, index : Int) -> Int {
  let b0 = Byte::to_int(buf.bytes[index])
  let b1 = Byte::to_int(buf.bytes[index + 1])
  (b0 << 8) + b1
}

///|
fn buffer_read_u32_le(buf : ArrayBufferData, index : Int) -> UInt {
  let b0 = byte_to_uint(buf.bytes[index])
  let b1 = byte_to_uint(buf.bytes[index + 1])
  let b2 = byte_to_uint(buf.bytes[index + 2])
  let b3 = byte_to_uint(buf.bytes[index + 3])
  let v0 = b0
  let v1 = b1 << 8
  let v2 = b2 << 16
  let v3 = b3 << 24
  UInt::lor(v0, UInt::lor(v1, UInt::lor(v2, v3)))
}

///|
fn buffer_read_u32_be(buf : ArrayBufferData, index : Int) -> UInt {
  let b0 = byte_to_uint(buf.bytes[index])
  let b1 = byte_to_uint(buf.bytes[index + 1])
  let b2 = byte_to_uint(buf.bytes[index + 2])
  let b3 = byte_to_uint(buf.bytes[index + 3])
  let v0 = b0 << 24
  let v1 = b1 << 16
  let v2 = b2 << 8
  let v3 = b3
  UInt::lor(v0, UInt::lor(v1, UInt::lor(v2, v3)))
}

///|
fn buffer_read_u64_le(buf : ArrayBufferData, index : Int) -> UInt64 {
  let b0 = UInt64::extend_uint(byte_to_uint(buf.bytes[index]))
  let b1 = UInt64::extend_uint(byte_to_uint(buf.bytes[index + 1])) << 8
  let b2 = UInt64::extend_uint(byte_to_uint(buf.bytes[index + 2])) << 16
  let b3 = UInt64::extend_uint(byte_to_uint(buf.bytes[index + 3])) << 24
  let b4 = UInt64::extend_uint(byte_to_uint(buf.bytes[index + 4])) << 32
  let b5 = UInt64::extend_uint(byte_to_uint(buf.bytes[index + 5])) << 40
  let b6 = UInt64::extend_uint(byte_to_uint(buf.bytes[index + 6])) << 48
  let b7 = UInt64::extend_uint(byte_to_uint(buf.bytes[index + 7])) << 56
  let v0 = UInt64::lor(b0, b1)
  let v1 = UInt64::lor(b2, b3)
  let v2 = UInt64::lor(b4, b5)
  let v3 = UInt64::lor(b6, b7)
  UInt64::lor(UInt64::lor(v0, v1), UInt64::lor(v2, v3))
}

///|
fn buffer_read_u64_be(buf : ArrayBufferData, index : Int) -> UInt64 {
  let b0 = UInt64::extend_uint(byte_to_uint(buf.bytes[index])) << 56
  let b1 = UInt64::extend_uint(byte_to_uint(buf.bytes[index + 1])) << 48
  let b2 = UInt64::extend_uint(byte_to_uint(buf.bytes[index + 2])) << 40
  let b3 = UInt64::extend_uint(byte_to_uint(buf.bytes[index + 3])) << 32
  let b4 = UInt64::extend_uint(byte_to_uint(buf.bytes[index + 4])) << 24
  let b5 = UInt64::extend_uint(byte_to_uint(buf.bytes[index + 5])) << 16
  let b6 = UInt64::extend_uint(byte_to_uint(buf.bytes[index + 6])) << 8
  let b7 = UInt64::extend_uint(byte_to_uint(buf.bytes[index + 7]))
  let v0 = UInt64::lor(b0, b1)
  let v1 = UInt64::lor(b2, b3)
  let v2 = UInt64::lor(b4, b5)
  let v3 = UInt64::lor(b6, b7)
  UInt64::lor(UInt64::lor(v0, v1), UInt64::lor(v2, v3))
}

///|
fn buffer_write_u16_le(buf : ArrayBufferData, index : Int, value : Int) -> Unit {
  let low = Int::to_byte(value & 0xff)
  let high = Int::to_byte((value >> 8) & 0xff)
  buf.bytes[index] = low
  buf.bytes[index + 1] = high
}

///|
fn buffer_write_u16_be(buf : ArrayBufferData, index : Int, value : Int) -> Unit {
  let high = Int::to_byte((value >> 8) & 0xff)
  let low = Int::to_byte(value & 0xff)
  buf.bytes[index] = high
  buf.bytes[index + 1] = low
}

///|
fn buffer_write_u32_le(
  buf : ArrayBufferData,
  index : Int,
  value : UInt,
) -> Unit {
  let b0 = UInt::reinterpret_as_int(UInt::land(value, 0xffU))
  let b1 = UInt::reinterpret_as_int(UInt::land(value >> 8, 0xffU))
  let b2 = UInt::reinterpret_as_int(UInt::land(value >> 16, 0xffU))
  let b3 = UInt::reinterpret_as_int(UInt::land(value >> 24, 0xffU))
  buf.bytes[index] = Int::to_byte(b0)
  buf.bytes[index + 1] = Int::to_byte(b1)
  buf.bytes[index + 2] = Int::to_byte(b2)
  buf.bytes[index + 3] = Int::to_byte(b3)
}

///|
fn buffer_write_u32_be(
  buf : ArrayBufferData,
  index : Int,
  value : UInt,
) -> Unit {
  let b0 = UInt::reinterpret_as_int(UInt::land(value >> 24, 0xffU))
  let b1 = UInt::reinterpret_as_int(UInt::land(value >> 16, 0xffU))
  let b2 = UInt::reinterpret_as_int(UInt::land(value >> 8, 0xffU))
  let b3 = UInt::reinterpret_as_int(UInt::land(value, 0xffU))
  buf.bytes[index] = Int::to_byte(b0)
  buf.bytes[index + 1] = Int::to_byte(b1)
  buf.bytes[index + 2] = Int::to_byte(b2)
  buf.bytes[index + 3] = Int::to_byte(b3)
}

///|
fn buffer_write_u64_le(
  buf : ArrayBufferData,
  index : Int,
  value : UInt64,
) -> Unit {
  let bytes = UInt64::to_le_bytes(value)
  buf.bytes[index] = bytes[0]
  buf.bytes[index + 1] = bytes[1]
  buf.bytes[index + 2] = bytes[2]
  buf.bytes[index + 3] = bytes[3]
  buf.bytes[index + 4] = bytes[4]
  buf.bytes[index + 5] = bytes[5]
  buf.bytes[index + 6] = bytes[6]
  buf.bytes[index + 7] = bytes[7]
}

///|
fn buffer_write_u64_be(
  buf : ArrayBufferData,
  index : Int,
  value : UInt64,
) -> Unit {
  let bytes = UInt64::to_le_bytes(value)
  buf.bytes[index] = bytes[7]
  buf.bytes[index + 1] = bytes[6]
  buf.bytes[index + 2] = bytes[5]
  buf.bytes[index + 3] = bytes[4]
  buf.bytes[index + 4] = bytes[3]
  buf.bytes[index + 5] = bytes[2]
  buf.bytes[index + 6] = bytes[1]
  buf.bytes[index + 7] = bytes[0]
}

///|
fn clamp_uint8(value : Double) -> Int {
  if Double::is_nan(value) {
    return 0
  }
  if value <= 0.0 {
    return 0
  }
  if value >= 255.0 {
    return 255
  }
  let floor_value = Double::floor(value)
  let int_floor = Int64::to_int(Double::to_int64(floor_value))
  let diff = value - floor_value
  if diff > 0.5 {
    return int_floor + 1
  }
  if diff < 0.5 {
    return int_floor
  }
  if Int::land(int_floor, 1) == 1 {
    int_floor + 1
  } else {
    int_floor
  }
}

///|
fn float32_from_bytes_le(buf : ArrayBufferData, index : Int) -> Double {
  let bits = buffer_read_u32_le(buf, index)
  let f = Float::reinterpret_from_uint(bits)
  Float::to_double(f)
}

///|
fn float32_to_bytes_le(value : Double) -> Bytes {
  let f = Float::from_double(value)
  f.to_le_bytes()
}

///|
fn float64_from_bytes_le(buf : ArrayBufferData, index : Int) -> Double {
  let bits = buffer_read_u64_le(buf, index)
  UInt64::reinterpret_as_double(bits)
}

///|
fn float64_to_bytes_le(value : Double) -> Bytes {
  let bits = Double::reinterpret_as_uint64(value)
  UInt64::to_le_bytes(bits)
}

///|
let float16_scale : Double = @math.scalbn(1.0, 1008)

///|
fn float16_bits_to_double(bits : UInt) -> Double {
  let b = UInt::to_uint64(bits)
  let mut v1 = b & 0x7fffUL
  if v1 >= 0x7c00UL {
    v1 = v1 + 0x1f8000UL
  }
  let sign = b >> 15
  let d_bits = (sign << 63) | (v1 << (52 - 10))
  let d = UInt64::reinterpret_as_double(d_bits)
  d * float16_scale
}

///|
fn double_to_float16_bits(value : Double) -> UInt {
  let mut a = Double::reinterpret_as_uint64(value)
  let sgn = a >> 63
  a = a & 0x7fffffffffffffffUL
  let mut v = 0UL
  if a > 0x7ff0000000000000UL {
    v = 0x7c01UL
  } else if a < 0x3f10000000000000UL {
    if a <= 0x3e60000000000000UL {
      v = 0UL
    } else {
      let shift = 1051 - UInt64::to_int(a >> 52)
      a = (1UL << 52) | (a & ((1UL << 52) - 1UL))
      let addend = ((a >> shift) & 1UL) + ((1UL << (shift - 1)) - 1UL)
      v = (a + addend) >> shift
    }
  } else {
    a = a - 0x3f00000000000000UL
    let addend = ((a >> (52 - 10)) & 1UL) + ((1UL << (52 - 11)) - 1UL)
    v = (a + addend) >> (52 - 10)
    if v > 0x7c00UL {
      v = 0x7c00UL
    }
  }
  UInt64::to_uint(v | (sgn << 15))
}

///|
priv enum DataViewValueKind {
  Int8
  Uint8
  Int16
  Uint16
  Int32
  Uint32
  BigInt64
  BigUint64
  Float16
  Float32
  Float64
}

///|
fn dataview_value_size(kind : DataViewValueKind) -> Int {
  match kind {
    DataViewValueKind::Int8 => 1
    DataViewValueKind::Uint8 => 1
    DataViewValueKind::Int16 => 2
    DataViewValueKind::Uint16 => 2
    DataViewValueKind::Int32 => 4
    DataViewValueKind::Uint32 => 4
    DataViewValueKind::BigInt64 => 8
    DataViewValueKind::BigUint64 => 8
    DataViewValueKind::Float16 => 2
    DataViewValueKind::Float32 => 4
    DataViewValueKind::Float64 => 8
  }
}

///|
fn dataview_get_value(
  data : DataViewData,
  args : Array[Value],
  kind : DataViewValueKind,
) -> Value raise {
  let pos64 = if args.is_empty() { 0L } else { to_index_int64(args[0]) }
  let little_endian = args.length() > 1 && is_truthy(args[1])
  let size = dataview_value_size(kind)
  match data.buffer.array_buffer_data {
    Some(buf) => {
      if buf.detached {
        return throw_type_error("ArrayBuffer is detached")
      }
      let len = dataview_effective_length(data)
      let end = pos64 + Int64::from_int(size)
      if end > Int64::from_int(len) {
        return throw_range_error("out of bound")
      }
      if dataview_is_oob(data) {
        return throw_type_error("ArrayBuffer is detached or resized")
      }
      let pos = Int64::to_int(pos64)
      let byte_index = data.byte_offset + pos
      if byte_index + size > buf.bytes.length() {
        return throw_type_error("ArrayBuffer is detached or resized")
      }
      match kind {
        DataViewValueKind::Int8 => {
          let raw = Byte::to_int(buf.bytes[byte_index])
          let value = if raw >= 128 { raw - 256 } else { raw }
          Number(Double::from_int(value))
        }
        DataViewValueKind::Uint8 => {
          let value = Byte::to_int(buf.bytes[byte_index])
          Number(Double::from_int(value))
        }
        DataViewValueKind::Int16 => {
          let raw = if little_endian {
            buffer_read_u16_le(buf, byte_index)
          } else {
            buffer_read_u16_be(buf, byte_index)
          }
          let value = if raw >= 0x8000 { raw - 0x10000 } else { raw }
          Number(Double::from_int(value))
        }
        DataViewValueKind::Uint16 => {
          let value = if little_endian {
            buffer_read_u16_le(buf, byte_index)
          } else {
            buffer_read_u16_be(buf, byte_index)
          }
          Number(Double::from_int(value))
        }
        DataViewValueKind::Int32 => {
          let raw = if little_endian {
            buffer_read_u32_le(buf, byte_index)
          } else {
            buffer_read_u32_be(buf, byte_index)
          }
          Number(Double::from_int(UInt::reinterpret_as_int(raw)))
        }
        DataViewValueKind::Uint32 => {
          let value = if little_endian {
            buffer_read_u32_le(buf, byte_index)
          } else {
            buffer_read_u32_be(buf, byte_index)
          }
          Number(UInt::to_double(value))
        }
        DataViewValueKind::BigInt64 => {
          let bits = if little_endian {
            buffer_read_u64_le(buf, byte_index)
          } else {
            buffer_read_u64_be(buf, byte_index)
          }
          let signed = UInt64::reinterpret_as_int64(bits)
          BigInt(@bigint.BigInt::from_int64(signed))
        }
        DataViewValueKind::BigUint64 => {
          let bits = if little_endian {
            buffer_read_u64_le(buf, byte_index)
          } else {
            buffer_read_u64_be(buf, byte_index)
          }
          BigInt(@bigint.BigInt::from_uint64(bits))
        }
        DataViewValueKind::Float16 => {
          let raw = if little_endian {
            buffer_read_u16_le(buf, byte_index)
          } else {
            buffer_read_u16_be(buf, byte_index)
          }
          Number(float16_bits_to_double(Int::reinterpret_as_uint(raw)))
        }
        DataViewValueKind::Float32 => {
          let bits = if little_endian {
            buffer_read_u32_le(buf, byte_index)
          } else {
            buffer_read_u32_be(buf, byte_index)
          }
          let f = Float::reinterpret_from_uint(bits)
          Number(Float::to_double(f))
        }
        DataViewValueKind::Float64 => {
          let bits = if little_endian {
            buffer_read_u64_le(buf, byte_index)
          } else {
            buffer_read_u64_be(buf, byte_index)
          }
          Number(UInt64::reinterpret_as_double(bits))
        }
      }
    }
    None => throw_type_error("ArrayBuffer is detached")
  }
}

///|
fn buffer_write_bytes(
  buf : ArrayBufferData,
  index : Int,
  bytes : Bytes,
  reverse : Bool,
) -> Unit {
  let len = bytes.length()
  let mut i = 0
  while i < len {
    let src = if reverse { len - 1 - i } else { i }
    buf.bytes[index + i] = bytes[src]
    i = i + 1
  }
}

///|
fn dataview_set_value(
  data : DataViewData,
  args : Array[Value],
  kind : DataViewValueKind,
) -> Value raise {
  let pos64 = if args.is_empty() { 0L } else { to_index_int64(args[0]) }
  let value_arg = if args.length() > 1 { args[1] } else { Undefined }
  let little_endian = args.length() > 2 && is_truthy(args[2])
  let size = dataview_value_size(kind)
  let mut byte_value : Byte? = None
  let mut u16_value : Int? = None
  let mut u32_value : UInt? = None
  let mut u64_value : UInt64? = None
  let mut bytes_value : Bytes? = None
  match kind {
    DataViewValueKind::Int8 | DataViewValueKind::Uint8 => {
      let bits = to_uint32(to_number(value_arg))
      byte_value = Some(Int::to_byte(UInt::reinterpret_as_int(bits & 0xffU)))
    }
    DataViewValueKind::Int16 | DataViewValueKind::Uint16 => {
      let bits = to_uint32(to_number(value_arg))
      u16_value = Some(UInt::reinterpret_as_int(UInt::land(bits, 0xffffU)))
    }
    DataViewValueKind::Int32 | DataViewValueKind::Uint32 =>
      u32_value = Some(to_uint32(to_number(value_arg)))
    DataViewValueKind::BigInt64 =>
      u64_value = Some(bigint_to_uint64_bits(value_arg, true))
    DataViewValueKind::BigUint64 =>
      u64_value = Some(bigint_to_uint64_bits(value_arg, false))
    DataViewValueKind::Float16 => {
      let num = to_number(value_arg)
      let bits = double_to_float16_bits(num)
      u16_value = Some(UInt::reinterpret_as_int(bits))
    }
    DataViewValueKind::Float32 => {
      let num = to_number(value_arg)
      bytes_value = Some(float32_to_bytes_le(num))
    }
    DataViewValueKind::Float64 => {
      let num = to_number(value_arg)
      bytes_value = Some(float64_to_bytes_le(num))
    }
  }
  match data.buffer.array_buffer_data {
    Some(buf) => {
      if buf.detached {
        return throw_type_error("ArrayBuffer is detached")
      }
      let len = dataview_effective_length(data)
      let end = pos64 + Int64::from_int(size)
      if end > Int64::from_int(len) {
        return throw_range_error("out of bound")
      }
      if dataview_is_oob(data) {
        return throw_type_error("ArrayBuffer is detached or resized")
      }
      let pos = Int64::to_int(pos64)
      let byte_index = data.byte_offset + pos
      if byte_index + size > buf.bytes.length() {
        return throw_type_error("ArrayBuffer is detached or resized")
      }
      match byte_value {
        Some(byte) => buf.bytes[byte_index] = byte
        None =>
          match u16_value {
            Some(u16) =>
              if little_endian {
                buffer_write_u16_le(buf, byte_index, u16)
              } else {
                buffer_write_u16_be(buf, byte_index, u16)
              }
            None =>
              match u32_value {
                Some(u32) =>
                  if little_endian {
                    buffer_write_u32_le(buf, byte_index, u32)
                  } else {
                    buffer_write_u32_be(buf, byte_index, u32)
                  }
                None =>
                  match u64_value {
                    Some(u64) =>
                      if little_endian {
                        buffer_write_u64_le(buf, byte_index, u64)
                      } else {
                        buffer_write_u64_be(buf, byte_index, u64)
                      }
                    None =>
                      match bytes_value {
                        Some(bytes) =>
                          buffer_write_bytes(
                            buf,
                            byte_index,
                            bytes,
                            !little_endian,
                          )
                        None => ()
                      }
                  }
              }
          }
      }
      Undefined
    }
    None => throw_type_error("ArrayBuffer is detached")
  }
}

///|
fn typed_array_get_index(data : TypedArrayData, index : Int) -> Value {
  let len = typed_array_effective_length(data)
  if index < 0 || index >= len {
    return Undefined
  }
  match data.buffer.array_buffer_data {
    Some(buf) =>
      if buf.detached {
        Undefined
      } else {
        let byte_index = data.byte_offset + index * data.bytes_per_element
        if byte_index + data.bytes_per_element > buf.bytes.length() {
          return Undefined
        }
        match data.kind {
          TypedArrayKind::Uint8 => {
            let value = Byte::to_int(buf.bytes[byte_index])
            Number(Double::from_int(value))
          }
          TypedArrayKind::Int8 => {
            let raw = Byte::to_int(buf.bytes[byte_index])
            let value = if raw >= 128 { raw - 256 } else { raw }
            Number(Double::from_int(value))
          }
          TypedArrayKind::Uint8Clamped => {
            let value = Byte::to_int(buf.bytes[byte_index])
            Number(Double::from_int(value))
          }
          TypedArrayKind::Uint16 => {
            let value = buffer_read_u16_le(buf, byte_index)
            Number(Double::from_int(value))
          }
          TypedArrayKind::Int16 => {
            let raw = buffer_read_u16_le(buf, byte_index)
            let value = if raw >= 0x8000 { raw - 0x10000 } else { raw }
            Number(Double::from_int(value))
          }
          TypedArrayKind::Uint32 => {
            let value = buffer_read_u32_le(buf, byte_index)
            Number(UInt::to_double(value))
          }
          TypedArrayKind::Int32 => {
            let value = buffer_read_u32_le(buf, byte_index)
            Number(Double::from_int(UInt::reinterpret_as_int(value)))
          }
          TypedArrayKind::BigInt64 => {
            let bits = buffer_read_u64_le(buf, byte_index)
            let signed = UInt64::reinterpret_as_int64(bits)
            BigInt(@bigint.BigInt::from_int64(signed))
          }
          TypedArrayKind::BigUint64 => {
            let bits = buffer_read_u64_le(buf, byte_index)
            BigInt(@bigint.BigInt::from_uint64(bits))
          }
          TypedArrayKind::Float32 =>
            Number(float32_from_bytes_le(buf, byte_index))
          TypedArrayKind::Float64 =>
            Number(float64_from_bytes_le(buf, byte_index))
          TypedArrayKind::Float16 => {
            let raw = buffer_read_u16_le(buf, byte_index)
            Number(float16_bits_to_double(Int::reinterpret_as_uint(raw)))
          }
        }
      }
    None => Undefined
  }
}

///|
fn bigint_to_uint64_bits(value : Value, as_int : Bool) -> UInt64 raise {
  let big = to_bigint(value)
  let modulus = @bigint.BigInt::from_int(1) << 64
  let mut result = big.mod(modulus)
  if result.compare_int(0) < 0 {
    result = result.add(modulus)
  }
  if as_int {
    let half = modulus >> 1
    if result.compare(half) >= 0 {
      result = result.sub(modulus)
    }
    let signed = result.to_int64()
    Int64::reinterpret_as_uint64(signed)
  } else {
    result.to_uint64()
  }
}

///|
fn typed_array_set_index(
  data : TypedArrayData,
  index : Int,
  value : Value,
) -> Bool raise {
  if index < 0 {
    return false
  }
  match data.kind {
    TypedArrayKind::BigInt64 => {
      let len = typed_array_effective_length(data)
      if index >= len {
        return true
      }
      match data.buffer.array_buffer_data {
        Some(buf) =>
          if buf.detached {
            true
          } else {
            let byte_index = data.byte_offset + index * data.bytes_per_element
            if byte_index + data.bytes_per_element > buf.bytes.length() {
              return true
            }
            let bits = bigint_to_uint64_bits(value, true)
            buffer_write_u64_le(buf, byte_index, bits)
            true
          }
        None => true
      }
    }
    TypedArrayKind::BigUint64 => {
      let len = typed_array_effective_length(data)
      if index >= len {
        return true
      }
      match data.buffer.array_buffer_data {
        Some(buf) =>
          if buf.detached {
            true
          } else {
            let byte_index = data.byte_offset + index * data.bytes_per_element
            if byte_index + data.bytes_per_element > buf.bytes.length() {
              return true
            }
            let bits = bigint_to_uint64_bits(value, false)
            buffer_write_u64_le(buf, byte_index, bits)
            true
          }
        None => true
      }
    }
    _ => {
      let num = to_number(value)
      let len = typed_array_effective_length(data)
      if index >= len {
        return true
      }
      match data.buffer.array_buffer_data {
        Some(buf) =>
          if buf.detached {
            true
          } else {
            let byte_index = data.byte_offset + index * data.bytes_per_element
            if byte_index + data.bytes_per_element > buf.bytes.length() {
              return true
            }
            match data.kind {
              TypedArrayKind::Uint8 => {
                let masked = UInt::land(to_uint32(num), 0xffU)
                buf.bytes[byte_index] = Int::to_byte(
                  UInt::reinterpret_as_int(masked),
                )
              }
              TypedArrayKind::Int8 => {
                let masked = UInt::land(to_uint32(num), 0xffU)
                buf.bytes[byte_index] = Int::to_byte(
                  UInt::reinterpret_as_int(masked),
                )
              }
              TypedArrayKind::Uint8Clamped => {
                let clamped = clamp_uint8(num)
                buf.bytes[byte_index] = Int::to_byte(clamped)
              }
              TypedArrayKind::Uint16 => {
                let masked = UInt::land(to_uint32(num), 0xffffU)
                buffer_write_u16_le(
                  buf,
                  byte_index,
                  UInt::reinterpret_as_int(masked),
                )
              }
              TypedArrayKind::Int16 => {
                let masked = UInt::land(to_uint32(num), 0xffffU)
                buffer_write_u16_le(
                  buf,
                  byte_index,
                  UInt::reinterpret_as_int(masked),
                )
              }
              TypedArrayKind::Uint32 => {
                let masked = to_uint32(num)
                buffer_write_u32_le(buf, byte_index, masked)
              }
              TypedArrayKind::Int32 => {
                let signed = to_int32(num)
                let bits = Int::reinterpret_as_uint(signed)
                buffer_write_u32_le(buf, byte_index, bits)
              }
              TypedArrayKind::Float32 => {
                let bytes = float32_to_bytes_le(num)
                buf.bytes[byte_index] = bytes[0]
                buf.bytes[byte_index + 1] = bytes[1]
                buf.bytes[byte_index + 2] = bytes[2]
                buf.bytes[byte_index + 3] = bytes[3]
              }
              TypedArrayKind::Float64 => {
                let bytes = float64_to_bytes_le(num)
                buf.bytes[byte_index] = bytes[0]
                buf.bytes[byte_index + 1] = bytes[1]
                buf.bytes[byte_index + 2] = bytes[2]
                buf.bytes[byte_index + 3] = bytes[3]
                buf.bytes[byte_index + 4] = bytes[4]
                buf.bytes[byte_index + 5] = bytes[5]
                buf.bytes[byte_index + 6] = bytes[6]
                buf.bytes[byte_index + 7] = bytes[7]
              }
              TypedArrayKind::Float16 => {
                let bits = double_to_float16_bits(num)
                let low = UInt::reinterpret_as_int(UInt::land(bits, 0xffU))
                let high = UInt::reinterpret_as_int(
                  UInt::land(bits >> 8, 0xffU),
                )
                buf.bytes[byte_index] = Int::to_byte(low)
                buf.bytes[byte_index + 1] = Int::to_byte(high)
              }
              TypedArrayKind::BigInt64 => ()
              TypedArrayKind::BigUint64 => ()
            }
            true
          }
        None => false
      }
    }
  }
}

///|
fn require_typed_array(value : Value?) -> (ArrayValue, TypedArrayData) raise {
  match value {
    Some(Array(arr)) =>
      match arr.typed_array_data {
        Some(data) => (arr, data)
        None => {
          let _ = throw_type_error("not a typed array")
          (
            arr,
            TypedArrayData::{
              kind: TypedArrayKind::Uint8,
              buffer: new_object_struct(None),
              byte_offset: 0,
              length: 0,
              length_tracking: false,
              bytes_per_element: 1,
            },
          )
        }
      }
    _ => {
      let _ = throw_type_error("not a typed array")
      (
        register_array_value(ArrayValue::{
          id: alloc_id(),
          elements: [],
          proto: value_from_object(array_proto()),
          props: Map::new(),
          typed_array_data: None,
          extensible: true,
        }),
        TypedArrayData::{
          kind: TypedArrayKind::Uint8,
          buffer: new_object_struct(None),
          byte_offset: 0,
          length: 0,
          length_tracking: false,
          bytes_per_element: 1,
        },
      )
    }
  }
}

///|
fn typed_array_kind_from_value(value : Value) -> TypedArrayKind? {
  match value {
    Array(arr) =>
      match arr.typed_array_data {
        Some(data) => Some(data.kind)
        None => None
      }
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => typed_array_kind_from_value(data.target)
        None => None
      }
    _ => None
  }
}

///|
fn require_typed_array_checked(
  value : Value?,
) -> (ArrayValue, TypedArrayData) raise {
  let (arr, data) = require_typed_array(value)
  if typed_array_is_oob(data) {
    let _ = throw_type_error("ArrayBuffer is detached")

  }
  (arr, data)
}

///|
enum AtomicsOpKind {
  Add
  And
  Or
  Sub
  Xor
  Exchange
  CompareExchange
  Load
} derive(Eq)

///|
fn atomics_kind_is_integer(kind : TypedArrayKind) -> Bool {
  match kind {
    TypedArrayKind::Int8
    | TypedArrayKind::Uint8
    | TypedArrayKind::Int16
    | TypedArrayKind::Uint16
    | TypedArrayKind::Int32
    | TypedArrayKind::Uint32
    | TypedArrayKind::BigInt64
    | TypedArrayKind::BigUint64 => true
    _ => false
  }
}

///|
fn atomics_kind_is_waitable(kind : TypedArrayKind) -> Bool {
  match kind {
    TypedArrayKind::Int32 | TypedArrayKind::BigInt64 => true
    _ => false
  }
}

///|
fn atomics_require_typed_array(
  target : Value,
  waitable_only : Bool,
) -> (ArrayValue, TypedArrayData) raise {
  match target {
    Array(arr) =>
      match arr.typed_array_data {
        Some(data) =>
          if waitable_only && !atomics_kind_is_waitable(data.kind) {
            let _ = throw_type_error("integer TypedArray expected")
            (arr, data)
          } else if !waitable_only && !atomics_kind_is_integer(data.kind) {
            let _ = throw_type_error("integer TypedArray expected")
            (arr, data)
          } else {
            (arr, data)
          }
        None => {
          let _ = throw_type_error("integer TypedArray expected")
          (
            arr,
            TypedArrayData::{
              kind: TypedArrayKind::Uint8,
              buffer: new_object_struct(None),
              byte_offset: 0,
              length: 0,
              length_tracking: false,
              bytes_per_element: 1,
            },
          )
        }
      }
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => atomics_require_typed_array(data.target, waitable_only)
        None => {
          let _ = throw_type_error("integer TypedArray expected")
          (
            register_array_value(ArrayValue::{
              id: alloc_id(),
              elements: [],
              proto: value_from_object(array_proto()),
              props: Map::new(),
              typed_array_data: None,
              extensible: true,
            }),
            TypedArrayData::{
              kind: TypedArrayKind::Uint8,
              buffer: new_object_struct(None),
              byte_offset: 0,
              length: 0,
              length_tracking: false,
              bytes_per_element: 1,
            },
          )
        }
      }
    _ => {
      let _ = throw_type_error("integer TypedArray expected")
      (
        register_array_value(ArrayValue::{
          id: alloc_id(),
          elements: [],
          proto: value_from_object(array_proto()),
          props: Map::new(),
          typed_array_data: None,
          extensible: true,
        }),
        TypedArrayData::{
          kind: TypedArrayKind::Uint8,
          buffer: new_object_struct(None),
          byte_offset: 0,
          length: 0,
          length_tracking: false,
          bytes_per_element: 1,
        },
      )
    }
  }
}

///|
fn atomics_get_op_data(
  target : Value,
  index_value : Value,
) -> (TypedArrayData, Int) raise {
  let (_, data) = atomics_require_typed_array(target, false)
  match data.buffer.array_buffer_data {
    Some(buf) =>
      if buf.detached {
        let _ = throw_type_error("ArrayBuffer is detached")
        return (data, 0)
      }
    None => {
      let _ = throw_type_error("ArrayBuffer is detached")
      return (data, 0)
    }
  }
  let old_len = typed_array_effective_length(data)
  let index64 = to_index_int64(index_value)
  if index64 >= Int64::from_int(old_len) {
    let _ = throw_range_error("out-of-bound access")
    return (data, 0)
  }
  if typed_array_is_oob(data) {
    let _ = throw_type_error("ArrayBuffer is detached or resized")
    return (data, 0)
  }
  let current_len = typed_array_effective_length(data)
  if index64 >= Int64::from_int(current_len) {
    let _ = throw_range_error("out-of-bound access")
    return (data, 0)
  }
  (data, Int64::to_int(index64))
}

///|
fn atomics_get_wait_data(
  target : Value,
  index_value : Value,
  allow_non_shared : Bool,
) -> (TypedArrayData, Int, Bool, Bool) raise {
  let (_, data) = atomics_require_typed_array(target, true)
  let mut shared = false
  match data.buffer.array_buffer_data {
    Some(buf) => {
      shared = buf.shared
      if buf.detached {
        let _ = throw_type_error("ArrayBuffer is detached")
        return (data, 0, false, false)
      }
      if !shared && !allow_non_shared {
        let _ = throw_type_error("not a SharedArrayBuffer TypedArray")
        return (data, 0, false, false)
      }
    }
    None => {
      let _ = throw_type_error("ArrayBuffer is detached")
      return (data, 0, false, false)
    }
  }
  let old_len = typed_array_effective_length(data)
  let index64 = to_index_int64(index_value)
  if index64 >= Int64::from_int(old_len) {
    let _ = throw_range_error("out-of-bound access")
    return (data, 0, shared, false)
  }
  if !allow_non_shared {
    if typed_array_is_oob(data) {
      let _ = throw_type_error("ArrayBuffer is detached or resized")
      return (data, 0, shared, false)
    }
    let current_len = typed_array_effective_length(data)
    if index64 >= Int64::from_int(current_len) {
      let _ = throw_range_error("out-of-bound access")
      return (data, 0, shared, false)
    }
  }
  let current_len = typed_array_effective_length(data)
  let valid_now = index64 < Int64::from_int(current_len)
  (data, Int64::to_int(index64), shared, valid_now)
}

///|
fn atomics_byte_index(data : TypedArrayData, index : Int) -> Int {
  data.byte_offset + index * data.bytes_per_element
}

///|
fn atomics_value_from_bits(kind : TypedArrayKind, bits : UInt) -> Value {
  match kind {
    TypedArrayKind::Int8 => {
      let value = if bits >= 0x80U {
        UInt::reinterpret_as_int(bits) - 0x100
      } else {
        UInt::reinterpret_as_int(bits)
      }
      Number(Double::from_int(value))
    }
    TypedArrayKind::Uint8 =>
      Number(Double::from_int(UInt::reinterpret_as_int(bits)))
    TypedArrayKind::Int16 => {
      let value = if bits >= 0x8000U {
        UInt::reinterpret_as_int(bits) - 0x10000
      } else {
        UInt::reinterpret_as_int(bits)
      }
      Number(Double::from_int(value))
    }
    TypedArrayKind::Uint16 =>
      Number(Double::from_int(UInt::reinterpret_as_int(bits)))
    TypedArrayKind::Int32 =>
      Number(Double::from_int(UInt::reinterpret_as_int(bits)))
    TypedArrayKind::Uint32 => Number(UInt::to_double(bits))
    TypedArrayKind::Uint8Clamped =>
      Number(Double::from_int(UInt::reinterpret_as_int(bits)))
    _ => Number(UInt::to_double(bits))
  }
}

///|
fn atomics_mask_for_kind(kind : TypedArrayKind) -> UInt {
  match kind {
    TypedArrayKind::Int8 | TypedArrayKind::Uint8 => 0xffU
    TypedArrayKind::Int16 | TypedArrayKind::Uint16 => 0xffffU
    TypedArrayKind::Int32 | TypedArrayKind::Uint32 => 0xffffffffU
    _ => 0xffffffffU
  }
}

///|
fn atomics_read_bits(data : TypedArrayData, index : Int) -> UInt {
  match data.buffer.array_buffer_data {
    Some(buf) => {
      let byte_index = atomics_byte_index(data, index)
      match data.kind {
        TypedArrayKind::Int8
        | TypedArrayKind::Uint8
        | TypedArrayKind::Uint8Clamped =>
          Int::reinterpret_as_uint(Byte::to_int(buf.bytes[byte_index]))
        TypedArrayKind::Int16 | TypedArrayKind::Uint16 =>
          Int::reinterpret_as_uint(buffer_read_u16_le(buf, byte_index))
        TypedArrayKind::Int32 | TypedArrayKind::Uint32 =>
          buffer_read_u32_le(buf, byte_index)
        _ => 0U
      }
    }
    None => 0U
  }
}

///|
fn atomics_write_bits(data : TypedArrayData, index : Int, bits : UInt) -> Unit {
  match data.buffer.array_buffer_data {
    Some(buf) => {
      let byte_index = atomics_byte_index(data, index)
      match data.kind {
        TypedArrayKind::Int8
        | TypedArrayKind::Uint8
        | TypedArrayKind::Uint8Clamped =>
          buf.bytes[byte_index] = Int::to_byte(
            UInt::reinterpret_as_int(bits & 0xffU),
          )
        TypedArrayKind::Int16 | TypedArrayKind::Uint16 =>
          buffer_write_u16_le(
            buf,
            byte_index,
            UInt::reinterpret_as_int(bits & 0xffffU),
          )
        TypedArrayKind::Int32 | TypedArrayKind::Uint32 =>
          buffer_write_u32_le(buf, byte_index, bits)
        _ => ()
      }
    }
    None => ()
  }
}

///|
fn atomics_op_value(args : Array[Value], op : AtomicsOpKind) -> Value raise {
  let target = if args.is_empty() { Undefined } else { args[0] }
  let index_value = if args.length() > 1 { args[1] } else { Undefined }
  let value_arg = if args.length() > 2 { args[2] } else { Undefined }
  let rep_arg = if args.length() > 3 { args[3] } else { Undefined }
  let (data, index) = atomics_get_op_data(target, index_value)
  let agent_id = current_agent_id()
  let is_main = agent_id is None
  let byte_index = atomics_byte_index(data, index)
  let is_bigint = data.kind == TypedArrayKind::BigInt64 ||
    data.kind == TypedArrayKind::BigUint64
  if op == AtomicsOpKind::Load &&
    is_main &&
    agent_lock_has_pending(data.buffer.id, byte_index, is_bigint) {
    if is_bigint {
      return BigInt(@bigint.BigInt::from_int(1))
    }
    return atomics_value_from_bits(data.kind, 1U)
  }
  match data.kind {
    TypedArrayKind::BigInt64 | TypedArrayKind::BigUint64 => {
      let bits = match data.buffer.array_buffer_data {
        Some(buf) => buffer_read_u64_le(buf, byte_index)
        None => 0UL
      }
      if op == AtomicsOpKind::Load {
        match agent_id {
          Some(id) =>
            if bits == 0UL {
              if agent_spin_should_release(id, data.buffer.id, byte_index) {
                return BigInt(@bigint.BigInt::from_int(1))
              }
            } else {
              agent_spin_clear(id, data.buffer.id, byte_index)
            }
          None => ()
        }
      }
      let input_bits = if op == AtomicsOpKind::Load {
        0UL
      } else if data.kind == TypedArrayKind::BigInt64 {
        bigint_to_uint64_bits(value_arg, true)
      } else {
        bigint_to_uint64_bits(value_arg, false)
      }
      let rep_bits = if op == AtomicsOpKind::CompareExchange {
        if data.kind == TypedArrayKind::BigInt64 {
          bigint_to_uint64_bits(rep_arg, true)
        } else {
          bigint_to_uint64_bits(rep_arg, false)
        }
      } else {
        0UL
      }
      let mut ret_bits = bits
      let mut new_bits = bits
      let mut force_exchange = false
      let mut enqueue_lock = false
      let is_lock_op = agent_id is Some(_) &&
        op == AtomicsOpKind::CompareExchange &&
        input_bits == 0UL &&
        rep_bits == 1UL
      match op {
        AtomicsOpKind::Load => ()
        AtomicsOpKind::Add => new_bits = bits + input_bits
        AtomicsOpKind::And => new_bits = UInt64::land(bits, input_bits)
        AtomicsOpKind::Or => new_bits = UInt64::lor(bits, input_bits)
        AtomicsOpKind::Sub => new_bits = bits - input_bits
        AtomicsOpKind::Xor => new_bits = UInt64::lxor(bits, input_bits)
        AtomicsOpKind::Exchange => new_bits = input_bits
        AtomicsOpKind::CompareExchange =>
          if bits == input_bits {
            new_bits = rep_bits
            enqueue_lock = is_lock_op
          } else if is_lock_op {
            new_bits = rep_bits
            ret_bits = input_bits
            force_exchange = true
            enqueue_lock = true
          }
      }
      if op != AtomicsOpKind::Load &&
        !(op == AtomicsOpKind::CompareExchange &&
        bits != input_bits &&
        !force_exchange) {
        match data.buffer.array_buffer_data {
          Some(buf) => buffer_write_u64_le(buf, byte_index, new_bits)
          None => ()
        }
      }
      if enqueue_lock {
        agent_lock_enqueue(data.buffer.id, byte_index, true)
      }
      if data.kind == TypedArrayKind::BigInt64 {
        let signed = UInt64::reinterpret_as_int64(ret_bits)
        BigInt(@bigint.BigInt::from_int64(signed))
      } else {
        BigInt(@bigint.BigInt::from_uint64(ret_bits))
      }
    }
    _ => {
      let mask = atomics_mask_for_kind(data.kind)
      let old_bits = atomics_read_bits(data, index) & mask
      if op == AtomicsOpKind::Load {
        match agent_id {
          Some(id) =>
            if old_bits == 0U {
              if agent_spin_should_release(id, data.buffer.id, byte_index) {
                return atomics_value_from_bits(data.kind, 1U)
              }
            } else {
              agent_spin_clear(id, data.buffer.id, byte_index)
            }
          None => ()
        }
      }
      let input_bits = to_uint32(to_number(value_arg)) & mask
      let rep_bits = to_uint32(to_number(rep_arg)) & mask
      let mut ret_bits = old_bits
      let mut new_bits = old_bits
      let mut force_exchange = false
      let mut enqueue_lock = false
      let is_lock_op = agent_id is Some(_) &&
        op == AtomicsOpKind::CompareExchange &&
        input_bits == 0U &&
        rep_bits == 1U
      match op {
        AtomicsOpKind::Load => ()
        AtomicsOpKind::Add => new_bits = (old_bits + input_bits) & mask
        AtomicsOpKind::And => new_bits = UInt::land(old_bits, input_bits)
        AtomicsOpKind::Or => new_bits = UInt::lor(old_bits, input_bits)
        AtomicsOpKind::Sub => new_bits = (old_bits - input_bits) & mask
        AtomicsOpKind::Xor => new_bits = UInt::lxor(old_bits, input_bits)
        AtomicsOpKind::Exchange => new_bits = input_bits
        AtomicsOpKind::CompareExchange =>
          if old_bits == input_bits {
            new_bits = rep_bits
            enqueue_lock = is_lock_op
          } else if is_lock_op {
            new_bits = rep_bits
            ret_bits = input_bits
            force_exchange = true
            enqueue_lock = true
          }
      }
      if op != AtomicsOpKind::Load &&
        !(op == AtomicsOpKind::CompareExchange &&
        old_bits != input_bits &&
        !force_exchange) {
        atomics_write_bits(data, index, new_bits)
      }
      if enqueue_lock {
        agent_lock_enqueue(data.buffer.id, byte_index, false)
      }
      atomics_value_from_bits(data.kind, ret_bits)
    }
  }
}

///|
fn atomics_to_integer(value : Value) -> Double raise {
  let num = to_number(value)
  if Double::is_nan(num) {
    0.0
  } else if num == 0.0 || Double::is_inf(num) {
    num
  } else {
    Double::trunc(num)
  }
}

///|
fn atomics_store_value(args : Array[Value]) -> Value raise {
  let target = if args.is_empty() { Undefined } else { args[0] }
  let index_value = if args.length() > 1 { args[1] } else { Undefined }
  let value_arg = if args.length() > 2 { args[2] } else { Undefined }
  let (data, index) = atomics_get_op_data(target, index_value)
  let is_main = current_agent_id() is None
  let byte_index = atomics_byte_index(data, index)
  match data.kind {
    TypedArrayKind::BigInt64 => {
      let ret = to_bigint(value_arg)
      let bits = bigint_to_uint64_bits(BigInt(ret), true)
      if is_main && bits == 0UL {
        agent_lock_pop(data.buffer.id, byte_index, true)
      }
      match data.buffer.array_buffer_data {
        Some(buf) => buffer_write_u64_le(buf, byte_index, bits)
        None => ()
      }
      BigInt(ret)
    }
    TypedArrayKind::BigUint64 => {
      let ret = to_bigint(value_arg)
      let bits = bigint_to_uint64_bits(BigInt(ret), false)
      if is_main && bits == 0UL {
        agent_lock_pop(data.buffer.id, byte_index, true)
      }
      match data.buffer.array_buffer_data {
        Some(buf) => buffer_write_u64_le(buf, byte_index, bits)
        None => ()
      }
      BigInt(ret)
    }
    _ => {
      let num = atomics_to_integer(value_arg)
      let bits = to_uint32(num) & atomics_mask_for_kind(data.kind)
      if is_main && bits == 0U {
        agent_lock_pop(data.buffer.id, byte_index, false)
      }
      atomics_write_bits(data, index, bits)
      let mut ret = num
      if is_negative_zero(ret) {
        ret = 0.0
      }
      Number(ret)
    }
  }
}

///|
fn atomics_is_lock_free_value(args : Array[Value]) -> Value raise {
  let size = if args.is_empty() { 0 } else { to_int32_sat(to_number(args[0])) }
  Bool(size == 1 || size == 2 || size == 4 || size == 8)
}

///|
fn atomics_pause_value(args : Array[Value]) -> Value raise {
  if !args.is_empty() {
    match args[0] {
      Undefined => ()
      Number(num) =>
        if Double::is_inf(num) || Double::trunc(num) != num {
          return throw_type_error("not an integral number")
        }
      _ => return throw_type_error("not an integral number")
    }
  }
  Undefined
}

///|
fn atomics_timeout_ms(value : Value) -> (Int64, Bool) raise {
  let num = to_number(value)
  let max_double = 9.223372036854776e18
  if Double::is_nan(num) || num >= max_double {
    (9223372036854775807L, true)
  } else if num < 0.0 {
    (0L, false)
  } else {
    (Double::to_int64(Double::trunc(num)), false)
  }
}

///|
fn atomics_wait_value(args : Array[Value]) -> Value raise {
  let target = if args.is_empty() { Undefined } else { args[0] }
  let index_value = if args.length() > 1 { args[1] } else { Undefined }
  let value_arg = if args.length() > 2 { args[2] } else { Undefined }
  let timeout_arg = if args.length() > 3 { args[3] } else { Undefined }
  let (data, index, _, _) = atomics_get_wait_data(target, index_value, false)
  let expected_bigint = if data.kind == TypedArrayKind::BigInt64 {
    Some(to_bigint(value_arg))
  } else {
    None
  }
  let expected_int32 = if data.kind == TypedArrayKind::BigInt64 {
    0
  } else {
    to_int32(to_number(value_arg))
  }
  let (timeout_ms, infinite) = atomics_timeout_ms(timeout_arg)
  if !can_block() {
    return throw_type_error("cannot block in this thread")
  }
  let matches = if data.kind == TypedArrayKind::BigInt64 {
    let expected = match expected_bigint {
      Some(value) => value
      None => @bigint.BigInt::from_int(0)
    }
    let current = typed_array_get_index(data, index)
    same_value(current, BigInt(expected))
  } else {
    let current = typed_array_get_index(data, index)
    to_int32(to_number(current)) == expected_int32
  }
  if !matches {
    return String("not-equal")
  }
  if timeout_ms <= 0L {
    return String("timed-out")
  }
  match current_agent_id() {
    Some(agent_id) => {
      let immediate_timeout = 50L
      if !infinite && timeout_ms <= immediate_timeout {
        let _ = agent_clock_advance(timeout_ms)
        return String("timed-out")
      }
      let now = agent_clock_now()
      let deadline = if infinite { None } else { Some(now + timeout_ms) }
      let waiter_id = atomics_next_waiter_id()
      let waiter = AtomicsWaiter::{
        id: waiter_id,
        buffer_id: data.buffer.id,
        byte_index: atomics_byte_index(data, index),
        status: AtomicsWaitStatus::Waiting,
        start_time: now,
        deadline,
      }
      atomics_waiter_add(waiter)
      atomics_agent_push_waiter(agent_id, waiter_id)
      let token = atomics_waiter_token_prefix + Int::to_string(waiter_id)
      String(token)
    }
    None => String("timed-out")
  }
}

///|
fn atomics_notify_value(args : Array[Value]) -> Value raise {
  let target = if args.is_empty() { Undefined } else { args[0] }
  let index_value = if args.length() > 1 { args[1] } else { Undefined }
  let count_value = if args.length() > 2 { args[2] } else { Undefined }
  let (data, index, shared, valid_now) = atomics_get_wait_data(
    target, index_value, true,
  )
  let count = if count_value is Undefined {
    2147483647
  } else {
    let count64 = to_int64_clamp64(count_value, 0L, 2147483647L, 0L)
    Int64::to_int(count64)
  }
  if !shared || !valid_now || count <= 0 {
    return Number(Double::from_int(0))
  }
  let now = agent_clock_now()
  atomics_record_notify_time(data.buffer.id, now)
  let mut woken = 0
  atomics_waiter_list_ref.update(fn(list) {
    for id in list {
      if woken >= count {
        break
      }
      match atomics_waiter_get(id) {
        Some(waiter) =>
          if waiter.status == AtomicsWaitStatus::Waiting &&
            waiter.buffer_id == data.buffer.id &&
            waiter.byte_index == atomics_byte_index(data, index) {
            atomics_waiter_update_status(id, AtomicsWaitStatus::Ok)
            woken = woken + 1
          }
        None => ()
      }
    }
    list
  })
  Number(Double::from_int(woken))
}

///|
fn new_promise_value_with_proto(proto : Value?) -> Value {
  let value = new_object_value_with_proto(proto)
  match value {
    Object(obj) => {
      let data = PromiseData::{
        state: PromiseState::Pending,
        value: Undefined,
        fulfill_reactions: [],
        reject_reactions: [],
        is_handled: false,
      }
      promise_table_ref.update(fn(table) {
        table.set(obj.id, data)
        table
      })
    }
    _ => ()
  }
  value
}

///|
fn promise_table_get(id : Int) -> PromiseData? {
  let mut result : PromiseData? = None
  promise_table_ref.update(fn(table) {
    result = table.get(id)
    table
  })
  result
}

///|
fn promise_data_from_value(value : Value) -> PromiseData? {
  match value {
    Object(obj) => promise_table_get(obj.id)
    _ => None
  }
}

///|
fn require_promise_data(this_value : Value?) -> PromiseData raise {
  match this_value {
    Some(Object(obj)) =>
      match promise_table_get(obj.id) {
        Some(data) => data
        None => {
          let _ = throw_type_error("not a Promise")
          PromiseData::{
            state: PromiseState::Pending,
            value: Undefined,
            fulfill_reactions: [],
            reject_reactions: [],
            is_handled: false,
          }
        }
      }
    _ => {
      let _ = throw_type_error("not a Promise")
      PromiseData::{
        state: PromiseState::Pending,
        value: Undefined,
        fulfill_reactions: [],
        reject_reactions: [],
        is_handled: false,
      }
    }
  }
}

///|
fn promise_settle(
  data : PromiseData,
  state : PromiseState,
  value : Value,
) -> Unit {
  let _ = data.is_handled
  match data.state {
    PromiseState::Pending => ()
    _ => return
  }
  data.state = state
  data.value = value
  let reactions = if state is PromiseState::Fulfilled {
    let items = data.fulfill_reactions
    data.fulfill_reactions = []
    data.reject_reactions = []
    items
  } else {
    let items = data.reject_reactions
    data.fulfill_reactions = []
    data.reject_reactions = []
    items
  }
  for reaction in reactions {
    enqueue_job(new_builtin_value(BuiltinFunction::PromiseReactionJob), [
      reaction.resolve,
      reaction.reject,
      reaction.handler,
      Bool(state is PromiseState::Rejected),
      value,
    ])
  }
}

///|
fn perform_promise_then(
  promise : Value,
  data : PromiseData,
  on_fulfilled : Value,
  on_rejected : Value,
  resolve : Value,
  reject : Value,
) -> Unit {
  let fulfill_handler = if is_callable(on_fulfilled) {
    on_fulfilled
  } else {
    Undefined
  }
  let reject_handler = if is_callable(on_rejected) {
    on_rejected
  } else {
    Undefined
  }
  match data.state {
    PromiseState::Pending => {
      data.fulfill_reactions.push(PromiseReaction::{
        resolve,
        reject,
        handler: fulfill_handler,
      })
      data.reject_reactions.push(PromiseReaction::{
        resolve,
        reject,
        handler: reject_handler,
      })
    }
    PromiseState::Fulfilled =>
      enqueue_job(new_builtin_value(BuiltinFunction::PromiseReactionJob), [
        resolve,
        reject,
        fulfill_handler,
        Bool(false),
        data.value,
      ])
    PromiseState::Rejected =>
      enqueue_job(new_builtin_value(BuiltinFunction::PromiseReactionJob), [
        resolve,
        reject,
        reject_handler,
        Bool(true),
        data.value,
      ])
  }
  data.is_handled = true
  let _ = promise

}

///|
fn promise_resolve_func_data_get(id : Int) -> PromiseResolveFunctionData? {
  let mut value : PromiseResolveFunctionData? = None
  promise_resolve_func_data_ref.update(fn(table) {
    value = table.get(id)
    table
  })
  value
}

///|
fn promise_resolve_func_data_set(
  id : Int,
  data : PromiseResolveFunctionData,
) -> Unit {
  promise_resolve_func_data_ref.update(fn(table) {
    table.set(id, data)
    table
  })
}

///|
fn async_generator_resolve_func_data_get(
  id : Int,
) -> AsyncGeneratorResolveFunctionData? {
  let mut value : AsyncGeneratorResolveFunctionData? = None
  async_generator_resolve_func_data_ref.update(fn(table) {
    value = table.get(id)
    table
  })
  value
}

///|
fn async_generator_resolve_func_data_set(
  id : Int,
  data : AsyncGeneratorResolveFunctionData,
) -> Unit {
  async_generator_resolve_func_data_ref.update(fn(table) {
    table.set(id, data)
    table
  })
}

///|
fn async_function_resolve_func_data_get(
  id : Int,
) -> AsyncFunctionResolveFunctionData? {
  let mut value : AsyncFunctionResolveFunctionData? = None
  async_function_resolve_func_data_ref.update(fn(table) {
    value = table.get(id)
    table
  })
  value
}

///|
fn async_function_resolve_func_data_set(
  id : Int,
  data : AsyncFunctionResolveFunctionData,
) -> Unit {
  async_function_resolve_func_data_ref.update(fn(table) {
    table.set(id, data)
    table
  })
}

///|
fn async_function_data_get(id : Int) -> AsyncFunctionData? {
  let mut value : AsyncFunctionData? = None
  async_function_data_ref.update(fn(table) {
    value = table.get(id)
    table
  })
  value
}

///|
fn async_function_data_set(id : Int, data : AsyncFunctionData) -> Unit {
  async_function_data_ref.update(fn(table) {
    table.set(id, data)
    table
  })
}

///|
fn async_function_data_clear(id : Int) -> Unit {
  async_function_data_ref.update(fn(table) {
    let _ = table.remove(id)
    table
  })
}

///|
fn promise_executor_data_get(id : Int) -> PromiseExecutorData? {
  let mut value : PromiseExecutorData? = None
  promise_executor_data_ref.update(fn(table) {
    value = table.get(id)
    table
  })
  value
}

///|
fn promise_executor_data_set(id : Int, data : PromiseExecutorData) -> Unit {
  promise_executor_data_ref.update(fn(table) {
    table.set(id, data)
    table
  })
}

///|
fn promise_all_element_data_get(id : Int) -> PromiseAllElementData? {
  let mut value : PromiseAllElementData? = None
  promise_all_element_data_ref.update(fn(table) {
    value = table.get(id)
    table
  })
  value
}

///|
fn promise_all_element_data_set(id : Int, data : PromiseAllElementData) -> Unit {
  promise_all_element_data_ref.update(fn(table) {
    table.set(id, data)
    table
  })
}

///|
fn promise_then_finally_data_get(id : Int) -> PromiseThenFinallyData? {
  let mut value : PromiseThenFinallyData? = None
  promise_then_finally_data_ref.update(fn(table) {
    value = table.get(id)
    table
  })
  value
}

///|
fn promise_then_finally_data_set(
  id : Int,
  data : PromiseThenFinallyData,
) -> Unit {
  promise_then_finally_data_ref.update(fn(table) {
    table.set(id, data)
    table
  })
}

///|
fn async_from_sync_unwrap_data_get(
  id : Int,
) -> AsyncFromSyncIteratorUnwrapData? {
  let mut value : AsyncFromSyncIteratorUnwrapData? = None
  async_from_sync_unwrap_data_ref.update(fn(table) {
    value = table.get(id)
    table
  })
  value
}

///|
fn async_from_sync_unwrap_data_set(
  id : Int,
  data : AsyncFromSyncIteratorUnwrapData,
) -> Unit {
  async_from_sync_unwrap_data_ref.update(fn(table) {
    table.set(id, data)
    table
  })
}

///|
fn async_from_sync_close_wrap_data_get(
  id : Int,
) -> AsyncFromSyncIteratorCloseWrapData? {
  let mut value : AsyncFromSyncIteratorCloseWrapData? = None
  async_from_sync_close_wrap_data_ref.update(fn(table) {
    value = table.get(id)
    table
  })
  value
}

///|
fn async_from_sync_close_wrap_data_set(
  id : Int,
  data : AsyncFromSyncIteratorCloseWrapData,
) -> Unit {
  async_from_sync_close_wrap_data_ref.update(fn(table) {
    table.set(id, data)
    table
  })
}

///|
fn promise_finally_value_data_get(id : Int) -> Value? {
  let mut value : Value? = None
  promise_finally_value_data_ref.update(fn(table) {
    value = table.get(id)
    table
  })
  value
}

///|
fn promise_finally_value_data_set(id : Int, value : Value) -> Unit {
  promise_finally_value_data_ref.update(fn(table) {
    table.set(id, value)
    table
  })
}

///|
fn promise_all_remaining_add(
  remaining : PromiseAllRemaining,
  addend : Int,
) -> Bool {
  remaining.count = remaining.count + addend
  remaining.count == 0
}

///|
fn promise_species_constructor(promise : Value) -> Value raise {
  let default_ctor = promise_ctor_value_for_current_env()
  let ctor = property_get(promise, "constructor")
  match ctor {
    Undefined => default_ctor
    _ =>
      if !is_object_like(ctor) {
        throw_type_error("constructor is not an object")
      } else {
        match symbol_species_key() {
          Some(key) =>
            match property_get(ctor, key) {
              Undefined | Null => default_ctor
              species =>
                if !is_constructor_value(species) {
                  throw_type_error("not a constructor")
                } else {
                  species
                }
            }
          None => default_ctor
        }
      }
  }
}

///|
fn create_promise_resolving_functions(promise : Value) -> (Value, Value) {
  let shared = PromiseResolveShared::{ already_resolved: false }
  let resolve = new_builtin_value(BuiltinFunction::PromiseResolveFunction)
  let reject = new_builtin_value(BuiltinFunction::PromiseRejectFunction)
  match resolve {
    Builtin(builtin) =>
      promise_resolve_func_data_set(builtin.id, PromiseResolveFunctionData::{
        promise,
        shared,
        is_reject: false,
      })
    _ => ()
  }
  match reject {
    Builtin(builtin) =>
      promise_resolve_func_data_set(builtin.id, PromiseResolveFunctionData::{
        promise,
        shared,
        is_reject: true,
      })
    _ => ()
  }
  (resolve, reject)
}

///|
fn new_promise_capability_executor() -> Value {
  let executor = new_builtin_value(BuiltinFunction::PromiseCapabilityExecutor)
  match executor {
    Builtin(builtin) =>
      promise_executor_data_set(builtin.id, PromiseExecutorData::{
        resolve: None,
        reject: None,
      })
    _ => ()
  }
  executor
}

///|
fn new_promise_capability(ctor : Value) -> (Value, Value, Value) raise {
  let executor = new_promise_capability_executor()
  let promise = if ctor is Undefined {
    let default_ctor = promise_ctor_value_for_current_env()
    call_constructor(default_ctor, [executor])
  } else {
    call_constructor(ctor, [executor])
  }
  let mut resolve_value = Undefined
  let mut reject_value = Undefined
  match executor {
    Builtin(builtin) =>
      match promise_executor_data_get(builtin.id) {
        Some(data) => {
          match data.resolve {
            Some(value) => resolve_value = value
            None => ()
          }
          match data.reject {
            Some(value) => reject_value = value
            None => ()
          }
        }
        None => ()
      }
    _ => ()
  }
  if !is_callable(resolve_value) || !is_callable(reject_value) {
    let _ = throw_type_error("executor not called")

  }
  (promise, resolve_value, reject_value)
}

///|
fn promise_resolve_value(
  this_value : Value,
  value : Value,
  is_reject : Bool,
) -> Value raise {
  if !is_object_like(this_value) {
    return throw_type_error("not an object")
  }
  if !is_reject {
    match promise_data_from_value(value) {
      Some(_) => {
        let ctor = property_get(value, "constructor")
        if strict_eq(ctor, this_value) {
          return value
        }
      }
      None => ()
    }
  }
  let (promise, resolve, reject) = new_promise_capability(this_value)
  let target = if is_reject { reject } else { resolve }
  let _ = call_value_with_this(target, [value], Undefined)
  promise
}

///|
fn new_promise_all_element_function(data : PromiseAllElementData) -> Value {
  let func = new_builtin_value(BuiltinFunction::PromiseAllResolveElement)
  match func {
    Builtin(builtin) => promise_all_element_data_set(builtin.id, data)
    _ => ()
  }
  func
}

///|
fn new_promise_then_finally_function(data : PromiseThenFinallyData) -> Value {
  let func = new_builtin_value(BuiltinFunction::PromiseThenFinally)
  match func {
    Builtin(builtin) => promise_then_finally_data_set(builtin.id, data)
    _ => ()
  }
  func
}

///|
fn new_promise_finally_value_thunk(value : Value) -> Value {
  let func = new_builtin_value(BuiltinFunction::PromiseFinallyValueThunk)
  match func {
    Builtin(builtin) => promise_finally_value_data_set(builtin.id, value)
    _ => ()
  }
  func
}

///|
fn new_promise_finally_thrower(value : Value) -> Value {
  let func = new_builtin_value(BuiltinFunction::PromiseFinallyThrower)
  match func {
    Builtin(builtin) => promise_finally_value_data_set(builtin.id, value)
    _ => ()
  }
  func
}

///|
fn set_array_index(values : Value, index : Int, value : Value) -> Unit raise {
  let name = Int::to_string(index)
  create_data_property_or_throw(values, name, value)
}

///|
fn promise_invoke_then(
  promise : Value,
  on_fulfilled : Value,
  on_rejected : Value,
) -> Value raise {
  let then_method = property_get(promise, "then")
  if !is_callable(then_method) {
    return throw_type_error("not a function")
  }
  call_value_with_this(then_method, [on_fulfilled, on_rejected], promise)
}

///|
fn promise_then_value(promise : Value, value : Value) -> Value raise {
  let on_fulfilled = new_promise_finally_value_thunk(value)
  promise_invoke_then(promise, on_fulfilled, Undefined)
}

///|
fn promise_all_value(
  this_value : Value,
  iterable : Value,
  mode : Int,
) -> Value raise {
  if !is_object_like(this_value) {
    return throw_type_error("not an object")
  }
  let (result_promise, resolve, reject) = new_promise_capability(this_value)
  let mut promise_resolve = Undefined
  try {
    promise_resolve = property_get(this_value, "resolve")
    if !is_callable(promise_resolve) {
      let error = type_error_value("not a function")
      let _ = call_value_with_this(reject, [error], Undefined)
      return result_promise
    }
  } catch {
    ThrowSignal(value) => {
      let _ = call_value_with_this(reject, [value], Undefined)
      return result_promise
    }
    err => raise err
  }
  let mut iterator = Undefined
  let mut next_method = Undefined
  try {
    let (iter_value, next_value) = get_iterator_from_value(iterable)
    iterator = iter_value
    next_method = next_value
  } catch {
    ThrowSignal(value) => {
      let _ = call_value_with_this(reject, [value], Undefined)
      return result_promise
    }
    err => raise err
  }
  let values = new_array_value([])
  let remaining = PromiseAllRemaining::{ count: 1 }
  let mut index = 0
  try {
    while true {
      let mut step = Undefined
      try {
        step = call_value_with_this(next_method, [], iterator)
      } catch {
        ThrowSignal(value) => {
          let _ = call_value_with_this(reject, [value], Undefined)
          return result_promise
        }
        err => raise err
      }
      let step_obj = to_object(step)
      let mut done = false
      try {
        done = is_truthy(property_get(step_obj, "done"))
      } catch {
        ThrowSignal(value) => {
          let _ = call_value_with_this(reject, [value], Undefined)
          return result_promise
        }
        err => raise err
      }
      if done {
        break
      }
      let mut item = Undefined
      try {
        item = property_get(step_obj, "value")
      } catch {
        ThrowSignal(value) => {
          let _ = call_value_with_this(reject, [value], Undefined)
          return result_promise
        }
        err => raise err
      }
      try {
        let next_promise = call_value_with_this(
          promise_resolve,
          [item],
          this_value,
        )
        let shared = PromiseAllElementShared::{ already_called: false }
        let result_resolve = if mode == 2 { reject } else { resolve }
        let resolve_data = PromiseAllElementData::{
          shared,
          index,
          values,
          result_resolve,
          remaining,
          mode,
          is_reject: false,
        }
        let mut resolve_element = new_promise_all_element_function(resolve_data)
        let mut reject_element : Value = Undefined
        if mode == 1 {
          let reject_data = PromiseAllElementData::{
            shared,
            index,
            values,
            result_resolve: resolve,
            remaining,
            mode,
            is_reject: true,
          }
          reject_element = new_promise_all_element_function(reject_data)
        } else if mode == 2 {
          let _ = set_array_index(values, index, Undefined)
          reject_element = resolve_element
          resolve_element = resolve
        } else {
          reject_element = reject
        }
        let _ = promise_all_remaining_add(remaining, 1)
        let _ = promise_invoke_then(
          next_promise, resolve_element, reject_element,
        )
        index = index + 1
      } catch {
        ThrowSignal(value) => {
          iterator_close_on_error(iterator)
          let _ = call_value_with_this(reject, [value], Undefined)
          return result_promise
        }
        err => {
          iterator_close_on_error(iterator)
          raise err
        }
      }
    }
  } catch {
    ThrowSignal(value) => {
      iterator_close_on_error(iterator)
      let _ = call_value_with_this(reject, [value], Undefined)
      return result_promise
    }
    err => {
      iterator_close_on_error(iterator)
      raise err
    }
  }
  if promise_all_remaining_add(remaining, -1) {
    try {
      if mode == 2 {
        let error = new_aggregate_error_value([values])
        let _ = call_value_with_this(reject, [error], Undefined)

      } else {
        let _ = call_value_with_this(resolve, [values], Undefined)

      }
    } catch {
      ThrowSignal(value) => {
        let _ = call_value_with_this(reject, [value], Undefined)

      }
      err => raise err
    }
  }
  result_promise
}

///|
fn promise_race_value(this_value : Value, iterable : Value) -> Value raise {
  if !is_object_like(this_value) {
    return throw_type_error("not an object")
  }
  let (result_promise, resolve, reject) = new_promise_capability(this_value)
  let mut promise_resolve = Undefined
  try {
    promise_resolve = property_get(this_value, "resolve")
    if !is_callable(promise_resolve) {
      let error = type_error_value("not a function")
      let _ = call_value_with_this(reject, [error], Undefined)
      return result_promise
    }
  } catch {
    ThrowSignal(value) => {
      let _ = call_value_with_this(reject, [value], Undefined)
      return result_promise
    }
    err => raise err
  }
  let mut iterator = Undefined
  let mut next_method = Undefined
  try {
    let (iter_value, next_value) = get_iterator_from_value(iterable)
    iterator = iter_value
    next_method = next_value
  } catch {
    ThrowSignal(value) => {
      let _ = call_value_with_this(reject, [value], Undefined)
      return result_promise
    }
    err => raise err
  }
  try {
    while true {
      let mut step = Undefined
      try {
        step = call_value_with_this(next_method, [], iterator)
      } catch {
        ThrowSignal(value) => {
          let _ = call_value_with_this(reject, [value], Undefined)
          return result_promise
        }
        err => raise err
      }
      let step_obj = to_object(step)
      let mut done = false
      try {
        done = is_truthy(property_get(step_obj, "done"))
      } catch {
        ThrowSignal(value) => {
          let _ = call_value_with_this(reject, [value], Undefined)
          return result_promise
        }
        err => raise err
      }
      if done {
        break
      }
      let mut item = Undefined
      try {
        item = property_get(step_obj, "value")
      } catch {
        ThrowSignal(value) => {
          let _ = call_value_with_this(reject, [value], Undefined)
          return result_promise
        }
        err => raise err
      }
      try {
        let next_promise = call_value_with_this(
          promise_resolve,
          [item],
          this_value,
        )
        let _ = promise_invoke_then(next_promise, resolve, reject)

      } catch {
        ThrowSignal(value) => {
          iterator_close_on_error(iterator)
          let _ = call_value_with_this(reject, [value], Undefined)
          return result_promise
        }
        err => {
          iterator_close_on_error(iterator)
          raise err
        }
      }
    }
  } catch {
    ThrowSignal(value) => {
      iterator_close_on_error(iterator)
      let _ = call_value_with_this(reject, [value], Undefined)
      return result_promise
    }
    err => {
      iterator_close_on_error(iterator)
      raise err
    }
  }
  result_promise
}

///|
fn promise_try_value(this_value : Value, args : Array[Value]) -> Value raise {
  if !is_object_like(this_value) {
    return throw_type_error("not an object")
  }
  let (result_promise, resolve, reject) = new_promise_capability(this_value)
  let call_args : Array[Value] = []
  let func = if args.is_empty() { Undefined } else { args[0] }
  let mut i = 1
  while i < args.length() {
    call_args.push(args[i])
    i = i + 1
  }
  let mut is_reject = false
  let mut result = Undefined
  try {
    result = call_value_with_this(func, call_args, Undefined)
  } catch {
    ThrowSignal(value) => {
      is_reject = true
      result = value
    }
    err => raise err
  }
  let target = if is_reject { reject } else { resolve }
  let _ = call_value_with_this(target, [result], Undefined)
  result_promise
}

///|
fn promise_with_resolvers_value(this_value : Value) -> Value raise {
  if !is_object_like(this_value) {
    return throw_type_error("not an object")
  }
  let (promise, resolve, reject) = new_promise_capability(this_value)
  let obj = new_object_value()
  create_data_property_or_throw(obj, "promise", promise)
  create_data_property_or_throw(obj, "resolve", resolve)
  create_data_property_or_throw(obj, "reject", reject)
  obj
}

///|
fn array_from_args_with_proto(
  args : Array[Value],
  proto : Value?,
) -> Value raise {
  if args.length() == 1 {
    match args[0] {
      Number(n) => {
        let new_len_uint = to_uint32(n)
        let new_len_num = UInt::to_double(new_len_uint)
        if Double::is_nan(n) || new_len_num != n {
          return throw_range_error("invalid array length")
        }
        let len64 = Double::to_int64(new_len_num)
        let result = new_array_value_with_proto([], proto~)
        match result {
          Array(arr) =>
            set_length_prop(arr.props, Number(Int64::to_double(len64)))
          _ => ()
        }
        return result
      }
      _ => ()
    }
  }
  let elements : Array[Value?] = []
  for value in args {
    elements.push(Some(value))
  }
  new_array_value_with_proto(elements, proto~)
}

///|
fn function_from_args(args : Array[Value]) -> Value raise {
  let base_env = match root_env() {
    Some(root) => root
    None => Env::new(None)
  }
  function_from_args_with_env(args, base_env)
}

///|
fn generator_function_from_args(args : Array[Value]) -> Value raise {
  let base_env = match root_env() {
    Some(root) => root
    None => Env::new(None)
  }
  function_from_args_with_env_kind(args, base_env, true, false)
}

///|
fn async_generator_function_from_args(args : Array[Value]) -> Value raise {
  let base_env = match root_env() {
    Some(root) => root
    None => Env::new(None)
  }
  function_from_args_with_env_kind(args, base_env, true, true)
}

///|
fn async_function_from_args(args : Array[Value]) -> Value raise {
  let base_env = match root_env() {
    Some(root) => root
    None => Env::new(None)
  }
  function_from_args_with_env_kind(args, base_env, false, true)
}

///|
fn function_from_args_with_env(
  args : Array[Value],
  base_env : Env,
) -> Value raise {
  function_from_args_with_env_kind(args, base_env, false, false)
}

///|
fn function_from_args_with_env_kind(
  args : Array[Value],
  base_env : Env,
  is_generator : Bool,
  is_async : Bool,
) -> Value raise {
  let mut params_source = ""
  if args.length() > 1 {
    let parts : Array[String] = []
    for i = 0; i < args.length() - 1; i = i + 1 {
      parts.push(to_string_strict(args[i]))
    }
    params_source = parts.join(",")
  }
  let body = if args.is_empty() {
    ""
  } else {
    to_string_strict(args[args.length() - 1])
  }
  let mut header = "("
  if is_async {
    header = header + "async "
  }
  header = header + "function"
  if is_generator {
    header = header + "*"
  }
  header = header + " anonymous("
  let source = header + params_source + "\n) {\n" + body + "\n})"
  let script = parse_script_with_pos(source)
  if script.body.is_empty() {
    return throw_type_error("invalid function body")
  }
  let func_def = match script.body[0] {
    FunctionDecl(func) => func
    ExprStmt(expr) =>
      match expr {
        @engine.Expr::FunctionExpr(func) => func
        @engine.Expr::Paren(inner) =>
          match inner {
            @engine.Expr::FunctionExpr(func) => func
            _ => return throw_type_error("invalid function body")
          }
        _ => return throw_type_error("invalid function body")
      }
    _ => return throw_type_error("invalid function body")
  }
  let func_env = Env::new(Some(base_env))
  func_env.strict = false
  with_source_value(source, fn() {
    let func_value = to_function_value(func_env, func_def, false)
    match func_def.name {
      Some(name) =>
        env_define_readonly(func_env, name, Value::Function(func_value), false)
      None => ()
    }
    if !is_async || is_generator {
      ensure_function_prototype(func_value)
    }
    Value::Function(func_value)
  })
}

///|
fn new_arguments_value(
  func : FunctionValue,
  env : Env,
  args : Array[Value],
  is_strict : Bool,
  mapped_allowed : Bool,
) -> Value {
  let param_names = if mapped_allowed {
    let names : Array[String] = []
    for param in func.params {
      if param.is_rest {
        break
      }
      match param.binding {
        @engine.VarBinding::Name(name) => names.push(name)
        _ => ()
      }
    }
    names
  } else {
    []
  }
  let elements : Array[Value?] = []
  for value in args {
    elements.push(Some(value))
  }
  let mapped : Array[Bool] = []
  let param_len = param_names.length()
  let arg_len = elements.length()
  for i = 0; i < arg_len; i = i + 1 {
    mapped.push(false)
  }
  if !is_strict && mapped_allowed && param_len > 0 {
    let seen : Map[String, Bool] = Map::new()
    let mut i = param_len - 1
    while i >= 0 {
      let name = param_names[i]
      if !seen.contains(name) {
        seen.set(name, true)
        if i < arg_len {
          mapped[i] = true
        }
      }
      if i == 0 {
        break
      }
      i = i - 1
    }
  }
  let props : Map[String, Property] = Map::new()
  props.set("length", property_data_non_enum(Number(Double::from_int(arg_len))))
  if is_strict || !mapped_allowed {
    let thrower = throw_type_error_value_for_env(env)
    props.set("callee", property_accessor_non_config(thrower, thrower))
  } else {
    props.set("callee", property_data_non_enum(Value::Function(func)))
  }
  let mut array_iterator_value : Value? = None
  match array_proto_for_env(env) {
    Some(array_proto_obj) => {
      match symbol_iterator_key() {
        Some(key) =>
          match array_proto_obj.props.get(key) {
            Some(prop) => array_iterator_value = Some(prop.value)
            None => ()
          }
        None => ()
      }
      if array_iterator_value is None {
        match array_proto_obj.props.get("values") {
          Some(prop) => array_iterator_value = Some(prop.value)
          None => ()
        }
      }
    }
    None => ()
  }
  match symbol_iterator_key() {
    Some(key) =>
      match array_iterator_value {
        Some(value) => props.set(key, property_data_non_enum(value))
        None =>
          props.set(
            key,
            property_data_non_enum(
              new_builtin_value(BuiltinFunction::ArrayValues),
            ),
          )
      }
    None => ()
  }
  let args_value = register_arguments_value(ArgumentsValue::{
    id: alloc_id(),
    env,
    params: param_names,
    mapped,
    elements,
    props,
    proto: value_from_object(object_proto()),
    extensible: true,
  })
  Arguments(args_value)
}

///|
fn property_data(value : Value) -> Property {
  Property::{
    value,
    writable: true,
    configurable: true,
    enumerable: true,
    getter: None,
    setter: None,
  }
}

///|
fn property_data_readonly(value : Value) -> Property {
  Property::{
    value,
    writable: false,
    configurable: true,
    enumerable: false,
    getter: None,
    setter: None,
  }
}

///|
fn property_data_const(value : Value) -> Property {
  Property::{
    value,
    writable: false,
    configurable: false,
    enumerable: false,
    getter: None,
    setter: None,
  }
}

///|
fn property_data_non_enum_non_config(value : Value) -> Property {
  Property::{
    value,
    writable: true,
    configurable: false,
    enumerable: false,
    getter: None,
    setter: None,
  }
}

///|
fn property_data_non_enum(value : Value) -> Property {
  Property::{
    value,
    writable: true,
    configurable: true,
    enumerable: false,
    getter: None,
    setter: None,
  }
}

///|
fn property_accessor(getter : Value, setter : Value) -> Property {
  Property::{
    value: Undefined,
    writable: false,
    configurable: true,
    enumerable: false,
    getter: Some(getter),
    setter: Some(setter),
  }
}

///|
fn property_accessor_non_config(getter : Value, setter : Value) -> Property {
  Property::{
    value: Undefined,
    writable: false,
    configurable: false,
    enumerable: false,
    getter: Some(getter),
    setter: Some(setter),
  }
}

///|
fn set_accessor_property(
  props : Map[String, Property],
  name : String,
  getter : Value?,
  setter : Value?,
) -> Unit {
  match props.get(name) {
    Some(prop) =>
      if prop.getter is Some(_) || prop.setter is Some(_) {
        let next_getter = match getter {
          Some(_) => getter
          None => prop.getter
        }
        let next_setter = match setter {
          Some(_) => setter
          None => prop.setter
        }
        props.set(name, Property::{
          value: Undefined,
          writable: false,
          configurable: prop.configurable,
          enumerable: prop.enumerable,
          getter: next_getter,
          setter: next_setter,
        })
      } else {
        props.set(name, Property::{
          value: Undefined,
          writable: false,
          configurable: true,
          enumerable: true,
          getter,
          setter,
        })
      }
    None =>
      props.set(name, Property::{
        value: Undefined,
        writable: false,
        configurable: true,
        enumerable: true,
        getter,
        setter,
      })
  }
}

///|
fn set_accessor_property_with_enum(
  props : Map[String, Property],
  name : String,
  getter : Value?,
  setter : Value?,
  enumerable : Bool,
) -> Unit {
  match props.get(name) {
    Some(prop) =>
      if prop.getter is Some(_) || prop.setter is Some(_) {
        let next_getter = match getter {
          Some(_) => getter
          None => prop.getter
        }
        let next_setter = match setter {
          Some(_) => setter
          None => prop.setter
        }
        props.set(name, Property::{
          value: Undefined,
          writable: false,
          configurable: prop.configurable,
          enumerable,
          getter: next_getter,
          setter: next_setter,
        })
      } else {
        props.set(name, Property::{
          value: Undefined,
          writable: false,
          configurable: true,
          enumerable,
          getter,
          setter,
        })
      }
    None =>
      props.set(name, Property::{
        value: Undefined,
        writable: false,
        configurable: true,
        enumerable,
        getter,
        setter,
      })
  }
}

///|
fn copy_proxy_data_properties(
  target : ObjectValue,
  source : Value,
  data : ProxyData,
) -> Unit raise {
  let keys = proxy_own_keys_values(data)
  for key_value in keys {
    let name = match key_value {
      String(text) => text
      Symbol(symbol) => symbol_prop_key(symbol)
      _ => {
        let _ = throw_type_error("ownKeys must return strings or symbols")
        continue
      }
    }
    let desc = proxy_get_own_property_descriptor(data, name)
    match desc {
      Undefined => ()
      _ =>
        if !is_object_like(desc) {
          let _ = throw_type_error("invalid property descriptor")

        } else {
          let enumerable_value = property_get(desc, "enumerable")
          if is_truthy(enumerable_value) {
            let value = property_get(source, name)
            target.props.set(name, property_data(value))
          }
        }
    }
  }
}

///|
fn copy_data_properties(target : ObjectValue, source : Value) -> Unit raise {
  if !is_object_like(source) {
    return
  }
  let from = to_object(source)
  match from {
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => {
          copy_proxy_data_properties(target, from, data)
          return
        }
        None => ()
      }
    _ => ()
  }
  let keys = own_enumerable_string_keys(from)
  for key in keys {
    let value = property_get(from, key)
    target.props.set(key, property_data(value))
  }
  let symbols = own_symbol_keys(from, false)
  for symbol in symbols {
    let key = symbol_prop_key(symbol)
    let value = property_get(from, key)
    target.props.set(key, property_data(value))
  }
}

///|
fn copy_data_properties_excluding(
  target : ObjectValue,
  source : Value,
  excluded : Array[String],
) -> Unit raise {
  if !is_object_like(source) {
    return
  }
  let from = to_object(source)
  let keys = own_property_keys_values(from)
  for key in keys {
    let key_name = match key {
      String(name) => name
      Symbol(symbol) => symbol_prop_key(symbol)
      _ => continue
    }
    if excluded.contains(key_name) {
      continue
    }
    let desc = get_own_property_descriptor(from, key_name)
    match desc {
      Undefined => ()
      _ =>
        if !is_object_like(desc) {
          let _ = throw_type_error("invalid property descriptor")

        } else {
          let enumerable_value = property_get(desc, "enumerable")
          if is_truthy(enumerable_value) {
            let value = property_get(from, key_name)
            target.props.set(key_name, property_data(value))
          }
        }
    }
  }
}

///|
fn eval_object_literal(
  env : Env,
  props : Array[@engine.ObjectProp],
) -> Value raise {
  with_gc_frame(fn() raise {
    let obj = new_object_value()
    match obj {
      Object(value) => {
        let _ = gc_root_push(obj)
        for prop in props {
          let _ = with_gc_frame(fn() raise {
            match prop {
              @engine.ObjectProp::KeyValue(key, expr) =>
                if obj_key_is_proto(key) {
                  let proto_value = eval_expr(env, expr)
                  let _ = gc_root_push(proto_value)
                  match proto_value {
                    Null => value.proto = None
                    _ if is_object_like(proto_value) =>
                      value.proto = Some(proto_value)
                    _ => ()
                  }
                } else {
                  let (name, key_value) = obj_key_property_name(env, key)
                  match key_value {
                    Some(key_value_item) => {
                      let _ = gc_root_push(key_value_item)

                    }
                    None => ()
                  }
                  let prop_value = eval_named_expr(env, expr, name, key_value)
                  let _ = gc_root_push(prop_value)
                  value.props.set(name, property_data(prop_value))
                }
              @engine.ObjectProp::Method(key, func) => {
                let (name, key_value) = obj_key_property_name(env, key)
                match key_value {
                  Some(key_value_item) => {
                    let _ = gc_root_push(key_value_item)

                  }
                  None => ()
                }
                let func_value = to_function_value(env, func, false)
                let func = Value::Function(func_value)
                let _ = gc_root_push(func)
                func_value.is_constructor = false
                set_function_name(
                  func_value,
                  function_name_from_key(name, key_value, None),
                )
                func_value.home_object = Some(Value::Object(value))
                value.props.set(name, property_data(func))
              }
              @engine.ObjectProp::Shorthand(name) => {
                let prop_value = env_get(env, name)
                let _ = gc_root_push(prop_value)
                value.props.set(name, property_data(prop_value))
              }
              @engine.ObjectProp::Getter(key, func) => {
                let (name, key_value) = obj_key_property_name(env, key)
                match key_value {
                  Some(key_value_item) => {
                    let _ = gc_root_push(key_value_item)

                  }
                  None => ()
                }
                let func_value = to_function_value(env, func, false)
                let getter = Value::Function(func_value)
                let _ = gc_root_push(getter)
                func_value.is_constructor = false
                set_function_name(
                  func_value,
                  function_name_from_key(name, key_value, Some("get ")),
                )
                func_value.home_object = Some(Value::Object(value))
                set_accessor_property(value.props, name, Some(getter), None)
              }
              @engine.ObjectProp::Setter(key, func) => {
                let (name, key_value) = obj_key_property_name(env, key)
                match key_value {
                  Some(key_value_item) => {
                    let _ = gc_root_push(key_value_item)

                  }
                  None => ()
                }
                let func_value = to_function_value(env, func, false)
                let setter = Value::Function(func_value)
                let _ = gc_root_push(setter)
                func_value.is_constructor = false
                set_function_name(
                  func_value,
                  function_name_from_key(name, key_value, Some("set ")),
                )
                func_value.home_object = Some(Value::Object(value))
                set_accessor_property(value.props, name, None, Some(setter))
              }
              @engine.ObjectProp::Spread(expr) => {
                let spread_value = eval_expr(env, expr)
                let _ = gc_root_push(spread_value)
                copy_data_properties(value, spread_value)
              }
            }
            Undefined
          })

        }
        obj
      }
      _ => obj
    }
  })
}

///|
fn gen_eval_obj_key(
  env : Env,
  key : @engine.ObjKey,
  k : (String, Value?) -> GenStep raise,
) -> GenStep raise {
  match key {
    @engine.ObjKey::Computed(expr) =>
      gen_eval_expr_cont(env, expr, fn(value) raise {
        let _ = gen_root_push(value)
        k(property_key_name(value), Some(value))
      })
    _ => k(obj_key_simple_name(key), None)
  }
}

///|
fn gen_eval_object_literal(
  env : Env,
  props : Array[@engine.ObjectProp],
  index : Int,
  target : ObjectValue,
  k : (Value) -> GenStep raise,
) -> GenStep raise {
  if index >= props.length() {
    return k(Value::Object(target))
  }
  let prop = props[index]
  match prop {
    @engine.ObjectProp::KeyValue(key, expr) =>
      if obj_key_is_proto(key) {
        gen_eval_expr_cont(env, expr, fn(value) raise {
          let _ = gen_root_push(value)
          match value {
            Null => target.proto = None
            _ if is_object_like(value) => target.proto = Some(value)
            _ => ()
          }
          gen_eval_object_literal(env, props, index + 1, target, k)
        })
      } else {
        gen_eval_obj_key(env, key, fn(name, key_value) raise {
          match key_value {
            Some(key_value_item) => {
              let _ = gen_root_push(key_value_item)

            }
            None => ()
          }
          gen_eval_named_expr_cont(env, expr, name, key_value, fn(value) raise {
            let _ = gen_root_push(value)
            target.props.set(name, property_data(value))
            gen_eval_object_literal(env, props, index + 1, target, k)
          })
        })
      }
    @engine.ObjectProp::Method(key, func) =>
      gen_eval_obj_key(env, key, fn(name, key_value) raise {
        match key_value {
          Some(key_value_item) => {
            let _ = gen_root_push(key_value_item)

          }
          None => ()
        }
        let func_value = to_function_value(env, func, false)
        let func = Value::Function(func_value)
        let _ = gen_root_push(func)
        func_value.is_constructor = false
        set_function_name(
          func_value,
          function_name_from_key(name, key_value, None),
        )
        func_value.home_object = Some(Value::Object(target))
        target.props.set(name, property_data(func))
        gen_eval_object_literal(env, props, index + 1, target, k)
      })
    @engine.ObjectProp::Shorthand(name) => {
      let value = env_get(env, name)
      let _ = gen_root_push(value)
      target.props.set(name, property_data(value))
      gen_eval_object_literal(env, props, index + 1, target, k)
    }
    @engine.ObjectProp::Getter(key, func) =>
      gen_eval_obj_key(env, key, fn(name, key_value) raise {
        match key_value {
          Some(key_value_item) => {
            let _ = gen_root_push(key_value_item)

          }
          None => ()
        }
        let func_value = to_function_value(env, func, false)
        func_value.is_constructor = false
        set_function_name(
          func_value,
          function_name_from_key(name, key_value, Some("get ")),
        )
        func_value.home_object = Some(Value::Object(target))
        let getter = Value::Function(func_value)
        let _ = gen_root_push(getter)
        set_accessor_property(target.props, name, Some(getter), None)
        gen_eval_object_literal(env, props, index + 1, target, k)
      })
    @engine.ObjectProp::Setter(key, func) =>
      gen_eval_obj_key(env, key, fn(name, key_value) raise {
        match key_value {
          Some(key_value_item) => {
            let _ = gen_root_push(key_value_item)

          }
          None => ()
        }
        let func_value = to_function_value(env, func, false)
        func_value.is_constructor = false
        set_function_name(
          func_value,
          function_name_from_key(name, key_value, Some("set ")),
        )
        func_value.home_object = Some(Value::Object(target))
        let setter = Value::Function(func_value)
        let _ = gen_root_push(setter)
        set_accessor_property(target.props, name, None, Some(setter))
        gen_eval_object_literal(env, props, index + 1, target, k)
      })
    @engine.ObjectProp::Spread(expr) =>
      gen_eval_expr_cont(env, expr, fn(value) raise {
        let _ = gen_root_push(value)
        copy_data_properties(target, value)
        gen_eval_object_literal(env, props, index + 1, target, k)
      })
  }
}

///|
fn obj_key_simple_name(key : @engine.ObjKey) -> String {
  match key {
    @engine.ObjKey::Ident(id) => id
    @engine.ObjKey::Private(id) => "#" + id
    @engine.ObjKey::String(s) => s
    @engine.ObjKey::Number(value) => number_to_string_radix(value, 10)
    @engine.ObjKey::Computed(_) => ""
  }
}

///|
fn obj_key_is_proto(key : @engine.ObjKey) -> Bool {
  match key {
    @engine.ObjKey::Ident(name) => name == "__proto__"
    @engine.ObjKey::String(name) => name == "__proto__"
    _ => false
  }
}

///|
fn obj_key_property_name(
  env : Env,
  key : @engine.ObjKey,
) -> (String, Value?) raise {
  match key {
    @engine.ObjKey::Computed(expr) => {
      let value = eval_expr(env, expr)
      (property_key_name(value), Some(value))
    }
    _ => (obj_key_simple_name(key), None)
  }
}

///|
fn gen_obj_key_property_name(
  env : Env,
  key : @engine.ObjKey,
  k : (String, Value?) -> GenStep raise,
) -> GenStep raise {
  match key {
    @engine.ObjKey::Computed(expr) =>
      gen_eval_expr_cont(env, expr, fn(value) raise {
        let _ = gen_root_push(value)
        k(property_key_name(value), Some(value))
      })
    _ => k(obj_key_simple_name(key), None)
  }
}

///|
fn function_name_from_key(
  name : String,
  key_value : Value?,
  prefix : String?,
) -> String {
  let base = match key_value {
    Some(value) =>
      match symbol_from_value(value) {
        Some(symbol) =>
          match symbol.description {
            Some(desc) => "[" + desc + "]"
            None => ""
          }
        None => name
      }
    None => name
  }
  match prefix {
    Some(value) => value + base
    None => base
  }
}

///|
fn set_function_name(func : FunctionValue, name : String) -> Unit {
  func.props.set("name", property_data_readonly(String(name)))
}

///|
fn set_anonymous_function_name(
  value : Value,
  name : String,
  key_value : Value?,
) -> Unit {
  match value {
    Function(func) =>
      if func.name is None {
        let mut allow = true
        match func.props.get("name") {
          Some(prop) =>
            match prop.value {
              String(value) => allow = value == ""
              _ => allow = false
            }
          None => ()
        }
        if allow {
          set_function_name(func, function_name_from_key(name, key_value, None))
        }
      }
    _ => ()
  }
}

///|
fn eval_named_expr(
  env : Env,
  expr : @engine.Expr,
  name : String,
  key_value : Value?,
) -> Value raise {
  let hint_name = function_name_from_key(name, key_value, None)
  match unwrap_paren(expr) {
    @engine.Expr::ClassExpr(class_def) =>
      if class_def.name is None {
        return eval_class(env, class_def, name_hint=Some(hint_name))
      }
    _ => ()
  }
  let value = eval_expr(env, expr)
  if is_anonymous_function_definition(expr) {
    set_anonymous_function_name(value, name, key_value)
  }
  value
}

///|
fn is_anonymous_function_definition(expr : @engine.Expr) -> Bool {
  match expr {
    @engine.Expr::FunctionExpr(func) => func.name is None
    @engine.Expr::ClassExpr(class_def) => class_def.name is None
    @engine.Expr::Paren(inner) => is_anonymous_function_definition(inner)
    _ => false
  }
}

///|
fn define_class_method(
  target : Value,
  name : String,
  func : FunctionValue,
) -> Unit raise {
  let desc = property_descriptor_object(
    property_data_non_enum(Value::Function(func)),
  )
  let _ = define_property(target, prop_key_value_from_name(name), desc)

}

///|
fn define_class_accessor(
  target : Value,
  name : String,
  getter : Value?,
  setter : Value?,
) -> Unit raise {
  let mut final_getter = getter
  let mut final_setter = setter
  match props_map_for_value(target) {
    Some(props) =>
      match props.get(name) {
        Some(prop) =>
          if prop.getter is Some(_) || prop.setter is Some(_) {
            if final_getter is None {
              final_getter = prop.getter
            }
            if final_setter is None {
              final_setter = prop.setter
            }
          }
        None => ()
      }
    None => ()
  }
  let desc = property_descriptor_object(Property::{
    value: Undefined,
    writable: false,
    configurable: true,
    enumerable: false,
    getter: final_getter,
    setter: final_setter,
  })
  let _ = define_property(target, prop_key_value_from_name(name), desc)

}

///|
priv enum ClassStaticInit {
  Field(ClassFieldRecord)
  Block(Array[@engine.Stmt])
}

///|
fn static_super_constructor_for_env(
  env : Env,
  ctor_func : FunctionValue,
) -> Value? {
  match ctor_func.super_constructor {
    Some(value) => Some(value)
    None =>
      match function_proto_for_env(env) {
        Some(value) => Some(value)
        None => function_proto()
      }
  }
}

///|
fn with_static_super_context(
  ctor_func : FunctionValue,
  static_super_ctor : Value?,
  f : () -> Value raise,
) -> Value raise {
  let saved_home = ctor_func.home_object
  let saved_super = ctor_func.super_constructor
  ctor_func.home_object = Some(Value::Function(ctor_func))
  ctor_func.super_constructor = static_super_ctor
  try with_current_function(ctor_func, f) catch {
    err => {
      ctor_func.home_object = saved_home
      ctor_func.super_constructor = saved_super
      raise err
    }
  } noraise {
    value => {
      ctor_func.home_object = saved_home
      ctor_func.super_constructor = saved_super
      value
    }
  }
}

///|
fn with_static_super_context_step(
  ctor_func : FunctionValue,
  static_super_ctor : Value?,
  f : () -> GenStep raise,
) -> GenStep raise {
  let saved_home = ctor_func.home_object
  let saved_super = ctor_func.super_constructor
  ctor_func.home_object = Some(Value::Function(ctor_func))
  ctor_func.super_constructor = static_super_ctor
  let step = with_current_function_step(ctor_func, f) catch {
    err => {
      ctor_func.home_object = saved_home
      ctor_func.super_constructor = saved_super
      raise err
    }
  }
  gen_bind_noraise(step, fn(control) {
    ctor_func.home_object = saved_home
    ctor_func.super_constructor = saved_super
    Done(control)
  })
}

///|
fn with_class_field_init_context(f : () -> Value raise) -> Value raise {
  let mut current : FunctionValue? = None
  let mut saved_flag = false
  match current_function() {
    Some(func) => {
      current = Some(func)
      saved_flag = func.in_class_field_init
      func.in_class_field_init = true
    }
    None => ()
  }
  try f() catch {
    err => {
      match current {
        Some(func) => func.in_class_field_init = saved_flag
        None => ()
      }
      raise err
    }
  } noraise {
    value => {
      match current {
        Some(func) => func.in_class_field_init = saved_flag
        None => ()
      }
      value
    }
  }
}

///|
fn with_class_field_init_context_step(f : () -> GenStep raise) -> GenStep raise {
  let mut current : FunctionValue? = None
  let mut saved_flag = false
  match current_function() {
    Some(func) => {
      current = Some(func)
      saved_flag = func.in_class_field_init
      func.in_class_field_init = true
    }
    None => ()
  }
  let step = f() catch {
    err => {
      match current {
        Some(func) => func.in_class_field_init = saved_flag
        None => ()
      }
      raise err
    }
  }
  gen_bind_noraise(step, fn(control) {
    match current {
      Some(func) => func.in_class_field_init = saved_flag
      None => ()
    }
    Done(control)
  })
}

///|
fn eval_class_field_initializer(env : Env, expr : @engine.Expr) -> Value raise {
  let saved_new_target = env.new_target
  env.new_target = Undefined
  try with_class_field_init_context(fn() raise { eval_expr(env, expr) }) catch {
    err => {
      env.new_target = saved_new_target
      raise err
    }
  } noraise {
    value => {
      env.new_target = saved_new_target
      value
    }
  }
}

///|
fn gen_eval_class_field_initializer(
  env : Env,
  expr : @engine.Expr,
) -> GenStep raise {
  let saved_new_target = env.new_target
  env.new_target = Undefined
  let step = with_class_field_init_context_step(fn() {
    gen_eval_expr_cont(env, expr, fn(value) { Done(Normal(value)) })
  })
  gen_bind(step, fn(control) {
    env.new_target = saved_new_target
    Done(control)
  })
}

///|
fn eval_class(
  env : Env,
  class_def : @engine.ClassDef,
  name_hint? : String? = None,
) -> Value raise {
  let class_env = Env::new(Some(env))
  match class_def.name {
    Some(name) => {
      env_declare_uninitialized(class_env, name)
      class_env.readonly_bindings.set(name, true)
    }
    None => ()
  }
  let mut super_value : Value? = None
  match class_def.super_class {
    Some(expr) => super_value = Some(eval_expr(class_env, expr))
    None => ()
  }
  match super_value {
    Some(value) =>
      match value {
        Null => ()
        _ =>
          if !is_constructor_value(value) {
            let _ = throw_type_error("not a constructor")

          }
      }
    None => ()
  }
  for class_member in class_def.body {
    match class_member {
      @engine.ClassMember::Method(@engine.ObjKey::Private(name), _, _) =>
        if class_env.private_bindings.get(name) is None {
          ignore(env_define_private_name(class_env, name))
        }
      @engine.ClassMember::Getter(@engine.ObjKey::Private(name), _, _) =>
        if class_env.private_bindings.get(name) is None {
          ignore(env_define_private_name(class_env, name))
        }
      @engine.ClassMember::Setter(@engine.ObjKey::Private(name), _, _) =>
        if class_env.private_bindings.get(name) is None {
          ignore(env_define_private_name(class_env, name))
        }
      @engine.ClassMember::Field(@engine.ObjKey::Private(name), _, _) =>
        if class_env.private_bindings.get(name) is None {
          ignore(env_define_private_name(class_env, name))
        }
      _ => ()
    }
  }
  let mut constructor_def : @engine.FunctionDef? = None
  for class_member in class_def.body {
    match class_member {
      @engine.ClassMember::Method(@engine.ObjKey::Ident(name), func, is_static)
      | @engine.ClassMember::Method(
        @engine.ObjKey::String(name),
        func,
        is_static
      ) =>
        if !is_static && name == "constructor" {
          constructor_def = Some(func)
        }
      _ => ()
    }
  }
  let ctor_def = match constructor_def {
    Some(func) =>
      match class_def.name {
        Some(class_name) =>
          @engine.FunctionDef::new(
            Some(class_name),
            func.params,
            func.param_inits,
            func.body,
            true,
            func.is_generator,
            func.is_async,
            false,
            func.offset,
            func.end_offset,
          )
        None =>
          @engine.FunctionDef::new(
            None,
            func.params,
            func.param_inits,
            func.body,
            true,
            func.is_generator,
            func.is_async,
            false,
            func.offset,
            func.end_offset,
          )
      }
    None =>
      @engine.FunctionDef::new(
        class_def.name,
        ([] : Array[@engine.ParamBinding]),
        ([] : Array[@engine.Expr?]),
        ([] : Array[@engine.Stmt]),
        true,
        false,
        false,
        false,
        class_def.offset,
        class_def.end_offset,
      )
  }
  let ctor_func = to_function_value(class_env, ctor_def, false)
  ctor_func.is_class_constructor = true
  if class_def.name is None {
    match name_hint {
      Some(name) => set_function_name(ctor_func, name)
      None => ()
    }
  }
  match current_source() {
    Some(source) => {
      let end_offset = if class_def.end_offset > class_def.offset {
        class_def.end_offset
      } else {
        class_def.offset
      }
      ctor_func.source = Some(
        slice_source_range(source, class_def.offset, end_offset),
      )
    }
    None => ()
  }
  let field_env = Env::new(Some(class_env))
  env_set_local(field_env, "this", Value::Function(ctor_func))
  field_env.new_target = Undefined
  match super_value {
    Some(value) => {
      ctor_func.super_constructor = Some(value)
      match value {
        Null => ()
        _ => ctor_func.proto = Some(value)
      }
    }
    None => ()
  }
  if constructor_def is None {
    match super_value {
      Some(_) => ctor_func.is_default_constructor = true
      None => ()
    }
  }
  ensure_function_prototype(ctor_func)
  let proto_value = property_get(Value::Function(ctor_func), "prototype")
  let proto_obj = match proto_value {
    Object(obj) => obj
    _ => {
      let fresh = new_object_value()
      match fresh {
        Object(obj) => {
          ctor_func.props.set(
            "prototype",
            property_data_non_enum_non_config(fresh),
          )
          obj
        }
        _ => return Value::Function(ctor_func)
      }
    }
  }
  ctor_func.home_object = Some(Value::Object(proto_obj))
  match super_value {
    Some(Null) => proto_obj.proto = None
    Some(value) => {
      let base_proto_value = property_get(value, "prototype")
      if is_object_like(base_proto_value) {
        proto_obj.proto = Some(base_proto_value)
      } else if base_proto_value is Null {
        proto_obj.proto = None
      } else {
        let _ = throw_type_error("parent prototype must be an object or null")

      }
    }
    None => ()
  }
  let static_super_ctor = static_super_constructor_for_env(class_env, ctor_func)
  let instance_fields : Array[ClassFieldRecord] = []
  let static_inits : Array[ClassStaticInit] = []
  let private_instance_props : Map[String, Property] = Map::new()
  let _ = with_gc_frame(fn() raise {
    let _ = gc_root_push(Value::Function(ctor_func))
    let _ = gc_root_push(Value::Object(proto_obj))
    match static_super_ctor {
      Some(value) => {
        let _ = gc_root_push(value)

      }
      None => ()
    }
    for class_member in class_def.body {
      let mut skip_member = false
      match class_member {
        @engine.ClassMember::Method(key, _, is_static) =>
          if !is_static {
            match key {
              @engine.ObjKey::Ident(name) =>
                if name == "constructor" {
                  skip_member = true
                }
              _ => ()
            }
          }
        _ => ()
      }
      if skip_member {
        continue
      }
      let _ = with_gc_frame(fn() raise {
        match class_member {
          @engine.ClassMember::Method(key, func, is_static) =>
            match key {
              @engine.ObjKey::Private(name) => {
                let key_name = env_private_key_checked(class_env, name)
                let func_value = to_function_value(class_env, func, false)
                let func = Value::Function(func_value)
                let _ = gc_root_push(func)
                func_value.is_constructor = false
                set_function_name(
                  func_value,
                  function_name_from_key("#" + name, None, None),
                )
                if is_static {
                  func_value.super_constructor = static_super_ctor
                  func_value.home_object = Some(Value::Function(ctor_func))
                  define_private_property(
                    Value::Function(ctor_func),
                    key_name,
                    property_data_readonly(func),
                  )
                } else {
                  func_value.home_object = Some(Value::Object(proto_obj))
                  private_instance_props.set(
                    key_name,
                    property_data_readonly(func),
                  )
                }
              }
              _ => {
                let (name, key_value) = obj_key_property_name(class_env, key)
                match key_value {
                  Some(key_value_item) => {
                    let _ = gc_root_push(key_value_item)

                  }
                  None => ()
                }
                let func_value = to_function_value(class_env, func, false)
                let func = Value::Function(func_value)
                let _ = gc_root_push(func)
                func_value.is_constructor = false
                set_function_name(
                  func_value,
                  function_name_from_key(name, key_value, None),
                )
                if is_static {
                  func_value.super_constructor = static_super_ctor
                  func_value.home_object = Some(Value::Function(ctor_func))
                } else {
                  func_value.home_object = Some(Value::Object(proto_obj))
                }
                let target = if is_static {
                  Value::Function(ctor_func)
                } else {
                  Value::Object(proto_obj)
                }
                define_class_method(target, name, func_value)
              }
            }
          @engine.ClassMember::Getter(key, func, is_static) =>
            match key {
              @engine.ObjKey::Private(name) => {
                let key_name = env_private_key_checked(class_env, name)
                let func_value = to_function_value(class_env, func, false)
                let getter = Value::Function(func_value)
                let _ = gc_root_push(getter)
                func_value.is_constructor = false
                set_function_name(
                  func_value,
                  function_name_from_key("#" + name, None, Some("get ")),
                )
                if is_static {
                  func_value.super_constructor = static_super_ctor
                  func_value.home_object = Some(Value::Function(ctor_func))
                  set_accessor_property(
                    ctor_func.props,
                    key_name,
                    Some(getter),
                    None,
                  )
                } else {
                  func_value.home_object = Some(Value::Object(proto_obj))
                  set_accessor_property(
                    private_instance_props,
                    key_name,
                    Some(getter),
                    None,
                  )
                }
              }
              _ => {
                let (name, key_value) = obj_key_property_name(class_env, key)
                match key_value {
                  Some(key_value_item) => {
                    let _ = gc_root_push(key_value_item)

                  }
                  None => ()
                }
                let func_value = to_function_value(class_env, func, false)
                let getter = Value::Function(func_value)
                let _ = gc_root_push(getter)
                func_value.is_constructor = false
                set_function_name(
                  func_value,
                  function_name_from_key(name, key_value, Some("get ")),
                )
                if is_static {
                  func_value.super_constructor = static_super_ctor
                  func_value.home_object = Some(Value::Function(ctor_func))
                } else {
                  func_value.home_object = Some(Value::Object(proto_obj))
                }
                let target = if is_static {
                  Value::Function(ctor_func)
                } else {
                  Value::Object(proto_obj)
                }
                define_class_accessor(target, name, Some(getter), None)
              }
            }
          @engine.ClassMember::Setter(key, func, is_static) =>
            match key {
              @engine.ObjKey::Private(name) => {
                let key_name = env_private_key_checked(class_env, name)
                let func_value = to_function_value(class_env, func, false)
                let setter = Value::Function(func_value)
                let _ = gc_root_push(setter)
                func_value.is_constructor = false
                set_function_name(
                  func_value,
                  function_name_from_key("#" + name, None, Some("set ")),
                )
                if is_static {
                  func_value.super_constructor = static_super_ctor
                  func_value.home_object = Some(Value::Function(ctor_func))
                  set_accessor_property(
                    ctor_func.props,
                    key_name,
                    None,
                    Some(setter),
                  )
                } else {
                  func_value.home_object = Some(Value::Object(proto_obj))
                  set_accessor_property(
                    private_instance_props,
                    key_name,
                    None,
                    Some(setter),
                  )
                }
              }
              _ => {
                let (name, key_value) = obj_key_property_name(class_env, key)
                match key_value {
                  Some(key_value_item) => {
                    let _ = gc_root_push(key_value_item)

                  }
                  None => ()
                }
                let func_value = to_function_value(class_env, func, false)
                let setter = Value::Function(func_value)
                let _ = gc_root_push(setter)
                func_value.is_constructor = false
                set_function_name(
                  func_value,
                  function_name_from_key(name, key_value, Some("set ")),
                )
                if is_static {
                  func_value.super_constructor = static_super_ctor
                  func_value.home_object = Some(Value::Function(ctor_func))
                } else {
                  func_value.home_object = Some(Value::Object(proto_obj))
                }
                let target = if is_static {
                  Value::Function(ctor_func)
                } else {
                  Value::Object(proto_obj)
                }
                define_class_accessor(target, name, None, Some(setter))
              }
            }
          @engine.ClassMember::Field(key, init, is_static) =>
            match key {
              @engine.ObjKey::Private(name) => {
                let key_name = env_private_key_checked(class_env, name)
                let record = ClassFieldRecord::{
                  is_private: true,
                  name: key_name,
                  display_name: "#" + name,
                  init,
                }
                if is_static {
                  static_inits.push(ClassStaticInit::Field(record))
                } else {
                  instance_fields.push(record)
                }
              }
              _ => {
                let (name, key_value) = obj_key_property_name(class_env, key)
                match key_value {
                  Some(key_value_item) => {
                    let _ = gc_root_push(key_value_item)

                  }
                  None => ()
                }
                let record = ClassFieldRecord::{
                  is_private: false,
                  name,
                  display_name: function_name_from_key(name, key_value, None),
                  init,
                }
                if is_static {
                  static_inits.push(ClassStaticInit::Field(record))
                } else {
                  instance_fields.push(record)
                }
              }
            }
          @engine.ClassMember::StaticBlock(stmts) =>
            static_inits.push(ClassStaticInit::Block(stmts))
        }
        Undefined
      })

    }
    Undefined
  })
  match class_def.name {
    Some(name) =>
      if class_env.uninitialized_bindings.contains(name) {
        env_initialize_binding(class_env, name, Value::Function(ctor_func))
      } else {
        env_define_readonly(class_env, name, Value::Function(ctor_func), true)
      }
    None => ()
  }
  if !static_inits.is_empty() {
    for init in static_inits {
      match init {
        ClassStaticInit::Field(field) => {
          let should_set_name = match field.init {
            Some(expr) => is_anonymous_function_definition(expr)
            None => false
          }
          let value = match field.init {
            Some(expr) =>
              with_static_super_context(ctor_func, static_super_ctor, fn() raise {
                eval_class_field_initializer(field_env, expr)
              })
            None => Undefined
          }
          if should_set_name {
            set_anonymous_function_name(value, field.display_name, None)
          }
          if field.is_private {
            define_private_property(
              Value::Function(ctor_func),
              field.name,
              property_data(value),
            )
          } else {
            let desc = property_descriptor_object(property_data(value))
            let _ = define_property(
              Value::Function(ctor_func),
              prop_key_value_from_name(field.name),
              desc,
            )

          }
        }
        ClassStaticInit::Block(stmts) => {
          let block_env = Env::new(Some(field_env))
          block_env.var_env = Some(block_env)
          env_set_local(block_env, "this", Value::Function(ctor_func))
          block_env.new_target = Undefined
          hoist_decls(block_env, stmts, false, false)
          ignore(
            with_static_super_context(ctor_func, static_super_ctor, fn() raise {
              eval_block(block_env, stmts)
            }),
          )
        }
      }
    }
  }
  ctor_func.private_instance_props = private_instance_props
  ctor_func.instance_fields = instance_fields
  Value::Function(ctor_func)
}

///|
fn gen_eval_class_static_inits(
  field_env : Env,
  index : Int,
  ctor_func : FunctionValue,
  static_super_ctor : Value?,
  static_inits : Array[ClassStaticInit],
  instance_fields : Array[ClassFieldRecord],
  private_instance_props : Map[String, Property],
) -> GenStep raise {
  if index >= static_inits.length() {
    ctor_func.private_instance_props = private_instance_props
    ctor_func.instance_fields = instance_fields
    return Done(Normal(Value::Function(ctor_func)))
  }
  match static_inits[index] {
    ClassStaticInit::Field(field) => {
      let should_set_name = match field.init {
        Some(expr) => is_anonymous_function_definition(expr)
        None => false
      }
      match field.init {
        Some(expr) => {
          let step = with_static_super_context_step(
            ctor_func,
            static_super_ctor,
            fn() raise { gen_eval_class_field_initializer(field_env, expr) },
          )
          gen_bind(step, fn(control) raise {
            match control {
              Normal(value) => {
                if should_set_name {
                  set_anonymous_function_name(value, field.display_name, None)
                }
                if field.is_private {
                  define_private_property(
                    Value::Function(ctor_func),
                    field.name,
                    property_data(value),
                  )
                } else {
                  let desc = property_descriptor_object(property_data(value))
                  let _ = define_property(
                    Value::Function(ctor_func),
                    prop_key_value_from_name(field.name),
                    desc,
                  )

                }
                gen_eval_class_static_inits(
                  field_env,
                  index + 1,
                  ctor_func,
                  static_super_ctor,
                  static_inits,
                  instance_fields,
                  private_instance_props,
                )
              }
              Return(value) => Done(Return(value))
              Throw(value) => Done(Throw(value))
              Break(label, value_opt) => Done(Break(label, value_opt))
              Continue(label, value_opt) => Done(Continue(label, value_opt))
            }
          })
        }
        None => {
          let value = Undefined
          if field.is_private {
            define_private_property(
              Value::Function(ctor_func),
              field.name,
              property_data(value),
            )
          } else {
            let desc = property_descriptor_object(property_data(value))
            let _ = define_property(
              Value::Function(ctor_func),
              prop_key_value_from_name(field.name),
              desc,
            )

          }
          gen_eval_class_static_inits(
            field_env,
            index + 1,
            ctor_func,
            static_super_ctor,
            static_inits,
            instance_fields,
            private_instance_props,
          )
        }
      }
    }
    ClassStaticInit::Block(stmts) => {
      let block_env = Env::new(Some(field_env))
      block_env.var_env = Some(block_env)
      env_set_local(block_env, "this", Value::Function(ctor_func))
      block_env.new_target = Undefined
      hoist_decls(block_env, stmts, false, false)
      let step = with_static_super_context_step(ctor_func, static_super_ctor, fn() raise {
        gen_eval_block(block_env, stmts)
      })
      gen_bind(step, fn(control) raise {
        match control {
          Normal(_) =>
            gen_eval_class_static_inits(
              field_env,
              index + 1,
              ctor_func,
              static_super_ctor,
              static_inits,
              instance_fields,
              private_instance_props,
            )
          Return(value) => Done(Return(value))
          Throw(value) => Done(Throw(value))
          Break(label, value_opt) => Done(Break(label, value_opt))
          Continue(label, value_opt) => Done(Continue(label, value_opt))
        }
      })
    }
  }
}

///|
fn gen_eval_class_members(
  class_env : Env,
  field_env : Env,
  members : Array[@engine.ClassMember],
  index : Int,
  ctor_func : FunctionValue,
  proto_obj : ObjectValue,
  static_super_ctor : Value?,
  class_name : String?,
  instance_fields : Array[ClassFieldRecord],
  static_inits : Array[ClassStaticInit],
  private_instance_props : Map[String, Property],
) -> GenStep raise {
  if index >= members.length() {
    match class_name {
      Some(name) =>
        if class_env.uninitialized_bindings.contains(name) {
          env_initialize_binding(class_env, name, Value::Function(ctor_func))
        } else {
          env_define_readonly(class_env, name, Value::Function(ctor_func), true)
        }
      None => ()
    }
    return gen_eval_class_static_inits(
      field_env, 0, ctor_func, static_super_ctor, static_inits, instance_fields,
      private_instance_props,
    )
  }
  match members[index] {
    @engine.ClassMember::Method(key, func, is_static) =>
      match key {
        @engine.ObjKey::Private(name) => {
          let key_name = env_private_key_checked(class_env, name)
          let func_value = to_function_value(class_env, func, false)
          let func = Value::Function(func_value)
          let _ = gen_root_push(func)
          func_value.is_constructor = false
          set_function_name(
            func_value,
            function_name_from_key("#" + name, None, None),
          )
          if is_static {
            func_value.super_constructor = static_super_ctor
            func_value.home_object = Some(Value::Function(ctor_func))
            define_private_property(
              Value::Function(ctor_func),
              key_name,
              property_data_readonly(func),
            )
          } else {
            func_value.home_object = Some(Value::Object(proto_obj))
            private_instance_props.set(key_name, property_data_readonly(func))
          }
          gen_eval_class_members(
            class_env,
            field_env,
            members,
            index + 1,
            ctor_func,
            proto_obj,
            static_super_ctor,
            class_name,
            instance_fields,
            static_inits,
            private_instance_props,
          )
        }
        _ => {
          if !is_static {
            match key {
              @engine.ObjKey::Ident(name) =>
                if name == "constructor" {
                  return gen_eval_class_members(
                    class_env,
                    field_env,
                    members,
                    index + 1,
                    ctor_func,
                    proto_obj,
                    static_super_ctor,
                    class_name,
                    instance_fields,
                    static_inits,
                    private_instance_props,
                  )
                }
              _ => ()
            }
          }
          gen_obj_key_property_name(class_env, key, fn(name, key_value) raise {
            match key_value {
              Some(key_value_item) => {
                let _ = gen_root_push(key_value_item)

              }
              None => ()
            }
            let func_value = to_function_value(class_env, func, false)
            let func = Value::Function(func_value)
            let _ = gen_root_push(func)
            func_value.is_constructor = false
            set_function_name(
              func_value,
              function_name_from_key(name, key_value, None),
            )
            if is_static {
              func_value.super_constructor = static_super_ctor
              func_value.home_object = Some(Value::Function(ctor_func))
            } else {
              func_value.home_object = Some(Value::Object(proto_obj))
            }
            let target = if is_static {
              Value::Function(ctor_func)
            } else {
              Value::Object(proto_obj)
            }
            define_class_method(target, name, func_value)
            gen_eval_class_members(
              class_env,
              field_env,
              members,
              index + 1,
              ctor_func,
              proto_obj,
              static_super_ctor,
              class_name,
              instance_fields,
              static_inits,
              private_instance_props,
            )
          })
        }
      }
    @engine.ClassMember::Getter(key, func, is_static) =>
      match key {
        @engine.ObjKey::Private(name) => {
          let key_name = env_private_key_checked(class_env, name)
          let func_value = to_function_value(class_env, func, false)
          let getter = Value::Function(func_value)
          let _ = gen_root_push(getter)
          func_value.is_constructor = false
          set_function_name(
            func_value,
            function_name_from_key("#" + name, None, Some("get ")),
          )
          if is_static {
            func_value.super_constructor = static_super_ctor
            func_value.home_object = Some(Value::Function(ctor_func))
            set_accessor_property(ctor_func.props, key_name, Some(getter), None)
          } else {
            func_value.home_object = Some(Value::Object(proto_obj))
            set_accessor_property(
              private_instance_props,
              key_name,
              Some(getter),
              None,
            )
          }
          gen_eval_class_members(
            class_env,
            field_env,
            members,
            index + 1,
            ctor_func,
            proto_obj,
            static_super_ctor,
            class_name,
            instance_fields,
            static_inits,
            private_instance_props,
          )
        }
        _ =>
          gen_obj_key_property_name(class_env, key, fn(name, key_value) raise {
            match key_value {
              Some(key_value_item) => {
                let _ = gen_root_push(key_value_item)

              }
              None => ()
            }
            let func_value = to_function_value(class_env, func, false)
            func_value.is_constructor = false
            set_function_name(
              func_value,
              function_name_from_key(name, key_value, Some("get ")),
            )
            if is_static {
              func_value.super_constructor = static_super_ctor
              func_value.home_object = Some(Value::Function(ctor_func))
            } else {
              func_value.home_object = Some(Value::Object(proto_obj))
            }
            let target = if is_static {
              Value::Function(ctor_func)
            } else {
              Value::Object(proto_obj)
            }
            let getter = Value::Function(func_value)
            let _ = gen_root_push(getter)
            define_class_accessor(target, name, Some(getter), None)
            gen_eval_class_members(
              class_env,
              field_env,
              members,
              index + 1,
              ctor_func,
              proto_obj,
              static_super_ctor,
              class_name,
              instance_fields,
              static_inits,
              private_instance_props,
            )
          })
      }
    @engine.ClassMember::Setter(key, func, is_static) =>
      match key {
        @engine.ObjKey::Private(name) => {
          let key_name = env_private_key_checked(class_env, name)
          let func_value = to_function_value(class_env, func, false)
          let setter = Value::Function(func_value)
          let _ = gen_root_push(setter)
          func_value.is_constructor = false
          set_function_name(
            func_value,
            function_name_from_key("#" + name, None, Some("set ")),
          )
          if is_static {
            func_value.super_constructor = static_super_ctor
            func_value.home_object = Some(Value::Function(ctor_func))
            set_accessor_property(ctor_func.props, key_name, None, Some(setter))
          } else {
            func_value.home_object = Some(Value::Object(proto_obj))
            set_accessor_property(
              private_instance_props,
              key_name,
              None,
              Some(setter),
            )
          }
          gen_eval_class_members(
            class_env,
            field_env,
            members,
            index + 1,
            ctor_func,
            proto_obj,
            static_super_ctor,
            class_name,
            instance_fields,
            static_inits,
            private_instance_props,
          )
        }
        _ =>
          gen_obj_key_property_name(class_env, key, fn(name, key_value) raise {
            match key_value {
              Some(key_value_item) => {
                let _ = gen_root_push(key_value_item)

              }
              None => ()
            }
            let func_value = to_function_value(class_env, func, false)
            func_value.is_constructor = false
            set_function_name(
              func_value,
              function_name_from_key(name, key_value, Some("set ")),
            )
            if is_static {
              func_value.super_constructor = static_super_ctor
              func_value.home_object = Some(Value::Function(ctor_func))
            } else {
              func_value.home_object = Some(Value::Object(proto_obj))
            }
            let target = if is_static {
              Value::Function(ctor_func)
            } else {
              Value::Object(proto_obj)
            }
            let setter = Value::Function(func_value)
            let _ = gen_root_push(setter)
            define_class_accessor(target, name, None, Some(setter))
            gen_eval_class_members(
              class_env,
              field_env,
              members,
              index + 1,
              ctor_func,
              proto_obj,
              static_super_ctor,
              class_name,
              instance_fields,
              static_inits,
              private_instance_props,
            )
          })
      }
    @engine.ClassMember::Field(key, init, is_static) =>
      match key {
        @engine.ObjKey::Private(name) => {
          let key_name = env_private_key_checked(class_env, name)
          let record = ClassFieldRecord::{
            is_private: true,
            name: key_name,
            display_name: "#" + name,
            init,
          }
          if is_static {
            static_inits.push(ClassStaticInit::Field(record))
          } else {
            instance_fields.push(record)
          }
          gen_eval_class_members(
            class_env,
            field_env,
            members,
            index + 1,
            ctor_func,
            proto_obj,
            static_super_ctor,
            class_name,
            instance_fields,
            static_inits,
            private_instance_props,
          )
        }
        _ =>
          gen_obj_key_property_name(class_env, key, fn(name, key_value) raise {
            match key_value {
              Some(key_value_item) => {
                let _ = gen_root_push(key_value_item)

              }
              None => ()
            }
            let record = ClassFieldRecord::{
              is_private: false,
              name,
              display_name: function_name_from_key(name, key_value, None),
              init,
            }
            if is_static {
              static_inits.push(ClassStaticInit::Field(record))
            } else {
              instance_fields.push(record)
            }
            gen_eval_class_members(
              class_env,
              field_env,
              members,
              index + 1,
              ctor_func,
              proto_obj,
              static_super_ctor,
              class_name,
              instance_fields,
              static_inits,
              private_instance_props,
            )
          })
      }
    @engine.ClassMember::StaticBlock(stmts) => {
      static_inits.push(ClassStaticInit::Block(stmts))
      gen_eval_class_members(
        class_env,
        field_env,
        members,
        index + 1,
        ctor_func,
        proto_obj,
        static_super_ctor,
        class_name,
        instance_fields,
        static_inits,
        private_instance_props,
      )
    }
  }
}

///|
fn gen_eval_class(
  env : Env,
  class_def : @engine.ClassDef,
  name_hint? : String? = None,
) -> GenStep raise {
  let class_env = Env::new(Some(env))
  match class_def.name {
    Some(name) => {
      env_declare_uninitialized(class_env, name)
      class_env.readonly_bindings.set(name, true)
    }
    None => ()
  }
  let after_super = fn(super_value : Value?) -> GenStep raise {
    match super_value {
      Some(value) =>
        match value {
          Null => ()
          _ =>
            if !is_constructor_value(value) {
              let _ = throw_type_error("not a constructor")

            }
        }
      None => ()
    }
    for class_member in class_def.body {
      match class_member {
        @engine.ClassMember::Method(@engine.ObjKey::Private(name), _, _) =>
          if class_env.private_bindings.get(name) is None {
            ignore(env_define_private_name(class_env, name))
          }
        @engine.ClassMember::Getter(@engine.ObjKey::Private(name), _, _) =>
          if class_env.private_bindings.get(name) is None {
            ignore(env_define_private_name(class_env, name))
          }
        @engine.ClassMember::Setter(@engine.ObjKey::Private(name), _, _) =>
          if class_env.private_bindings.get(name) is None {
            ignore(env_define_private_name(class_env, name))
          }
        @engine.ClassMember::Field(@engine.ObjKey::Private(name), _, _) =>
          if class_env.private_bindings.get(name) is None {
            ignore(env_define_private_name(class_env, name))
          }
        _ => ()
      }
    }
    let mut constructor_def : @engine.FunctionDef? = None
    for class_member in class_def.body {
      match class_member {
        @engine.ClassMember::Method(
          @engine.ObjKey::Ident(name),
          func,
          is_static
        ) =>
          if !is_static && name == "constructor" {
            constructor_def = Some(func)
          }
        _ => ()
      }
    }
    let ctor_def = match constructor_def {
      Some(func) =>
        match class_def.name {
          Some(class_name) =>
            @engine.FunctionDef::new(
              Some(class_name),
              func.params,
              func.param_inits,
              func.body,
              true,
              func.is_generator,
              func.is_async,
              false,
              func.offset,
              func.end_offset,
            )
          None =>
            @engine.FunctionDef::new(
              None,
              func.params,
              func.param_inits,
              func.body,
              true,
              func.is_generator,
              func.is_async,
              false,
              func.offset,
              func.end_offset,
            )
        }
      None =>
        @engine.FunctionDef::new(
          class_def.name,
          ([] : Array[@engine.ParamBinding]),
          ([] : Array[@engine.Expr?]),
          ([] : Array[@engine.Stmt]),
          true,
          false,
          false,
          false,
          class_def.offset,
          class_def.end_offset,
        )
    }
    let ctor_func = to_function_value(class_env, ctor_def, false)
    ctor_func.is_class_constructor = true
    if class_def.name is None {
      match name_hint {
        Some(name) => set_function_name(ctor_func, name)
        None => ()
      }
    }
    match current_source() {
      Some(source) => {
        let end_offset = if class_def.end_offset > class_def.offset {
          class_def.end_offset
        } else {
          class_def.offset
        }
        ctor_func.source = Some(
          slice_source_range(source, class_def.offset, end_offset),
        )
      }
      None => ()
    }
    let field_env = Env::new(Some(class_env))
    env_set_local(field_env, "this", Value::Function(ctor_func))
    field_env.new_target = Undefined
    match super_value {
      Some(value) => {
        ctor_func.super_constructor = Some(value)
        match value {
          Null => ()
          _ => ctor_func.proto = Some(value)
        }
      }
      None => ()
    }
    if constructor_def is None {
      match super_value {
        Some(_) => ctor_func.is_default_constructor = true
        None => ()
      }
    }
    ensure_function_prototype(ctor_func)
    let proto_value = property_get(Value::Function(ctor_func), "prototype")
    let proto_obj = match proto_value {
      Object(obj) => obj
      _ => {
        let fresh = new_object_value()
        match fresh {
          Object(obj) => {
            ctor_func.props.set(
              "prototype",
              property_data_non_enum_non_config(fresh),
            )
            obj
          }
          _ => return Done(Normal(Value::Function(ctor_func)))
        }
      }
    }
    ctor_func.home_object = Some(Value::Object(proto_obj))
    match super_value {
      Some(Null) => proto_obj.proto = None
      Some(value) => {
        let base_proto_value = property_get(value, "prototype")
        if is_object_like(base_proto_value) {
          proto_obj.proto = Some(base_proto_value)
        } else if base_proto_value is Null {
          proto_obj.proto = None
        } else {
          let _ = throw_type_error("parent prototype must be an object or null")

        }
      }
      None => ()
    }
    let static_super_ctor = static_super_constructor_for_env(
      class_env, ctor_func,
    )
    let instance_fields : Array[ClassFieldRecord] = []
    let static_inits : Array[ClassStaticInit] = []
    let private_instance_props : Map[String, Property] = Map::new()
    gen_with_root_frame(fn() raise {
      let _ = gen_root_push(Value::Function(ctor_func))
      let _ = gen_root_push(Value::Object(proto_obj))
      match static_super_ctor {
        Some(value) => {
          let _ = gen_root_push(value)

        }
        None => ()
      }
      gen_eval_class_members(
        class_env,
        field_env,
        class_def.body,
        0,
        ctor_func,
        proto_obj,
        static_super_ctor,
        class_def.name,
        instance_fields,
        static_inits,
        private_instance_props,
      )
    })
  }
  match class_def.super_class {
    Some(expr) =>
      gen_eval_expr_cont(class_env, expr, fn(value) raise {
        after_super(Some(value))
      })
    None => after_super(None)
  }
}

///|
fn eval_array_literal(env : Env, elems : Array[@engine.Expr?]) -> Value raise {
  with_gc_frame(fn() raise {
    let values : Array[Value?] = []
    for elem in elems {
      match elem {
        Some(@engine.Expr::Spread(inner)) => {
          let spread_value = eval_expr(env, inner)
          let _ = gc_root_push(spread_value)
          for value in build_spread_list(spread_value) {
            values.push(Some(value))
            let _ = gc_root_push(value)

          }
        }
        Some(expr) => {
          let value = eval_expr(env, expr)
          values.push(Some(value))
          let _ = gc_root_push(value)

        }
        None => values.push(None)
      }
    }
    let array_proto_value = match value_from_object(array_proto_for_env(env)) {
      Some(value) => Some(value)
      None => value_from_object(array_proto())
    }
    new_array_value_with_proto(values, proto=array_proto_value)
  })
}

///|
fn resolve_super_base() -> Value raise {
  match current_super_function() {
    Some(func) =>
      match func.home_object {
        Some(home) =>
          match get_proto_of_value(home) {
            Some(base) => base
            None => Null
          }
        None =>
          match func.super_constructor {
            Some(value) => value
            None => throw_reference_error("super is not defined")
          }
      }
    None => throw_reference_error("super is not defined")
  }
}

///|
fn super_base_and_receiver(env : Env) -> (Value, Value) raise {
  let receiver = env_get(env, "this")
  let base = resolve_super_base()
  (base, receiver)
}

///|
fn super_set_property(
  env : Env,
  base : Value,
  receiver : Value,
  name : String,
  value : Value,
) -> Unit raise {
  let ok = match base {
    Object(obj) =>
      set_property_with_proto(
        obj.props,
        obj.proto,
        name,
        value,
        receiver,
        obj.extensible,
      )
    Function(func) =>
      set_property_with_proto(
        func.props,
        func.proto,
        name,
        value,
        receiver,
        func.extensible,
      )
    BoundFunction(bound) =>
      set_property_with_proto(
        bound.props,
        bound.proto,
        name,
        value,
        receiver,
        bound.extensible,
      )
    Builtin(builtin) =>
      set_property_with_proto(
        builtin.props,
        builtin.proto,
        name,
        value,
        receiver,
        builtin.extensible,
      )
    _ => false
  }
  if !ok && env.strict {
    let _ = throw_type_error("cannot set property")

  }
}

///|
fn eval_super_member(env : Env, key : @engine.MemberKey) -> Value raise {
  match key {
    @engine.MemberKey::Private(_) =>
      return throw_syntax_error("private class field forbidden after super")
    _ => ()
  }
  let (base, receiver) = super_base_and_receiver(env)
  let name = member_key_name(env, key)
  let base_obj = to_object(base)
  property_get_with_receiver(base_obj, name, receiver)
}

///|
fn eval_super_member_call(
  env : Env,
  key : @engine.MemberKey,
  args : Array[@engine.Expr],
) -> Value raise {
  match key {
    @engine.MemberKey::Private(_) =>
      return throw_syntax_error("private class field forbidden after super")
    _ => ()
  }
  let (base, receiver) = super_base_and_receiver(env)
  let name = member_key_name(env, key)
  let base_obj = to_object(base)
  let callee = property_get_with_receiver(base_obj, name, receiver)
  let argv = eval_args(env, args)
  call_value_with_this(callee, argv, receiver)
}

///|
fn eval_super_call(env : Env, args : Array[@engine.Expr]) -> Value raise {
  let super_ctor = match current_super_function() {
    Some(func) =>
      if func.is_class_constructor && func.super_constructor is Some(_) {
        match get_proto_of_value(Value::Function(func)) {
          Some(value) => value
          None => Null
        }
      } else {
        match func.super_constructor {
          Some(value) => value
          None => throw_reference_error("super is not defined")
        }
      }
    None => throw_reference_error("super is not defined")
  }
  let argv = eval_args(env, args)
  if !is_constructor_value(super_ctor) {
    return throw_not_constructor(super_ctor)
  }
  let super_env = find_this_env(env)
  let already_initialized = !super_env.this_uninitialized
  let result = call_constructor(
    super_ctor,
    argv,
    new_target=super_env.new_target,
  )
  if already_initialized {
    let _ = throw_reference_error("this is already initialized")

  }
  env_set_local(super_env, "this", result)
  if super_env.this_uninitialized {
    super_env.this_uninitialized = false
    match current_super_function() {
      Some(func) => init_instance_fields(func, super_env, result)
      None => ()
    }
  }
  result
}

///|
fn eval_member(
  env : Env,
  obj_expr : @engine.Expr,
  key : @engine.MemberKey,
) -> Value raise {
  with_gc_frame(fn() raise {
    match key {
      @engine.MemberKey::Private(name) => {
        let target = eval_expr(env, obj_expr)
        let _ = gc_root_push(target)
        let key_name = env_private_key_checked(env, name)
        private_property_get(target, key_name, name)
      }
      _ => {
        let target_value = eval_expr(env, obj_expr)
        let _ = gc_root_push(target_value)
        let target_obj = to_object(target_value)
        let name = member_key_name(env, key)
        property_get_with_receiver(target_obj, name, target_value)
      }
    }
  })
}

///|
fn eval_optional_chain_with_this(
  env : Env,
  base : @engine.Expr,
  segments : Array[@engine.ChainSegment],
) -> (Value, Value?) raise {
  fn eval_optional_chain_base_with_this(
    env : Env,
    base : @engine.Expr,
  ) -> (Value, Value?) raise {
    match unwrap_paren(base) {
      @engine.Expr::Member(obj_expr, key, offset) =>
        match obj_expr {
          Super => {
            let value = with_expr_pos(offset, fn() raise {
              eval_super_member(env, key)
            })
            (value, Some(env_get(env, "this")))
          }
          _ => {
            let target = eval_expr(env, obj_expr)
            let base_depth = gc_root_depth()
            let _ = gc_root_push(target)
            let value = with_expr_pos(offset, fn() raise {
              match key {
                @engine.MemberKey::Private(name) => {
                  let key_name = env_private_key_checked(env, name)
                  private_property_get(target, key_name, name)
                }
                _ => {
                  let name = member_key_name(env, key)
                  let target_obj = to_object(target)
                  property_get_with_receiver(target_obj, name, target)
                }
              }
            })
            gc_root_pop_to(base_depth)
            (value, Some(target))
          }
        }
      @engine.Expr::OptionalChain(inner_base, inner_segments) =>
        eval_optional_chain_with_this(env, inner_base, inner_segments)
      _ => (eval_expr(env, base), None)
    }
  }

  with_gc_frame_pair(fn() raise {
    let (base_value, base_this) = eval_optional_chain_base_with_this(env, base)
    let mut current = base_value
    let mut this_value : Value? = base_this
    for segment in segments {
      let base_depth = gc_root_depth()
      let _ = gc_root_push(current)
      match this_value {
        Some(this_obj) => {
          let _ = gc_root_push(this_obj)

        }
        None => ()
      }
      match segment {
        @engine.ChainSegment::Member(key, optional, offset) => {
          if optional && is_nullish(current) {
            gc_root_pop_to(base_depth)
            return (Undefined, None)
          }
          let next = with_expr_pos(offset, fn() raise {
            match key {
              @engine.MemberKey::Private(name) => {
                let key_name = env_private_key_checked(env, name)
                private_property_get(current, key_name, name)
              }
              _ => {
                let name = member_key_name(env, key)
                let target = to_object(current)
                property_get_with_receiver(target, name, current)
              }
            }
          })
          this_value = Some(current)
          current = next
        }
        @engine.ChainSegment::Call(args, optional, offset) => {
          if optional && is_nullish(current) {
            gc_root_pop_to(base_depth)
            return (Undefined, None)
          }
          let argv = eval_args(env, args)
          for value in argv {
            let _ = gc_root_push(value)

          }
          let result = with_expr_pos(offset, fn() raise {
            match this_value {
              Some(this_obj) => call_value_with_this(current, argv, this_obj)
              None => call_value(current, argv)
            }
          })
          current = result
          this_value = None
        }
      }
      gc_root_pop_to(base_depth)
    }
    (current, this_value)
  })
}

///|
fn eval_optional_chain(
  env : Env,
  base : @engine.Expr,
  segments : Array[@engine.ChainSegment],
) -> Value raise {
  let (value, _) = eval_optional_chain_with_this(env, base, segments)
  value
}

///|
fn property_key_name(value : Value) -> String raise {
  let prim = if is_object_like(value) {
    to_primitive(value, true)
  } else {
    value
  }
  match symbol_from_value(prim) {
    Some(symbol) => symbol_prop_key(symbol)
    None => to_string_strict(prim)
  }
}

///|
fn member_key_name(env : Env, key : @engine.MemberKey) -> String raise {
  match key {
    @engine.MemberKey::Ident(name) => name
    @engine.MemberKey::Private(name) => env_private_key_checked(env, name)
    @engine.MemberKey::Computed(expr) => property_key_name(eval_expr(env, expr))
  }
}

///|
fn string_property_get(value : String, name : String) -> Value raise {
  if name == "length" {
    return Number(Double::from_int(value.length()))
  }
  match parse_array_index(name) {
    Some(index) =>
      if index >= 0 && index < value.length() {
        return String(value.unsafe_substring(start=index, end=index + 1))
      }
    None => ()
  }
  match string_proto() {
    Some(proto) =>
      property_get_from_chain(proto.props, proto.proto, name, String(value))
    None => Undefined
  }
}

///|
fn string_object_get(
  obj : ObjectValue,
  name : String,
  receiver : Value,
) -> Value raise {
  match obj.string_data {
    Some(value) => {
      if name == "length" {
        return Number(Double::from_int(value.length()))
      }
      match parse_array_index(name) {
        Some(index) =>
          if index >= 0 && index < value.length() {
            return String(value.unsafe_substring(start=index, end=index + 1))
          }
        None => ()
      }
      property_get_from_chain(obj.props, obj.proto, name, receiver)
    }
    None => property_get_from_chain(obj.props, obj.proto, name, receiver)
  }
}

///|
fn number_property_get(value : Double, name : String) -> Value raise {
  match number_proto() {
    Some(proto) =>
      property_get_from_chain(proto.props, proto.proto, name, Number(value))
    None => Undefined
  }
}

///|
fn bigint_property_get(value : @bigint.BigInt, name : String) -> Value raise {
  match bigint_proto() {
    Some(proto) =>
      property_get_from_chain(proto.props, proto.proto, name, BigInt(value))
    None => Undefined
  }
}

///|
fn property_get_with_receiver(
  target : Value,
  name : String,
  receiver : Value,
) -> Value raise {
  match target {
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => proxy_get_value(data, name, receiver)
        None => string_object_get(obj, name, receiver)
      }
    Function(func) => function_property_get_with_receiver(func, name, receiver)
    BoundFunction(bound) =>
      property_get_from_chain(bound.props, bound.proto, name, receiver)
    Builtin(builtin) =>
      property_get_from_chain(builtin.props, builtin.proto, name, receiver)
    Array(arr) => array_get_with_receiver(arr, name, receiver)
    Arguments(args) => arguments_get_with_receiver(args, name, receiver)
    String(value) => string_property_get(value, name)
    Number(value) => number_property_get(value, name)
    BigInt(value) => bigint_property_get(value, name)
    _ => Undefined
  }
}

///|
fn property_get(target : Value, name : String) -> Value raise {
  property_get_with_receiver(target, name, target)
}

///|
fn proxy_get_value(
  data : ProxyData,
  name : String,
  receiver : Value,
) -> Value raise {
  proxy_check_revoked(data)
  let handler = data.handler
  let target = data.target
  let trap = property_get(handler, "get")
  match trap {
    Undefined | Null => property_get_with_receiver(target, name, receiver)
    _ => {
      if !is_callable(trap) {
        let _ = throw_type_error("get is not callable")
        return Undefined
      }
      let key_value = match symbol_from_prop_key(name) {
        Some(symbol) => Symbol(symbol)
        None => String(name)
      }
      let result = call_value_with_this(
        trap,
        [target, key_value, receiver],
        handler,
      )
      let desc = get_own_property_descriptor(target, name)
      match desc {
        Undefined => result
        _ =>
          if !is_object_like(desc) {
            let _ = throw_type_error("invalid property descriptor")
            Undefined
          } else {
            let configurable = is_truthy(property_get(desc, "configurable"))
            if !configurable {
              let is_data = has_property(desc, "value") ||
                has_property(desc, "writable")
              if is_data {
                let writable = is_truthy(property_get(desc, "writable"))
                if !writable {
                  let expected = property_get(desc, "value")
                  if !same_value(expected, result) {
                    let _ = throw_type_error("proxy: inconsistent get")
                    return Undefined
                  }
                }
              } else {
                let getter = property_get(desc, "get")
                if getter is Undefined && !(result is Undefined) {
                  let _ = throw_type_error("proxy: inconsistent get")
                  return Undefined
                }
              }
            }
            result
          }
      }
    }
  }
}

///|
fn proxy_apply_value(
  data : ProxyData,
  this_arg : Value,
  args : Array[Value],
) -> Value raise {
  proxy_check_revoked(data)
  let handler = data.handler
  let target = data.target
  let trap = property_get(handler, "apply")
  match trap {
    Undefined | Null => call_value_with_this(target, args, this_arg)
    _ => {
      if !is_callable(trap) {
        return throw_type_error("apply is not callable")
      }
      let arg_values : Array[Value?] = []
      for value in args {
        arg_values.push(Some(value))
      }
      let args_array = new_array_value(arg_values)
      call_value_with_this(trap, [target, this_arg, args_array], handler)
    }
  }
}

///|
fn proxy_construct_value(
  data : ProxyData,
  args : Array[Value],
  new_target : Value,
) -> Value raise {
  proxy_check_revoked(data)
  let handler = data.handler
  let target = data.target
  let trap = property_get(handler, "construct")
  match trap {
    Undefined | Null => call_constructor(target, args, new_target~)
    _ => {
      if !is_callable(trap) {
        return throw_type_error("construct is not callable")
      }
      let arg_values : Array[Value?] = []
      for value in args {
        arg_values.push(Some(value))
      }
      let args_array = new_array_value(arg_values)
      let result = call_value_with_this(
        trap,
        [target, args_array, new_target],
        handler,
      )
      if is_object_like(result) {
        result
      } else {
        throw_type_error("proxy construct returned non-object")
      }
    }
  }
}

///|
fn proxy_has_value(data : ProxyData, name : String) -> Bool raise {
  proxy_check_revoked(data)
  let handler = data.handler
  let target = data.target
  let trap = property_get(handler, "has")
  match trap {
    Undefined | Null => has_property_value(target, name)
    _ => {
      if !is_callable(trap) {
        let _ = throw_type_error("has is not callable")
        return false
      }
      let key_value = prop_key_value_from_name(name)
      let result = call_value_with_this(trap, [target, key_value], handler)
      let ok = is_truthy(result)
      if !ok {
        let desc = get_own_property_descriptor(target, name)
        match desc {
          Undefined => ()
          _ =>
            if !is_object_like(desc) {
              let _ = throw_type_error("invalid property descriptor")
              return false
            } else {
              let configurable = is_truthy(property_get(desc, "configurable"))
              if !configurable || !is_extensible_value_checked(target) {
                let _ = throw_type_error("proxy: inconsistent has")
                return false
              }
            }
        }
      }
      ok
    }
  }
}

///|
fn proxy_set_value(
  data : ProxyData,
  name : String,
  value : Value,
  receiver : Value,
  throw_flag : Bool,
) -> Bool raise {
  proxy_check_revoked(data)
  let handler = data.handler
  let target = data.target
  let trap = property_get(handler, "set")
  match trap {
    Undefined | Null => set_value_with_receiver(target, name, value, receiver)
    _ => {
      if !is_callable(trap) {
        let _ = throw_type_error("set is not callable")
        return false
      }
      let key_value = prop_key_value_from_name(name)
      let result = call_value_with_this(
        trap,
        [target, key_value, value, receiver],
        handler,
      )
      let ok = is_truthy(result)
      if ok {
        let desc = get_own_property_descriptor(target, name)
        match desc {
          Undefined => ()
          _ =>
            if !is_object_like(desc) {
              let _ = throw_type_error("invalid property descriptor")
              return false
            } else {
              let configurable = is_truthy(property_get(desc, "configurable"))
              if !configurable {
                if descriptor_is_data(desc) {
                  let writable = is_truthy(property_get(desc, "writable"))
                  if !writable {
                    let expected = property_get(desc, "value")
                    if !same_value(expected, value) {
                      let _ = throw_type_error("proxy: inconsistent set")
                      return false
                    }
                  }
                } else {
                  let setter = property_get(desc, "set")
                  if setter is Undefined {
                    let _ = throw_type_error("proxy: inconsistent set")
                    return false
                  }
                }
              }
            }
        }
      } else if throw_flag {
        let _ = throw_type_error("proxy: cannot set property")
        return false
      }
      ok
    }
  }
}

///|
fn proxy_define_property(
  data : ProxyData,
  name : String,
  desc_info : PropertyDescInfo,
  throw_flag : Bool,
) -> Bool raise {
  proxy_check_revoked(data)
  let handler = data.handler
  let target = data.target
  let trap = property_get(handler, "defineProperty")
  let desc_is_data = desc_info.has_value || desc_info.has_writable
  let desc_is_accessor = desc_info.has_get || desc_info.has_set
  match trap {
    Undefined | Null =>
      define_property_value(
        target,
        prop_key_value_from_name(name),
        property_descriptor_object_from_info(desc_info),
        throw_flag,
      )
    _ => {
      if !is_callable(trap) {
        let _ = throw_type_error("defineProperty is not callable")
        return false
      }
      let key_value = prop_key_value_from_name(name)
      let desc_obj = property_descriptor_object_from_info(desc_info)
      let result = call_value_with_this(
        trap,
        [target, key_value, desc_obj],
        handler,
      )
      let ok = is_truthy(result)
      if !ok {
        if throw_flag {
          let _ = throw_type_error("proxy: defineProperty exception")

        }
        return false
      }
      let target_desc = get_own_property_descriptor(target, name)
      match target_desc {
        Undefined => {
          if !is_extensible_value_checked(target) {
            let _ = throw_type_error("proxy: inconsistent defineProperty")
            return false
          }
          if desc_info.has_configurable && !desc_info.configurable {
            let _ = throw_type_error("proxy: inconsistent defineProperty")
            return false
          }
        }
        _ =>
          if !is_object_like(target_desc) {
            let _ = throw_type_error("invalid property descriptor")
            return false
          } else {
            let target_configurable = is_truthy(
              property_get(target_desc, "configurable"),
            )
            if !target_configurable {
              if desc_info.has_configurable && desc_info.configurable {
                let _ = throw_type_error("proxy: inconsistent defineProperty")
                return false
              }
              if desc_info.has_enumerable &&
                desc_info.enumerable !=
                is_truthy(property_get(target_desc, "enumerable")) {
                let _ = throw_type_error("proxy: inconsistent defineProperty")
                return false
              }
              let target_is_data = descriptor_is_data(target_desc)
              let target_is_accessor = descriptor_is_accessor(target_desc)
              if (desc_is_data || desc_is_accessor) &&
                (
                  desc_is_data != target_is_data ||
                  desc_is_accessor != target_is_accessor
                ) {
                let _ = throw_type_error("proxy: inconsistent defineProperty")
                return false
              }
              if target_is_data {
                let target_writable = is_truthy(
                  property_get(target_desc, "writable"),
                )
                if !target_writable {
                  if desc_info.has_writable && desc_info.writable {
                    let _ = throw_type_error(
                      "proxy: inconsistent defineProperty",
                    )
                    return false
                  }
                  if desc_info.has_value &&
                    !same_value(
                      desc_info.value,
                      property_get(target_desc, "value"),
                    ) {
                    let _ = throw_type_error(
                      "proxy: inconsistent defineProperty",
                    )
                    return false
                  }
                } else if desc_info.has_writable && !desc_info.writable {
                  let _ = throw_type_error("proxy: inconsistent defineProperty")
                  return false
                }
              } else {
                if desc_info.has_get &&
                  !same_value(
                    desc_info.getter,
                    property_get(target_desc, "get"),
                  ) {
                  let _ = throw_type_error("proxy: inconsistent defineProperty")
                  return false
                }
                if desc_info.has_set &&
                  !same_value(
                    desc_info.setter,
                    property_get(target_desc, "set"),
                  ) {
                  let _ = throw_type_error("proxy: inconsistent defineProperty")
                  return false
                }
              }
            } else if desc_info.has_configurable && !desc_info.configurable {
              let _ = throw_type_error("proxy: inconsistent defineProperty")
              return false
            }
          }
      }
      ok
    }
  }
}

///|
fn proxy_delete_property(data : ProxyData, name : String) -> Bool raise {
  proxy_check_revoked(data)
  let handler = data.handler
  let target = data.target
  let trap = property_get(handler, "deleteProperty")
  match trap {
    Undefined | Null => delete_property_value(target, name)
    _ => {
      if !is_callable(trap) {
        let _ = throw_type_error("deleteProperty is not callable")
        return false
      }
      let key_value = prop_key_value_from_name(name)
      let result = call_value_with_this(trap, [target, key_value], handler)
      let ok = is_truthy(result)
      if ok {
        let desc = get_own_property_descriptor(target, name)
        match desc {
          Undefined => ()
          _ =>
            if !is_object_like(desc) {
              let _ = throw_type_error("invalid property descriptor")
              return false
            } else {
              let configurable = is_truthy(property_get(desc, "configurable"))
              if !configurable || !is_extensible_value_checked(target) {
                let _ = throw_type_error("proxy: inconsistent deleteProperty")
                return false
              }
            }
        }
      }
      ok
    }
  }
}

///|
fn proxy_is_extensible(data : ProxyData) -> Bool raise {
  proxy_check_revoked(data)
  let handler = data.handler
  let target = data.target
  let trap = property_get(handler, "isExtensible")
  match trap {
    Undefined | Null => is_extensible_value_checked(target)
    _ => {
      if !is_callable(trap) {
        let _ = throw_type_error("isExtensible is not callable")
        return false
      }
      let result = call_value_with_this(trap, [target], handler)
      let ok = is_truthy(result)
      let target_ext = is_extensible_value_checked(target)
      if ok != target_ext {
        let _ = throw_type_error("proxy: inconsistent isExtensible")
        return false
      }
      ok
    }
  }
}

///|
fn proxy_prevent_extensions(data : ProxyData) -> Bool raise {
  proxy_check_revoked(data)
  let handler = data.handler
  let target = data.target
  let trap = property_get(handler, "preventExtensions")
  match trap {
    Undefined | Null => prevent_extensions_value(target)
    _ => {
      if !is_callable(trap) {
        let _ = throw_type_error("preventExtensions is not callable")
        return false
      }
      let result = call_value_with_this(trap, [target], handler)
      let ok = is_truthy(result)
      if ok && is_extensible_value_checked(target) {
        let _ = throw_type_error("proxy: inconsistent preventExtensions")
        return false
      }
      ok
    }
  }
}

///|
fn proxy_get_prototype(data : ProxyData) -> Value? raise {
  proxy_check_revoked(data)
  let handler = data.handler
  let target = data.target
  let trap = property_get(handler, "getPrototypeOf")
  match trap {
    Undefined | Null => get_proto_of_value_checked(target)
    _ => {
      if !is_callable(trap) {
        let _ = throw_type_error("getPrototypeOf is not callable")
        return None
      }
      let result = call_value_with_this(trap, [target], handler)
      let proto_value = match result {
        Null => None
        _ =>
          if is_object_like(result) {
            Some(result)
          } else {
            let _ = throw_type_error("proxy: inconsistent prototype")
            return None
          }
      }
      if !is_extensible_value_checked(target) {
        let target_proto = get_proto_of_value_checked(target)
        let target_value = match target_proto {
          Some(value) => value
          None => Null
        }
        let result_value = match proto_value {
          Some(value) => value
          None => Null
        }
        if !same_value(result_value, target_value) {
          let _ = throw_type_error("proxy: inconsistent prototype")
          return None
        }
      }
      proto_value
    }
  }
}

///|
fn proxy_set_prototype(
  data : ProxyData,
  proto : Value?,
  throw_flag : Bool,
) -> Bool raise {
  proxy_check_revoked(data)
  let handler = data.handler
  let target = data.target
  let proto_value = match proto {
    Some(value) => value
    None => Null
  }
  let trap = property_get(handler, "setPrototypeOf")
  match trap {
    Undefined | Null => set_proto_of_value(target, proto, throw_flag)
    _ => {
      if !is_callable(trap) {
        let _ = throw_type_error("setPrototypeOf is not callable")
        return false
      }
      let result = call_value_with_this(trap, [target, proto_value], handler)
      let ok = is_truthy(result)
      if !ok {
        if throw_flag {
          let _ = throw_type_error("proxy: cannot set prototype")

        }
        return false
      }
      if !is_extensible_value_checked(target) {
        let target_proto = get_proto_of_value_checked(target)
        let target_value = match target_proto {
          Some(value) => value
          None => Null
        }
        if !same_value(proto_value, target_value) {
          let _ = throw_type_error("proxy: inconsistent prototype")
          return false
        }
      }
      true
    }
  }
}

///|
fn proto_for_value(target : Value) -> Value? {
  match target {
    Object(obj) => obj.proto
    Function(func) => func.proto
    BoundFunction(bound) => bound.proto
    Builtin(builtin) => builtin.proto
    Array(arr) => arr.proto
    Arguments(args) => args.proto
    _ => None
  }
}

///|
fn property_get_raw(target : Value, name : String) -> Value raise {
  match props_map_for_value(target) {
    Some(props) =>
      property_get_from_chain_raw(props, proto_for_value(target), name, target)
    None => property_get(target, name)
  }
}

///|
fn array_length_from_props(arr : ArrayValue) -> Int64 {
  match arr.props.get("length") {
    Some(prop) =>
      match prop.value {
        Number(num) =>
          if Double::is_nan(num) || Double::is_inf(num) {
            0L
          } else {
            let trunc = Double::trunc(num)
            if trunc <= 0.0 {
              0L
            } else if trunc > Int64::to_double(max_array_length) {
              max_array_length
            } else {
              Double::to_int64(trunc)
            }
          }
        _ => Int64::from_int(arr.elements.length())
      }
    None => Int64::from_int(arr.elements.length())
  }
}

///|
fn array_length_value_from_props(
  arr : ArrayValue,
  receiver : Value,
) -> Value raise {
  match property_get_from_props(arr.props, "length", receiver) {
    Some(value) => value
    None => Number(Double::from_int(arr.elements.length()))
  }
}

///|
fn array_get_with_receiver(
  arr : ArrayValue,
  name : String,
  receiver : Value,
) -> Value raise {
  match arr.typed_array_data {
    Some(data) =>
      return typed_array_get_with_receiver(arr, data, name, receiver)
    None => ()
  }
  if name == "length" {
    return array_length_value_from_props(arr, receiver)
  }
  match parse_array_index(name) {
    Some(index) =>
      if index >= 0 {
        if index < arr.elements.length() {
          match property_get_from_props(arr.props, name, receiver) {
            Some(value) => return value
            None => ()
          }
          match arr.elements[index] {
            Some(value) => return value
            None => ()
          }
        } else {
          match property_get_from_props(arr.props, name, receiver) {
            Some(value) => return value
            None => ()
          }
        }
        match arr.proto {
          Some(proto) =>
            return property_get_with_receiver(proto, name, receiver)
          None => return Undefined
        }
      } else {
        return Undefined
      }
    None => {
      match property_get_from_props(arr.props, name, receiver) {
        Some(value) => return value
        None => ()
      }
      match arr.proto {
        Some(proto) => return property_get_with_receiver(proto, name, receiver)
        None => return Undefined
      }
    }
  }
  Undefined
}

///|
fn typed_array_get_with_receiver(
  arr : ArrayValue,
  data : TypedArrayData,
  name : String,
  receiver : Value,
) -> Value raise {
  match canonical_numeric_index_string(name) {
    Some(index) =>
      if typed_array_is_valid_integer_index(data, index) {
        typed_array_get_index(data, Double::to_int(index))
      } else {
        Undefined
      }
    None => {
      match property_get_from_props(arr.props, name, receiver) {
        Some(value) => return value
        None => ()
      }
      match arr.proto {
        Some(proto) => property_get_with_receiver(proto, name, receiver)
        None => Undefined
      }
    }
  }
}

///|
fn arguments_has_index(args : ArgumentsValue, index : Int) -> Bool {
  if index < 0 {
    return false
  }
  let name = Int::to_string(index)
  if args.props.contains(name) {
    return true
  }
  if index >= args.elements.length() {
    return false
  }
  if index < args.mapped.length() && args.mapped[index] {
    return true
  }
  args.elements[index] is Some(_)
}

///|
fn arguments_index_value(args : ArgumentsValue, index : Int) -> Value {
  if index < 0 || index >= args.elements.length() {
    return Undefined
  }
  if index < args.mapped.length() &&
    index < args.params.length() &&
    args.mapped[index] {
    let name = args.params[index]
    match args.env.bindings.get(name) {
      Some(value) => return value
      None => return Undefined
    }
  }
  let name = Int::to_string(index)
  match args.props.get(name) {
    Some(prop) => prop.value
    None =>
      match args.elements[index] {
        Some(value) => value
        None => Undefined
      }
  }
}

///|
fn arguments_get_with_receiver(
  args : ArgumentsValue,
  name : String,
  receiver : Value,
) -> Value raise {
  match parse_array_index(name) {
    Some(index) =>
      if index >= 0 {
        if index < args.elements.length() {
          if index < args.mapped.length() &&
            index < args.params.length() &&
            args.mapped[index] {
            let param_name = args.params[index]
            match args.env.bindings.get(param_name) {
              Some(value) => return value
              None => return Undefined
            }
          }
          match property_get_from_props(args.props, name, receiver) {
            Some(value) => return value
            None => ()
          }
          match args.elements[index] {
            Some(value) => return value
            None => ()
          }
        }
        match property_get_from_props(args.props, name, receiver) {
          Some(value) => return value
          None => ()
        }
      }
    None => ()
  }
  match property_get_from_props(args.props, name, receiver) {
    Some(value) => value
    None =>
      match args.proto {
        Some(proto) => property_get_with_receiver(proto, name, receiver)
        None => Undefined
      }
  }
}

///|
fn property_get_from_props(
  props : Map[String, Property],
  name : String,
  receiver : Value,
) -> Value? raise {
  match property_get_from_props_raw(props, name, receiver) {
    Some(value) => Some(module_binding_deref(value))
    None => None
  }
}

///|
fn property_get_from_props_raw(
  props : Map[String, Property],
  name : String,
  receiver : Value,
) -> Value? raise {
  match props.get(name) {
    Some(prop) =>
      Some(
        match prop.getter {
          Some(getter) =>
            match getter {
              Undefined | Null => Undefined
              _ => call_value_with_this(getter, [], receiver)
            }
          None => prop.value
        },
      )
    None => None
  }
}

///|
fn property_get_from_chain(
  props : Map[String, Property],
  proto : Value?,
  name : String,
  receiver : Value,
) -> Value raise {
  match property_get_from_props(props, name, receiver) {
    Some(value) => value
    None =>
      match proto {
        Some(parent) => property_get_with_receiver(parent, name, receiver)
        None => Undefined
      }
  }
}

///|
fn define_private_property(
  target : Value,
  key : String,
  prop : Property,
) -> Unit raise {
  match props_map_for_value(target) {
    Some(props) =>
      if props.contains(key) {
        let _ = throw_type_error("private class field already exists")

      } else {
        props.set(key, prop)
      }
    None => {
      let _ = throw_type_error("invalid private access")

    }
  }
}

///|
fn private_property_get(
  target : Value,
  key : String,
  name : String,
) -> Value raise {
  match props_map_for_value(target) {
    Some(props) =>
      match props.get(key) {
        Some(prop) =>
          if prop.getter is Some(_) || prop.setter is Some(_) {
            match prop.getter {
              Some(getter) =>
                match getter {
                  Undefined | Null =>
                    throw_type_error(
                      "private class field '#" +
                      name +
                      "' does not have a getter",
                    )
                  _ => call_value_with_this(getter, [], target)
                }
              None =>
                throw_type_error(
                  "private class field '#" + name + "' does not have a getter",
                )
            }
          } else {
            module_binding_deref(prop.value)
          }
        None =>
          throw_type_error("private class field '#" + name + "' does not exist")
      }
    None =>
      throw_type_error("private class field '#" + name + "' does not exist")
  }
}

///|
fn private_property_set(
  target : Value,
  key : String,
  name : String,
  value : Value,
) -> Unit raise {
  match props_map_for_value(target) {
    Some(props) =>
      match props.get(key) {
        Some(prop) =>
          if prop.getter is Some(_) || prop.setter is Some(_) {
            match prop.setter {
              Some(setter) =>
                match setter {
                  Undefined | Null => {
                    let _ = throw_type_error(
                      "private class field '#" + name + "' is not writable",
                    )

                  }
                  _ => {
                    let _ = call_value_with_this(setter, [value], target)

                  }
                }
              None => {
                let _ = throw_type_error(
                  "private class field '#" + name + "' is not writable",
                )

              }
            }
          } else if prop.writable {
            props.set(key, Property::{
              value,
              writable: prop.writable,
              configurable: prop.configurable,
              enumerable: prop.enumerable,
              getter: prop.getter,
              setter: prop.setter,
            })
          } else {
            let _ = throw_type_error(
              "private class field '#" + name + "' is not writable",
            )

          }
        None => {
          let _ = throw_type_error(
            "private class field '#" + name + "' does not exist",
          )

        }
      }
    None => {
      let _ = throw_type_error(
        "private class field '#" + name + "' does not exist",
      )

    }
  }
}

///|
fn property_get_from_chain_raw(
  props : Map[String, Property],
  proto : Value?,
  name : String,
  receiver : Value,
) -> Value raise {
  match property_get_from_props_raw(props, name, receiver) {
    Some(value) => value
    None =>
      match proto {
        Some(parent) =>
          match props_map_for_value(parent) {
            Some(parent_props) =>
              property_get_from_chain_raw(
                parent_props,
                proto_for_value(parent),
                name,
                receiver,
              )
            None => Undefined
          }
        None => Undefined
      }
  }
}

///|
fn primitive_proto(value : Value) -> Value? {
  let env = current_env()
  match value {
    String(_) =>
      match env {
        Some(env) =>
          match value_from_object(string_proto_for_env(env)) {
            Some(value) => Some(value)
            None => value_from_object(string_proto())
          }
        None => value_from_object(string_proto())
      }
    Number(_) =>
      match env {
        Some(env) =>
          match value_from_object(number_proto_for_env(env)) {
            Some(value) => Some(value)
            None => value_from_object(number_proto())
          }
        None => value_from_object(number_proto())
      }
    Bool(_) =>
      match env {
        Some(env) =>
          match value_from_object(bool_proto_for_env(env)) {
            Some(value) => Some(value)
            None => value_from_object(bool_proto())
          }
        None => value_from_object(bool_proto())
      }
    BigInt(_) =>
      match env {
        Some(env) =>
          match value_from_object(bigint_proto_for_env(env)) {
            Some(value) => Some(value)
            None => value_from_object(bigint_proto())
          }
        None => value_from_object(bigint_proto())
      }
    Symbol(_) =>
      match env {
        Some(env) =>
          match value_from_object(symbol_proto_for_env(env)) {
            Some(value) => Some(value)
            None => value_from_object(symbol_proto())
          }
        None => value_from_object(symbol_proto())
      }
    _ => None
  }
}

///|
fn set_property_for_value(
  target : Value,
  name : String,
  value : Value,
  strict : Bool,
) -> Value raise {
  if is_object_like(target) {
    let _ = property_set(target, name, value, strict)
    return value
  }
  match target {
    Null | Undefined => {
      let _ = throw_type_error("cannot set property")
      value
    }
    _ => {
      let ok = match primitive_proto(target) {
        Some(proto) => set_value_with_receiver(proto, name, value, target)
        None => false
      }
      if !ok && strict {
        let _ = throw_type_error("cannot set property")

      }
      value
    }
  }
}

///|
fn property_set(
  target : Value,
  name : String,
  value : Value,
  strict : Bool,
) -> Value raise {
  match target {
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => {
          let ok = proxy_set_value(data, name, value, target, false)
          if !ok && strict {
            return throw_type_error("proxy: cannot set property")
          }
          return value
        }
        None => ()
      }
    _ => ()
  }
  let ok = match target {
    Object(obj) =>
      if is_array_proto_object(obj) {
        array_proto_set(obj, name, value)
      } else {
        match obj.string_data {
          Some(string_value) =>
            if name == "length" {
              false
            } else {
              match parse_array_index(name) {
                Some(index) =>
                  if index >= 0 && index < string_value.length() {
                    false
                  } else {
                    set_property_with_proto(
                      obj.props,
                      obj.proto,
                      name,
                      value,
                      target,
                      obj.extensible,
                    )
                  }
                None =>
                  set_property_with_proto(
                    obj.props,
                    obj.proto,
                    name,
                    value,
                    target,
                    obj.extensible,
                  )
              }
            }
          None =>
            set_property_with_proto(
              obj.props,
              obj.proto,
              name,
              value,
              target,
              obj.extensible,
            )
        }
      }
    Function(func) => {
      if name == "prototype" && !func.props.contains(name) {
        ensure_function_prototype(func)
      }
      set_property_with_proto(
        func.props,
        func.proto,
        name,
        value,
        Value::Function(func),
        func.extensible,
      )
    }
    BoundFunction(bound) =>
      set_property_with_proto(
        bound.props,
        bound.proto,
        name,
        value,
        Value::BoundFunction(bound),
        bound.extensible,
      )
    Builtin(builtin) =>
      set_property_with_proto(
        builtin.props,
        builtin.proto,
        name,
        value,
        Value::Builtin(builtin),
        builtin.extensible,
      )
    Array(arr) => array_set(arr, name, value)
    Arguments(args) => arguments_set(args, name, value)
    _ => false
  }
  if !ok && strict {
    return throw_type_error("cannot set property")
  }
  value
}

///|
fn set_value_with_receiver(
  target : Value,
  name : String,
  value : Value,
  receiver : Value,
) -> Bool raise {
  if !is_object_like(target) {
    return false
  }
  match target {
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => return proxy_set_value(data, name, value, receiver, false)
        None => ()
      }
    _ => ()
  }
  match target {
    Object(obj) if obj.is_module_namespace => return false
    _ => ()
  }
  match target {
    Array(arr) =>
      match arr.typed_array_data {
        Some(data) =>
          match canonical_numeric_index_string(name) {
            Some(index) =>
              if same_value(target, receiver) {
                integer_indexed_element_set(data, index, value)
                return true
              } else if !typed_array_is_valid_integer_index(data, index) {
                return true
              }
            None => ()
          }
        None => ()
      }
    _ => ()
  }
  let desc = get_own_property_descriptor(target, name)
  match desc {
    Undefined =>
      match get_proto_of_value(target) {
        Some(proto) => set_value_with_receiver(proto, name, value, receiver)
        None =>
          if !is_object_like(receiver) {
            false
          } else {
            let (receiver_desc, receiver_info) = get_own_property_descriptor_with_info(
              receiver, name,
            )
            match receiver_desc {
              Undefined =>
                if !is_extensible_value(receiver) {
                  false
                } else {
                  let desc_obj = property_descriptor_object(
                    property_data(value),
                  )
                  define_property_value(
                    receiver,
                    prop_key_value_from_name(name),
                    desc_obj,
                    false,
                  )
                }
              _ =>
                if !is_object_like(receiver_desc) {
                  let _ = throw_type_error("invalid property descriptor")
                  false
                } else {
                  let info = match receiver_info {
                    Some(info) => info
                    None => to_property_desc_info(receiver_desc)
                  }
                  if info.has_get || info.has_set {
                    false
                  } else {
                    let receiver_writable = if info.has_writable {
                      info.writable
                    } else {
                      false
                    }
                    if !receiver_writable {
                      false
                    } else {
                      let desc_obj = new_object_value()
                      match desc_obj {
                        Object(obj) =>
                          obj.props.set("value", property_data(value))
                        _ => ()
                      }
                      define_property_value(
                        receiver,
                        prop_key_value_from_name(name),
                        desc_obj,
                        false,
                      )
                    }
                  }
                }
            }
          }
      }
    _ =>
      if !is_object_like(desc) {
        let _ = throw_type_error("invalid property descriptor")
        false
      } else if descriptor_is_data(desc) {
        let writable = is_truthy(property_get(desc, "writable"))
        if !writable {
          return false
        }
        if !is_object_like(receiver) {
          return false
        }
        let (receiver_desc, receiver_info) = get_own_property_descriptor_with_info(
          receiver, name,
        )
        match receiver_desc {
          Undefined =>
            if !is_extensible_value(receiver) {
              false
            } else {
              let desc_obj = property_descriptor_object(property_data(value))
              define_property_value(
                receiver,
                prop_key_value_from_name(name),
                desc_obj,
                false,
              )
            }
          _ =>
            if !is_object_like(receiver_desc) {
              let _ = throw_type_error("invalid property descriptor")
              false
            } else {
              let info = match receiver_info {
                Some(info) => info
                None => to_property_desc_info(receiver_desc)
              }
              if info.has_get || info.has_set {
                false
              } else {
                let receiver_writable = if info.has_writable {
                  info.writable
                } else {
                  false
                }
                if !receiver_writable {
                  false
                } else {
                  let desc_obj = new_object_value()
                  match desc_obj {
                    Object(obj) => obj.props.set("value", property_data(value))
                    _ => ()
                  }
                  define_property_value(
                    receiver,
                    prop_key_value_from_name(name),
                    desc_obj,
                    false,
                  )
                }
              }
            }
        }
      } else {
        let setter = property_get(desc, "set")
        if setter is Undefined {
          false
        } else {
          let _ = call_value_with_this(setter, [value], receiver)
          true
        }
      }
  }
}

///|
fn array_set_length_int64(
  arr : ArrayValue,
  target_len : Int64,
  allow_nonwritable_equal : Bool,
) -> Bool {
  let current_len = array_length_from_props(arr)
  match arr.props.get("length") {
    Some(prop) =>
      if !prop.writable {
        if allow_nonwritable_equal && target_len == current_len {
          return true
        }
        return false
      }
    None => ()
  }
  if target_len >= current_len {
    let max_dense_len = 2147483647
    if target_len <= Int64::from_int(max_dense_len) {
      let target_int = Int64::to_int(target_len)
      while arr.elements.length() < target_int {
        arr.elements.push(None)
      }
    }
    set_length_prop(arr.props, Number(Int64::to_double(target_len)))
    return true
  }
  let mut final_len = target_len
  for key, prop in arr.props {
    match array_index_from_name(key) {
      Some(index) =>
        if index >= target_len && !prop.configurable {
          let blocked_len = index + 1L
          if blocked_len > final_len {
            final_len = blocked_len
          }
        }
      None => ()
    }
  }
  let to_remove : Array[String] = []
  for key, prop in arr.props {
    match array_index_from_name(key) {
      Some(index) =>
        if index >= final_len && prop.configurable {
          to_remove.push(key)
        }
      None => ()
    }
  }
  for key in to_remove {
    arr.props.remove(key)
  }
  if final_len <= Int64::from_int(arr.elements.length()) {
    let final_int = Int64::to_int(final_len)
    arr.elements.truncate(final_int)
  }
  set_length_prop(arr.props, Number(Int64::to_double(final_len)))
  final_len == target_len
}

///|
fn array_set_sparse(
  arr : ArrayValue,
  name : String,
  value : Value,
  receiver : Value,
  index64 : Int64,
) -> Bool raise {
  if arr.props.contains(name) {
    return set_property_in(arr.props, name, value, receiver)
  }
  match arr.proto {
    Some(proto) => return set_value_with_receiver(proto, name, value, receiver)
    None => ()
  }
  if !arr.extensible {
    return false
  }
  let _ = set_property_in(arr.props, name, value, receiver)
  let current_len = array_length_from_props(arr)
  let next_len = index64 + 1L
  if next_len > current_len {
    set_length_prop(arr.props, Number(Int64::to_double(next_len)))
  }
  true
}

///|
fn array_set(arr : ArrayValue, name : String, value : Value) -> Bool raise {
  match arr.typed_array_data {
    Some(data) => return typed_array_set(arr, data, name, value)
    None => ()
  }
  let receiver = Array(arr)
  if name == "length" {
    let new_len_uint = to_uint32(to_number(value))
    let number_len = to_number(value)
    let new_len_num = UInt::to_double(new_len_uint)
    if Double::is_nan(number_len) || new_len_num != number_len {
      let _ = throw_range_error("invalid array length")
      return false
    }
    let target_len = Double::to_int64(new_len_num)
    return array_set_length_int64(arr, target_len, false)
  }
  match array_index_from_name(name) {
    Some(index64) => {
      if index64 < 0L {
        return false
      }
      let current_len = array_length_from_props(arr)
      match arr.props.get("length") {
        Some(prop) =>
          if !prop.writable && index64 >= current_len {
            return false
          }
        None => ()
      }
      let max_dense_index = 2147483646
      if index64 <= Int64::from_int(max_dense_index) {
        let index = Int64::to_int(index64)
        let elements_len = arr.elements.length()
        if index > elements_len {
          return array_set_sparse(arr, name, value, receiver, index64)
        }
        let mut has_existing = arr.props.contains(name)
        if !has_existing && index < elements_len {
          has_existing = match arr.elements[index] {
            Some(_) => true
            None => false
          }
        }
        if has_existing {
          if arr.props.contains(name) {
            return set_property_in(arr.props, name, value, receiver)
          }
          if index < arr.elements.length() {
            arr.elements[index] = Some(value)
          }
          let current_len = array_length_from_props(arr)
          let elem_len = Int64::from_int(arr.elements.length())
          let new_len = if elem_len > current_len {
            elem_len
          } else {
            current_len
          }
          set_length_prop(arr.props, Number(Int64::to_double(new_len)))
          return true
        }
        match arr.proto {
          Some(proto) =>
            return set_value_with_receiver(proto, name, value, receiver)
          None => ()
        }
        if !arr.extensible {
          return false
        }
        while arr.elements.length() < index {
          arr.elements.push(None)
        }
        if index == arr.elements.length() {
          arr.elements.push(Some(value))
        } else {
          arr.elements[index] = Some(value)
        }
        let current_len = array_length_from_props(arr)
        let elem_len = Int64::from_int(arr.elements.length())
        let new_len = if elem_len > current_len {
          elem_len
        } else {
          current_len
        }
        set_length_prop(arr.props, Number(Int64::to_double(new_len)))
        true
      } else {
        array_set_sparse(arr, name, value, receiver, index64)
      }
    }
    None =>
      set_property_with_proto(
        arr.props,
        arr.proto,
        name,
        value,
        receiver,
        arr.extensible,
      )
  }
}

///|
fn set_length_prop(props : Map[String, Property], value : Value) -> Unit {
  match props.get("length") {
    Some(prop) =>
      props.set("length", Property::{
        value,
        writable: prop.writable,
        configurable: false,
        enumerable: false,
        getter: None,
        setter: None,
      })
    None => props.set("length", property_data_non_enum_non_config(value))
  }
}

///|
fn array_proto_length(obj : ObjectValue) -> Int {
  match obj.props.get("length") {
    Some(prop) =>
      match prop.value {
        Number(num) => Int64::to_int(Double::to_int64(Double::trunc(num)))
        _ => 0
      }
    None => 0
  }
}

///|
fn array_proto_set_length(obj : ObjectValue, value : Value) -> Bool raise {
  match obj.props.get("length") {
    Some(prop) => if !prop.writable { return false }
    None => ()
  }
  let new_len = to_number(value)
  if Double::is_nan(new_len) || new_len < 0.0 {
    return false
  }
  let len = Double::to_int64(Double::trunc(new_len))
  if len < 0L {
    return false
  }
  let target = Int64::to_int(len)
  let current_len = array_proto_length(obj)
  if target < current_len {
    let mut i = current_len - 1
    while i >= target {
      let index_name = Int::to_string(i)
      match obj.props.get(index_name) {
        Some(prop) =>
          if !prop.configurable {
            let final_len = i + 1
            set_length_prop(obj.props, Number(Double::from_int(final_len)))
            return false
          } else {
            obj.props.remove(index_name)
          }
        None => ()
      }
      if i == 0 {
        break
      }
      i = i - 1
    }
  }
  set_length_prop(obj.props, Number(Double::from_int(target)))
  true
}

///|
fn array_proto_set(
  obj : ObjectValue,
  name : String,
  value : Value,
) -> Bool raise {
  let receiver = Object(obj)
  if name == "length" {
    return array_proto_set_length(obj, value)
  }
  match parse_array_index(name) {
    Some(index) => {
      if index < 0 {
        return false
      }
      let has_existing = obj.props.contains(name)
      if !has_existing && !obj.extensible {
        return false
      }
      if obj.props.contains(name) {
        return set_property_in(obj.props, name, value, receiver)
      }
      match get_property_in_chain(obj.proto, name) {
        Some(desc) =>
          if descriptor_is_accessor(desc) {
            match property_get(desc, "set") {
              Undefined | Null => return false
              setter => {
                let _ = call_value_with_this(setter, [value], receiver)
                return true
              }
            }
          } else {
            let writable = is_truthy(property_get(desc, "writable"))
            if !writable {
              return false
            }
          }
        None => ()
      }
      let current_len = array_proto_length(obj)
      match obj.props.get("length") {
        Some(prop) => if !prop.writable && index >= current_len { return false }
        None => ()
      }
      let _ = set_property_in(obj.props, name, value, receiver)
      if index >= current_len {
        set_length_prop(obj.props, Number(Double::from_int(index + 1)))
      }
      true
    }
    None =>
      set_property_with_proto(
        obj.props,
        obj.proto,
        name,
        value,
        receiver,
        obj.extensible,
      )
  }
}

///|
fn arguments_set(
  args : ArgumentsValue,
  name : String,
  value : Value,
) -> Bool raise {
  let receiver = Arguments(args)
  if name == "length" || name == "callee" {
    return set_property_in(args.props, name, value, receiver)
  }
  match parse_array_index(name) {
    Some(index) => {
      if index < 0 {
        return false
      }
      if !args.extensible && !arguments_has_index(args, index) {
        return false
      }
      if args.props.contains(name) &&
        !(index < args.mapped.length() && args.mapped[index]) {
        return set_property_in(args.props, name, value, receiver)
      }
      arguments_set_index(args, index, value)
    }
    None =>
      if args.extensible || args.props.contains(name) {
        set_property_in(args.props, name, value, receiver)
      } else {
        false
      }
  }
}

///|
fn arguments_set_index(
  args : ArgumentsValue,
  index : Int,
  value : Value,
) -> Bool raise {
  if index < 0 {
    return false
  }
  let len = args.elements.length()
  if index < len {
    if index < args.mapped.length() &&
      index < args.params.length() &&
      args.mapped[index] {
      env_set_local(args.env, args.params[index], value)
    }
    args.elements[index] = Some(value)
    true
  } else {
    set_property_in(args.props, Int::to_string(index), value, Arguments(args))
  }
}

///|
fn array_to_string(arr : ArrayValue) -> String {
  array_join(arr, ",")
}

///|
fn array_join(arr : ArrayValue, sep : String) -> String {
  match arr.typed_array_data {
    Some(data) => return typed_array_join(data, sep)
    None => ()
  }
  let parts : Array[String] = []
  let len = arr.elements.length()
  for i = 0; i < len; i = i + 1 {
    let name = Int::to_string(i)
    let mut value_opt : Value? = None
    match arr.props.get(name) {
      Some(prop) => value_opt = Some(prop.value)
      None => ()
    }
    match value_opt {
      Some(value) =>
        match value {
          Undefined => parts.push("")
          Null => parts.push("")
          _ => parts.push(to_string_value(value))
        }
      None =>
        match arr.elements[i] {
          None => parts.push("")
          Some(value) =>
            match value {
              Undefined => parts.push("")
              Null => parts.push("")
              _ => parts.push(to_string_value(value))
            }
        }
    }
  }
  parts.join(sep)
}

///|
fn array_join_value(target : Value, sep_value : Value?) -> String raise {
  let obj = to_object(target)
  let len = array_like_length_int64(obj)
  let sep = match sep_value {
    None => ","
    Some(Undefined) => ","
    Some(value) => to_string_strict(value)
  }
  if len <= 0L {
    return ""
  }
  let sb = StringBuilder::new()
  let mut i = 0L
  while i < len {
    if i > 0L {
      sb.write_string(sep)
    }
    let name = Int64::to_string(i)
    let value = property_get(obj, name)
    match value {
      Undefined => ()
      Null => ()
      _ => sb.write_string(to_string_strict(value))
    }
    i = i + 1L
  }
  sb.to_string()
}

///|
fn value_to_locale_string(value : Value) -> String raise {
  match value {
    Undefined => to_string_strict(value)
    Null => to_string_strict(value)
    _ => {
      let obj = to_object(value)
      let locale_method = property_get_with_receiver(
        obj, "toLocaleString", value,
      )
      if !is_callable(locale_method) {
        let _ = throw_type_error("not a function")

      }
      let result = call_value_with_this(locale_method, [], value)
      to_string_strict(result)
    }
  }
}

///|
fn array_to_locale_string_value(target : Value) -> String raise {
  let obj = to_object(target)
  let len = array_like_length_int64(obj)
  if len <= 0L {
    return ""
  }
  let sb = StringBuilder::new()
  let mut i = 0L
  while i < len {
    if i > 0L {
      sb.write_string(",")
    }
    let name = Int64::to_string(i)
    let value = property_get(obj, name)
    match value {
      Undefined => ()
      Null => ()
      _ => sb.write_string(value_to_locale_string(value))
    }
    i = i + 1L
  }
  sb.to_string()
}

///|
fn typed_array_join(data : TypedArrayData, sep : String) -> String {
  let parts : Array[String] = []
  let len = typed_array_effective_length(data)
  let mut i = 0
  while i < len {
    let value = typed_array_get_index(data, i)
    match value {
      Undefined => parts.push("")
      Null => parts.push("")
      _ => parts.push(to_string_value(value))
    }
    i = i + 1
  }
  parts.join(sep)
}

///|
fn parse_array_index(name : String) -> Int? {
  if name.is_empty() {
    return None
  }
  let mut first = true
  for ch in name {
    if ch < '0' || ch > '9' {
      return None
    }
    if first {
      if ch == '0' && name.length() > 1 {
        return None
      }
      first = false
    }
  }
  try @strconv.parse_int64(name, base=10) catch {
    _ => None
  } noraise {
    value => {
      let max_int = 2147483647
      if value < 0L || value > Int64::from_int(max_int) {
        None
      } else {
        Some(Int64::to_int(value))
      }
    }
  }
}

///|
fn canonical_numeric_index_string(name : String) -> Double? {
  if name == "-0" {
    return Some(negative_zero())
  }
  let num = string_to_number(name)
  let text = number_to_string_radix(num, 10)
  if text == name {
    Some(num)
  } else {
    None
  }
}

///|
fn array_index_from_name(name : String) -> Int64? {
  try @strconv.parse_int64(name, base=10) catch {
    _ => None
  } noraise {
    value =>
      if value >= 0L &&
        value <= max_array_index &&
        Int64::to_string(value) == name {
        Some(value)
      } else {
        None
      }
  }
}

///|
priv enum ArrayIterKind {
  ForEach
  Map
  Filter
  Every
  SomeMatch
}

///|
priv enum ArrayFindKind {
  Find
  FindIndex
  FindLast
  FindLastIndex
}

///|
fn array_like_length(value : Value) -> Int raise {
  let len64 = array_like_length_int64(value)
  let max_int = 2147483647
  if len64 > Int64::from_int(max_int) {
    max_int
  } else {
    Int64::to_int(len64)
  }
}

///|
fn array_like_length_int64(value : Value) -> Int64 raise {
  let len_value = property_get(value, "length")
  let len_num = to_number(len_value)
  if Double::is_nan(len_num) || len_num <= 0.0 {
    return 0L
  }
  if Double::is_inf(len_num) {
    return 9007199254740991L
  }
  let trunc = Double::trunc(len_num)
  if trunc <= 0.0 {
    return 0L
  }
  if trunc >= 9007199254740991.0 {
    return 9007199254740991L
  }
  Double::to_int64(trunc)
}

///|
fn array_species_create(obj : Value, len : Int) -> Value raise {
  if !is_array_value(obj) {
    let array_proto_value = match current_env() {
      Some(env) =>
        match value_from_object(array_proto_for_env(env)) {
          Some(value) => Some(value)
          None => value_from_object(array_proto())
        }
      None => value_from_object(array_proto())
    }
    return new_array_value_with_proto(
      Array::make(len, None),
      proto=array_proto_value,
    )
  }
  let ctor = property_get(obj, "constructor")
  let mut species = ctor
  if is_constructor_value(ctor) {
    match (current_env(), function_realm_env(ctor)) {
      (Some(current), Some(realm)) =>
        if current.id != realm.id {
          let realm_array = property_get(global_object_value(realm), "Array")
          if same_value(ctor, realm_array) {
            species = Undefined
          }
        }
      _ => ()
    }
  }
  if is_object_like(species) {
    match symbol_species_key() {
      Some(key) => {
        let next = property_get(species, key)
        species = match next {
          Null => Undefined
          _ => next
        }
      }
      None => ()
    }
  }
  if species is Undefined {
    let array_proto_value = match current_env() {
      Some(env) =>
        match value_from_object(array_proto_for_env(env)) {
          Some(value) => Some(value)
          None => value_from_object(array_proto())
        }
      None => value_from_object(array_proto())
    }
    return new_array_value_with_proto(
      Array::make(len, None),
      proto=array_proto_value,
    )
  }
  call_constructor(species, [Number(Double::from_int(len))])
}

///|
fn array_species_create64(obj : Value, len : Int64) -> Value raise {
  let max_int = 2147483647
  if !is_array_value(obj) {
    if len > Int64::from_int(max_int) {
      return throw_range_error("invalid array length")
    }
    let array_proto_value = match current_env() {
      Some(env) =>
        match value_from_object(array_proto_for_env(env)) {
          Some(value) => Some(value)
          None => value_from_object(array_proto())
        }
      None => value_from_object(array_proto())
    }
    return new_array_value_with_proto(
      Array::make(Int64::to_int(len), None),
      proto=array_proto_value,
    )
  }
  let ctor = property_get(obj, "constructor")
  let mut species = ctor
  if is_constructor_value(ctor) {
    match (current_env(), function_realm_env(ctor)) {
      (Some(current), Some(realm)) =>
        if current.id != realm.id {
          let realm_array = property_get(global_object_value(realm), "Array")
          if same_value(ctor, realm_array) {
            species = Undefined
          }
        }
      _ => ()
    }
  }
  if is_object_like(species) {
    match symbol_species_key() {
      Some(key) => {
        let next = property_get(species, key)
        species = match next {
          Null => Undefined
          _ => next
        }
      }
      None => ()
    }
  }
  if species is Undefined {
    if len > Int64::from_int(max_int) {
      return throw_range_error("invalid array length")
    }
    let array_proto_value = match current_env() {
      Some(env) =>
        match value_from_object(array_proto_for_env(env)) {
          Some(value) => Some(value)
          None => value_from_object(array_proto())
        }
      None => value_from_object(array_proto())
    }
    return new_array_value_with_proto(
      Array::make(Int64::to_int(len), None),
      proto=array_proto_value,
    )
  }
  call_constructor(species, [Number(Int64::to_double(len))])
}

///|
fn typed_array_species_constructor(
  obj : Value,
  kind : TypedArrayKind,
) -> Value raise {
  let ctor = property_get(obj, "constructor")
  let mut species = ctor
  if is_object_like(species) {
    match symbol_species_key() {
      Some(key) => {
        let next = property_get(species, key)
        species = match next {
          Null => Undefined
          _ => next
        }
      }
      None => ()
    }
  }
  if species is Undefined {
    match
      typed_array_ctor_for_kind_env(function_realm_env_checked(ctor), kind) {
      Some(value) => return value
      None => return ctor
    }
  }
  if !is_constructor_value(species) {
    let _ = throw_type_error("not a constructor")

  }
  species
}

///|
fn typed_array_species_create64(
  obj : Value,
  kind : TypedArrayKind,
  len : Int64,
) -> Value raise {
  let max_int = 2147483647
  if len > Int64::from_int(max_int) {
    return throw_range_error("invalid typed array length")
  }
  let ctor = typed_array_species_constructor(obj, kind)
  let result = call_constructor(ctor, [Number(Int64::to_double(len))])
  let (_, data) = require_typed_array(Some(result))
  let new_len = typed_array_effective_length(data)
  if new_len < Int64::to_int(len) {
    return throw_type_error("TypedArray length is too small")
  }
  result
}

///|
fn typed_array_create_from_constructor(
  ctor : Value,
  len : Int64,
) -> Value raise {
  let max_int = 2147483647
  if len < 0L || len > Int64::from_int(max_int) {
    return throw_range_error("invalid typed array length")
  }
  let result = call_constructor(ctor, [Number(Int64::to_double(len))])
  let (_, data) = require_typed_array_checked(Some(result))
  let new_len = typed_array_effective_length(data)
  if new_len < Int64::to_int(len) {
    return throw_type_error("TypedArray length is too small")
  }
  result
}

///|
fn is_concat_spreadable(value : Value) -> Bool raise {
  if is_object_like(value) {
    match symbol_is_concat_spreadable_key() {
      Some(key) =>
        match property_get(value, key) {
          Undefined => ()
          spread => return is_truthy(spread)
        }
      None => ()
    }
  }
  is_array_value(value)
}

///|
fn array_iterate(
  obj : Value,
  callback : Value,
  this_arg : Value,
  kind : ArrayIterKind,
) -> Value raise {
  let len = array_like_length_int64(obj)
  if !is_callable(callback) {
    return throw_type_error("not a function")
  }
  let result = match kind {
    ArrayIterKind::Map => array_species_create64(obj, len)
    ArrayIterKind::Filter => array_species_create64(obj, 0L)
    _ => Undefined
  }
  let mut out_index = 0L
  let mut k = 0L
  while k < len {
    let key = Int64::to_string(k)
    if has_property_value(obj, key) {
      let value = property_get(obj, key)
      let res = call_value_with_this(
        callback,
        [value, Number(Int64::to_double(k)), obj],
        this_arg,
      )
      match kind {
        ArrayIterKind::ForEach => ()
        ArrayIterKind::Map => create_data_property_or_throw(result, key, res)
        ArrayIterKind::Filter =>
          if is_truthy(res) {
            create_data_property_or_throw(
              result,
              Int64::to_string(out_index),
              value,
            )
            out_index = out_index + 1
          }
        ArrayIterKind::Every => if !is_truthy(res) { return Bool(false) }
        ArrayIterKind::SomeMatch => if is_truthy(res) { return Bool(true) }
      }
    }
    k = k + 1
  }
  match kind {
    ArrayIterKind::Every => Bool(true)
    ArrayIterKind::SomeMatch => Bool(false)
    _ => result
  }
}

///|
fn array_reduce_impl(
  obj : Value,
  callback : Value,
  initial : Value?,
  from_right : Bool,
) -> Value raise {
  let len = array_like_length_int64(obj)
  if !is_callable(callback) {
    return throw_type_error("not a function")
  }
  let mut k = 0L
  let mut acc : Value? = initial
  if acc is None {
    for {
      if k >= len {
        return throw_type_error("Reduce of empty array with no initial value")
      }
      let k1 = if from_right { len - k - 1L } else { k }
      k = k + 1L
      let key = Int64::to_string(k1)
      if has_property_value(obj, key) {
        acc = Some(property_get(obj, key))
        break
      }
    }
  }
  let mut current = match acc {
    Some(value) => value
    None => Undefined
  }
  while k < len {
    let k1 = if from_right { len - k - 1L } else { k }
    let key = Int64::to_string(k1)
    if has_property_value(obj, key) {
      let value = property_get(obj, key)
      current = call_value_with_this(
        callback,
        [current, value, Number(Int64::to_double(k1)), obj],
        Undefined,
      )
    }
    k = k + 1L
  }
  current
}

///|
fn array_index_of_value(this_value : Value, args : Array[Value]) -> Value raise {
  let obj = to_object(this_value)
  let len = array_like_length_int64(obj)
  if len <= 0L {
    return Number(-1.0)
  }
  let search = if args.is_empty() { Undefined } else { args[0] }
  let mut from_index = 0L
  if args.length() > 1 {
    from_index = to_int64_clamp64(args[1], 0L, len, len)
  }
  if from_index >= len {
    return Number(-1.0)
  }
  let mut k = from_index
  while k < len {
    let name = Int64::to_string(k)
    if has_property_value(obj, name) {
      let value = property_get(obj, name)
      if strict_eq(value, search) {
        return Number(Int64::to_double(k))
      }
    }
    k = k + 1
  }
  Number(-1.0)
}

///|
fn array_last_index_of_value(
  this_value : Value,
  args : Array[Value],
) -> Value raise {
  let obj = to_object(this_value)
  let len = array_like_length_int64(obj)
  if len <= 0L {
    return Number(-1.0)
  }
  let search = if args.is_empty() { Undefined } else { args[0] }
  let mut from_index = len - 1L
  if args.length() > 1 {
    from_index = to_int64_clamp64(args[1], -1L, len - 1L, len)
  }
  if from_index < 0 {
    return Number(-1.0)
  }
  let mut k = from_index
  while k >= 0 {
    let name = Int64::to_string(k)
    if has_property_value(obj, name) {
      let value = property_get(obj, name)
      if strict_eq(value, search) {
        return Number(Int64::to_double(k))
      }
    }
    if k == 0 {
      break
    }
    k = k - 1
  }
  Number(-1.0)
}

///|
fn array_includes_value(this_value : Value, args : Array[Value]) -> Value raise {
  let obj = to_object(this_value)
  let len = array_like_length_int64(obj)
  if len <= 0L {
    return Bool(false)
  }
  let search = if args.is_empty() { Undefined } else { args[0] }
  let mut from_index = 0L
  if args.length() > 1 {
    from_index = to_int64_clamp64(args[1], 0L, len, len)
  }
  if from_index >= len {
    return Bool(false)
  }
  let mut k = from_index
  while k < len {
    let value = property_get(obj, Int64::to_string(k))
    if same_value_zero(value, search) {
      return Bool(true)
    }
    k = k + 1
  }
  Bool(false)
}

///|
fn array_find_value(
  this_value : Value,
  args : Array[Value],
  kind : ArrayFindKind,
) -> Value raise {
  let obj = to_object(this_value)
  let len = array_like_length_int64(obj)
  let callback = if args.is_empty() { Undefined } else { args[0] }
  if !is_callable(callback) {
    return throw_type_error("not a function")
  }
  let this_arg = if args.length() > 1 { args[1] } else { Undefined }
  let mut k = 0L
  let mut end = len
  let mut dir = 1L
  let mut is_last = false
  match kind {
    ArrayFindKind::FindLast | ArrayFindKind::FindLastIndex => is_last = true
    _ => ()
  }
  if is_last {
    k = len - 1
    end = -1L
    dir = -1L
  }
  while k != end {
    let value = property_get(obj, Int64::to_string(k))
    let result = call_value_with_this(
      callback,
      [value, Number(Int64::to_double(k)), this_value],
      this_arg,
    )
    if is_truthy(result) {
      return match kind {
        ArrayFindKind::FindIndex | ArrayFindKind::FindLastIndex =>
          Number(Int64::to_double(k))
        _ => value
      }
    }
    k = k + dir
  }
  match kind {
    ArrayFindKind::FindIndex | ArrayFindKind::FindLastIndex => Number(-1.0)
    _ => Undefined
  }
}

///|
fn typed_array_get_length_value(this_value : Value?) -> Value raise {
  let (_, data) = require_typed_array(this_value)
  Number(Double::from_int(typed_array_effective_length(data)))
}

///|
fn typed_array_get_buffer_value(this_value : Value?) -> Value raise {
  let (_, data) = require_typed_array(this_value)
  Object(data.buffer)
}

///|
fn typed_array_get_byte_length_value(this_value : Value?) -> Value raise {
  let (_, data) = require_typed_array(this_value)
  if typed_array_is_oob(data) {
    Number(0.0)
  } else {
    Number(Double::from_int(typed_array_effective_byte_length(data)))
  }
}

///|
fn typed_array_get_byte_offset_value(this_value : Value?) -> Value raise {
  let (_, data) = require_typed_array(this_value)
  if typed_array_is_oob(data) {
    Number(0.0)
  } else {
    Number(Double::from_int(data.byte_offset))
  }
}

///|
fn typed_array_get_to_string_tag_value(this_value : Value?) -> Value {
  match this_value {
    Some(value) =>
      match typed_array_kind_from_value(value) {
        Some(kind) => String(typed_array_constructor_name(kind))
        None => Undefined
      }
    None => Undefined
  }
}

///|
fn to_int64_sat_value(value : Value) -> Int64 raise {
  let num = to_number(value)
  let max_i64 = 9223372036854775807L
  let min_i64 = -9223372036854775807L - 1L
  if Double::is_nan(num) {
    return 0L
  }
  if Double::is_inf(num) {
    return if num < 0.0 { min_i64 } else { max_i64 }
  }
  let trunc = Double::trunc(num)
  if trunc > 9223372036854775807.0 {
    return max_i64
  }
  if trunc < -9223372036854775808.0 {
    return min_i64
  }
  Double::to_int64(trunc)
}

///|
fn typed_array_set_index_or_throw(
  target : Value,
  index : Int,
  value : Value,
) -> Unit raise {
  let _ = property_set(target, Int::to_string(index), value, true)

}

///|
fn typed_array_values_value(this_value : Value) -> Value raise {
  let (arr, _) = require_typed_array_checked(Some(this_value))
  new_array_iterator(Array(arr), 1)
}

///|
fn typed_array_keys_value(this_value : Value) -> Value raise {
  let (arr, _) = require_typed_array_checked(Some(this_value))
  new_array_iterator(Array(arr), 0)
}

///|
fn typed_array_entries_value(this_value : Value) -> Value raise {
  let (arr, _) = require_typed_array_checked(Some(this_value))
  new_array_iterator(Array(arr), 2)
}

///|
fn typed_array_at_value(this_value : Value, args : Array[Value]) -> Value raise {
  let (_, data) = require_typed_array_checked(Some(this_value))
  let len = typed_array_effective_length(data)
  let index = if args.is_empty() { 0 } else { to_int32_sat(to_number(args[0])) }
  let mut actual = index
  if actual < 0 {
    actual = len + actual
  }
  if actual < 0 || actual >= len {
    Undefined
  } else {
    typed_array_get_index(data, actual)
  }
}

///|
fn typed_array_with_value(
  this_value : Value,
  args : Array[Value],
) -> Value raise {
  let (_, data) = require_typed_array_checked(Some(this_value))
  let len64 = Int64::from_int(typed_array_effective_length(data))
  let max_int = 2147483647
  if len64 > Int64::from_int(max_int) {
    return throw_range_error("invalid typed array length")
  }
  let len = Int64::to_int(len64)
  let index_value = if args.is_empty() { Undefined } else { args[0] }
  let mut idx64 = to_int64_sat_value(index_value)
  if idx64 < 0L {
    idx64 = len64 + idx64
  }
  let replacement_value = if args.length() > 1 { args[1] } else { Undefined }
  let replacement = to_primitive(replacement_value, false)
  let current_len = Int64::from_int(typed_array_effective_length(data))
  if typed_array_is_oob(data) || idx64 < 0L || idx64 >= current_len {
    return throw_range_error("invalid array index")
  }
  let result = new_typed_array_value(data.kind, len)
  let mut k = 0
  while k < len {
    let value = if Int64::from_int(k) == idx64 {
      replacement
    } else {
      typed_array_get_index(data, k)
    }
    typed_array_set_index_or_throw(result, k, value)
    k = k + 1
  }
  result
}

///|
fn typed_array_map_value(
  this_value : Value,
  args : Array[Value],
) -> Value raise {
  let (arr, data) = require_typed_array_checked(Some(this_value))
  let callback = if args.is_empty() { Undefined } else { args[0] }
  let this_arg = if args.length() > 1 { args[1] } else { Undefined }
  if !is_callable(callback) {
    return throw_type_error("not a function")
  }
  let len = typed_array_effective_length(data)
  let result = typed_array_species_create64(
    this_value,
    data.kind,
    Int64::from_int(len),
  )
  let mut k = 0
  while k < len {
    let value = typed_array_get_index(data, k)
    let mapped = call_value_with_this(
      callback,
      [value, Number(Double::from_int(k)), Array(arr)],
      this_arg,
    )
    typed_array_set_index_or_throw(result, k, mapped)
    k = k + 1
  }
  result
}

///|
fn typed_array_filter_value(
  this_value : Value,
  args : Array[Value],
) -> Value raise {
  let (arr, data) = require_typed_array_checked(Some(this_value))
  let callback = if args.is_empty() { Undefined } else { args[0] }
  let this_arg = if args.length() > 1 { args[1] } else { Undefined }
  if !is_callable(callback) {
    return throw_type_error("not a function")
  }
  let len = typed_array_effective_length(data)
  let selected : Array[Value] = []
  let mut k = 0
  while k < len {
    let value = typed_array_get_index(data, k)
    let res = call_value_with_this(
      callback,
      [value, Number(Double::from_int(k)), Array(arr)],
      this_arg,
    )
    if is_truthy(res) {
      selected.push(value)
    }
    k = k + 1
  }
  let result_len = selected.length()
  let result = typed_array_species_create64(
    this_value,
    data.kind,
    Int64::from_int(result_len),
  )
  let mut i = 0
  while i < result_len {
    typed_array_set_index_or_throw(result, i, selected[i])
    i = i + 1
  }
  result
}

///|
fn typed_array_slice_value(
  this_value : Value,
  args : Array[Value],
) -> Value raise {
  let (_, data) = require_typed_array_checked(Some(this_value))
  let len = typed_array_effective_length(data)
  let len64 = Int64::from_int(len)
  let mut start = 0L
  if args.length() > 0 {
    start = to_int64_clamp64(args[0], 0L, len64, len64)
  }
  let mut end = len64
  if args.length() > 1 && !(args[1] is Undefined) {
    end = to_int64_clamp64(args[1], 0L, len64, len64)
  }
  let mut count64 = if end > start { end - start } else { 0L }
  let result = typed_array_species_create64(this_value, data.kind, count64)
  if count64 <= 0L {
    let _ = require_typed_array_checked(Some(result))
    return result
  }
  let (_, data_checked) = require_typed_array_checked(Some(this_value))
  let (_, result_data) = require_typed_array_checked(Some(result))
  let current_len64 = Int64::from_int(
    typed_array_effective_length(data_checked),
  )
  let mut space64 = current_len64 - start
  if space64 < 0L {
    space64 = 0L
  }
  if count64 > space64 {
    count64 = space64
  }
  if data_checked.kind == result_data.kind {
    let src_start = data_checked.byte_offset +
      Int64::to_int(start) * data_checked.bytes_per_element
    let dst_start = result_data.byte_offset
    let byte_count = Int64::to_int(count64) * data_checked.bytes_per_element
    match
      (
        data_checked.buffer.array_buffer_data,
        result_data.buffer.array_buffer_data,
      ) {
      (Some(src_buf), Some(dst_buf)) => {
        let mut idx = 0
        while idx < byte_count {
          dst_buf.bytes[dst_start + idx] = src_buf.bytes[src_start + idx]
          idx = idx + 1
        }
      }
      _ => ()
    }
    return result
  }
  let mut k = 0L
  while k < count64 {
    let value = typed_array_get_index(data_checked, Int64::to_int(start + k))
    typed_array_set_index_or_throw(result, Int64::to_int(k), value)
    k = k + 1L
  }
  result
}

///|
fn typed_array_subarray_value(
  this_value : Value,
  args : Array[Value],
) -> Value raise {
  let (_, data) = require_typed_array(Some(this_value))
  let len64 = Int64::from_int(typed_array_effective_length(data))
  let mut start = 0L
  if args.length() > 0 {
    start = to_int64_clamp64(args[0], 0L, len64, len64)
  }
  let mut end = len64
  let mut tracking = data.length_tracking
  if args.length() > 1 && !(args[1] is Undefined) {
    end = to_int64_clamp64(args[1], 0L, len64, len64)
    tracking = false
  }
  let count64 = if end > start { end - start } else { 0L }
  let offset = data.byte_offset + Int64::to_int(start) * data.bytes_per_element
  let ctor = typed_array_species_constructor(this_value, data.kind)
  let result = if tracking {
    call_constructor(ctor, [
      Object(data.buffer),
      Number(Double::from_int(offset)),
    ])
  } else {
    call_constructor(ctor, [
      Object(data.buffer),
      Number(Double::from_int(offset)),
      Number(Int64::to_double(count64)),
    ])
  }
  let _ = require_typed_array_checked(Some(result))
  result
}

///|
fn typed_array_reverse_value(this_value : Value) -> Value raise {
  let (_, data) = require_typed_array_checked(Some(this_value))
  let len = typed_array_effective_length(data)
  if len > 1 {
    let mut lower = 0
    let mut upper = len - 1
    while lower < upper {
      let lower_value = typed_array_get_index(data, lower)
      let upper_value = typed_array_get_index(data, upper)
      let _ = typed_array_set_index(data, lower, upper_value)
      let _ = typed_array_set_index(data, upper, lower_value)
      lower = lower + 1
      upper = upper - 1
    }
  }
  this_value
}

///|
fn typed_array_to_reversed_value(this_value : Value) -> Value raise {
  let (_, data) = require_typed_array_checked(Some(this_value))
  let len = typed_array_effective_length(data)
  let result = new_typed_array_value(data.kind, len)
  let mut out_index = 0
  let mut i = len - 1
  while i >= 0 && out_index < len {
    let value = typed_array_get_index(data, i)
    typed_array_set_index_or_throw(result, out_index, value)
    out_index = out_index + 1
    if i == 0 {
      break
    }
    i = i - 1
  }
  result
}

///|
fn typed_array_collect_values(data : TypedArrayData) -> Array[Value] {
  let len = typed_array_effective_length(data)
  let values : Array[Value] = []
  let mut i = 0
  while i < len {
    values.push(typed_array_get_index(data, i))
    i = i + 1
  }
  values
}

///|
fn typed_array_compare_values(
  left : Value,
  right : Value,
  kind : TypedArrayKind,
  compare_fn : Value?,
) -> Int raise {
  match compare_fn {
    Some(func) => {
      let num = to_number(call_value_with_this(func, [left, right], Undefined))
      if Double::is_nan(num) {
        0
      } else if num > 0.0 {
        1
      } else if num < 0.0 {
        -1
      } else {
        0
      }
    }
    None =>
      match kind {
        TypedArrayKind::BigInt64 | TypedArrayKind::BigUint64 => {
          let left_big = to_bigint(left)
          let right_big = to_bigint(right)
          if left_big < right_big {
            -1
          } else if left_big > right_big {
            1
          } else {
            0
          }
        }
        _ => {
          let left_num = to_number(left)
          let right_num = to_number(right)
          if Double::is_nan(left_num) {
            if Double::is_nan(right_num) {
              0
            } else {
              1
            }
          } else if Double::is_nan(right_num) {
            -1
          } else if left_num < right_num {
            -1
          } else if left_num > right_num {
            1
          } else if left_num == 0.0 && right_num == 0.0 {
            let left_neg = is_negative_zero(left_num)
            let right_neg = is_negative_zero(right_num)
            if left_neg == right_neg {
              0
            } else if left_neg {
              -1
            } else {
              1
            }
          } else {
            0
          }
        }
      }
  }
}

///|
fn typed_array_counting_sort_16(
  values : Array[Value],
  signed : Bool,
) -> Array[Value] raise {
  let len = values.length()
  let counts : Array[Int] = Array::make(65536, 0)
  let mut i = 0
  while i < len {
    let value = values[i]
    let num = match value {
      Number(n) => n
      _ => to_number(value)
    }
    let mut idx = to_int32(num)
    if signed {
      idx = idx + 0x8000
    }
    counts[idx] = counts[idx] + 1
    i = i + 1
  }
  let sorted : Array[Value] = Array::make(len, Undefined)
  let mut out = 0
  let mut v = 0
  while v < 65536 {
    let count = counts[v]
    if count > 0 {
      let num = if signed { v - 0x8000 } else { v }
      let val = Number(Double::from_int(num))
      let mut c = 0
      while c < count {
        sorted[out] = val
        out = out + 1
        c = c + 1
      }
    }
    v = v + 1
  }
  sorted
}

///|
fn typed_array_counting_sort_float16(
  values : Array[Value],
) -> Array[Value] raise {
  let len = values.length()
  let counts : Array[Int] = Array::make(65537, 0)
  let mut i = 0
  while i < len {
    let value = values[i]
    let num = match value {
      Number(n) => n
      _ => to_number(value)
    }
    let key = if Double::is_nan(num) {
      65536
    } else {
      let bits = double_to_float16_bits(num)
      let bits_int = UInt::reinterpret_as_int(bits)
      if Int::land(bits_int, 0x8000) != 0 {
        Int::lxor(bits_int, 0xffff)
      } else {
        Int::lxor(bits_int, 0x8000)
      }
    }
    counts[key] = counts[key] + 1
    i = i + 1
  }
  let sorted : Array[Value] = Array::make(len, Undefined)
  let mut out = 0
  let mut key = 0
  while key < 65536 {
    let count = counts[key]
    if count > 0 {
      let bits_int = if key < 0x8000 {
        Int::lxor(key, 0xffff)
      } else {
        Int::lxor(key, 0x8000)
      }
      let bits = Int::reinterpret_as_uint(bits_int)
      let val = Number(float16_bits_to_double(bits))
      let mut c = 0
      while c < count {
        sorted[out] = val
        out = out + 1
        c = c + 1
      }
    }
    key = key + 1
  }
  let nan_count = counts[65536]
  if nan_count > 0 {
    let val = Number(nan())
    let mut c = 0
    while c < nan_count {
      sorted[out] = val
      out = out + 1
      c = c + 1
    }
  }
  sorted
}

///|
fn typed_array_counting_sort_16_data(
  data : TypedArrayData,
  signed : Bool,
) -> Unit {
  let len = typed_array_effective_length(data)
  if len < 2 {
    return
  }
  match data.buffer.array_buffer_data {
    Some(buf) => {
      let counts : Array[Int] = Array::make(65536, 0)
      let mut i = 0
      let mut byte_index = data.byte_offset
      while i < len {
        let raw = buffer_read_u16_le(buf, byte_index)
        let idx = if signed { Int::lxor(raw, 0x8000) } else { raw }
        counts[idx] = counts[idx] + 1
        i = i + 1
        byte_index = byte_index + 2
      }
      byte_index = data.byte_offset
      let mut idx = 0
      while idx < 65536 {
        let count = counts[idx]
        if count > 0 {
          let raw = if signed { Int::lxor(idx, 0x8000) } else { idx }
          let mut c = 0
          while c < count {
            buffer_write_u16_le(buf, byte_index, raw)
            byte_index = byte_index + 2
            c = c + 1
          }
        }
        idx = idx + 1
      }
    }
    None => ()
  }
}

///|
fn typed_array_counting_sort_float16_data(data : TypedArrayData) -> Unit {
  let len = typed_array_effective_length(data)
  if len < 2 {
    return
  }
  match data.buffer.array_buffer_data {
    Some(buf) => {
      let counts : Array[Int] = Array::make(65536, 0)
      let nan_bits : Array[Int] = []
      let mut i = 0
      let mut byte_index = data.byte_offset
      while i < len {
        let raw = buffer_read_u16_le(buf, byte_index)
        let exp = Int::land(raw, 0x7c00)
        let mant = Int::land(raw, 0x03ff)
        if exp == 0x7c00 && mant != 0 {
          nan_bits.push(raw)
        } else {
          let idx = if Int::land(raw, 0x8000) != 0 {
            Int::lxor(raw, 0xffff)
          } else {
            Int::lxor(raw, 0x8000)
          }
          counts[idx] = counts[idx] + 1
        }
        i = i + 1
        byte_index = byte_index + 2
      }
      byte_index = data.byte_offset
      let mut idx = 0
      while idx < 65536 {
        let count = counts[idx]
        if count > 0 {
          let raw = if idx < 0x8000 {
            Int::lxor(idx, 0xffff)
          } else {
            Int::lxor(idx, 0x8000)
          }
          let mut c = 0
          while c < count {
            buffer_write_u16_le(buf, byte_index, raw)
            byte_index = byte_index + 2
            c = c + 1
          }
        }
        idx = idx + 1
      }
      for raw in nan_bits {
        buffer_write_u16_le(buf, byte_index, raw)
        byte_index = byte_index + 2
      }
    }
    None => ()
  }
}

///|
fn typed_array_quick_sort_values(
  values : Array[Value],
  kind : TypedArrayKind,
  compare_fn : Value?,
) -> Unit raise {
  let len = values.length()
  if len < 2 {
    return
  }
  let stack : Array[(Int, Int)] = []
  stack.push((0, len - 1))
  while !stack.is_empty() {
    let last = stack.length() - 1
    let (lo, hi) = stack[last]
    let _ = stack.pop()
    let pivot = values[(lo + hi) / 2]
    let mut i = lo
    let mut j = hi
    while i <= j {
      while typed_array_compare_values(values[i], pivot, kind, compare_fn) < 0 {
        i = i + 1
      }
      while typed_array_compare_values(values[j], pivot, kind, compare_fn) > 0 {
        j = j - 1
      }
      if i <= j {
        if i != j {
          let tmp = values[i]
          values[i] = values[j]
          values[j] = tmp
        }
        i = i + 1
        if j == 0 {
          break
        }
        j = j - 1
      }
    }
    if lo < j {
      stack.push((lo, j))
    }
    if i < hi {
      stack.push((i, hi))
    }
  }
}

///|
fn typed_array_compare_indices(
  values : Array[Value],
  kind : TypedArrayKind,
  compare_fn : Value,
  left : Int,
  right : Int,
) -> Int raise {
  let cmp = typed_array_compare_values(
    values[left],
    values[right],
    kind,
    Some(compare_fn),
  )
  if cmp == 0 {
    if left < right {
      -1
    } else if left > right {
      1
    } else {
      0
    }
  } else {
    cmp
  }
}

///|
fn typed_array_quick_sort_indices(
  indices : Array[Int],
  values : Array[Value],
  kind : TypedArrayKind,
  compare_fn : Value,
) -> Unit raise {
  let len = indices.length()
  if len < 2 {
    return
  }
  let stack : Array[(Int, Int)] = []
  stack.push((0, len - 1))
  while !stack.is_empty() {
    let last = stack.length() - 1
    let (lo, hi) = stack[last]
    let _ = stack.pop()
    let pivot_index = indices[(lo + hi) / 2]
    let mut i = lo
    let mut j = hi
    while i <= j {
      while typed_array_compare_indices(
              values,
              kind,
              compare_fn,
              indices[i],
              pivot_index,
            ) <
            0 {
        i = i + 1
      }
      while typed_array_compare_indices(
              values,
              kind,
              compare_fn,
              indices[j],
              pivot_index,
            ) >
            0 {
        j = j - 1
      }
      if i <= j {
        if i != j {
          let tmp = indices[i]
          indices[i] = indices[j]
          indices[j] = tmp
        }
        i = i + 1
        if j == 0 {
          break
        }
        j = j - 1
      }
    }
    if lo < j {
      stack.push((lo, j))
    }
    if i < hi {
      stack.push((i, hi))
    }
  }
}

///|
fn typed_array_sort_values(
  values : Array[Value],
  kind : TypedArrayKind,
  compare_fn : Value?,
) -> Array[Value] raise {
  match compare_fn {
    Some(func) => {
      let indices : Array[Int] = []
      let mut i = 0
      while i < values.length() {
        indices.push(i)
        i = i + 1
      }
      typed_array_quick_sort_indices(indices, values, kind, func)
      let sorted : Array[Value] = []
      for index in indices {
        sorted.push(values[index])
      }
      sorted
    }
    None => {
      let len = values.length()
      let counting_sort_threshold = 65536 * 4
      if len >= counting_sort_threshold {
        match kind {
          TypedArrayKind::Int16 =>
            return typed_array_counting_sort_16(values, true)
          TypedArrayKind::Uint16 =>
            return typed_array_counting_sort_16(values, false)
          TypedArrayKind::Float16 =>
            return typed_array_counting_sort_float16(values)
          _ => ()
        }
      }
      typed_array_quick_sort_values(values, kind, None)
      values
    }
  }
}

///|
fn typed_array_sort_value(
  this_value : Value,
  args : Array[Value],
) -> Value raise {
  let (arr, data) = require_typed_array_checked(Some(this_value))
  let compare_arg = if args.is_empty() { Undefined } else { args[0] }
  let compare_fn = if compare_arg is Undefined {
    None
  } else if !is_callable(compare_arg) {
    return throw_type_error("not a function")
  } else {
    Some(compare_arg)
  }
  match compare_fn {
    None => {
      let len = typed_array_effective_length(data)
      let counting_sort_threshold = 65536 * 4
      if len >= counting_sort_threshold {
        match data.kind {
          TypedArrayKind::Int16 => {
            typed_array_counting_sort_16_data(data, true)
            return Array(arr)
          }
          TypedArrayKind::Uint16 => {
            typed_array_counting_sort_16_data(data, false)
            return Array(arr)
          }
          TypedArrayKind::Float16 => {
            typed_array_counting_sort_float16_data(data)
            return Array(arr)
          }
          _ => ()
        }
      }
    }
    _ => ()
  }
  let values = typed_array_collect_values(data)
  let sorted = typed_array_sort_values(values, data.kind, compare_fn)
  let mut i = 0
  while i < sorted.length() {
    let _ = typed_array_set_index(data, i, sorted[i])
    i = i + 1
  }
  Array(arr)
}

///|
fn typed_array_to_sorted_value(
  this_value : Value,
  args : Array[Value],
) -> Value raise {
  let (_, data) = require_typed_array_checked(Some(this_value))
  let compare_arg = if args.is_empty() { Undefined } else { args[0] }
  let compare_fn = if compare_arg is Undefined {
    None
  } else if !is_callable(compare_arg) {
    return throw_type_error("not a function")
  } else {
    Some(compare_arg)
  }
  let values = typed_array_collect_values(data)
  let sorted = typed_array_sort_values(values, data.kind, compare_fn)
  let result = new_typed_array_value(data.kind, values.length())
  let mut i = 0
  while i < sorted.length() {
    typed_array_set_index_or_throw(result, i, sorted[i])
    i = i + 1
  }
  result
}

///|
fn typed_array_join_impl(
  this_value : Value,
  sep_value : Value?,
  to_locale : Bool,
) -> String raise {
  let (_, data) = require_typed_array_checked(Some(this_value))
  let mut sep = ","
  let old_len = typed_array_effective_length(data)
  let mut new_len = old_len
  if !to_locale {
    match sep_value {
      None => ()
      Some(Undefined) => ()
      Some(value) => {
        sep = to_string_strict(value)
        new_len = typed_array_effective_length(data)
      }
    }
  }
  let len = if new_len < old_len { new_len } else { old_len }
  let sb = StringBuilder::new()
  let mut i = 0
  while i < len {
    if i > 0 {
      sb.write_string(sep)
    }
    let value = typed_array_get_index(data, i)
    match value {
      Undefined | Null => ()
      _ =>
        if to_locale {
          sb.write_string(value_to_locale_string(value))
        } else {
          sb.write_string(to_string_strict(value))
        }
    }
    i = i + 1
  }
  let mut extra_start = new_len
  if extra_start < 1 {
    extra_start = 1
  }
  i = extra_start
  while i < old_len {
    sb.write_string(sep)
    i = i + 1
  }
  sb.to_string()
}

///|
fn typed_array_join_value(
  this_value : Value,
  args : Array[Value],
) -> String raise {
  let sep_value = if args.is_empty() { None } else { Some(args[0]) }
  typed_array_join_impl(this_value, sep_value, false)
}

///|
fn typed_array_to_locale_string_value(this_value : Value) -> String raise {
  typed_array_join_impl(this_value, None, true)
}

///|
fn typed_array_iterate_value(
  this_value : Value,
  callback : Value,
  this_arg : Value,
  kind : ArrayIterKind,
) -> Value raise {
  let (_, data) = require_typed_array_checked(Some(this_value))
  if !is_callable(callback) {
    return throw_type_error("not a function")
  }
  let len = typed_array_effective_length(data)
  let mut k = 0
  while k < len {
    let value = typed_array_get_index(data, k)
    let res = call_value_with_this(
      callback,
      [value, Number(Double::from_int(k)), this_value],
      this_arg,
    )
    match kind {
      ArrayIterKind::Every => if !is_truthy(res) { return Bool(false) }
      ArrayIterKind::SomeMatch => if is_truthy(res) { return Bool(true) }
      ArrayIterKind::ForEach => ()
      _ => ()
    }
    k = k + 1
  }
  match kind {
    ArrayIterKind::Every => Bool(true)
    ArrayIterKind::SomeMatch => Bool(false)
    _ => Undefined
  }
}

///|
fn typed_array_reduce_value(
  this_value : Value,
  args : Array[Value],
  from_right : Bool,
) -> Value raise {
  let (_, data) = require_typed_array_checked(Some(this_value))
  let callback = if args.is_empty() { Undefined } else { args[0] }
  if !is_callable(callback) {
    return throw_type_error("not a function")
  }
  let len = typed_array_effective_length(data)
  let mut k = 0
  let mut acc : Value? = if args.length() > 1 { Some(args[1]) } else { None }
  if acc is None {
    if len == 0 {
      return throw_type_error("Reduce of empty array with no initial value")
    }
    let index = if from_right { len - 1 } else { 0 }
    acc = Some(typed_array_get_index(data, index))
    k = 1
  }
  let mut current = match acc {
    Some(value) => value
    None => Undefined
  }
  while k < len {
    let index = if from_right { len - k - 1 } else { k }
    let value = typed_array_get_index(data, index)
    current = call_value_with_this(
      callback,
      [current, value, Number(Double::from_int(index)), this_value],
      Undefined,
    )
    k = k + 1
  }
  current
}

///|
fn typed_array_find_value(
  this_value : Value,
  args : Array[Value],
  kind : ArrayFindKind,
) -> Value raise {
  let (_, data) = require_typed_array_checked(Some(this_value))
  let len = typed_array_effective_length(data)
  let callback = if args.is_empty() { Undefined } else { args[0] }
  if !is_callable(callback) {
    return throw_type_error("not a function")
  }
  let this_arg = if args.length() > 1 { args[1] } else { Undefined }
  let mut k = 0
  let mut end = len
  let mut dir = 1
  let mut is_last = false
  match kind {
    ArrayFindKind::FindLast | ArrayFindKind::FindLastIndex => is_last = true
    _ => ()
  }
  if is_last {
    k = len - 1
    end = -1
    dir = -1
  }
  while k != end {
    let value = typed_array_get_index(data, k)
    let result = call_value_with_this(
      callback,
      [value, Number(Double::from_int(k)), this_value],
      this_arg,
    )
    if is_truthy(result) {
      return match kind {
        ArrayFindKind::FindIndex | ArrayFindKind::FindLastIndex =>
          Number(Double::from_int(k))
        _ => value
      }
    }
    k = k + dir
  }
  match kind {
    ArrayFindKind::FindIndex | ArrayFindKind::FindLastIndex => Number(-1.0)
    _ => Undefined
  }
}

///|
fn typed_array_index_of_value(
  this_value : Value,
  args : Array[Value],
) -> Value raise {
  let (_, data) = require_typed_array_checked(Some(this_value))
  let len = typed_array_effective_length(data)
  if len <= 0 {
    return Number(-1.0)
  }
  let search = if args.is_empty() { Undefined } else { args[0] }
  let len64 = Int64::from_int(len)
  let mut from_index = 0L
  if args.length() > 1 {
    from_index = to_int64_clamp64(args[1], 0L, len64, len64)
  }
  if from_index >= len64 {
    return Number(-1.0)
  }
  let (_, data_checked) = require_typed_array(Some(this_value))
  let current_len = typed_array_effective_length(data_checked)
  let search_len = if current_len < len { current_len } else { len }
  if search_len <= 0 {
    return Number(-1.0)
  }
  let search_len64 = Int64::from_int(search_len)
  if from_index >= search_len64 {
    return Number(-1.0)
  }
  let mut k = Int64::to_int(from_index)
  while k < search_len {
    let value = typed_array_get_index(data_checked, k)
    if strict_eq(value, search) {
      return Number(Double::from_int(k))
    }
    k = k + 1
  }
  Number(-1.0)
}

///|
fn typed_array_last_index_of_value(
  this_value : Value,
  args : Array[Value],
) -> Value raise {
  let (_, data) = require_typed_array_checked(Some(this_value))
  let len = typed_array_effective_length(data)
  if len <= 0 {
    return Number(-1.0)
  }
  let search = if args.is_empty() { Undefined } else { args[0] }
  let len64 = Int64::from_int(len)
  let mut from_index = len64 - 1L
  if args.length() > 1 {
    from_index = to_int64_clamp64(args[1], -1L, len64 - 1L, len64)
  }
  if from_index < 0L {
    return Number(-1.0)
  }
  let (_, data_checked) = require_typed_array(Some(this_value))
  let current_len = typed_array_effective_length(data_checked)
  if current_len <= 0 {
    return Number(-1.0)
  }
  let current_len64 = Int64::from_int(current_len)
  if from_index >= current_len64 {
    from_index = current_len64 - 1L
  }
  if from_index < 0L {
    return Number(-1.0)
  }
  let mut k = Int64::to_int(from_index)
  while k >= 0 {
    let value = typed_array_get_index(data_checked, k)
    if strict_eq(value, search) {
      return Number(Double::from_int(k))
    }
    if k == 0 {
      break
    }
    k = k - 1
  }
  Number(-1.0)
}

///|
fn typed_array_includes_value(
  this_value : Value,
  args : Array[Value],
) -> Value raise {
  let (_, data) = require_typed_array_checked(Some(this_value))
  let len = typed_array_effective_length(data)
  if len <= 0 {
    return Bool(false)
  }
  let search = if args.is_empty() { Undefined } else { args[0] }
  let len64 = Int64::from_int(len)
  let mut from_index = 0L
  if args.length() > 1 {
    from_index = to_int64_clamp64(args[1], 0L, len64, len64)
  }
  if from_index >= len64 {
    return Bool(false)
  }
  let (_, data_checked) = require_typed_array(Some(this_value))
  let mut k = Int64::to_int(from_index)
  while k < len {
    let value = typed_array_get_index(data_checked, k)
    if same_value_zero(value, search) {
      return Bool(true)
    }
    k = k + 1
  }
  Bool(false)
}

///|
fn typed_array_from_value(
  this_value : Value,
  args : Array[Value],
) -> Value raise {
  if !is_constructor_value(this_value) {
    return throw_type_error("not a constructor")
  }
  let mapfn = if args.length() > 1 { args[1] } else { Undefined }
  let this_arg = if args.length() > 2 { args[2] } else { Undefined }
  if !(mapfn is Undefined) && !is_callable(mapfn) {
    return throw_type_error("not a function")
  }
  let items = if args.is_empty() { Undefined } else { args[0] }
  if items is Undefined || items is Null {
    return throw_type_error("not an object")
  }
  let iter_method = match symbol_iterator_key() {
    Some(key) => property_get_with_receiver(items, key, items)
    None => Undefined
  }
  let mut array_value = Undefined
  let mut len64 = 0L
  if !(iter_method is Undefined) && !(iter_method is Null) {
    if !is_callable(iter_method) {
      return throw_type_error("value is not iterable")
    }
    let iterator = call_value_with_this(iter_method, [], items)
    let next_method = property_get(iterator, "next")
    if !is_callable(next_method) {
      return throw_type_error("not a function")
    }
    let array_proto_value = match current_env() {
      Some(env) =>
        match value_from_object(array_proto_for_env(env)) {
          Some(value) => Some(value)
          None => value_from_object(array_proto())
        }
      None => value_from_object(array_proto())
    }
    let values : Array[Value?] = []
    for {
      let (done, value) = iterator_step_value(iterator, next_method)
      if done {
        break
      }
      values.push(Some(value))
    }
    array_value = new_array_value_with_proto(values, proto=array_proto_value)
    len64 = Int64::from_int(values.length())
  } else {
    let obj = to_object(items)
    len64 = array_like_length_int64(obj)
    array_value = obj
  }
  let result = typed_array_create_from_constructor(this_value, len64)
  let mut k = 0L
  while k < len64 {
    let k_value = property_get(array_value, Int64::to_string(k))
    let mapped = if mapfn is Undefined {
      k_value
    } else {
      call_value_with_this(
        mapfn,
        [k_value, Number(Int64::to_double(k))],
        this_arg,
      )
    }
    let _ = property_set(result, Int64::to_string(k), mapped, true)
    k = k + 1L
  }
  result
}

///|
fn typed_array_of_value(this_value : Value, args : Array[Value]) -> Value raise {
  if !is_constructor_value(this_value) {
    return throw_type_error("not a constructor")
  }
  let len64 = Int64::from_int(args.length())
  let result = typed_array_create_from_constructor(this_value, len64)
  let mut i = 0
  while i < args.length() {
    let _ = property_set(result, Int::to_string(i), args[i], true)
    i = i + 1
  }
  result
}

///|
fn typed_array_set_value(
  this_value : Value,
  args : Array[Value],
) -> Value raise {
  let (_, data) = require_typed_array(Some(this_value))
  if args.is_empty() {
    return Undefined
  }
  let offset_value = if args.length() > 1 { args[1] } else { Undefined }
  let offset64 = to_int64_sat_value(offset_value)
  if offset64 < 0L {
    return throw_range_error("invalid array length")
  }
  if typed_array_is_oob(data) {
    return throw_type_error("ArrayBuffer is detached")
  }
  let target_len64 = Int64::from_int(typed_array_effective_length(data))
  let source = args[0]
  match source {
    Array(src_arr) =>
      match src_arr.typed_array_data {
        Some(src_data) => {
          if typed_array_is_oob(src_data) {
            return throw_type_error("ArrayBuffer is detached")
          }
          let source_len = typed_array_effective_length(src_data)
          let source_len64 = Int64::from_int(source_len)
          if offset64 > target_len64 - source_len64 {
            return throw_range_error("invalid array length")
          }
          let values : Array[Value] = []
          let mut i = 0
          while i < source_len {
            values.push(typed_array_get_index(src_data, i))
            i = i + 1
          }
          let offset = Int64::to_int(offset64)
          i = 0
          while i < source_len {
            let _ = typed_array_set_index(data, offset + i, values[i])
            i = i + 1
          }
        }
        None => {
          let source_value = Array(src_arr)
          let source_len64 = array_like_length_int64(source_value)
          if offset64 > target_len64 - source_len64 {
            return throw_range_error("invalid array length")
          }
          let offset = Int64::to_int(offset64)
          let mut i = 0L
          while i < source_len64 {
            let value = property_get(source_value, Int64::to_string(i))
            match data.kind {
              TypedArrayKind::BigInt64 | TypedArrayKind::BigUint64 => {
                let _ = to_bigint(value)

              }
              _ => ()
            }
            let _ = typed_array_set_index(
              data,
              offset + Int64::to_int(i),
              value,
            )
            i = i + 1L
          }
        }
      }
    _ => {
      let src_obj = to_object(source)
      let source_len64 = array_like_length_int64(src_obj)
      if offset64 > target_len64 - source_len64 {
        return throw_range_error("invalid array length")
      }
      let offset = Int64::to_int(offset64)
      let mut i = 0L
      while i < source_len64 {
        let value = property_get(src_obj, Int64::to_string(i))
        match data.kind {
          TypedArrayKind::BigInt64 | TypedArrayKind::BigUint64 => {
            let _ = to_bigint(value)

          }
          _ => ()
        }
        let _ = typed_array_set_index(data, offset + Int64::to_int(i), value)
        i = i + 1L
      }
    }
  }
  Undefined
}

///|
fn typed_array_copy_within_value(
  this_value : Value,
  args : Array[Value],
) -> Value raise {
  let (_, data) = require_typed_array_checked(Some(this_value))
  let len = typed_array_effective_length(data)
  let len64 = Int64::from_int(len)
  let to_value = if args.is_empty() { Undefined } else { args[0] }
  let from_value = if args.length() > 1 { args[1] } else { Undefined }
  let to = to_int64_clamp64(to_value, 0L, len64, len64)
  let from = to_int64_clamp64(from_value, 0L, len64, len64)
  let mut final_index = len64
  if args.length() > 2 && !(args[2] is Undefined) {
    final_index = to_int64_clamp64(args[2], 0L, len64, len64)
  }
  let (_, data_checked) = require_typed_array_checked(Some(this_value))
  let current_len64 = Int64::from_int(
    typed_array_effective_length(data_checked),
  )
  let mut count = final_index - from
  let max = len64 - to
  if max < count {
    count = max
  }
  let space = current_len64 - (if from > to { from } else { to })
  if space < count {
    count = space
  }
  if count <= 0L {
    return this_value
  }
  let dir = if from < to && to < from + count { -1L } else { 1L }
  let mut i = 0L
  while i < count {
    let from_index = if dir < 0L { from + count - i - 1L } else { from + i }
    let to_index = if dir < 0L { to + count - i - 1L } else { to + i }
    let value = typed_array_get_index(data_checked, Int64::to_int(from_index))
    let _ = typed_array_set_index(data_checked, Int64::to_int(to_index), value)
    i = i + 1L
  }
  this_value
}

///|
fn typed_array_fill_value(
  this_value : Value,
  args : Array[Value],
) -> Value raise {
  let (_, data) = require_typed_array_checked(Some(this_value))
  let len = typed_array_effective_length(data)
  let len64 = Int64::from_int(len)
  let fill_arg = if args.is_empty() { Undefined } else { args[0] }
  let fill_value = match data.kind {
    TypedArrayKind::BigInt64 | TypedArrayKind::BigUint64 =>
      BigInt(to_bigint(fill_arg))
    _ => Number(to_number(fill_arg))
  }
  let mut start = 0L
  if args.length() > 1 && !(args[1] is Undefined) {
    start = to_int64_clamp64(args[1], 0L, len64, len64)
  }
  let mut end = len64
  if args.length() > 2 && !(args[2] is Undefined) {
    end = to_int64_clamp64(args[2], 0L, len64, len64)
  }
  if typed_array_is_oob(data) {
    return throw_type_error("ArrayBuffer is detached")
  }
  let current_len64 = Int64::from_int(typed_array_effective_length(data))
  if end > current_len64 {
    end = current_len64
  }
  let mut k = start
  while k < end {
    let _ = typed_array_set_index(data, Int64::to_int(k), fill_value)
    k = k + 1L
  }
  this_value
}

///|
fn array_fill_value(this_value : Value, args : Array[Value]) -> Value raise {
  let obj = to_object(this_value)
  let len = array_like_length_int64(obj)
  let start = if args.length() > 1 && !(args[1] is Undefined) {
    to_int64_clamp64(args[1], 0L, len, len)
  } else {
    0L
  }
  let end = if args.length() > 2 && !(args[2] is Undefined) {
    to_int64_clamp64(args[2], 0L, len, len)
  } else {
    len
  }
  let fill_value = if args.is_empty() { Undefined } else { args[0] }
  let mut k = start
  while k < end {
    let _ = property_set(obj, Int64::to_string(k), fill_value, true)
    k = k + 1L
  }
  obj
}

///|
fn array_copy_within_value(
  this_value : Value,
  args : Array[Value],
) -> Value raise {
  let obj = to_object(this_value)
  let len = array_like_length_int64(obj)
  let to_value = if args.is_empty() { Undefined } else { args[0] }
  let from_value = if args.length() > 1 { args[1] } else { Undefined }
  let to = to_int64_clamp64(to_value, 0L, len, len)
  let from = to_int64_clamp64(from_value, 0L, len, len)
  let mut final_index = len
  if args.length() > 2 && !(args[2] is Undefined) {
    final_index = to_int64_clamp64(args[2], 0L, len, len)
  }
  let mut count = final_index - from
  let max = len - to
  if max < count {
    count = max
  }
  if count <= 0L {
    return obj
  }
  let dir = if from < to && to < from + count { -1L } else { 1L }
  let mut i = 0L
  while i < count {
    let from_index = if dir < 0L { from + count - i - 1L } else { from + i }
    let to_index = if dir < 0L { to + count - i - 1L } else { to + i }
    let from_name = Int64::to_string(from_index)
    let to_name = Int64::to_string(to_index)
    if has_property_value(obj, from_name) {
      let value = property_get(obj, from_name)
      let _ = property_set(obj, to_name, value, true)

    } else {
      delete_property_or_throw(obj, to_name)
    }
    i = i + 1L
  }
  obj
}

///|
fn flatten_into_array(
  target : Value,
  source : Value,
  source_len : Int,
  target_index : Int,
  depth : Int,
  mapper_fn : Value?,
  this_arg : Value,
) -> Int raise {
  let mut next_index = target_index
  let mut source_index = 0
  let max_safe = Double::to_int(9007199254740991.0)
  while source_index < source_len {
    let name = Int::to_string(source_index)
    if has_property_value(source, name) {
      let mut element = property_get(source, name)
      match mapper_fn {
        Some(func) =>
          element = call_value_with_this(
            func,
            [element, Number(Double::from_int(source_index)), source],
            this_arg,
          )
        None => ()
      }
      if depth > 0 && is_array_value(element) {
        let inner = to_object(element)
        let inner_len = array_like_length(inner)
        next_index = flatten_into_array(
          target,
          inner,
          inner_len,
          next_index,
          depth - 1,
          None,
          Undefined,
        )
      } else {
        if next_index >= max_safe {
          let _ = throw_type_error("Array too long")
          return next_index
        }
        create_data_property_or_throw(
          target,
          Int::to_string(next_index),
          element,
        )
        next_index = next_index + 1
      }
    }
    source_index = source_index + 1
  }
  next_index
}

///|
fn array_flatten_value(
  this_value : Value,
  args : Array[Value],
  map : Bool,
) -> Value raise {
  let obj = to_object(this_value)
  let source_len = array_like_length(obj)
  let mut depth = 1
  let mut mapper : Value? = None
  let mut this_arg = Undefined
  if map {
    let func = if args.is_empty() { Undefined } else { args[0] }
    if !is_callable(func) {
      return throw_type_error("not a function")
    }
    mapper = Some(func)
    if args.length() > 1 {
      this_arg = args[1]
    }
    depth = 1
  } else if args.length() > 0 && !(args[0] is Undefined) {
    depth = to_int32_sat(to_number(args[0]))
  }
  let target = array_species_create(obj, 0)
  let _ = flatten_into_array(
    target, obj, source_len, 0, depth, mapper, this_arg,
  )
  target
}

///|
fn array_with_value(this_value : Value, args : Array[Value]) -> Value raise {
  let obj = to_object(this_value)
  let len64 = array_like_length_int64(obj)
  let max_int = 2147483647
  if len64 > Int64::from_int(max_int) {
    return throw_range_error("invalid array length")
  }
  let len = Int64::to_int(len64)
  let index_value = if args.is_empty() { Undefined } else { args[0] }
  let idx_num = to_number(index_value)
  let max_i64 = 9223372036854775807L
  let min_i64 = -9223372036854775807L - 1L
  let mut idx64 = if Double::is_nan(idx_num) {
    0L
  } else if Double::is_inf(idx_num) {
    if idx_num < 0.0 {
      min_i64
    } else {
      max_i64
    }
  } else {
    let trunc = Double::trunc(idx_num)
    if trunc > 9223372036854775807.0 {
      max_i64
    } else if trunc < -9223372036854775808.0 {
      min_i64
    } else {
      Double::to_int64(trunc)
    }
  }
  if idx64 < 0L {
    idx64 = len64 + idx64
  }
  if idx64 < 0L || idx64 >= len64 {
    return throw_range_error("invalid array index: \{Int64::to_string(idx64)}")
  }
  let replacement = if args.length() > 1 { args[1] } else { Undefined }
  let array_proto_value = match current_env() {
    Some(env) =>
      match value_from_object(array_proto_for_env(env)) {
        Some(value) => Some(value)
        None => value_from_object(array_proto())
      }
    None => value_from_object(array_proto())
  }
  let result = new_array_value_with_proto(
    Array::make(len, None),
    proto=array_proto_value,
  )
  let mut k = 0
  while k < len {
    let value = if Int64::from_int(k) == idx64 {
      replacement
    } else {
      let key = Int::to_string(k)
      if has_property_value(obj, key) {
        property_get(obj, key)
      } else {
        Undefined
      }
    }
    create_data_property_or_throw(result, Int::to_string(k), value)
    k = k + 1
  }
  result
}

///|
fn array_to_reversed_value(this_value : Value) -> Value raise {
  let obj = to_object(this_value)
  let len64 = array_like_length_int64(obj)
  let max_int = 2147483647
  if len64 > Int64::from_int(max_int) {
    return throw_range_error("invalid array length")
  }
  let len = Int64::to_int(len64)
  let array_proto_value = match current_env() {
    Some(env) =>
      match value_from_object(array_proto_for_env(env)) {
        Some(value) => Some(value)
        None => value_from_object(array_proto())
      }
    None => value_from_object(array_proto())
  }
  let result = new_array_value_with_proto(
    Array::make(len, None),
    proto=array_proto_value,
  )
  let mut out_index = 0
  let mut i = len - 1
  while i >= 0 && out_index < len {
    let key = Int::to_string(i)
    let value = if has_property_value(obj, key) {
      property_get(obj, key)
    } else {
      Undefined
    }
    create_data_property_or_throw(result, Int::to_string(out_index), value)
    out_index = out_index + 1
    if i == 0 {
      break
    }
    i = i - 1
  }
  result
}

///|
fn array_to_sorted_value(
  this_value : Value,
  args : Array[Value],
) -> Value raise {
  let compare_arg = if args.is_empty() { Undefined } else { args[0] }
  if !(compare_arg is Undefined) && !is_callable(compare_arg) {
    return throw_type_error("not a function")
  }
  let compare_fn = if compare_arg is Undefined {
    None
  } else {
    Some(compare_arg)
  }
  let obj = to_object(this_value)
  let len64 = array_like_length_int64(obj)
  let max_int = 2147483647
  if len64 > Int64::from_int(max_int) {
    return throw_range_error("invalid array length")
  }
  let len = Int64::to_int(len64)
  let array_proto_value = match current_env() {
    Some(env) =>
      match value_from_object(array_proto_for_env(env)) {
        Some(value) => Some(value)
        None => value_from_object(array_proto())
      }
    None => value_from_object(array_proto())
  }
  let result = new_array_value_with_proto(
    Array::make(len, None),
    proto=array_proto_value,
  )
  let mut i = 0
  while i < len {
    let key = Int::to_string(i)
    let value = if has_property_value(obj, key) {
      property_get(obj, key)
    } else {
      Undefined
    }
    create_data_property_or_throw(result, Int::to_string(i), value)
    i = i + 1
  }
  array_sort_object(result, compare_fn)
}

///|
fn array_to_spliced_value(
  this_value : Value,
  args : Array[Value],
) -> Value raise {
  let obj = to_object(this_value)
  let len64 = array_like_length_int64(obj)
  let mut start = 0L
  if args.length() > 0 {
    start = to_int64_clamp64(args[0], 0L, len64, len64)
  }
  let mut del = 0L
  if args.length() > 0 {
    del = len64 - start
  }
  if args.length() > 1 {
    del = to_int64_clamp64(args[1], 0L, del, 0L)
  }
  let add = if args.length() > 2 {
    Int64::from_int(args.length() - 2)
  } else {
    0L
  }
  let new_len64 = len64 + add - del
  if Int64::to_double(new_len64) > 9007199254740991.0 {
    return throw_type_error("invalid array length")
  }
  if new_len64 > max_array_length {
    return throw_range_error("invalid array length")
  }
  let max_int = 2147483647
  if new_len64 > Int64::from_int(max_int) {
    return throw_range_error("invalid array length")
  }
  let new_len = Int64::to_int(new_len64)
  let array_proto_value = match current_env() {
    Some(env) =>
      match value_from_object(array_proto_for_env(env)) {
        Some(value) => Some(value)
        None => value_from_object(array_proto())
      }
    None => value_from_object(array_proto())
  }
  let result = new_array_value_with_proto(
    Array::make(new_len, None),
    proto=array_proto_value,
  )
  let mut write_index = 0L
  let mut i = 0L
  while i < start {
    let key = Int64::to_string(i)
    let value = if has_property_value(obj, key) {
      property_get(obj, key)
    } else {
      Undefined
    }
    create_data_property_or_throw(result, Int64::to_string(write_index), value)
    write_index = write_index + 1L
    i = i + 1L
  }
  let mut j = 0
  while j < Int64::to_int(add) {
    create_data_property_or_throw(
      result,
      Int64::to_string(write_index),
      args[2 + j],
    )
    write_index = write_index + 1L
    j = j + 1
  }
  i = start + del
  while i < len64 {
    let key = Int64::to_string(i)
    let value = if has_property_value(obj, key) {
      property_get(obj, key)
    } else {
      Undefined
    }
    create_data_property_or_throw(result, Int64::to_string(write_index), value)
    write_index = write_index + 1L
    i = i + 1L
  }
  result
}

///|
fn array_splice_value(this_value : Value, args : Array[Value]) -> Value raise {
  let obj = to_object(this_value)
  let len = array_like_length_int64(obj)
  let mut start = 0L
  if args.length() > 0 {
    start = to_int64_clamp64(args[0], 0L, len, len)
  }
  let mut item_count = 0
  let mut del_count = 0L
  if args.length() == 0 {
    item_count = 0
    del_count = 0L
  } else if args.length() == 1 {
    item_count = 0
    del_count = len - start
  } else {
    item_count = args.length() - 2
    del_count = to_int64_clamp64(args[1], 0L, len - start, 0L)
  }
  let item_count64 = Int64::from_int(item_count)
  let new_len = len + item_count64 - del_count
  if Int64::to_double(new_len) > 9007199254740991.0 {
    return throw_type_error("Array loo long")
  }
  let result = array_species_create64(obj, del_count)
  let mut k = 0L
  while k < del_count {
    let from_name = Int64::to_string(start + k)
    if has_property_value(obj, from_name) {
      let value = property_get(obj, from_name)
      create_data_property_or_throw(result, Int64::to_string(k), value)
    }
    k = k + 1L
  }
  let _ = property_set(
    result,
    "length",
    Number(Int64::to_double(del_count)),
    true,
  )
  if item_count64 < del_count {
    let mut k = start
    while k < len - del_count {
      let from = Int64::to_string(k + del_count)
      let to = Int64::to_string(k + item_count64)
      if has_property_value(obj, from) {
        let value = property_get(obj, from)
        let _ = property_set(obj, to, value, true)

      } else {
        delete_property_or_throw(obj, to)
      }
      k = k + 1L
    }
    let mut k = len
    while k > new_len {
      k = k - 1L
      delete_property_or_throw(obj, Int64::to_string(k))
    }
  } else if item_count64 > del_count {
    let mut k = len - del_count
    while k > start {
      k = k - 1L
      let from = Int64::to_string(k + del_count)
      let to = Int64::to_string(k + item_count64)
      if has_property_value(obj, from) {
        let value = property_get(obj, from)
        let _ = property_set(obj, to, value, true)

      } else {
        delete_property_or_throw(obj, to)
      }
    }
  }
  let mut i = 0
  while i < item_count {
    let _ = property_set(
      obj,
      Int64::to_string(start + Int64::from_int(i)),
      args[2 + i],
      true,
    )
    i = i + 1
  }
  let _ = property_set(obj, "length", Number(Int64::to_double(new_len)), true)
  result
}

///|
fn array_slice_value(this_value : Value, args : Array[Value]) -> Value raise {
  let obj = to_object(this_value)
  let len64 = array_like_length_int64(obj)
  let mut start = 0L
  if args.length() > 0 {
    start = to_int64_clamp64(args[0], 0L, len64, len64)
  }
  let mut end = len64
  if args.length() > 1 && !(args[1] is Undefined) {
    end = to_int64_clamp64(args[1], 0L, len64, len64)
  }
  let count64 = if end > start { end - start } else { 0L }
  let max_int = 2147483647
  if count64 > Int64::from_int(max_int) {
    return throw_range_error("invalid array length")
  }
  let count = Int64::to_int(count64)
  let result = array_species_create(obj, count)
  let mut k = start
  let mut n = 0
  while k < end {
    let name = Int64::to_string(k)
    if has_property(obj, name) {
      let value = property_get(obj, name)
      create_data_property_or_throw(result, Int::to_string(n), value)
    }
    k = k + 1
    n = n + 1
  }
  let _ = property_set(result, "length", Number(Double::from_int(count)), true)
  result
}

///|
fn array_reverse_value(this_value : Value) -> Value raise {
  let obj = to_object(this_value)
  let len = array_like_length_int64(obj)
  if len <= 1L {
    return obj
  }
  let middle = len / 2L
  let mut lower = 0L
  let mut upper = len - 1L
  while lower < middle {
    let lower_name = Int64::to_string(lower)
    let upper_name = Int64::to_string(upper)
    let lower_present = has_property_value(obj, lower_name)
    let mut lower_value = Undefined
    if lower_present {
      lower_value = property_get(obj, lower_name)
    }
    let upper_present = has_property_value(obj, upper_name)
    let mut upper_value = Undefined
    if upper_present {
      upper_value = property_get(obj, upper_name)
    }
    if lower_present {
      if upper_present {
        let _ = property_set(obj, lower_name, upper_value, true)
        let _ = property_set(obj, upper_name, lower_value, true)

      } else {
        delete_property_or_throw(obj, lower_name)
        let _ = property_set(obj, upper_name, lower_value, true)

      }
    } else if upper_present {
      let _ = property_set(obj, lower_name, upper_value, true)
      delete_property_or_throw(obj, upper_name)
    }
    lower = lower + 1L
    upper = upper - 1L
  }
  obj
}

///|
fn array_unshift_value(this_value : Value, args : Array[Value]) -> Value raise {
  let obj = to_object(this_value)
  let len = array_like_length_int64(obj)
  let item_count = args.length()
  if item_count == 0 {
    let _ = property_set(obj, "length", Number(Int64::to_double(len)), true)
    return Number(Int64::to_double(len))
  }
  let item_count64 = Int64::from_int(item_count)
  let new_len = len + item_count64
  let total = Int64::to_double(len) + Double::from_int(item_count)
  if total > 9007199254740991.0 {
    return throw_type_error("Array loo long")
  }
  let mut k = len
  while k > 0L {
    k = k - 1L
    let from = Int64::to_string(k)
    let to = Int64::to_string(k + item_count64)
    if has_property_value(obj, from) {
      let value = property_get(obj, from)
      let _ = property_set(obj, to, value, true)

    } else {
      delete_property_or_throw(obj, to)
    }
  }
  let mut i = 0
  while i < item_count {
    let index = Int64::from_int(i)
    let _ = property_set(obj, Int64::to_string(index), args[i], true)
    i = i + 1
  }
  let _ = property_set(obj, "length", Number(Int64::to_double(new_len)), true)
  Number(Int64::to_double(new_len))
}

///|
fn array_push_value(this_value : Value, args : Array[Value]) -> Value raise {
  let obj = to_object(this_value)
  let len = array_like_length_int64(obj)
  let item_count = args.length()
  if item_count == 0 {
    let _ = property_set(obj, "length", Number(Int64::to_double(len)), true)
    return Number(Int64::to_double(len))
  }
  let total = Int64::to_double(len) + Double::from_int(item_count)
  if total > 9007199254740991.0 {
    return throw_type_error("Array loo long")
  }
  let mut i = 0
  while i < item_count {
    let index = len + Int64::from_int(i)
    let _ = property_set(obj, Int64::to_string(index), args[i], true)
    i = i + 1
  }
  let new_len = len + Int64::from_int(item_count)
  let _ = property_set(obj, "length", Number(Int64::to_double(new_len)), true)
  Number(Int64::to_double(new_len))
}

///|
fn array_from_value(this_value : Value, args : Array[Value]) -> Value raise {
  let items = if args.is_empty() { Undefined } else { args[0] }
  let mapfn = if args.length() > 1 { args[1] } else { Undefined }
  let this_arg = if args.length() > 2 { args[2] } else { Undefined }
  if !(mapfn is Undefined) && !is_callable(mapfn) {
    return throw_type_error("not a function")
  }
  let obj = to_object(items)
  let iter_method = match symbol_iterator_key() {
    Some(key) => property_get_with_receiver(obj, key, items)
    None => Undefined
  }
  if !(iter_method is Undefined) && !(iter_method is Null) {
    if !is_callable(iter_method) {
      return throw_type_error("value is not iterable")
    }
    let result = if is_constructor_value(this_value) {
      call_constructor(this_value, [])
    } else {
      let array_proto_value = match current_env() {
        Some(env) =>
          match value_from_object(array_proto_for_env(env)) {
            Some(value) => Some(value)
            None => value_from_object(array_proto())
          }
        None => value_from_object(array_proto())
      }
      new_array_value_with_proto([], proto=array_proto_value)
    }
    let iterator = call_value_with_this(iter_method, [], obj)
    let next_method = property_get(iterator, "next")
    if !is_callable(next_method) {
      return throw_type_error("not a function")
    }
    let mut index = 0L
    while true {
      let (done, value) = iterator_step_value(iterator, next_method)
      if done {
        break
      }
      try {
        let mapped = if mapfn is Undefined {
          value
        } else {
          call_value_with_this(
            mapfn,
            [value, Number(Int64::to_double(index))],
            this_arg,
          )
        }
        create_data_property_or_throw(result, Int64::to_string(index), mapped)
      } catch {
        err => {
          iterator_close_on_error(iterator)
          raise err
        }
      }
      index = index + 1L
    }
    let _ = property_set(
      result,
      "length",
      Number(Int64::to_double(index)),
      true,
    )
    result
  } else {
    let len = array_like_length_int64(obj)
    let result = if is_constructor_value(this_value) {
      call_constructor(this_value, [Number(Int64::to_double(len))])
    } else {
      let array_proto_value = match current_env() {
        Some(env) =>
          match value_from_object(array_proto_for_env(env)) {
            Some(value) => Some(value)
            None => value_from_object(array_proto())
          }
        None => value_from_object(array_proto())
      }
      let created = new_array_value_with_proto([], proto=array_proto_value)
      let _ = property_set(
        created,
        "length",
        Number(Int64::to_double(len)),
        true,
      )
      created
    }
    let mut k = 0L
    while k < len {
      let value = property_get(obj, Int64::to_string(k))
      let mapped = if mapfn is Undefined {
        value
      } else {
        call_value_with_this(
          mapfn,
          [value, Number(Int64::to_double(k))],
          this_arg,
        )
      }
      create_data_property_or_throw(result, Int64::to_string(k), mapped)
      k = k + 1L
    }
    let _ = property_set(result, "length", Number(Int64::to_double(len)), true)
    result
  }
}

///|
fn array_of_value(this_value : Value, args : Array[Value]) -> Value raise {
  let len = args.length()
  let result = if is_constructor_value(this_value) {
    call_constructor(this_value, [Number(Double::from_int(len))])
  } else {
    new_array_value([])
  }
  let mut i = 0
  while i < len {
    create_data_property_or_throw(result, Int::to_string(i), args[i])
    i = i + 1
  }
  let _ = property_set(result, "length", Number(Double::from_int(len)), true)
  result
}

///|
fn get_iterator_from_value(value : Value) -> (Value, Value) raise {
  let obj = to_object(value)
  let iter_method = match symbol_iterator_key() {
    Some(key) => property_get_with_receiver(obj, key, value)
    None => Undefined
  }
  match iter_method {
    Undefined | Null => {
      let _ = throw_type_error("value is not iterable")
      return (Undefined, Undefined)
    }
    _ => ()
  }
  if !is_callable(iter_method) {
    let _ = throw_type_error("value is not iterable")
    return (Undefined, Undefined)
  }
  let iterator = call_value_with_this(iter_method, [], value)
  if !is_object_like(iterator) {
    let _ = throw_type_error("not an object")
    return (Undefined, Undefined)
  }
  let next_method = property_get(iterator, "next")
  (iterator, next_method)
}

///|
fn get_async_iterator_from_value(value : Value) -> (Value, Value) raise {
  let obj = to_object(value)
  let iter_method = match symbol_async_iterator_key() {
    Some(key) => property_get_with_receiver(obj, key, value)
    None => Undefined
  }
  match iter_method {
    Undefined | Null => {
      let (sync_iter, next_method) = get_iterator_from_value(value)
      let async_iter = new_async_from_sync_iterator(sync_iter, next_method)
      let async_next = property_get(async_iter, "next")
      if !is_callable(async_next) {
        let _ = throw_type_error("not a function")
        return (Undefined, Undefined)
      }
      (async_iter, async_next)
    }
    _ => {
      if !is_callable(iter_method) {
        let _ = throw_type_error("value is not async iterable")
        return (Undefined, Undefined)
      }
      let iterator = call_value_with_this(iter_method, [], value)
      if !is_object_like(iterator) {
        let _ = throw_type_error("not an object")
        return (Undefined, Undefined)
      }
      let next_method = property_get(iterator, "next")
      (iterator, next_method)
    }
  }
}

///|
fn await_value(value : Value) -> Value raise {
  let promise_ctor = promise_ctor_value_for_current_env()
  let promise = promise_resolve_value(promise_ctor, value, false)
  match promise_data_from_value(promise) {
    Some(data) => {
      run_pending_jobs()
      match data.state {
        PromiseState::Fulfilled => data.value
        PromiseState::Rejected => raise ThrowSignal(data.value)
        PromiseState::Pending => promise
      }
    }
    None => promise
  }
}

///|
fn async_iterator_step_value(
  iterator : Value,
  next_method : Value,
) -> (Bool, Value) raise {
  let result = call_value_with_this(next_method, [], iterator)
  let awaited = await_value(result)
  if !is_object_like(awaited) {
    let _ = throw_type_error("iterator must return an object")
    return (true, Undefined)
  }
  let done = is_truthy(property_get(awaited, "done"))
  let value = property_get(awaited, "value")
  (done, value)
}

///|
fn async_iterator_close(iterator : Value) -> Unit raise {
  let return_method = property_get(iterator, "return")
  match return_method {
    Undefined | Null => ()
    _ =>
      if !is_callable(return_method) {
        let _ = throw_type_error("not a function")

      } else {
        let result = call_value_with_this(return_method, [], iterator)
        let awaited = await_value(result)
        let _ = to_object(awaited)

      }
  }
}

///|
fn async_iterator_close_on_error(iterator : Value) -> Unit {
  async_iterator_close(iterator) catch {
    _ => ()
  }
}

///|
fn get_iterator_flattenable(value : Value) -> (Value, Value) raise {
  match value {
    String(_) => {
      let _ = throw_type_error("value is not iterable")
      return (Undefined, Undefined)
    }
    _ => ()
  }
  if !is_object_like(value) {
    let _ = throw_type_error("value is not iterable")
    return (Undefined, Undefined)
  }
  let iter_method = match symbol_iterator_key() {
    Some(key) => property_get(value, key)
    None => Undefined
  }
  match iter_method {
    Undefined | Null => {
      let next_method = property_get(value, "next")
      if !is_callable(next_method) {
        let _ = throw_type_error("not a function")
        return (Undefined, Undefined)
      }
      (value, next_method)
    }
    _ => {
      if !is_callable(iter_method) {
        let _ = throw_type_error("not a function")
        return (Undefined, Undefined)
      }
      let iterator = call_value_with_this(iter_method, [], value)
      if !is_object_like(iterator) {
        let _ = throw_type_error("not an object")
        return (Undefined, Undefined)
      }
      let next_method = property_get(iterator, "next")
      if !is_callable(next_method) {
        let _ = throw_type_error("not a function")
        return (Undefined, Undefined)
      }
      (iterator, next_method)
    }
  }
}

///|
fn iterator_step_value(
  iterator : Value,
  next_method : Value,
) -> (Bool, Value) raise {
  let step = call_value_with_this(next_method, [], iterator)
  if !is_object_like(step) {
    let _ = throw_type_error("iterator must return an object")
    return (true, Undefined)
  }
  let done_value = property_get(step, "done")
  if is_truthy(done_value) {
    (true, Undefined)
  } else {
    (false, property_get(step, "value"))
  }
}

///|
fn iterator_close(iterator : Value) -> Unit raise {
  let return_method = property_get(iterator, "return")
  match return_method {
    Undefined | Null => ()
    _ =>
      if !is_callable(return_method) {
        let _ = throw_type_error("not a function")

      } else {
        let result = call_value_with_this(return_method, [], iterator)
        if !is_object_like(result) {
          let _ = throw_type_error("iterator must return an object")

        }
      }
  }
}

///|
fn iterator_close_on_error(iterator : Value) -> Unit {
  try {
    let return_method = property_get(iterator, "return")
    match return_method {
      Undefined | Null => ()
      _ => {
        let _ = call_value_with_this(return_method, [], iterator)

      }
    }
  } catch {
    _ => ()
  }
}

///|
priv struct ArraySortSlot {
  value : Value
  mut str_cache : String?
  pos : Int
}

///|
fn array_sort_slot_string(slots : Array[ArraySortSlot], index : Int) -> String {
  match slots[index].str_cache {
    Some(text) => text
    None => {
      let text = to_string_value(slots[index].value)
      slots[index].str_cache = Some(text)
      text
    }
  }
}

///|
fn array_sort_compare(
  slots : Array[ArraySortSlot],
  left : Int,
  right : Int,
  compare_fn : Value?,
) -> Int raise {
  let left_value = slots[left].value
  let right_value = slots[right].value
  let mut cmp = 0
  match compare_fn {
    Some(func) =>
      if strict_eq(left_value, right_value) {
        cmp = 0
      } else {
        let res = call_value_with_this(
          func,
          [left_value, right_value],
          Undefined,
        )
        let num = to_number(res)
        if Double::is_nan(num) {
          cmp = 0
        } else if num > 0.0 {
          cmp = 1
        } else if num < 0.0 {
          cmp = -1
        } else {
          cmp = 0
        }
      }
    None => {
      let left_str = array_sort_slot_string(slots, left)
      let right_str = array_sort_slot_string(slots, right)
      let raw = string_lex_compare(left_str, right_str)
      if raw < 0 {
        cmp = -1
      } else if raw > 0 {
        cmp = 1
      } else {
        cmp = 0
      }
    }
  }
  if cmp == 0 {
    let left_pos = slots[left].pos
    let right_pos = slots[right].pos
    if left_pos < right_pos {
      -1
    } else if left_pos > right_pos {
      1
    } else {
      0
    }
  } else {
    cmp
  }
}

///|
fn array_sort_slots(
  slots : Array[ArraySortSlot],
  compare_fn : Value?,
) -> Unit raise {
  let len = slots.length()
  if len < 2 {
    return
  }
  let mut i = 1
  while i < len {
    let mut j = i
    while j > 0 {
      let cmp = array_sort_compare(slots, j - 1, j, compare_fn)
      if cmp <= 0 {
        break
      }
      let tmp = slots[j - 1]
      slots[j - 1] = slots[j]
      slots[j] = tmp
      j = j - 1
    }
    i = i + 1
  }
}

///|
fn array_sort_object(obj : Value, compare_fn : Value?) -> Value raise {
  let len = array_like_length(obj)
  let slots : Array[ArraySortSlot] = []
  let mut undefined_count = 0
  let mut index = 0
  while index < len {
    let key = Int::to_string(index)
    if has_property(obj, key) {
      let value = property_get(obj, key)
      match value {
        Undefined => undefined_count = undefined_count + 1
        _ => slots.push(ArraySortSlot::{ value, str_cache: None, pos: index })
      }
    }
    index = index + 1
  }
  array_sort_slots(slots, compare_fn)
  match obj {
    Array(arr) =>
      match arr.typed_array_data {
        Some(data) => {
          let write_limit = typed_array_effective_length(data)
          let mut write_index = 0
          for slot in slots {
            if write_index >= write_limit {
              break
            }
            let _ = property_set(
              obj,
              Int::to_string(write_index),
              slot.value,
              true,
            )
            write_index = write_index + 1
          }
          return obj
        }
        None => ()
      }
    _ => ()
  }
  let mut write_index = 0
  for slot in slots {
    let _ = property_set(obj, Int::to_string(write_index), slot.value, true)
    write_index = write_index + 1
  }
  let mut remaining = undefined_count
  while remaining > 0 {
    let _ = property_set(obj, Int::to_string(write_index), Undefined, true)
    write_index = write_index + 1
    remaining = remaining - 1
  }
  while write_index < len {
    delete_property_or_throw(obj, Int::to_string(write_index))
    write_index = write_index + 1
  }
  obj
}

///|
fn sort_int64s(values : Array[Int64]) -> Unit {
  if values.length() < 2 {
    return
  }
  for i = 1; i < values.length(); i = i + 1 {
    let key = values[i]
    let mut j = i - 1
    while j >= 0 && values[j] > key {
      values[j + 1] = values[j]
      j = j - 1
    }
    values[j + 1] = key
  }
}

///|
fn sort_strings_lex(values : Array[String]) -> Unit {
  if values.length() < 2 {
    return
  }
  for i = 1; i < values.length(); i = i + 1 {
    let key = values[i]
    let mut j = i - 1
    while j >= 0 && string_lex_compare(values[j], key) > 0 {
      values[j + 1] = values[j]
      j = j - 1
    }
    values[j + 1] = key
  }
}

///|
fn ordered_prop_keys(
  props : Map[String, Property],
  include_non_enum : Bool,
) -> Array[String] {
  let indices : Array[Int64] = []
  let non_indices : Array[String] = []
  for key, prop in props {
    if is_symbol_prop_key(key) || is_private_prop_key(key) {
      continue
    }
    if include_non_enum || prop.enumerable {
      match array_index_from_name(key) {
        Some(index) => indices.push(index)
        None => non_indices.push(key)
      }
    }
  }
  sort_int64s(indices)
  let names : Array[String] = []
  for index in indices {
    names.push(Int64::to_string(index))
  }
  for name in non_indices {
    names.push(name)
  }
  names
}

///|
fn module_namespace_prop_keys(
  props : Map[String, Property],
  include_non_enum : Bool,
) -> Array[String] {
  let names : Array[String] = []
  for key, prop in props {
    if is_symbol_prop_key(key) || is_private_prop_key(key) {
      continue
    }
    if !include_non_enum && !prop.enumerable {
      continue
    }
    names.push(key)
  }
  sort_strings_lex(names)
  names
}

///|
fn names_to_array_value(names : Array[String]) -> Value {
  let values : Array[Value?] = []
  for name in names {
    values.push(Some(String(name)))
  }
  new_array_value(values)
}

///|
fn is_extensible_value(value : Value) -> Bool {
  match value {
    Object(obj) => obj.extensible
    Function(func) => func.extensible
    BoundFunction(bound) => bound.extensible
    Builtin(builtin) => builtin.extensible
    Array(arr) => arr.extensible
    Arguments(args) => args.extensible
    _ => false
  }
}

///|
fn is_extensible_value_checked(value : Value) -> Bool raise {
  match value {
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => proxy_is_extensible(data)
        None => obj.extensible
      }
    Function(func) => func.extensible
    BoundFunction(bound) => bound.extensible
    Builtin(builtin) => builtin.extensible
    Array(arr) => arr.extensible
    Arguments(args) => args.extensible
    _ => false
  }
}

///|
fn prevent_extensions_value(value : Value) -> Bool raise {
  match value {
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => proxy_prevent_extensions(data)
        None => {
          obj.extensible = false
          true
        }
      }
    Function(func) => {
      func.extensible = false
      true
    }
    BoundFunction(bound) => {
      bound.extensible = false
      true
    }
    Builtin(builtin) => {
      builtin.extensible = false
      true
    }
    Array(arr) => {
      match arr.typed_array_data {
        Some(data) =>
          match data.buffer.array_buffer_data {
            Some(buf) =>
              if data.length_tracking || (buf.resizable && !buf.shared) {
                return false
              }
            None => ()
          }
        None => ()
      }
      arr.extensible = false
      true
    }
    Arguments(args) => {
      args.extensible = false
      true
    }
    _ => false
  }
}

///|
fn has_own_property(value : Value, name : String) -> Bool raise {
  let desc = get_own_property_descriptor(value, name)
  match desc {
    Undefined => false
    _ =>
      if !is_object_like(desc) {
        let _ = throw_type_error("invalid property descriptor")
        false
      } else {
        true
      }
  }
}

///|
fn set_property_in(
  props : Map[String, Property],
  name : String,
  value : Value,
  receiver : Value,
) -> Bool raise {
  match props.get(name) {
    Some(prop) =>
      match prop.setter {
        Some(setter) =>
          match setter {
            Undefined | Null => false
            _ => {
              let _ = call_value_with_this(setter, [value], receiver)
              true
            }
          }
        None =>
          if prop.writable {
            props.set(name, Property::{
              value,
              writable: prop.writable,
              configurable: prop.configurable,
              enumerable: prop.enumerable,
              getter: prop.getter,
              setter: prop.setter,
            })
            true
          } else {
            false
          }
      }
    None => {
      props.set(name, property_data(value))
      true
    }
  }
}

///|
fn integer_indexed_element_set(
  data : TypedArrayData,
  index : Double,
  value : Value,
) -> Unit raise {
  let converted = match data.kind {
    TypedArrayKind::BigInt64 | TypedArrayKind::BigUint64 =>
      BigInt(to_bigint(value))
    _ => Number(to_number(value))
  }
  if !typed_array_is_valid_integer_index(data, index) {
    return
  }
  let index_int = Double::to_int(index)
  let _ = typed_array_set_index(data, index_int, converted)

}

///|
fn typed_array_set(
  arr : ArrayValue,
  data : TypedArrayData,
  name : String,
  value : Value,
) -> Bool raise {
  if name == "length" {
    return false
  }
  match canonical_numeric_index_string(name) {
    Some(index) => {
      integer_indexed_element_set(data, index, value)
      true
    }
    None =>
      set_property_with_proto(
        arr.props,
        arr.proto,
        name,
        value,
        Array(arr),
        arr.extensible,
      )
  }
}

///|
fn get_property_in_chain(proto : Value?, name : String) -> Value? raise {
  match proto {
    None => None
    Some(obj) => {
      let desc = get_own_property_descriptor(obj, name)
      match desc {
        Undefined => get_property_in_chain(get_proto_of_value(obj), name)
        _ => Some(desc)
      }
    }
  }
}

///|
fn set_property_with_proto(
  props : Map[String, Property],
  proto : Value?,
  name : String,
  value : Value,
  receiver : Value,
  extensible : Bool,
) -> Bool raise {
  let _ = extensible
  if props.contains(name) {
    return set_property_in(props, name, value, receiver)
  }
  match proto {
    Some(parent) => set_value_with_receiver(parent, name, value, receiver)
    None =>
      if !is_object_like(receiver) {
        false
      } else {
        let receiver_desc = get_own_property_descriptor(receiver, name)
        match receiver_desc {
          Undefined =>
            if !is_extensible_value(receiver) {
              false
            } else {
              let desc_obj = property_descriptor_object(property_data(value))
              define_property_value(
                receiver,
                prop_key_value_from_name(name),
                desc_obj,
                false,
              )
            }
          _ =>
            if !is_object_like(receiver_desc) {
              let _ = throw_type_error("invalid property descriptor")
              false
            } else if descriptor_is_accessor(receiver_desc) {
              false
            } else {
              let receiver_writable = is_truthy(
                property_get(receiver_desc, "writable"),
              )
              if !receiver_writable {
                false
              } else {
                let desc_obj = new_object_value()
                match desc_obj {
                  Object(obj) => obj.props.set("value", property_data(value))
                  _ => ()
                }
                define_property_value(
                  receiver,
                  prop_key_value_from_name(name),
                  desc_obj,
                  false,
                )
              }
            }
        }
      }
  }
}

///|
fn function_property_get_with_receiver(
  func : FunctionValue,
  name : String,
  receiver : Value,
) -> Value raise {
  if name == "prototype" && !func.props.contains(name) {
    ensure_function_prototype(func)
  }
  property_get_from_chain(func.props, func.proto, name, receiver)
}

///|
fn function_debug_location(this_value : Value?, want_column : Bool) -> Value {
  match this_value {
    Some(Function(func)) => {
      let slot = if want_column { func.column_number } else { func.line_number }
      match slot {
        Some(value) => Number(Double::from_int(value))
        None => Undefined
      }
    }
    _ => Undefined
  }
}

///|
fn ensure_function_prototype(func : FunctionValue) -> Unit {
  if !func.is_constructor && !func.is_generator {
    return
  }
  if func.props.contains("prototype") {
    return
  }
  let proto = if func.is_generator {
    let base_proto = if func.is_async {
      match value_from_object(async_generator_proto_for_env(func.env)) {
        Some(value) => Some(value)
        None => value_from_object(async_generator_proto())
      }
    } else {
      match value_from_object(generator_proto_for_env(func.env)) {
        Some(value) => Some(value)
        None => value_from_object(generator_proto())
      }
    }
    new_object_value_with_proto(base_proto)
  } else {
    let default_proto = match
      value_from_object(object_proto_for_env(func.env)) {
      Some(value) => Some(value)
      None => value_from_object(object_proto())
    }
    new_object_value_with_proto(default_proto)
  }
  match proto {
    Object(obj) =>
      if !func.is_generator {
        obj.props.set(
          "constructor",
          property_data_non_enum(Value::Function(func)),
        )
      }
    _ => ()
  }
  let proto_prop = if func.is_class_constructor {
    property_data_const(proto)
  } else {
    property_data_non_enum_non_config(proto)
  }
  func.props.set("prototype", proto_prop)
}

///|
fn call_bound_function(
  bound : BoundFunctionValue,
  args : Array[Value],
  new_target? : Value = Undefined,
) -> Value raise {
  let final_args : Array[Value] = []
  for value in bound.bound_args {
    final_args.push(value)
  }
  for value in args {
    final_args.push(value)
  }
  call_value_with_this(bound.target, final_args, bound.bound_this, new_target~)
}

///|
fn call_value(value : Value, args : Array[Value]) -> Value raise {
  match value {
    Function(func) => call_user_function(func, args)
    BoundFunction(bound) => call_bound_function(bound, args)
    Builtin(builtin) => call_builtin_with_this(builtin, args, Undefined)
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => proxy_apply_value(data, Undefined, args)
        None => throw_type_error("not a function")
      }
    _ => throw_type_error("not a function")
  }
}

///|
fn call_value_with_this(
  value : Value,
  args : Array[Value],
  this_value : Value,
  new_target? : Value = Undefined,
) -> Value raise {
  match value {
    Function(func) =>
      call_user_function_with_this(func, args, this_value, new_target)
    BoundFunction(bound) => call_bound_function(bound, args, new_target~)
    Builtin(builtin) => call_builtin_with_this(builtin, args, this_value)
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => proxy_apply_value(data, this_value, args)
        None => throw_type_error("not a function")
      }
    _ => throw_type_error("not a function")
  }
}

///|
fn call_builtin(builtin : BuiltinValue, args : Array[Value]) -> Value raise {
  match builtin.kind {
    BuiltinFunction::JsonStringify => {
      let value = if args.is_empty() { Undefined } else { args[0] }
      let replacer = if args.length() > 1 { args[1] } else { Undefined }
      let space = if args.length() > 2 { args[2] } else { Undefined }
      json_stringify_with_replacer(value, replacer, space)
    }
    BuiltinFunction::JsonParse => {
      let text_value = if args.is_empty() { Undefined } else { args[0] }
      let reviver = if args.length() > 1 { args[1] } else { Undefined }
      json_parse_with_reviver(text_value, reviver)
    }
    BuiltinFunction::BjsonRead => bjson_read_value(args)
    BuiltinFunction::BjsonWrite => bjson_write_value(args)
    BuiltinFunction::ObjectConstructor =>
      if args.is_empty() {
        new_object_value()
      } else {
        match args[0] {
          Undefined => new_object_value()
          Null => new_object_value()
          _ =>
            if is_object_like(args[0]) {
              args[0]
            } else {
              let env = function_realm_env_checked(Value::Builtin(builtin))
              coerce_this(env, args[0])
            }
        }
      }
    BuiltinFunction::ProxyConstructor =>
      throw_type_error("Proxy constructor requires 'new'")
    BuiltinFunction::DataViewConstructor =>
      throw_type_error("DataView constructor requires 'new'")
    BuiltinFunction::ProxyRevocable => {
      let target = if args.is_empty() { Undefined } else { args[0] }
      let handler = if args.length() > 1 { args[1] } else { Undefined }
      let proxy = new_proxy_value(target, handler)
      let revoke = new_proxy_revoke_function(proxy)
      let result = new_object_value()
      match result {
        Object(obj) => {
          obj.props.set("proxy", property_data(proxy))
          obj.props.set("revoke", property_data(revoke))
        }
        _ => ()
      }
      result
    }
    BuiltinFunction::ProxyRevoke => {
      match builtin.this_value {
        Some(Object(obj)) =>
          match obj.proxy_data {
            Some(data) => {
              data.handler = Null
              data.target = Null
            }
            None => ()
          }
        _ => ()
      }
      Undefined
    }
    BuiltinFunction::ObjectDefineProperty => {
      if args.length() < 3 {
        return Undefined
      }
      define_property(args[0], args[1], args[2])
    }
    BuiltinFunction::ObjectDefineProperties => {
      let target = if args.is_empty() { Undefined } else { args[0] }
      let props = if args.length() > 1 { args[1] } else { Undefined }
      define_properties_from_object(target, props)
      target
    }
    BuiltinFunction::ObjectGetOwnPropertyDescriptor => {
      let target = if args.is_empty() { Undefined } else { args[0] }
      match target {
        Null => throw_type_error("not an object")
        Undefined => throw_type_error("not an object")
        _ => {
          let obj = if is_object_like(target) {
            target
          } else {
            to_object(target)
          }
          let key = if args.length() > 1 { args[1] } else { Undefined }
          let name = property_key_name(key)
          get_own_property_descriptor(obj, name)
        }
      }
    }
    BuiltinFunction::ObjectGetOwnPropertyNames => {
      if args.is_empty() {
        return throw_type_error("not an object")
      }
      let target = args[0]
      match target {
        Null => throw_type_error("not an object")
        Undefined => throw_type_error("not an object")
        _ => {
          let obj = if is_object_like(target) {
            target
          } else {
            to_object(target)
          }
          object_get_own_property_names(obj)
        }
      }
    }
    BuiltinFunction::ObjectGetOwnPropertySymbols => {
      if args.is_empty() {
        return throw_type_error("not an object")
      }
      let target = args[0]
      match target {
        Null => throw_type_error("not an object")
        Undefined => throw_type_error("not an object")
        _ => {
          let obj = if is_object_like(target) {
            target
          } else {
            to_object(target)
          }
          let values : Array[Value?] = match obj {
            Object(raw) =>
              match raw.proxy_data {
                Some(data) => {
                  let keys = proxy_own_keys_values(data)
                  let items : Array[Value?] = []
                  for key in keys {
                    match key {
                      Symbol(_) => items.push(Some(key))
                      _ => ()
                    }
                  }
                  items
                }
                None => {
                  let symbols = own_symbol_keys(obj, true)
                  let items : Array[Value?] = []
                  for symbol in symbols {
                    items.push(Some(Symbol(symbol)))
                  }
                  items
                }
              }
            _ => {
              let symbols = own_symbol_keys(obj, true)
              let items : Array[Value?] = []
              for symbol in symbols {
                items.push(Some(Symbol(symbol)))
              }
              items
            }
          }
          new_array_value(values)
        }
      }
    }
    BuiltinFunction::ObjectGetOwnPropertyDescriptors => {
      if args.is_empty() {
        return throw_type_error("not an object")
      }
      let target = args[0]
      match target {
        Null => throw_type_error("not an object")
        Undefined => throw_type_error("not an object")
        _ => {
          let obj = if is_object_like(target) {
            target
          } else {
            to_object(target)
          }
          object_get_own_property_descriptors(obj)
        }
      }
    }
    BuiltinFunction::ObjectGetPrototypeOf => {
      if args.is_empty() {
        return throw_type_error("not an object")
      }
      let target = args[0]
      match target {
        Null => throw_type_error("not an object")
        Undefined => throw_type_error("not an object")
        _ => {
          let obj = if is_object_like(target) {
            target
          } else {
            to_object(target)
          }
          match get_proto_of_value_checked(obj) {
            Some(proto) => proto
            None => Null
          }
        }
      }
    }
    BuiltinFunction::ObjectSetPrototypeOf => {
      if args.is_empty() {
        return Undefined
      }
      let target = args[0]
      match target {
        Null => throw_type_error("not an object")
        Undefined => throw_type_error("not an object")
        _ =>
          if !is_object_like(target) {
            target
          } else {
            let proto_value = if args.length() > 1 {
              args[1]
            } else {
              Undefined
            }
            let proto = match proto_value {
              _ if is_object_like(proto_value) => Some(proto_value)
              Null => None
              _ => {
                let _ = throw_type_error("not a prototype")
                None
              }
            }
            let _ = set_proto_of_value(target, proto, true)
            target
          }
      }
    }
    BuiltinFunction::ObjectCreate => {
      if args.is_empty() {
        return throw_type_error("not a prototype")
      }
      let proto_value = args[0]
      let proto = match proto_value {
        _ if is_object_like(proto_value) => Some(proto_value)
        Null => None
        _ => {
          let _ = throw_type_error("not a prototype")
          None
        }
      }
      let obj = new_object_value_with_proto(proto)
      if args.length() > 1 && !(args[1] is Undefined) {
        define_properties_from_object(obj, args[1])
      }
      obj
    }
    BuiltinFunction::ObjectKeys => {
      if args.is_empty() {
        return throw_type_error("not an object")
      }
      let target = args[0]
      match target {
        Null => throw_type_error("not an object")
        Undefined => throw_type_error("not an object")
        _ => {
          let obj = if is_object_like(target) {
            target
          } else {
            to_object(target)
          }
          object_keys(obj)
        }
      }
    }
    BuiltinFunction::ObjectValues => {
      if args.is_empty() {
        return throw_type_error("not an object")
      }
      let target = args[0]
      match target {
        Null => throw_type_error("not an object")
        Undefined => throw_type_error("not an object")
        _ => {
          let obj = if is_object_like(target) {
            target
          } else {
            to_object(target)
          }
          object_key_values(obj, OBJECT_KEYS_KIND_VALUES)
        }
      }
    }
    BuiltinFunction::ObjectEntries => {
      if args.is_empty() {
        return throw_type_error("not an object")
      }
      let target = args[0]
      match target {
        Null => throw_type_error("not an object")
        Undefined => throw_type_error("not an object")
        _ => {
          let obj = if is_object_like(target) {
            target
          } else {
            to_object(target)
          }
          object_key_values(obj, OBJECT_KEYS_KIND_ENTRIES)
        }
      }
    }
    BuiltinFunction::ObjectGroupBy => {
      let iterable = if args.is_empty() { Undefined } else { args[0] }
      let callback = if args.length() > 1 { args[1] } else { Undefined }
      object_group_by(iterable, callback)
    }
    BuiltinFunction::ObjectIs => {
      let left = if args.is_empty() { Undefined } else { args[0] }
      let right = if args.length() > 1 { args[1] } else { Undefined }
      Bool(same_value(left, right))
    }
    BuiltinFunction::ObjectIsExtensible => {
      if args.is_empty() {
        return Bool(false)
      }
      let target = args[0]
      if is_object_like(target) {
        Bool(is_extensible_value_checked(target))
      } else {
        Bool(false)
      }
    }
    BuiltinFunction::ObjectPreventExtensions => {
      if args.is_empty() {
        return Undefined
      }
      let target = args[0]
      if is_object_like(target) {
        if !prevent_extensions_value(target) {
          return throw_type_error(
            "proxy preventExtensions handler returned false",
          )
        }
        target
      } else {
        target
      }
    }
    BuiltinFunction::ObjectSeal => {
      let target = if args.is_empty() { Undefined } else { args[0] }
      object_seal(target, false)
    }
    BuiltinFunction::ObjectIsSealed => {
      let target = if args.is_empty() { Undefined } else { args[0] }
      Bool(object_is_sealed(target, false))
    }
    BuiltinFunction::ObjectIsFrozen => {
      let target = if args.is_empty() { Undefined } else { args[0] }
      Bool(object_is_sealed(target, true))
    }
    BuiltinFunction::ObjectFreeze => {
      let target = if args.is_empty() { Undefined } else { args[0] }
      object_seal(target, true)
    }
    BuiltinFunction::ObjectFromEntries => {
      let iterable = if args.is_empty() { Undefined } else { args[0] }
      object_from_entries(iterable)
    }
    BuiltinFunction::ObjectAssign => {
      if args.is_empty() {
        return throw_type_error("not an object")
      }
      let target = to_object(args[0])
      if args.length() > 1 {
        for i = 1; i < args.length(); i = i + 1 {
          let source = args[i]
          if source is Null || source is Undefined {
            continue
          }
          let from = to_object(source)
          let keys = own_property_keys_values(from)
          for key in keys {
            match key {
              String(name) => {
                let desc = get_own_property_descriptor(from, name)
                match desc {
                  Undefined => ()
                  _ =>
                    if !is_object_like(desc) {
                      let _ = throw_type_error("invalid property descriptor")

                    } else if is_truthy(property_get(desc, "enumerable")) {
                      let value = property_get(from, name)
                      let _ = property_set(target, name, value, true)

                    }
                }
              }
              Symbol(symbol) => {
                let name = symbol_prop_key(symbol)
                let desc = get_own_property_descriptor(from, name)
                match desc {
                  Undefined => ()
                  _ =>
                    if !is_object_like(desc) {
                      let _ = throw_type_error("invalid property descriptor")

                    } else if is_truthy(property_get(desc, "enumerable")) {
                      let value = property_get(from, name)
                      let _ = property_set(target, name, value, true)

                    }
                }
              }
              _ => ()
            }
          }
        }
      }
      target
    }
    BuiltinFunction::ObjectHasOwn => {
      let target = if args.is_empty() { Undefined } else { args[0] }
      let obj = to_object(target)
      let key = if args.length() > 1 { args[1] } else { Undefined }
      let name = property_key_name(key)
      Bool(has_own_property(obj, name))
    }
    BuiltinFunction::ObjectToString =>
      match builtin.this_value {
        Some(value) => String(object_to_string(value))
        None => String(object_to_string(Undefined))
      }
    BuiltinFunction::ObjectToLocaleString => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = to_object(target)
      let func = property_get_with_receiver(obj, "toString", target)
      if !is_callable(func) {
        return throw_type_error("not a function")
      }
      call_value_with_this(func, [], target)
    }
    BuiltinFunction::ObjectValueOf => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      to_object(target)
    }
    BuiltinFunction::ObjectHasOwnProperty => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let key = if args.is_empty() { Undefined } else { args[0] }
      let name = property_key_name(key)
      let obj = to_object(target)
      Bool(has_own_property(obj, name))
    }
    BuiltinFunction::ObjectPropertyIsEnumerable => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let key = if args.is_empty() { Undefined } else { args[0] }
      let name = property_key_name(key)
      let obj = to_object(target)
      let desc = get_own_property_descriptor(obj, name)
      match desc {
        Undefined => Bool(false)
        _ =>
          if !is_object_like(desc) {
            throw_type_error("invalid property descriptor")
          } else {
            Bool(is_truthy(property_get(desc, "enumerable")))
          }
      }
    }
    BuiltinFunction::ObjectIsPrototypeOf => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let value = if args.is_empty() { Undefined } else { args[0] }
      if !is_object_like(value) {
        return Bool(false)
      }
      let obj = to_object(target)
      let mut current = value
      while true {
        match get_proto_of_value_checked(current) {
          Some(proto) => {
            if strict_eq(proto, obj) {
              return Bool(true)
            }
            current = proto
          }
          None => return Bool(false)
        }
      }
      Bool(false)
    }
    BuiltinFunction::ObjectProtoGet => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      object_proto_get(target)
    }
    BuiltinFunction::ObjectProtoSet => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let proto_value = if args.is_empty() { Undefined } else { args[0] }
      object_proto_set(target, proto_value)
    }
    BuiltinFunction::ObjectDefineGetter => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let key = if args.is_empty() { Undefined } else { args[0] }
      let getter = if args.length() > 1 { args[1] } else { Undefined }
      object_define_accessor(target, key, getter, false)
    }
    BuiltinFunction::ObjectDefineSetter => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let key = if args.is_empty() { Undefined } else { args[0] }
      let setter = if args.length() > 1 { args[1] } else { Undefined }
      object_define_accessor(target, key, setter, true)
    }
    BuiltinFunction::ObjectLookupGetter => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let key = if args.is_empty() { Undefined } else { args[0] }
      object_lookup_accessor(target, key, false)
    }
    BuiltinFunction::ObjectLookupSetter => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let key = if args.is_empty() { Undefined } else { args[0] }
      object_lookup_accessor(target, key, true)
    }
    BuiltinFunction::ArrayToString => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = to_object(target)
      let join_method = property_get(obj, "join")
      if is_callable(join_method) {
        call_value_with_this(join_method, [], obj)
      } else {
        String(object_to_string(obj))
      }
    }
    BuiltinFunction::ArrayToLocaleString => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      String(array_to_locale_string_value(target))
    }
    BuiltinFunction::ArrayConstructor => {
      let array_proto_value = match current_env() {
        Some(env) =>
          match value_from_object(array_proto_for_env(env)) {
            Some(value) => Some(value)
            None => value_from_object(array_proto())
          }
        None => value_from_object(array_proto())
      }
      array_from_args_with_proto(args, array_proto_value)
    }
    BuiltinFunction::ArrayIsArray => {
      let value = if args.is_empty() { Undefined } else { args[0] }
      Bool(is_array_value(value))
    }
    BuiltinFunction::ArrayFrom => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      array_from_value(target, args)
    }
    BuiltinFunction::ArrayOf => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      array_of_value(target, args)
    }
    BuiltinFunction::ArrayPush =>
      array_push_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
      )
    BuiltinFunction::ArrayPop =>
      match builtin.this_value {
        Some(this_value) => {
          let obj = to_object(this_value)
          let len = array_like_length_int64(obj)
          let new_len = if len > 0L { len - 1L } else { 0L }
          let mut result = Undefined
          if len > 0L {
            let index_name = Int64::to_string(new_len)
            result = property_get(obj, index_name)
            delete_property_or_throw(obj, index_name)
          }
          let _ = property_set(
            obj,
            "length",
            Number(Int64::to_double(new_len)),
            true,
          )
          result
        }
        None => Undefined
      }
    BuiltinFunction::ArrayShift =>
      match builtin.this_value {
        Some(this_value) => {
          let obj = to_object(this_value)
          let len = array_like_length_int64(obj)
          if len <= 0L {
            let _ = property_set(
              obj,
              "length",
              Number(Double::from_int(0)),
              true,
            )
            Undefined
          } else {
            let first = property_get(obj, "0")
            let mut k = 1L
            while k < len {
              let from = Int64::to_string(k)
              let to = Int64::to_string(k - 1L)
              if has_property(obj, from) {
                let from_value = property_get(obj, from)
                let _ = property_set(obj, to, from_value, true)

              } else {
                delete_property_or_throw(obj, to)
              }
              k = k + 1L
            }
            delete_property_or_throw(obj, Int64::to_string(len - 1L))
            let _ = property_set(
              obj,
              "length",
              Number(Int64::to_double(len - 1L)),
              true,
            )
            first
          }
        }
        None => Undefined
      }
    BuiltinFunction::ArrayUnshift =>
      array_unshift_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
      )
    BuiltinFunction::ArraySplice =>
      array_splice_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
      )
    BuiltinFunction::ArraySlice =>
      array_slice_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
      )
    BuiltinFunction::ArrayReverse =>
      array_reverse_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
      )
    BuiltinFunction::ArrayConcat =>
      match builtin.this_value {
        Some(this_value) => {
          let obj = to_object(this_value)
          let result = array_species_create(obj, 0)
          let max_safe = 9007199254740991L
          let mut n = 0L
          let mut i = -1
          while i < args.length() {
            let element = if i < 0 { obj } else { args[i] }
            if is_concat_spreadable(element) {
              let len = array_like_length_int64(element)
              if n + len > max_safe {
                return throw_type_error("Array too long")
              }
              let mut k = 0L
              while k < len {
                let key = Int64::to_string(k)
                if has_property_value(element, key) {
                  let value = property_get(element, key)
                  create_data_property_or_throw(
                    result,
                    Int64::to_string(n),
                    value,
                  )
                }
                n = n + 1L
                k = k + 1L
              }
            } else {
              if n >= max_safe {
                return throw_type_error("Array too long")
              }
              create_data_property_or_throw(
                result,
                Int64::to_string(n),
                element,
              )
              n = n + 1L
            }
            i = i + 1
          }
          let _ = property_set(
            result,
            "length",
            Number(Int64::to_double(n)),
            true,
          )
          result
        }
        None => new_array_value([])
      }
    BuiltinFunction::ArrayJoin => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let sep_value = if args.is_empty() { None } else { Some(args[0]) }
      String(array_join_value(target, sep_value))
    }
    BuiltinFunction::ArrayIndexOf =>
      array_index_of_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
      )
    BuiltinFunction::ArrayLastIndexOf =>
      array_last_index_of_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
      )
    BuiltinFunction::ArrayIncludes =>
      array_includes_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
      )
    BuiltinFunction::ArrayCopyWithin =>
      array_copy_within_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
      )
    BuiltinFunction::ArrayFill =>
      array_fill_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
      )
    BuiltinFunction::ArrayFind =>
      array_find_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
        ArrayFindKind::Find,
      )
    BuiltinFunction::ArrayFindIndex =>
      array_find_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
        ArrayFindKind::FindIndex,
      )
    BuiltinFunction::ArrayFindLast =>
      array_find_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
        ArrayFindKind::FindLast,
      )
    BuiltinFunction::ArrayFindLastIndex =>
      array_find_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
        ArrayFindKind::FindLastIndex,
      )
    BuiltinFunction::ArrayFlat =>
      array_flatten_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
        false,
      )
    BuiltinFunction::ArrayFlatMap =>
      array_flatten_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
        true,
      )
    BuiltinFunction::ArrayToReversed =>
      array_to_reversed_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
      )
    BuiltinFunction::ArrayToSorted =>
      array_to_sorted_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
      )
    BuiltinFunction::ArrayToSpliced =>
      array_to_spliced_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
      )
    BuiltinFunction::ArrayWith =>
      array_with_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
      )
    BuiltinFunction::ArrayAt => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = to_object(target)
      let len = array_like_length(obj)
      let index = if args.is_empty() {
        0
      } else {
        to_int32_sat(to_number(args[0]))
      }
      let mut actual = index
      if actual < 0 {
        actual = len + actual
      }
      if actual < 0 || actual >= len {
        Undefined
      } else {
        property_get(obj, Int::to_string(actual))
      }
    }
    BuiltinFunction::ArrayMap => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = to_object(target)
      let callback = if args.is_empty() { Undefined } else { args[0] }
      let this_arg = if args.length() > 1 { args[1] } else { Undefined }
      array_iterate(obj, callback, this_arg, ArrayIterKind::Map)
    }
    BuiltinFunction::ArrayForEach => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = to_object(target)
      let callback = if args.is_empty() { Undefined } else { args[0] }
      let this_arg = if args.length() > 1 { args[1] } else { Undefined }
      let _ = array_iterate(obj, callback, this_arg, ArrayIterKind::ForEach)
      Undefined
    }
    BuiltinFunction::ArrayFilter => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = to_object(target)
      let callback = if args.is_empty() { Undefined } else { args[0] }
      let this_arg = if args.length() > 1 { args[1] } else { Undefined }
      array_iterate(obj, callback, this_arg, ArrayIterKind::Filter)
    }
    BuiltinFunction::ArrayEvery => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = to_object(target)
      let callback = if args.is_empty() { Undefined } else { args[0] }
      let this_arg = if args.length() > 1 { args[1] } else { Undefined }
      array_iterate(obj, callback, this_arg, ArrayIterKind::Every)
    }
    BuiltinFunction::ArraySome => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = to_object(target)
      let callback = if args.is_empty() { Undefined } else { args[0] }
      let this_arg = if args.length() > 1 { args[1] } else { Undefined }
      array_iterate(obj, callback, this_arg, ArrayIterKind::SomeMatch)
    }
    BuiltinFunction::ArrayReduce => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = to_object(target)
      let callback = if args.is_empty() { Undefined } else { args[0] }
      let initial = if args.length() > 1 { Some(args[1]) } else { None }
      array_reduce_impl(obj, callback, initial, false)
    }
    BuiltinFunction::ArrayReduceRight => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = to_object(target)
      let callback = if args.is_empty() { Undefined } else { args[0] }
      let initial = if args.length() > 1 { Some(args[1]) } else { None }
      array_reduce_impl(obj, callback, initial, true)
    }
    BuiltinFunction::ArraySort => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = to_object(target)
      let compare_arg = if args.is_empty() { Undefined } else { args[0] }
      let compare_fn = if compare_arg is Undefined {
        None
      } else if !is_callable(compare_arg) {
        return throw_type_error("not a function")
      } else {
        Some(compare_arg)
      }
      array_sort_object(obj, compare_fn)
    }
    BuiltinFunction::ArrayValues => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      new_array_iterator(to_object(target), 1)
    }
    BuiltinFunction::ArrayKeys => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      new_array_iterator(to_object(target), 0)
    }
    BuiltinFunction::ArrayEntries => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      new_array_iterator(to_object(target), 2)
    }
    BuiltinFunction::ArrayIteratorNext =>
      array_iterator_next(builtin.this_value)
    BuiltinFunction::IteratorReturnSelf =>
      iterator_return_self(builtin.this_value)
    BuiltinFunction::AsyncIteratorReturnSelf =>
      iterator_return_self(builtin.this_value)
    BuiltinFunction::AsyncFromSyncIteratorNext =>
      async_from_sync_iterator_step(
        builtin.this_value,
        args,
        async_from_sync_iter_kind_next,
      )
    BuiltinFunction::AsyncFromSyncIteratorReturn =>
      async_from_sync_iterator_step(
        builtin.this_value,
        args,
        async_from_sync_iter_kind_return,
      )
    BuiltinFunction::AsyncFromSyncIteratorThrow =>
      async_from_sync_iterator_step(
        builtin.this_value,
        args,
        async_from_sync_iter_kind_throw,
      )
    BuiltinFunction::AsyncFromSyncIteratorUnwrap =>
      async_from_sync_iterator_unwrap(builtin, args)
    BuiltinFunction::AsyncFromSyncIteratorCloseWrap =>
      async_from_sync_iterator_close_wrap(builtin, args)
    BuiltinFunction::IteratorConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::IteratorFrom =>
      iterator_from_value(if args.is_empty() { Undefined } else { args[0] })
    BuiltinFunction::IteratorConcat => iterator_concat_value(args)
    BuiltinFunction::IteratorConcatNext =>
      iterator_concat_next(builtin.this_value)
    BuiltinFunction::IteratorConcatReturn =>
      iterator_concat_return(builtin.this_value)
    BuiltinFunction::IteratorWrapNext => iterator_wrap_next(builtin.this_value)
    BuiltinFunction::IteratorWrapReturn =>
      iterator_wrap_return(builtin.this_value)
    BuiltinFunction::IteratorHelperNext =>
      iterator_helper_next(builtin.this_value)
    BuiltinFunction::IteratorHelperReturn =>
      iterator_helper_return(builtin.this_value)
    BuiltinFunction::IteratorDrop =>
      iterator_helper_create(
        iterator_helper_kind_drop,
        builtin.this_value,
        args,
      )
    BuiltinFunction::IteratorFilter =>
      iterator_helper_create(
        iterator_helper_kind_filter,
        builtin.this_value,
        args,
      )
    BuiltinFunction::IteratorFlatMap =>
      iterator_helper_create(
        iterator_helper_kind_flat_map,
        builtin.this_value,
        args,
      )
    BuiltinFunction::IteratorMap =>
      iterator_helper_create(iterator_helper_kind_map, builtin.this_value, args)
    BuiltinFunction::IteratorTake =>
      iterator_helper_create(
        iterator_helper_kind_take,
        builtin.this_value,
        args,
      )
    BuiltinFunction::IteratorEvery =>
      iterator_proto_iterate(
        iterator_proto_kind_every,
        builtin.this_value,
        args,
      )
    BuiltinFunction::IteratorFind =>
      iterator_proto_iterate(iterator_proto_kind_find, builtin.this_value, args)
    BuiltinFunction::IteratorForEach =>
      iterator_proto_iterate(
        iterator_proto_kind_for_each,
        builtin.this_value,
        args,
      )
    BuiltinFunction::IteratorSome =>
      iterator_proto_iterate(iterator_proto_kind_some, builtin.this_value, args)
    BuiltinFunction::IteratorReduce =>
      iterator_proto_reduce(builtin.this_value, args)
    BuiltinFunction::IteratorToArray =>
      iterator_proto_to_array(builtin.this_value)
    BuiltinFunction::IteratorConstructorGetter =>
      iterator_constructor_getter(builtin.this_value)
    BuiltinFunction::IteratorConstructorSetter =>
      iterator_constructor_setter(
        builtin.this_value,
        if args.is_empty() {
          Undefined
        } else {
          args[0]
        },
      )
    BuiltinFunction::IteratorToStringTagGetter =>
      iterator_to_string_tag_getter(builtin.this_value)
    BuiltinFunction::IteratorToStringTagSetter =>
      iterator_to_string_tag_setter(
        builtin.this_value,
        if args.is_empty() {
          Undefined
        } else {
          args[0]
        },
      )
    BuiltinFunction::FunctionCall => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      if !is_callable(target) {
        return throw_type_error("not a function")
      }
      if args.is_empty() {
        call_value_with_this(target, [], Undefined)
      } else {
        let rest : Array[Value] = []
        if args.length() > 1 {
          for i = 1; i < args.length(); i = i + 1 {
            rest.push(args[i])
          }
        }
        call_value_with_this(target, rest, args[0])
      }
    }
    BuiltinFunction::FunctionApply => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      if !is_callable(target) {
        return throw_type_error("not a function")
      }
      let this_arg = if args.is_empty() { Undefined } else { args[0] }
      let array_arg = if args.length() < 2 { Undefined } else { args[1] }
      if array_arg is Undefined || array_arg is Null {
        return call_value_with_this(target, [], this_arg)
      }
      if !is_object_like(array_arg) {
        return throw_type_error("argArray is not an object")
      }
      let argv = build_arg_list(array_arg)
      call_value_with_this(target, argv, this_arg)
    }
    BuiltinFunction::ReflectApply => {
      if args.length() < 3 {
        return throw_type_error("invalid arguments")
      }
      let target = args[0]
      if !is_callable(target) {
        return throw_type_error("not a function")
      }
      let this_arg = args[1]
      let array_arg = args[2]
      if !is_object_like(array_arg) {
        return throw_type_error("invalid arguments")
      }
      let argv = build_arg_list(array_arg)
      call_value_with_this(target, argv, this_arg)
    }
    BuiltinFunction::ReflectConstruct => {
      let target = if args.is_empty() { Undefined } else { args[0] }
      let array_arg = if args.length() > 1 { args[1] } else { Undefined }
      let new_target = if args.length() > 2 { args[2] } else { target }
      if !is_constructor_value(target) {
        return throw_not_constructor(target)
      }
      if !is_constructor_value(new_target) {
        return throw_not_constructor(new_target)
      }
      if !is_object_like(array_arg) {
        return throw_type_error("invalid arguments")
      }
      let argv = build_arg_list(array_arg)
      call_constructor(target, argv, new_target~)
    }
    BuiltinFunction::ReflectGet => {
      if args.is_empty() {
        return throw_type_error("not an object")
      }
      let target = args[0]
      if !is_object_like(target) {
        return throw_type_error("not an object")
      }
      let key = if args.length() > 1 { args[1] } else { Undefined }
      let receiver = if args.length() > 2 { args[2] } else { target }
      let name = property_key_name(key)
      property_get_with_receiver(target, name, receiver)
    }
    BuiltinFunction::ReflectGetOwnPropertyDescriptor => {
      if args.is_empty() {
        return throw_type_error("not an object")
      }
      let target = args[0]
      if !is_object_like(target) {
        return throw_type_error("not an object")
      }
      let key = if args.length() > 1 { args[1] } else { Undefined }
      let name = property_key_name(key)
      get_own_property_descriptor(target, name)
    }
    BuiltinFunction::ReflectGetPrototypeOf => {
      if args.is_empty() {
        return throw_type_error("not an object")
      }
      let target = args[0]
      if !is_object_like(target) {
        return throw_type_error("not an object")
      }
      match get_proto_of_value_checked(target) {
        Some(proto) => proto
        None => Null
      }
    }
    BuiltinFunction::ReflectDefineProperty => {
      if args.is_empty() {
        return throw_type_error("not an object")
      }
      let target = args[0]
      if !is_object_like(target) {
        return throw_type_error("not an object")
      }
      let key = if args.length() > 1 { args[1] } else { Undefined }
      let desc = if args.length() > 2 { args[2] } else { Undefined }
      Bool(define_property_value(target, key, desc, false))
    }
    BuiltinFunction::ReflectHas => {
      if args.is_empty() {
        return throw_type_error("not an object")
      }
      let target = args[0]
      if !is_object_like(target) {
        return throw_type_error("not an object")
      }
      let key = if args.length() > 1 { args[1] } else { Undefined }
      let name = property_key_name(key)
      Bool(has_property_value(target, name))
    }
    BuiltinFunction::ReflectIsExtensible => {
      if args.is_empty() {
        return throw_type_error("not an object")
      }
      let target = args[0]
      if !is_object_like(target) {
        return throw_type_error("not an object")
      }
      Bool(is_extensible_value_checked(target))
    }
    BuiltinFunction::ReflectSet => {
      if args.is_empty() {
        return throw_type_error("not an object")
      }
      let target = args[0]
      if !is_object_like(target) {
        return throw_type_error("not an object")
      }
      let key = if args.length() > 1 { args[1] } else { Undefined }
      let value = if args.length() > 2 { args[2] } else { Undefined }
      let receiver = if args.length() > 3 { args[3] } else { target }
      let name = property_key_name(key)
      Bool(set_value_with_receiver(target, name, value, receiver))
    }
    BuiltinFunction::ReflectSetPrototypeOf => {
      if args.is_empty() {
        return throw_type_error("not an object")
      }
      let target = args[0]
      if !is_object_like(target) {
        return throw_type_error("not an object")
      }
      let proto_value = if args.length() > 1 { args[1] } else { Undefined }
      match proto_value {
        _ if is_object_like(proto_value) =>
          Bool(set_proto_of_value(target, Some(proto_value), false))
        Null => Bool(set_proto_of_value(target, None, false))
        _ => throw_type_error("not a prototype")
      }
    }
    BuiltinFunction::ReflectDeleteProperty => {
      if args.is_empty() {
        return throw_type_error("not an object")
      }
      let target = args[0]
      if !is_object_like(target) {
        return throw_type_error("not an object")
      }
      let key = if args.length() > 1 { args[1] } else { Undefined }
      let name = property_key_name(key)
      Bool(delete_property_value(target, name))
    }
    BuiltinFunction::ReflectPreventExtensions => {
      if args.is_empty() {
        return throw_type_error("not an object")
      }
      let target = args[0]
      if !is_object_like(target) {
        return throw_type_error("not an object")
      }
      Bool(prevent_extensions_value(target))
    }
    BuiltinFunction::ReflectOwnKeys => {
      if args.is_empty() {
        return throw_type_error("not an object")
      }
      let target = args[0]
      if !is_object_like(target) {
        return throw_type_error("not an object")
      }
      let values : Array[Value?] = match target {
        Object(raw) =>
          match raw.proxy_data {
            Some(data) => {
              let keys = proxy_own_keys_values(data)
              let items : Array[Value?] = []
              for key in keys {
                items.push(Some(key))
              }
              items
            }
            None => {
              let keys = own_string_keys(target)
              let symbols = own_symbol_keys(target, true)
              let items : Array[Value?] = []
              for name in keys {
                items.push(Some(String(name)))
              }
              for symbol in symbols {
                items.push(Some(Symbol(symbol)))
              }
              items
            }
          }
        _ => {
          let keys = own_string_keys(target)
          let symbols = own_symbol_keys(target, true)
          let items : Array[Value?] = []
          for name in keys {
            items.push(Some(String(name)))
          }
          for symbol in symbols {
            items.push(Some(Symbol(symbol)))
          }
          items
        }
      }
      new_array_value(values)
    }
    BuiltinFunction::Eval => {
      let eval_env = match builtin.realm_env {
        Some(env) => env
        None =>
          match root_env() {
            Some(env) => env
            None => Env::new(None)
          }
      }
      eval_with_env_mode(eval_env, args, false)
    }
    BuiltinFunction::ModuleImport => {
      if args.is_empty() {
        return throw_type_error("missing module specifier")
      }
      let specifier = to_string_value(args[0])
      let attributes = if args.length() > 1 {
        module_attributes_from_value(args[1])
      } else {
        Undefined
      }
      module_import_from_specifier(specifier, attributes, true)
    }
    BuiltinFunction::ModuleImportDynamic => {
      if args.is_empty() {
        return throw_type_error("missing module specifier")
      }
      let (promise, resolve, reject) = new_promise_capability(Undefined)
      let mut base_path : String? = None
      match current_source_path() {
        Some(path) => base_path = Some(path)
        None =>
          match current_function() {
            Some(func) =>
              match func.source_path {
                Some(path) => base_path = Some(path)
                None => ()
              }
            None => ()
          }
      }
      try {
        let specifier = to_string_strict(args[0])
        let options = if args.length() > 1 { args[1] } else { Undefined }
        let attributes = module_attributes_from_options(options)
        let job = new_builtin_value(BuiltinFunction::ModuleImportDynamicJob)
        match job {
          Builtin(builtin) =>
            module_import_dynamic_job_data_set(builtin.id, ModuleImportDynamicJobData::{
              resolve,
              reject,
              specifier,
              attributes,
              base_path,
            })
          _ => ()
        }
        enqueue_job(job, [])
        promise
      } catch {
        ThrowSignal(value) => {
          let _ = call_value_with_this(reject, [value], Undefined)
          promise
        }
        err => raise err
      }
    }
    BuiltinFunction::ModuleImportDynamicJob => {
      match module_import_dynamic_job_data_take(builtin.id) {
        Some(data) =>
          try {
            let module_value = match data.base_path {
              Some(path) =>
                with_source_path(path, fn() raise {
                  module_import_from_specifier(
                    data.specifier,
                    data.attributes,
                    false,
                  )
                })
              None =>
                module_import_from_specifier(
                  data.specifier,
                  data.attributes,
                  false,
                )
            }
            let cache_key = match data.base_path {
              Some(path) =>
                with_source_path_string_option(path, fn() raise {
                  module_cache_key_from_specifier(
                    data.specifier,
                    data.attributes,
                  )
                })
              None =>
                module_cache_key_from_specifier(data.specifier, data.attributes)
            }
            match cache_key {
              Some(key) => {
                let eval_promise = module_evaluate(key)
                let chained = promise_then_value(eval_promise, module_value)
                let _ = promise_invoke_then(chained, data.resolve, data.reject)

              }
              None => {
                let _ = call_value_with_this(
                  data.resolve,
                  [module_value],
                  Undefined,
                )

              }
            }
          } catch {
            ThrowSignal(value) => {
              let _ = call_value_with_this(data.reject, [value], Undefined)

            }
            err => raise err
          }
        None => ()
      }
      Undefined
    }
    BuiltinFunction::ModuleImportBinding => {
      if args.length() < 2 {
        return throw_type_error("missing import binding")
      }
      let specifier = to_string_value(args[0])
      let name = to_string_value(args[1])
      let attributes = if args.length() > 2 {
        module_attributes_from_value(args[2])
      } else {
        Undefined
      }
      if name != "default" {
        match module_builtin_value(specifier) {
          Some(_) => ()
          None => {
            let full_path = resolve_path_from_source(specifier)
            let mut json_kind = module_test_json(attributes)
            if json_kind == 0 && full_path.has_suffix(".json") {
              json_kind = 1
            }
            if json_kind > 0 {
              return throw_syntax_error(
                "JSON modules do not support named imports",
              )
            }
          }
        }
      }
      let module_value = module_import_from_specifier(
        specifier, attributes, true,
      )
      let cache_key = module_cache_key_from_specifier(specifier, attributes)
      let export_target = match cache_key {
        Some(key) =>
          match module_record_get(key) {
            Some(record) => Object(record.exports)
            None => module_value
          }
        None => module_value
      }
      let mut resolved = false
      match cache_key {
        Some(key) =>
          match module_export_info_get(key) {
            Some(_) => {
              let result = module_resolve_export_name(key, name)
              if result.status == 0 {
                return throw_syntax_error("module export '\{name}' not found")
              } else if result.status == 2 {
                return throw_syntax_error("ambiguous export '\{name}'")
              }
              resolved = true
            }
            None => ()
          }
        None => ()
      }
      if !resolved && !has_property_value(export_target, name) {
        return throw_syntax_error("module export '\{name}' not found")
      }
      new_module_binding_value(export_target, name)
    }
    BuiltinFunction::ModuleBinding => {
      if args.is_empty() {
        return throw_type_error("missing binding name")
      }
      let name = to_string_value(args[0])
      match current_module_env_id() {
        Some(env_id) =>
          match module_env_get(env_id) {
            Some(env) =>
              match env.bindings.get(name) {
                Some(value) => value
                None => Undefined
              }
            None => throw_type_error("binding not in module")
          }
        None => throw_type_error("binding not in module")
      }
    }
    BuiltinFunction::ModuleExport => {
      if args.length() < 2 {
        return throw_type_error("missing export")
      }
      let name = to_string_value(args[0])
      let value = args[1]
      let binding_name = if args.length() > 2 {
        match args[2] {
          Null | Undefined => None
          _ => Some(to_string_value(args[2]))
        }
      } else {
        None
      }
      match current_module_exports() {
        Some(exports) => {
          let mut export_value = value
          if binding_name is None && name == "default" {
            set_anonymous_function_name(export_value, "default", None)
          }
          match current_module_env_id() {
            Some(env_id) => module_env_export_uninitialized_remove(env_id, name)
            None => ()
          }
          match (current_module_env_id(), binding_name) {
            (Some(env_id), Some(binding)) => {
              module_env_export_names_add(env_id, binding, name)
              match module_env_get(env_id) {
                Some(env) =>
                  match env.bindings.get(binding) {
                    Some(raw_value) =>
                      match module_binding_info(raw_value) {
                        Some(_) => export_value = raw_value
                        None => ()
                      }
                    None => ()
                  }
                None => ()
              }
            }
            _ => ()
          }
          exports.props.set(name, Property::{
            value: export_value,
            writable: false,
            configurable: false,
            enumerable: true,
            getter: None,
            setter: None,
          })
          match current_source_path() {
            Some(path) => module_namespace_add_export(path, exports, name)
            None => ()
          }
          export_value
        }
        None => throw_type_error("export not in module")
      }
    }
    BuiltinFunction::ModuleExportStar => {
      if args.is_empty() {
        return throw_type_error("missing module specifier")
      }
      let specifier = to_string_value(args[0])
      let attributes = if args.length() > 1 {
        module_attributes_from_value(args[1])
      } else {
        Undefined
      }
      let module_value = module_import_from_specifier(
        specifier, attributes, true,
      )
      let module_obj = to_object(module_value)
      let props = props_map_for_value(module_obj)
      match current_module_exports() {
        Some(exports) => {
          let mut module_path : String? = None
          match current_source_path() {
            Some(path) => module_path = Some(path)
            None => ()
          }
          match props {
            Some(props) =>
              for name, prop in props {
                if name == "default" || !prop.enumerable {
                  continue
                }
                let mut is_ambiguous = false
                match module_path {
                  Some(path) =>
                    match module_export_info_get(path) {
                      Some(_) => {
                        let result = module_resolve_export_name(path, name)
                        if result.status == 2 {
                          is_ambiguous = true
                        }
                      }
                      None => ()
                    }
                  None => ()
                }
                if is_ambiguous {
                  if exports.props.contains(name) {
                    exports.props.remove(name)
                  }
                  match module_path {
                    Some(path) => module_namespace_remove_export(path, name)
                    None => ()
                  }
                  continue
                }
                if exports.props.contains(name) {
                  continue
                }
                let value = new_module_binding_value(module_obj, name)
                exports.props.set(name, Property::{
                  value,
                  writable: false,
                  configurable: false,
                  enumerable: true,
                  getter: None,
                  setter: None,
                })
                match module_path {
                  Some(path) => module_namespace_add_export(path, exports, name)
                  None => ()
                }
              }
            None => ()
          }
          module_obj
        }
        None => throw_type_error("export not in module")
      }
    }
    BuiltinFunction::ModuleAsyncFulfilled => {
      match module_async_callback_data_get(builtin.id) {
        Some(path) => module_async_evaluation_fulfilled(path)
        None => ()
      }
      Undefined
    }
    BuiltinFunction::ModuleAsyncRejected => {
      let error = if args.is_empty() { Undefined } else { args[0] }
      match module_async_callback_data_get(builtin.id) {
        Some(path) => module_async_evaluation_rejected(path, error)
        None => ()
      }
      Undefined
    }
    BuiltinFunction::IsNaN => {
      let value = if args.is_empty() { Undefined } else { args[0] }
      Bool(Double::is_nan(to_number(value)))
    }
    BuiltinFunction::IsFinite => {
      let value = if args.is_empty() { Undefined } else { args[0] }
      let num = to_number(value)
      Bool(!Double::is_nan(num) && !Double::is_inf(num))
    }
    BuiltinFunction::FunctionBind => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      if !is_callable(target) {
        return throw_type_error("not a function")
      }
      let this_arg = if args.is_empty() { Undefined } else { args[0] }
      let bound_args : Array[Value] = []
      if args.length() > 1 {
        for i = 1; i < args.length(); i = i + 1 {
          bound_args.push(args[i])
        }
      }
      new_bound_function(target, this_arg, bound_args)
    }
    BuiltinFunction::FunctionToString => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      String(function_to_string_value(target))
    }
    BuiltinFunction::FunctionProtoLineNumber =>
      function_debug_location(builtin.this_value, false)
    BuiltinFunction::FunctionProtoColumnNumber =>
      function_debug_location(builtin.this_value, true)
    BuiltinFunction::FunctionSymbolHasInstance => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      if !is_callable(target) {
        return Bool(false)
      }
      let value = if args.is_empty() { Undefined } else { args[0] }
      Bool(ordinary_instanceof(value, target))
    }
    BuiltinFunction::BooleanConstructor => {
      if args.is_empty() {
        return Bool(false)
      }
      Bool(is_truthy(args[0]))
    }
    BuiltinFunction::BooleanToString => {
      let value = this_to_bool(builtin.this_value)
      if value {
        String("true")
      } else {
        String("false")
      }
    }
    BuiltinFunction::BooleanValueOf => Bool(this_to_bool(builtin.this_value))
    BuiltinFunction::StringConstructor => {
      if args.is_empty() {
        return String("")
      }
      match args[0] {
        Symbol(symbol) => String(symbol_to_string(symbol))
        _ => String(to_string_strict(args[0]))
      }
    }
    BuiltinFunction::StringFromCharCode => String(string_from_char_codes(args))
    BuiltinFunction::StringFromCodePoint =>
      String(string_from_code_points(args))
    BuiltinFunction::StringRaw => {
      let callsite = if args.is_empty() {
        to_object(Undefined)
      } else {
        to_object(args[0])
      }
      let raw_value = property_get(callsite, "raw")
      let raw_obj = to_object(raw_value)
      let len_value = property_get(raw_obj, "length")
      let len = to_length_int64(to_number(len_value))
      let mut result = ""
      let mut i = 0L
      while i < len {
        let part = property_get(raw_obj, Int64::to_string(i))
        result = result + to_string_strict(part)
        let arg_index = i + 1L
        if arg_index < len && arg_index < Int64::from_int(args.length()) {
          let arg_pos = Int64::to_int(arg_index)
          result = result + to_string_strict(args[arg_pos])
        }
        i = i + 1L
      }
      String(result)
    }
    BuiltinFunction::StringCharCodeAt => {
      let value = this_to_string_coerce(builtin.this_value)
      let index = if args.is_empty() {
        0
      } else {
        to_int32_sat(to_number(args[0]))
      }
      if index < 0 || index >= value.length() {
        Number(nan())
      } else {
        let code = value.code_unit_at(index)
        Number(Double::from_int(UInt16::to_int(code)))
      }
    }
    BuiltinFunction::StringCharAt => {
      let value = this_to_string_coerce(builtin.this_value)
      let index = if args.is_empty() {
        0
      } else {
        to_int32_sat(to_number(args[0]))
      }
      if index < 0 || index >= value.length() {
        String("")
      } else {
        String(value.unsafe_substring(start=index, end=index + 1))
      }
    }
    BuiltinFunction::StringCodePointAt => {
      let value = this_to_string_coerce(builtin.this_value)
      let index = if args.is_empty() {
        0
      } else {
        to_int32_sat(to_number(args[0]))
      }
      if index < 0 || index >= value.length() {
        Undefined
      } else {
        let first = UInt16::to_int(value.code_unit_at(index))
        if first >= 0xD800 && first <= 0xDBFF && index + 1 < value.length() {
          let second = UInt16::to_int(value.code_unit_at(index + 1))
          if second >= 0xDC00 && second <= 0xDFFF {
            let code_point = 0x10000 +
              ((first - 0xD800) << 10) +
              (second - 0xDC00)
            Number(Double::from_int(code_point))
          } else {
            Number(Double::from_int(first))
          }
        } else {
          Number(Double::from_int(first))
        }
      }
    }
    BuiltinFunction::StringConcat => {
      let value = this_to_string_coerce(builtin.this_value)
      let mut result = value
      for arg in args {
        result = result + to_string_strict(arg)
      }
      String(result)
    }
    BuiltinFunction::StringSubstring => {
      let value = this_to_string_coerce(builtin.this_value)
      let len = value.length()
      let start = if args.is_empty() {
        0
      } else {
        clamp_index(to_number(args[0]), len)
      }
      let end = if args.length() < 2 || args[1] is Undefined {
        len
      } else {
        clamp_index(to_number(args[1]), len)
      }
      let (from, to) = if start > end { (end, start) } else { (start, end) }
      String(value.unsafe_substring(start=from, end=to))
    }
    BuiltinFunction::StringSubstr => {
      let value = this_to_string_coerce(builtin.this_value)
      let len = value.length()
      let start = if args.is_empty() {
        0
      } else {
        to_int32_sat(to_number(args[0]))
      }
      let mut from = start
      if from < 0 {
        from = from + len
        if from < 0 {
          from = 0
        }
      } else if from > len {
        from = len
      }
      let mut count = len - from
      if args.length() > 1 && !(args[1] is Undefined) {
        let limit = to_int32_sat(to_number(args[1]))
        let mut size = limit
        if size < 0 {
          size = 0
        }
        let max_len = len - from
        if size > max_len {
          size = max_len
        }
        count = size
      }
      String(value.unsafe_substring(start=from, end=from + count))
    }
    BuiltinFunction::StringSlice => {
      let value = this_to_string_coerce(builtin.this_value)
      let len = value.length()
      let start = if args.is_empty() {
        0
      } else {
        slice_index(to_number(args[0]), len)
      }
      let end = if args.length() < 2 || args[1] is Undefined {
        len
      } else {
        slice_index(to_number(args[1]), len)
      }
      if end <= start {
        String("")
      } else {
        String(value.unsafe_substring(start~, end~))
      }
    }
    BuiltinFunction::StringIndexOf => {
      let value = this_to_string_coerce(builtin.this_value)
      let search = if args.is_empty() {
        to_string_strict(Undefined)
      } else {
        to_string_strict(args[0])
      }
      let len = value.length()
      let from = if args.length() < 2 {
        0
      } else {
        clamp_index(to_number(args[1]), len)
      }
      let index = string_index_of(value, search, from)
      Number(Double::from_int(index))
    }
    BuiltinFunction::StringLastIndexOf => {
      let value = this_to_string_coerce(builtin.this_value)
      let search = if args.is_empty() {
        to_string_strict(Undefined)
      } else {
        to_string_strict(args[0])
      }
      let len = value.length()
      let from = if args.length() < 2 {
        len
      } else {
        clamp_last_index(to_number(args[1]), len)
      }
      let index = string_last_index_of(value, search, from)
      Number(Double::from_int(index))
    }
    BuiltinFunction::StringSplit => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      if !args.is_empty() && is_object_like(args[0]) {
        match symbol_split_key() {
          Some(key) =>
            match property_get(args[0], key) {
              Undefined | Null => ()
              splitter =>
                return call_value_with_this(
                  splitter,
                  [
                    this_value,
                    if args.length() > 1 {
                      args[1]
                    } else {
                      Undefined
                    },
                  ],
                  args[0],
                )
            }
          None => ()
        }
      }
      let value = this_to_string_coerce(builtin.this_value)
      let limit = if args.length() < 2 || args[1] is Undefined {
        0xffffffffU
      } else {
        to_uint32(to_number(args[1]))
      }
      string_split_value(value, args, limit)
    }
    BuiltinFunction::StringPadStart => {
      let value = this_to_string_coerce(builtin.this_value)
      let target = if args.is_empty() { 0.0 } else { to_number(args[0]) }
      let fill = if args.length() < 2 || args[1] is Undefined {
        " "
      } else {
        to_string_strict(args[1])
      }
      if Double::is_inf(target) || Double::is_nan(target) {
        String(value)
      } else {
        let target_len = Double::to_int(Double::trunc(target))
        String(string_pad_start(value, target_len, fill))
      }
    }
    BuiltinFunction::StringPadEnd => {
      let value = this_to_string_coerce(builtin.this_value)
      let target = if args.is_empty() { 0.0 } else { to_number(args[0]) }
      let fill = if args.length() < 2 || args[1] is Undefined {
        " "
      } else {
        to_string_strict(args[1])
      }
      if Double::is_inf(target) || Double::is_nan(target) {
        String(value)
      } else {
        let target_len = Double::to_int(Double::trunc(target))
        String(string_pad_end(value, target_len, fill))
      }
    }
    BuiltinFunction::StringAt => {
      let value = this_to_string_coerce(builtin.this_value)
      let len = value.length()
      let index = if args.is_empty() {
        0
      } else {
        to_int32_sat(to_number(args[0]))
      }
      let mut idx = index
      if idx < 0 {
        idx = idx + len
      }
      if idx < 0 || idx >= len {
        Undefined
      } else {
        String(value.unsafe_substring(start=idx, end=idx + 1))
      }
    }
    BuiltinFunction::StringIncludes => {
      let value = this_to_string_coerce(builtin.this_value)
      let search_value = if args.is_empty() { Undefined } else { args[0] }
      if is_regexp_value(search_value) {
        let _ = throw_type_error("regexp not supported")

      }
      let search = to_string_strict(search_value)
      let len = value.length()
      let from = if args.length() > 1 && !(args[1] is Undefined) {
        clamp_index(to_number(args[1]), len)
      } else {
        0
      }
      Bool(string_index_of(value, search, from) >= 0)
    }
    BuiltinFunction::StringStartsWith => {
      let value = this_to_string_coerce(builtin.this_value)
      let search_value = if args.is_empty() { Undefined } else { args[0] }
      if is_regexp_value(search_value) {
        let _ = throw_type_error("regexp not supported")

      }
      let search = to_string_strict(search_value)
      let len = value.length()
      let pos = if args.length() > 1 && !(args[1] is Undefined) {
        clamp_index(to_number(args[1]), len)
      } else {
        0
      }
      if search.is_empty() {
        Bool(true)
      } else if pos + search.length() > len {
        Bool(false)
      } else {
        let slice = value.unsafe_substring(start=pos, end=pos + search.length())
        Bool(slice == search)
      }
    }
    BuiltinFunction::StringEndsWith => {
      let value = this_to_string_coerce(builtin.this_value)
      let search_value = if args.is_empty() { Undefined } else { args[0] }
      if is_regexp_value(search_value) {
        let _ = throw_type_error("regexp not supported")

      }
      let search = to_string_strict(search_value)
      let len = value.length()
      let end = if args.length() > 1 && !(args[1] is Undefined) {
        clamp_index(to_number(args[1]), len)
      } else {
        len
      }
      let search_len = search.length()
      if search_len == 0 {
        Bool(true)
      } else if search_len > end {
        Bool(false)
      } else {
        let start = end - search_len
        let slice = value.unsafe_substring(start~, end~)
        Bool(slice == search)
      }
    }
    BuiltinFunction::StringRepeat => {
      let value = this_to_string_coerce(builtin.this_value)
      let count_num = if args.is_empty() {
        to_number(Undefined)
      } else {
        to_number(args[0])
      }
      if Double::is_inf(count_num) || count_num < 0.0 {
        throw_range_error("invalid repeat count")
      } else {
        let count = if Double::is_nan(count_num) {
          0
        } else {
          Int64::to_int(Double::to_int64(Double::trunc(count_num)))
        }
        if count < 0 || count > 2147483647 {
          throw_range_error("invalid repeat count")
        } else if count == 0 {
          String("")
        } else if count == 1 {
          String(value)
        } else {
          let len = value.length()
          if len > 0 && count > js_string_len_max / len {
            throw_range_error("invalid string length")
          } else {
            String(value.repeat(count))
          }
        }
      }
    }
    BuiltinFunction::StringReplace => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      string_replace_value(this_value, args)
    }
    BuiltinFunction::StringReplaceAll => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      string_replace_all_value(this_value, args)
    }
    BuiltinFunction::StringTrim => {
      let value = this_to_string_coerce(builtin.this_value)
      String(trim_js_whitespace(value))
    }
    BuiltinFunction::StringTrimStart => {
      let value = this_to_string_coerce(builtin.this_value)
      String(trim_js_whitespace_start(value))
    }
    BuiltinFunction::StringTrimEnd => {
      let value = this_to_string_coerce(builtin.this_value)
      String(trim_js_whitespace_end(value))
    }
    BuiltinFunction::StringToLowerCase => {
      let value = this_to_string_coerce(builtin.this_value)
      String(string_case_convert(value, true))
    }
    BuiltinFunction::StringToUpperCase => {
      let value = this_to_string_coerce(builtin.this_value)
      String(string_case_convert(value, false))
    }
    BuiltinFunction::StringToLocaleLowerCase => {
      let value = this_to_string_coerce(builtin.this_value)
      String(string_case_convert(value, true))
    }
    BuiltinFunction::StringToLocaleUpperCase => {
      let value = this_to_string_coerce(builtin.this_value)
      String(string_case_convert(value, false))
    }
    BuiltinFunction::StringLocaleCompare => {
      let value = this_to_string_coerce(builtin.this_value)
      let other = if args.is_empty() {
        to_string_strict(Undefined)
      } else {
        to_string_strict(args[0])
      }
      let left = string_normalize_form(value, "NFC")
      let right = string_normalize_form(other, "NFC")
      Number(Double::from_int(string_lex_compare(left, right)))
    }
    BuiltinFunction::StringNormalize => {
      let value = this_to_string_coerce(builtin.this_value)
      let form = if args.is_empty() || args[0] is Undefined {
        "NFC"
      } else {
        to_string_strict(args[0])
      }
      String(string_normalize_form(value, form))
    }
    BuiltinFunction::StringIsWellFormed => {
      let value = this_to_string_coerce(builtin.this_value)
      Bool(string_find_invalid_codepoint(value) < 0)
    }
    BuiltinFunction::StringToWellFormed => {
      let value = this_to_string_coerce(builtin.this_value)
      if string_find_invalid_codepoint(value) < 0 {
        String(value)
      } else {
        String(string_to_well_formed(value))
      }
    }
    BuiltinFunction::StringMatch => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let value = this_to_string_coerce(builtin.this_value)
      let search = if args.is_empty() { Undefined } else { args[0] }
      string_match_value(this_value, value, search)
    }
    BuiltinFunction::StringMatchAll => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let value = this_to_string_coerce(builtin.this_value)
      let search = if args.is_empty() { Undefined } else { args[0] }
      string_match_all_value(this_value, value, search)
    }
    BuiltinFunction::StringSearch => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let value = this_to_string_coerce(builtin.this_value)
      let search = if args.is_empty() { Undefined } else { args[0] }
      string_search_value(this_value, value, search)
    }
    BuiltinFunction::StringToString =>
      String(this_to_string(builtin.this_value))
    BuiltinFunction::StringValueOf => String(this_to_string(builtin.this_value))
    BuiltinFunction::StringAnchor =>
      string_create_html(builtin.this_value, args, "a", Some("name"))
    BuiltinFunction::StringBig =>
      string_create_html(builtin.this_value, args, "big", None)
    BuiltinFunction::StringBlink =>
      string_create_html(builtin.this_value, args, "blink", None)
    BuiltinFunction::StringBold =>
      string_create_html(builtin.this_value, args, "b", None)
    BuiltinFunction::StringFixed =>
      string_create_html(builtin.this_value, args, "tt", None)
    BuiltinFunction::StringFontcolor =>
      string_create_html(builtin.this_value, args, "font", Some("color"))
    BuiltinFunction::StringFontsize =>
      string_create_html(builtin.this_value, args, "font", Some("size"))
    BuiltinFunction::StringItalics =>
      string_create_html(builtin.this_value, args, "i", None)
    BuiltinFunction::StringLink =>
      string_create_html(builtin.this_value, args, "a", Some("href"))
    BuiltinFunction::StringSmall =>
      string_create_html(builtin.this_value, args, "small", None)
    BuiltinFunction::StringStrike =>
      string_create_html(builtin.this_value, args, "strike", None)
    BuiltinFunction::StringSub =>
      string_create_html(builtin.this_value, args, "sub", None)
    BuiltinFunction::StringSup =>
      string_create_html(builtin.this_value, args, "sup", None)
    BuiltinFunction::StringIterator => {
      let text = match builtin.this_value {
        Some(Null) | Some(Undefined) | None => {
          let _ = throw_type_error("not a string")
          ""
        }
        Some(value) => to_string_strict(value)
      }
      new_string_iterator(String(text))
    }
    BuiltinFunction::StringIteratorNext =>
      string_iterator_next(builtin.this_value)
    BuiltinFunction::NumberConstructor => {
      if args.is_empty() {
        return Number(0.0)
      }
      let prim = if is_object_like(args[0]) {
        to_primitive(args[0], false)
      } else {
        args[0]
      }
      match prim {
        Symbol(_) => throw_type_error("cannot convert symbol to number")
        BigInt(b) => Number(bigint_to_number(b))
        _ => Number(to_number(prim))
      }
    }
    BuiltinFunction::NumberIsNaN => {
      if args.is_empty() {
        return Bool(false)
      }
      match args[0] {
        Number(value) => Bool(Double::is_nan(value))
        _ => Bool(false)
      }
    }
    BuiltinFunction::NumberIsFinite => {
      if args.is_empty() {
        return Bool(false)
      }
      match args[0] {
        Number(value) => Bool(!Double::is_nan(value) && !Double::is_inf(value))
        _ => Bool(false)
      }
    }
    BuiltinFunction::NumberIsInteger => {
      if args.is_empty() {
        return Bool(false)
      }
      match args[0] {
        Number(value) =>
          if Double::is_nan(value) || Double::is_inf(value) {
            Bool(false)
          } else {
            Bool(Double::trunc(value) == value)
          }
        _ => Bool(false)
      }
    }
    BuiltinFunction::NumberIsSafeInteger => {
      if args.is_empty() {
        return Bool(false)
      }
      match args[0] {
        Number(value) =>
          if Double::is_nan(value) || Double::is_inf(value) {
            Bool(false)
          } else if Double::trunc(value) != value {
            Bool(false)
          } else {
            Bool(Double::abs(value) <= 9007199254740991.0)
          }
        _ => Bool(false)
      }
    }
    BuiltinFunction::NumberToString => {
      let value = this_to_number(builtin.this_value)
      if args.is_empty() || args[0] is Undefined {
        String(number_to_string_radix(value, 10))
      } else {
        let radix = Double::to_int(Double::trunc(to_number(args[0])))
        if radix < 2 || radix > 36 {
          throw_range_error("radix must be between 2 and 36")
        } else {
          String(number_to_string_radix(value, radix))
        }
      }
    }
    BuiltinFunction::NumberToLocaleString => {
      let value = this_to_number(builtin.this_value)
      String(number_to_string_radix(value, 10))
    }
    BuiltinFunction::NumberToFixed => {
      let value = this_to_number(builtin.this_value)
      let arg = if args.is_empty() { Undefined } else { args[0] }
      let digits = to_int32_sat(to_number(arg))
      if digits < 0 || digits > 100 {
        throw_range_error("invalid number of digits")
      } else {
        String(number_to_fixed(value, digits))
      }
    }
    BuiltinFunction::NumberToExponential => {
      let value = this_to_number(builtin.this_value)
      let arg = if args.is_empty() { Undefined } else { args[0] }
      let digits = to_int32_sat(to_number(arg))
      if Double::is_nan(value) || Double::is_inf(value) {
        String(number_to_string_radix(value, 10))
      } else if arg is Undefined {
        String(number_to_exponential_free(value))
      } else if digits < 0 || digits > 100 {
        throw_range_error("invalid number of digits")
      } else {
        String(number_to_exponential(value, digits))
      }
    }
    BuiltinFunction::NumberToPrecision => {
      let value = this_to_number(builtin.this_value)
      let arg = if args.is_empty() { Undefined } else { args[0] }
      let precision = to_int32_sat(to_number(arg))
      if arg is Undefined {
        String(number_to_string_radix(value, 10))
      } else if Double::is_nan(value) || Double::is_inf(value) {
        String(number_to_string_radix(value, 10))
      } else if precision < 1 || precision > 100 {
        throw_range_error("invalid number of digits")
      } else {
        String(number_to_precision(value, precision))
      }
    }
    BuiltinFunction::NumberValueOf => Number(this_to_number(builtin.this_value))
    BuiltinFunction::BigIntConstructor => {
      if args.is_empty() {
        return throw_type_error("cannot convert to BigInt")
      }
      BigInt(bigint_from_value(args[0]))
    }
    BuiltinFunction::BigIntToString => {
      let value = this_to_bigint(builtin.this_value)
      if args.is_empty() || args[0] is Undefined {
        String(bigint_to_string_radix(value, 10))
      } else {
        let radix = Double::to_int(Double::trunc(to_number(args[0])))
        if radix < 2 || radix > 36 {
          throw_range_error("invalid radix")
        } else {
          String(bigint_to_string_radix(value, radix))
        }
      }
    }
    BuiltinFunction::BigIntValueOf => BigInt(this_to_bigint(builtin.this_value))
    BuiltinFunction::BigIntAsIntN => {
      let bits_value = if args.is_empty() { Undefined } else { args[0] }
      let bigint_value = if args.length() > 1 { args[1] } else { Undefined }
      bigint_as_n(bits_value, bigint_value, true)
    }
    BuiltinFunction::BigIntAsUintN => {
      let bits_value = if args.is_empty() { Undefined } else { args[0] }
      let bigint_value = if args.length() > 1 { args[1] } else { Undefined }
      bigint_as_n(bits_value, bigint_value, false)
    }
    BuiltinFunction::SymbolConstructor => {
      let description = if args.is_empty() || args[0] is Undefined {
        None
      } else {
        Some(to_string_strict(args[0]))
      }
      let symbol = SymbolValue::{
        id: alloc_symbol_id(),
        description,
        key: None,
      }
      register_symbol(symbol)
      Symbol(symbol)
    }
    BuiltinFunction::SymbolFor => {
      let key_value = if args.is_empty() { Undefined } else { args[0] }
      let key = to_string_strict(key_value)
      match symbol_registry_get(key) {
        Some(symbol) => Symbol(symbol)
        None => {
          let symbol = SymbolValue::{
            id: alloc_symbol_id(),
            description: Some(key),
            key: Some(key),
          }
          symbol_registry_set(key, symbol)
          register_symbol(symbol)
          Symbol(symbol)
        }
      }
    }
    BuiltinFunction::SymbolKeyFor => {
      if args.is_empty() {
        return throw_type_error("not a symbol")
      }
      match args[0] {
        Symbol(symbol) =>
          match symbol.key {
            Some(key) => String(key)
            None => Undefined
          }
        _ => throw_type_error("not a symbol")
      }
    }
    BuiltinFunction::SymbolToString =>
      String(symbol_to_string(this_to_symbol(builtin.this_value)))
    BuiltinFunction::SymbolValueOf => Symbol(this_to_symbol(builtin.this_value))
    BuiltinFunction::SymbolToPrimitive =>
      Symbol(this_to_symbol(builtin.this_value))
    BuiltinFunction::SymbolDescription =>
      match this_to_symbol(builtin.this_value).description {
        Some(desc) => String(desc)
        None => Undefined
      }
    BuiltinFunction::RegExpConstructor =>
      regexp_from_args(args, false, new_target=Value::Builtin(builtin))
    BuiltinFunction::ParseInt => parse_int_value(args)
    BuiltinFunction::ParseFloat => parse_float_value(args)
    BuiltinFunction::DecodeURI => {
      let text = if args.is_empty() {
        "undefined"
      } else {
        to_string_strict(args[0])
      }
      String(uri_decode(text, false))
    }
    BuiltinFunction::DecodeURIComponent => {
      let text = if args.is_empty() {
        "undefined"
      } else {
        to_string_strict(args[0])
      }
      String(uri_decode(text, true))
    }
    BuiltinFunction::EncodeURI => {
      let text = if args.is_empty() {
        "undefined"
      } else {
        to_string_strict(args[0])
      }
      String(uri_encode(text, false))
    }
    BuiltinFunction::EncodeURIComponent => {
      let text = if args.is_empty() {
        "undefined"
      } else {
        to_string_strict(args[0])
      }
      String(uri_encode(text, true))
    }
    BuiltinFunction::Escape => {
      let text = if args.is_empty() {
        "undefined"
      } else {
        to_string_strict(args[0])
      }
      String(uri_escape(text))
    }
    BuiltinFunction::Unescape => {
      let text = if args.is_empty() {
        "undefined"
      } else {
        to_string_strict(args[0])
      }
      String(uri_unescape(text))
    }
    BuiltinFunction::MathAbs =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(Double::abs(to_number(args[0])))
      }
    BuiltinFunction::MathAcos =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(@math.acos(to_number(args[0])))
      }
    BuiltinFunction::MathAcosh =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(@math.acosh(to_number(args[0])))
      }
    BuiltinFunction::MathAsin =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(@math.asin(to_number(args[0])))
      }
    BuiltinFunction::MathAsinh =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(@math.asinh(to_number(args[0])))
      }
    BuiltinFunction::MathAtan =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(@math.atan(to_number(args[0])))
      }
    BuiltinFunction::MathAtan2 => {
      let y = if args.is_empty() { nan() } else { to_number(args[0]) }
      let x = if args.length() < 2 { nan() } else { to_number(args[1]) }
      Number(@math.atan2(y, x))
    }
    BuiltinFunction::MathAtanh =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(@math.atanh(to_number(args[0])))
      }
    BuiltinFunction::MathCbrt =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(@math.cbrt(to_number(args[0])))
      }
    BuiltinFunction::MathCeil =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(Double::ceil(to_number(args[0])))
      }
    BuiltinFunction::MathClz32 => {
      let value = if args.is_empty() { nan() } else { to_number(args[0]) }
      Number(Double::from_int(math_clz32_value(value)))
    }
    BuiltinFunction::MathCos =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(@math.cos(to_number(args[0])))
      }
    BuiltinFunction::MathCosh =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(math_cosh_value(to_number(args[0])))
      }
    BuiltinFunction::MathExp =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(@math.exp(to_number(args[0])))
      }
    BuiltinFunction::MathExpm1 =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(@math.expm1(to_number(args[0])))
      }
    BuiltinFunction::MathFloor =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(Double::floor(to_number(args[0])))
      }
    BuiltinFunction::MathFround =>
      if args.is_empty() {
        Number(nan())
      } else {
        let value = Float::from_double(to_number(args[0])).to_double()
        Number(value)
      }
    BuiltinFunction::MathF16Round =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(math_f16round_value(to_number(args[0])))
      }
    BuiltinFunction::MathHypot => Number(math_hypot(args))
    BuiltinFunction::MathImul => {
      let a = if args.is_empty() { 0.0 } else { to_number(args[0]) }
      let b = if args.length() < 2 { 0.0 } else { to_number(args[1]) }
      Number(Double::from_int(imul(a, b)))
    }
    BuiltinFunction::MathLog =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(@math.ln(to_number(args[0])))
      }
    BuiltinFunction::MathLog1p =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(@math.ln_1p(to_number(args[0])))
      }
    BuiltinFunction::MathLog2 =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(@math.log2(to_number(args[0])))
      }
    BuiltinFunction::MathLog10 =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(@math.log10(to_number(args[0])))
      }
    BuiltinFunction::MathMax => Number(math_max(args))
    BuiltinFunction::MathMin => Number(math_min(args))
    BuiltinFunction::MathPow => {
      let base = if args.is_empty() { nan() } else { to_number(args[0]) }
      let exp = if args.length() < 2 { nan() } else { to_number(args[1]) }
      Number(@math.pow(base, exp))
    }
    BuiltinFunction::MathRandom => Number(math_random_value())
    BuiltinFunction::MathRound =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(math_round_value(to_number(args[0])))
      }
    BuiltinFunction::MathSign =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(math_sign_value(to_number(args[0])))
      }
    BuiltinFunction::MathSin =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(@math.sin(to_number(args[0])))
      }
    BuiltinFunction::MathSinh =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(@math.sinh(to_number(args[0])))
      }
    BuiltinFunction::MathSqrt =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(Double::sqrt(to_number(args[0])))
      }
    BuiltinFunction::MathTan =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(@math.tan(to_number(args[0])))
      }
    BuiltinFunction::MathTanh =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(@math.tanh(to_number(args[0])))
      }
    BuiltinFunction::MathTrunc =>
      if args.is_empty() {
        Number(nan())
      } else {
        Number(math_trunc_value(to_number(args[0])))
      }
    BuiltinFunction::MathSumPrecise => math_sum_precise(args)
    BuiltinFunction::RegExpExec => {
      let (obj, data) = require_regexp(builtin.this_value)
      let input = if args.is_empty() {
        "undefined"
      } else {
        to_string_strict(args[0])
      }
      regexp_exec_value(obj, data, input)
    }
    BuiltinFunction::RegExpTest => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let input = if args.is_empty() { Undefined } else { args[0] }
      match regexp_exec_method(this_value, input) {
        Null => Bool(false)
        _ => Bool(true)
      }
    }
    BuiltinFunction::RegExpToString =>
      regexp_to_string_value(builtin.this_value)
    BuiltinFunction::RegExpCompile =>
      regexp_compile_value(builtin.this_value, args)
    BuiltinFunction::RegExpEscape =>
      if args.is_empty() || !(args[0] is String(_)) {
        throw_type_error("not a string")
      } else {
        let text = to_string_value(args[0])
        String(regexp_escape_string(text))
      }
    BuiltinFunction::RegExpGetFlags =>
      regexp_get_flags_value(builtin.this_value)
    BuiltinFunction::RegExpGetSource =>
      regexp_get_source_value(builtin.this_value)
    BuiltinFunction::RegExpGetGlobal =>
      regexp_get_flag_value(builtin.this_value, "global")
    BuiltinFunction::RegExpGetIgnoreCase =>
      regexp_get_flag_value(builtin.this_value, "ignoreCase")
    BuiltinFunction::RegExpGetMultiline =>
      regexp_get_flag_value(builtin.this_value, "multiline")
    BuiltinFunction::RegExpGetDotAll =>
      regexp_get_flag_value(builtin.this_value, "dotAll")
    BuiltinFunction::RegExpGetUnicode =>
      regexp_get_flag_value(builtin.this_value, "unicode")
    BuiltinFunction::RegExpGetUnicodeSets =>
      regexp_get_flag_value(builtin.this_value, "unicodeSets")
    BuiltinFunction::RegExpGetSticky =>
      regexp_get_flag_value(builtin.this_value, "sticky")
    BuiltinFunction::RegExpGetHasIndices =>
      regexp_get_flag_value(builtin.this_value, "hasIndices")
    BuiltinFunction::RegExpSymbolMatch => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let input = if args.is_empty() {
        "undefined"
      } else {
        to_string_strict(args[0])
      }
      regexp_symbol_match_value(this_value, input)
    }
    BuiltinFunction::RegExpSymbolMatchAll => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let input = if args.is_empty() {
        "undefined"
      } else {
        to_string_strict(args[0])
      }
      regexp_symbol_match_all_value(this_value, input)
    }
    BuiltinFunction::RegExpSymbolReplace => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let input = if args.is_empty() {
        "undefined"
      } else {
        to_string_strict(args[0])
      }
      let replace_value = if args.length() > 1 { args[1] } else { Undefined }
      regexp_symbol_replace_value(this_value, input, replace_value)
    }
    BuiltinFunction::RegExpSymbolSearch => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let input = if args.is_empty() {
        "undefined"
      } else {
        to_string_strict(args[0])
      }
      regexp_symbol_search_value(this_value, input)
    }
    BuiltinFunction::RegExpSymbolSplit => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let input = if args.is_empty() {
        "undefined"
      } else {
        to_string_strict(args[0])
      }
      let limit_value = if args.length() > 1 { args[1] } else { Undefined }
      regexp_symbol_split_value(this_value, input, limit_value)
    }
    BuiltinFunction::RegExpStringIteratorNext =>
      regexp_string_iterator_next(builtin.this_value)
    BuiltinFunction::SpeciesGetter =>
      match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
    BuiltinFunction::DateConstructor => {
      let ms = date_now_ms()
      String(date_to_string(ms))
    }
    BuiltinFunction::DateParse => {
      let text = if args.is_empty() {
        "undefined"
      } else {
        to_string_value(args[0])
      }
      Number(date_parse_string(text))
    }
    BuiltinFunction::DateUTC => Number(date_utc_from_args(args))
    BuiltinFunction::DateNow => Number(date_now_ms())
    BuiltinFunction::DateToISOString => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      if Double::is_nan(ms) || Double::is_inf(ms) {
        return throw_range_error("Date value is NaN")
      }
      String(date_to_iso_string(ms))
    }
    BuiltinFunction::DateToString => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      if Double::is_nan(ms) || Double::is_inf(ms) {
        String("Invalid Date")
      } else {
        String(date_to_string(ms))
      }
    }
    BuiltinFunction::DateSymbolToPrimitive => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      if !is_object_like(this_value) {
        return throw_type_error("not an object")
      }
      if args.is_empty() {
        return throw_type_error("invalid hint")
      }
      let hint = match args[0] {
        String(value) =>
          if value == "number" {
            "number"
          } else if value == "string" || value == "default" {
            "string"
          } else {
            return throw_type_error("invalid hint")
          }
        _ => return throw_type_error("invalid hint")
      }
      let first = if hint == "string" { "toString" } else { "valueOf" }
      let second = if hint == "string" { "valueOf" } else { "toString" }
      match call_primitive_method(this_value, first) {
        Some(result) => result
        None =>
          match call_primitive_method(this_value, second) {
            Some(result) => result
            None => throw_type_error("cannot convert object to primitive")
          }
      }
    }
    BuiltinFunction::DateValueOf => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      Number(date_value_of(this_value))
    }
    BuiltinFunction::DateToUTCString => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      if !date_is_valid(ms) {
        String("Invalid Date")
      } else {
        String(date_to_utc_string(ms))
      }
    }
    BuiltinFunction::DateToDateString => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      if !date_is_valid(ms) {
        String("Invalid Date")
      } else {
        String(date_to_date_string(ms))
      }
    }
    BuiltinFunction::DateToTimeString => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      if !date_is_valid(ms) {
        String("Invalid Date")
      } else {
        String(date_to_time_string(ms))
      }
    }
    BuiltinFunction::DateToLocaleString => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      if !date_is_valid(ms) {
        String("Invalid Date")
      } else {
        String(date_to_string(ms))
      }
    }
    BuiltinFunction::DateToLocaleDateString => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      if !date_is_valid(ms) {
        String("Invalid Date")
      } else {
        String(date_to_string(ms))
      }
    }
    BuiltinFunction::DateToLocaleTimeString => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      if !date_is_valid(ms) {
        String("Invalid Date")
      } else {
        String(date_to_string(ms))
      }
    }
    BuiltinFunction::DateToJSON => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = to_object(this_value)
      let prim = to_primitive(obj, false)
      match prim {
        Number(num) =>
          if Double::is_nan(num) || Double::is_inf(num) {
            return Null
          }
        _ => ()
      }
      let iso_method = property_get(obj, "toISOString")
      if !is_callable(iso_method) {
        return throw_type_error("object needs toISOString method")
      }
      call_value_with_this(iso_method, [], obj)
    }
    BuiltinFunction::DateGetTimezoneOffset => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      if !date_is_valid(ms) {
        Number(nan())
      } else {
        Number(0.0)
      }
    }
    BuiltinFunction::DateGetTime => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      Number(date_value_of(this_value))
    }
    BuiltinFunction::DateGetYear => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      match date_fields_or_none(ms) {
        Some((year, _, _, _, _, _, _)) => Number(Double::from_int(year - 1900))
        None => Number(nan())
      }
    }
    BuiltinFunction::DateGetFullYear => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      match date_fields_or_none(ms) {
        Some((year, _, _, _, _, _, _)) => Number(Double::from_int(year))
        None => Number(nan())
      }
    }
    BuiltinFunction::DateGetUTCFullYear => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      match date_fields_or_none(ms) {
        Some((year, _, _, _, _, _, _)) => Number(Double::from_int(year))
        None => Number(nan())
      }
    }
    BuiltinFunction::DateGetMonth => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      match date_fields_or_none(ms) {
        Some((_, month, _, _, _, _, _)) => Number(Double::from_int(month))
        None => Number(nan())
      }
    }
    BuiltinFunction::DateGetUTCMonth => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      match date_fields_or_none(ms) {
        Some((_, month, _, _, _, _, _)) => Number(Double::from_int(month))
        None => Number(nan())
      }
    }
    BuiltinFunction::DateGetDate => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      match date_fields_or_none(ms) {
        Some((_, _, day, _, _, _, _)) => Number(Double::from_int(day))
        None => Number(nan())
      }
    }
    BuiltinFunction::DateGetUTCDate => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      match date_fields_or_none(ms) {
        Some((_, _, day, _, _, _, _)) => Number(Double::from_int(day))
        None => Number(nan())
      }
    }
    BuiltinFunction::DateGetDay => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      if !date_is_valid(ms) {
        Number(nan())
      } else {
        Number(Double::from_int(date_day_of_week(ms)))
      }
    }
    BuiltinFunction::DateGetUTCDay => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      if !date_is_valid(ms) {
        Number(nan())
      } else {
        Number(Double::from_int(date_day_of_week(ms)))
      }
    }
    BuiltinFunction::DateGetHours => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      match date_fields_or_none(ms) {
        Some((_, _, _, hour, _, _, _)) => Number(Double::from_int(hour))
        None => Number(nan())
      }
    }
    BuiltinFunction::DateGetUTCHours => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      match date_fields_or_none(ms) {
        Some((_, _, _, hour, _, _, _)) => Number(Double::from_int(hour))
        None => Number(nan())
      }
    }
    BuiltinFunction::DateGetMinutes => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      match date_fields_or_none(ms) {
        Some((_, _, _, _, minute, _, _)) => Number(Double::from_int(minute))
        None => Number(nan())
      }
    }
    BuiltinFunction::DateGetUTCMinutes => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      match date_fields_or_none(ms) {
        Some((_, _, _, _, minute, _, _)) => Number(Double::from_int(minute))
        None => Number(nan())
      }
    }
    BuiltinFunction::DateGetSeconds => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      match date_fields_or_none(ms) {
        Some((_, _, _, _, _, sec, _)) => Number(Double::from_int(sec))
        None => Number(nan())
      }
    }
    BuiltinFunction::DateGetUTCSeconds => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      match date_fields_or_none(ms) {
        Some((_, _, _, _, _, sec, _)) => Number(Double::from_int(sec))
        None => Number(nan())
      }
    }
    BuiltinFunction::DateGetMilliseconds => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      match date_fields_or_none(ms) {
        Some((_, _, _, _, _, _, milli)) => Number(Double::from_int(milli))
        None => Number(nan())
      }
    }
    BuiltinFunction::DateGetUTCMilliseconds => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let ms = date_value_of(this_value)
      match date_fields_or_none(ms) {
        Some((_, _, _, _, _, _, milli)) => Number(Double::from_int(milli))
        None => Number(nan())
      }
    }
    BuiltinFunction::DateSetTime => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = require_date_object(this_value)
      let value = if args.is_empty() {
        to_number(Undefined)
      } else {
        to_number(args[0])
      }
      let new_ms = date_time_clip(value)
      obj.date_data = Some(new_ms)
      Number(new_ms)
    }
    BuiltinFunction::DateSetMilliseconds => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = require_date_object(this_value)
      let new_ms = date_set_field_value(obj, args, 6, 7, false)
      Number(new_ms)
    }
    BuiltinFunction::DateSetUTCMilliseconds => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = require_date_object(this_value)
      let new_ms = date_set_field_value(obj, args, 6, 7, false)
      Number(new_ms)
    }
    BuiltinFunction::DateSetSeconds => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = require_date_object(this_value)
      let new_ms = date_set_field_value(obj, args, 5, 7, false)
      Number(new_ms)
    }
    BuiltinFunction::DateSetUTCSeconds => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = require_date_object(this_value)
      let new_ms = date_set_field_value(obj, args, 5, 7, false)
      Number(new_ms)
    }
    BuiltinFunction::DateSetMinutes => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = require_date_object(this_value)
      let new_ms = date_set_field_value(obj, args, 4, 7, false)
      Number(new_ms)
    }
    BuiltinFunction::DateSetUTCMinutes => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = require_date_object(this_value)
      let new_ms = date_set_field_value(obj, args, 4, 7, false)
      Number(new_ms)
    }
    BuiltinFunction::DateSetHours => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = require_date_object(this_value)
      let new_ms = date_set_field_value(obj, args, 3, 7, false)
      Number(new_ms)
    }
    BuiltinFunction::DateSetUTCHours => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = require_date_object(this_value)
      let new_ms = date_set_field_value(obj, args, 3, 7, false)
      Number(new_ms)
    }
    BuiltinFunction::DateSetDate => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = require_date_object(this_value)
      let new_ms = date_set_field_value(obj, args, 2, 3, false)
      Number(new_ms)
    }
    BuiltinFunction::DateSetUTCDate => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = require_date_object(this_value)
      let new_ms = date_set_field_value(obj, args, 2, 3, false)
      Number(new_ms)
    }
    BuiltinFunction::DateSetMonth => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = require_date_object(this_value)
      let new_ms = date_set_field_value(obj, args, 1, 3, false)
      Number(new_ms)
    }
    BuiltinFunction::DateSetUTCMonth => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = require_date_object(this_value)
      let new_ms = date_set_field_value(obj, args, 1, 3, false)
      Number(new_ms)
    }
    BuiltinFunction::DateSetYear => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = require_date_object(this_value)
      let mut year_val = if args.is_empty() {
        to_number(Undefined)
      } else {
        to_number(args[0])
      }
      if date_is_valid(year_val) {
        year_val = Double::trunc(year_val)
        if year_val >= 0.0 && year_val < 100.0 {
          year_val = year_val + 1900.0
        }
      }
      let year_args : Array[Value] = [Number(year_val)]
      let new_ms = date_set_field_value(obj, year_args, 0, 1, true)
      Number(new_ms)
    }
    BuiltinFunction::DateSetFullYear => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = require_date_object(this_value)
      let new_ms = date_set_field_value(obj, args, 0, 3, true)
      Number(new_ms)
    }
    BuiltinFunction::DateSetUTCFullYear => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let obj = require_date_object(this_value)
      let new_ms = date_set_field_value(obj, args, 0, 3, true)
      Number(new_ms)
    }
    BuiltinFunction::GeneratorNext => {
      let obj = require_generator(builtin.this_value)
      let arg = if args.is_empty() { Undefined } else { args[0] }
      generator_next_object(obj, arg)
    }
    BuiltinFunction::GeneratorReturn => {
      let obj = require_generator(builtin.this_value)
      let arg = if args.is_empty() { Undefined } else { args[0] }
      generator_return_object(obj, arg)
    }
    BuiltinFunction::GeneratorThrow => {
      let obj = require_generator(builtin.this_value)
      let arg = if args.is_empty() { Undefined } else { args[0] }
      generator_throw_object(obj, arg)
    }
    BuiltinFunction::AsyncGeneratorNext => {
      let arg = if args.is_empty() { Undefined } else { args[0] }
      async_generator_request(builtin.this_value, GenResume::Next(arg))
    }
    BuiltinFunction::AsyncGeneratorReturn => {
      let arg = if args.is_empty() { Undefined } else { args[0] }
      async_generator_request(builtin.this_value, GenResume::Return(arg))
    }
    BuiltinFunction::AsyncGeneratorThrow => {
      let arg = if args.is_empty() { Undefined } else { args[0] }
      async_generator_request(builtin.this_value, GenResume::Throw(arg))
    }
    BuiltinFunction::MapConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::MapGroupBy => {
      let iterable = if args.is_empty() { Undefined } else { args[0] }
      let callback = if args.length() > 1 { args[1] } else { Undefined }
      map_group_by(iterable, callback)
    }
    BuiltinFunction::MapGet => {
      let (_, data) = require_map(builtin.this_value)
      let key = if args.is_empty() { Undefined } else { args[0] }
      map_get_value(data, key)
    }
    BuiltinFunction::MapGetOrInsert => {
      let (_, data) = require_map(builtin.this_value)
      let key = if args.is_empty() { Undefined } else { args[0] }
      let value = if args.length() > 1 { args[1] } else { Undefined }
      map_get_or_insert(data, key, value, false)
    }
    BuiltinFunction::MapGetOrInsertComputed => {
      let (_, data) = require_map(builtin.this_value)
      let key = if args.is_empty() { Undefined } else { args[0] }
      let callback = if args.length() > 1 { args[1] } else { Undefined }
      map_get_or_insert(data, key, callback, true)
    }
    BuiltinFunction::MapSet => {
      let (obj, data) = require_map(builtin.this_value)
      if args.length() >= 2 {
        map_set_value(data, args[0], args[1])
      } else if args.length() == 1 {
        map_set_value(data, args[0], Undefined)
      } else {
        map_set_value(data, Undefined, Undefined)
      }
      Object(obj)
    }
    BuiltinFunction::MapHas => {
      let (_, data) = require_map(builtin.this_value)
      let key = if args.is_empty() { Undefined } else { args[0] }
      Bool(map_has_key(data, key))
    }
    BuiltinFunction::MapDelete => {
      let (_, data) = require_map(builtin.this_value)
      let key = if args.is_empty() { Undefined } else { args[0] }
      Bool(map_delete_key(data, key))
    }
    BuiltinFunction::MapClear => {
      let (_, data) = require_map(builtin.this_value)
      let mut index = 0
      while index < data.entries.length() {
        data.entries[index] = None
        index = index + 1
      }
      Undefined
    }
    BuiltinFunction::MapForEach => {
      let (obj, data) = require_map(builtin.this_value)
      if args.is_empty() {
        return Undefined
      }
      let callback = args[0]
      if !is_callable(callback) {
        return throw_type_error("not a function")
      }
      let this_arg = if args.length() > 1 { args[1] } else { Undefined }
      let mut index = 0
      while index < data.entries.length() {
        match data.entries[index] {
          Some((key, value)) => {
            let _ = call_value_with_this(
              callback,
              [value, key, Object(obj)],
              this_arg,
            )

          }
          None => ()
        }
        index = index + 1
      }
      Undefined
    }
    BuiltinFunction::MapSize => {
      let (_, data) = require_map(builtin.this_value)
      Number(Double::from_int(map_entry_count(data)))
    }
    BuiltinFunction::MapKeys => {
      let (_, data) = require_map(builtin.this_value)
      new_map_iterator(data, 0)
    }
    BuiltinFunction::MapValues => {
      let (_, data) = require_map(builtin.this_value)
      new_map_iterator(data, 1)
    }
    BuiltinFunction::MapEntries => {
      let (_, data) = require_map(builtin.this_value)
      new_map_iterator(data, 2)
    }
    BuiltinFunction::MapIteratorNext => map_iterator_next(builtin.this_value)
    BuiltinFunction::SetConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::SetAdd => {
      let (obj, data) = require_set(builtin.this_value)
      let value = if args.is_empty() { Undefined } else { args[0] }
      set_add_value(data, value)
      Object(obj)
    }
    BuiltinFunction::SetHas => {
      let (_, data) = require_set(builtin.this_value)
      let value = if args.is_empty() { Undefined } else { args[0] }
      Bool(set_has_value(data, value))
    }
    BuiltinFunction::SetDelete => {
      let (_, data) = require_set(builtin.this_value)
      let value = if args.is_empty() { Undefined } else { args[0] }
      Bool(set_delete_value(data, value))
    }
    BuiltinFunction::SetClear => {
      let (_, data) = require_set(builtin.this_value)
      let mut index = 0
      while index < data.entries.length() {
        data.entries[index] = None
        index = index + 1
      }
      Undefined
    }
    BuiltinFunction::SetForEach => {
      let (obj, data) = require_set(builtin.this_value)
      if args.is_empty() {
        return Undefined
      }
      let callback = args[0]
      if !is_callable(callback) {
        return throw_type_error("not a function")
      }
      let this_arg = if args.length() > 1 { args[1] } else { Undefined }
      let mut index = 0
      while index < data.entries.length() {
        match data.entries[index] {
          Some(entry) => {
            let _ = call_value_with_this(
              callback,
              [entry, entry, Object(obj)],
              this_arg,
            )

          }
          None => ()
        }
        index = index + 1
      }
      Undefined
    }
    BuiltinFunction::SetSize => {
      let (_, data) = require_set(builtin.this_value)
      Number(Double::from_int(set_entry_count(data)))
    }
    BuiltinFunction::SetValues => {
      let (_, data) = require_set(builtin.this_value)
      new_set_iterator(data, 0)
    }
    BuiltinFunction::SetEntries => {
      let (_, data) = require_set(builtin.this_value)
      new_set_iterator(data, 1)
    }
    BuiltinFunction::SetIsDisjointFrom => {
      let other = if args.is_empty() { Undefined } else { args[0] }
      set_is_disjoint_from(builtin.this_value, other)
    }
    BuiltinFunction::SetIsSubsetOf => {
      let other = if args.is_empty() { Undefined } else { args[0] }
      set_is_subset_of(builtin.this_value, other)
    }
    BuiltinFunction::SetIsSupersetOf => {
      let other = if args.is_empty() { Undefined } else { args[0] }
      set_is_superset_of(builtin.this_value, other)
    }
    BuiltinFunction::SetIntersection => {
      let other = if args.is_empty() { Undefined } else { args[0] }
      set_intersection(builtin.this_value, other)
    }
    BuiltinFunction::SetDifference => {
      let other = if args.is_empty() { Undefined } else { args[0] }
      set_difference(builtin.this_value, other)
    }
    BuiltinFunction::SetSymmetricDifference => {
      let other = if args.is_empty() { Undefined } else { args[0] }
      set_symmetric_difference(builtin.this_value, other)
    }
    BuiltinFunction::SetUnion => {
      let other = if args.is_empty() { Undefined } else { args[0] }
      set_union(builtin.this_value, other)
    }
    BuiltinFunction::SetIteratorNext => set_iterator_next(builtin.this_value)
    BuiltinFunction::WeakMapConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::WeakMapGet => {
      let (_, data) = require_weakmap(builtin.this_value)
      let key = if args.is_empty() { Undefined } else { args[0] }
      if !is_weakref_target(key) {
        return Undefined
      }
      weakmap_get_value(data, key)
    }
    BuiltinFunction::WeakMapGetOrInsert => {
      let (_, data) = require_weakmap(builtin.this_value)
      let key = if args.is_empty() { Undefined } else { args[0] }
      if !is_weakref_target(key) {
        return throw_type_error("invalid WeakMap key")
      }
      let value = if args.length() > 1 { args[1] } else { Undefined }
      weakmap_get_or_insert(data, key, value, false)
    }
    BuiltinFunction::WeakMapGetOrInsertComputed => {
      let (_, data) = require_weakmap(builtin.this_value)
      let key = if args.is_empty() { Undefined } else { args[0] }
      if !is_weakref_target(key) {
        return throw_type_error("invalid WeakMap key")
      }
      let callback = if args.length() > 1 { args[1] } else { Undefined }
      weakmap_get_or_insert(data, key, callback, true)
    }
    BuiltinFunction::WeakMapSet => {
      let (obj, data) = require_weakmap(builtin.this_value)
      if args.is_empty() {
        return throw_type_error("invalid WeakMap key")
      }
      let key = args[0]
      if !is_weakref_target(key) {
        return throw_type_error("invalid WeakMap key")
      }
      let value = if args.length() > 1 { args[1] } else { Undefined }
      weakmap_set_value(data, key, value)
      Object(obj)
    }
    BuiltinFunction::WeakMapHas => {
      let (_, data) = require_weakmap(builtin.this_value)
      let key = if args.is_empty() { Undefined } else { args[0] }
      if !is_weakref_target(key) {
        return Bool(false)
      }
      Bool(weakmap_has_key(data, key))
    }
    BuiltinFunction::WeakMapDelete => {
      let (_, data) = require_weakmap(builtin.this_value)
      let key = if args.is_empty() { Undefined } else { args[0] }
      if !is_weakref_target(key) {
        return Bool(false)
      }
      Bool(weakmap_delete_key(data, key))
    }
    BuiltinFunction::WeakSetConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::WeakSetAdd => {
      let (obj, data) = require_weakset(builtin.this_value)
      if args.is_empty() || !is_weakref_target(args[0]) {
        return throw_type_error("invalid WeakSet key")
      }
      weakset_add_value(data, args[0])
      Object(obj)
    }
    BuiltinFunction::WeakSetHas => {
      let (_, data) = require_weakset(builtin.this_value)
      let value = if args.is_empty() { Undefined } else { args[0] }
      if !is_weakref_target(value) {
        return Bool(false)
      }
      Bool(weakset_has_value(data, value))
    }
    BuiltinFunction::WeakSetDelete => {
      let (_, data) = require_weakset(builtin.this_value)
      let value = if args.is_empty() { Undefined } else { args[0] }
      if !is_weakref_target(value) {
        return Bool(false)
      }
      Bool(weakset_delete_value(data, value))
    }
    BuiltinFunction::WeakRefConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::WeakRefDeref => {
      let data = require_weakref(builtin.this_value)
      match data.target {
        Undefined => Undefined
        _ =>
          if is_live_value_now(data.target) {
            data.target
          } else {
            Undefined
          }
      }
    }
    BuiltinFunction::FinalizationRegistryConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::FinalizationRegistryRegister => {
      let data = require_finreg(builtin.this_value)
      if args.is_empty() {
        return throw_type_error("invalid target")
      }
      let target = args[0]
      if !is_weakref_target(target) {
        return throw_type_error("invalid target")
      }
      let held = if args.length() > 1 { args[1] } else { Undefined }
      if strict_eq(target, held) {
        return throw_type_error("held value cannot be the target")
      }
      let token = if args.length() >= 3 { args[2] } else { Undefined }
      match token {
        Undefined => ()
        _ =>
          if !is_weakref_target(token) {
            return throw_type_error("invalid unregister token")
          }
      }
      data.entries.push(FinalizationEntry::{ target, held_value: held, token })
      Undefined
    }
    BuiltinFunction::FinalizationRegistryUnregister => {
      let data = require_finreg(builtin.this_value)
      if args.is_empty() {
        return Bool(false)
      }
      let token = args[0]
      if !is_weakref_target(token) {
        return throw_type_error("invalid unregister token")
      }
      let mut removed = false
      let mut i = 0
      while i < data.entries.length() {
        let entry = data.entries[i]
        if strict_eq(entry.token, token) {
          let _ = data.entries.remove(i)
          removed = true
        } else {
          i = i + 1
        }
      }
      Bool(removed)
    }
    BuiltinFunction::PromiseConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::PromiseResolve => {
      let value = if args.is_empty() { Undefined } else { args[0] }
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      promise_resolve_value(this_value, value, false)
    }
    BuiltinFunction::PromiseReject => {
      let value = if args.is_empty() { Undefined } else { args[0] }
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      promise_resolve_value(this_value, value, true)
    }
    BuiltinFunction::PromiseThen => {
      let data = require_promise_data(builtin.this_value)
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let on_fulfilled = if args.is_empty() { Undefined } else { args[0] }
      let on_rejected = if args.length() > 1 { args[1] } else { Undefined }
      let ctor = promise_species_constructor(this_value)
      let (result_promise, resolve, reject) = new_promise_capability(ctor)
      perform_promise_then(
        this_value, data, on_fulfilled, on_rejected, resolve, reject,
      )
      result_promise
    }
    BuiltinFunction::PromiseCatch => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let on_rejected = if args.is_empty() { Undefined } else { args[0] }
      let target = to_object(this_value)
      let then_method = property_get_with_receiver(target, "then", this_value)
      if !is_callable(then_method) {
        return throw_type_error("not a function")
      }
      call_value_with_this(then_method, [Undefined, on_rejected], this_value)
    }
    BuiltinFunction::PromiseFinally => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let on_finally = if args.is_empty() { Undefined } else { args[0] }
      let ctor = promise_species_constructor(this_value)
      let mut then_fulfill = Undefined
      let mut then_reject = Undefined
      if !is_callable(on_finally) {
        then_fulfill = on_finally
        then_reject = on_finally
      } else {
        then_fulfill = new_promise_then_finally_function(PromiseThenFinallyData::{
          ctor,
          on_finally,
          is_reject: false,
        })
        then_reject = new_promise_then_finally_function(PromiseThenFinallyData::{
          ctor,
          on_finally,
          is_reject: true,
        })
      }
      let target = to_object(this_value)
      let then_method = property_get_with_receiver(target, "then", this_value)
      if !is_callable(then_method) {
        return throw_type_error("not a function")
      }
      call_value_with_this(then_method, [then_fulfill, then_reject], this_value)
    }
    BuiltinFunction::PromiseReactionJob => {
      let resolve = if args.is_empty() { Undefined } else { args[0] }
      let reject = if args.length() > 1 { args[1] } else { Undefined }
      let handler = if args.length() > 2 { args[2] } else { Undefined }
      let is_reject = if args.length() > 3 { is_truthy(args[3]) } else { false }
      let mut result = if args.length() > 4 { args[4] } else { Undefined }
      let mut rejected = is_reject
      if !(handler is Undefined) {
        try {
          result = call_value_with_this(handler, [result], Undefined)
          rejected = false
        } catch {
          ThrowSignal(value) => {
            result = value
            rejected = true
          }
          err => raise err
        }
      }
      let target = if rejected { reject } else { resolve }
      if target is Undefined {
        return Undefined
      }
      let _ = call_value_with_this(target, [result], Undefined)
      Undefined
    }
    BuiltinFunction::PromiseResolveFunction =>
      match promise_resolve_func_data_get(builtin.id) {
        Some(data) => {
          if data.shared.already_resolved {
            return Undefined
          }
          data.shared.already_resolved = true
          let resolution = if args.is_empty() { Undefined } else { args[0] }
          if data.is_reject || !is_object_like(resolution) {
            let state = if data.is_reject {
              PromiseState::Rejected
            } else {
              PromiseState::Fulfilled
            }
            match promise_data_from_value(data.promise) {
              Some(promise_data) =>
                promise_settle(promise_data, state, resolution)
              None => ()
            }
            return Undefined
          }
          if strict_eq(resolution, data.promise) {
            let error = type_error_value("promise self resolution")
            match promise_data_from_value(data.promise) {
              Some(promise_data) =>
                promise_settle(promise_data, PromiseState::Rejected, error)
              None => ()
            }
            return Undefined
          }
          let mut then_value = Undefined
          try {
            then_value = property_get(resolution, "then")
          } catch {
            ThrowSignal(value) => {
              match promise_data_from_value(data.promise) {
                Some(promise_data) =>
                  promise_settle(promise_data, PromiseState::Rejected, value)
                None => ()
              }
              return Undefined
            }
            err => raise err
          }
          if !is_callable(then_value) {
            match promise_data_from_value(data.promise) {
              Some(promise_data) =>
                promise_settle(
                  promise_data,
                  PromiseState::Fulfilled,
                  resolution,
                )
              None => ()
            }
            return Undefined
          }
          enqueue_job(
            new_builtin_value(BuiltinFunction::PromiseResolveThenableJob),
            [data.promise, resolution, then_value],
          )
          Undefined
        }
        None => Undefined
      }
    BuiltinFunction::AsyncGeneratorResolveFunction =>
      match async_generator_resolve_func_data_get(builtin.id) {
        Some(data) => {
          let arg = if args.is_empty() { Undefined } else { args[0] }
          match data.generator {
            Object(obj) =>
              match obj.async_generator_data {
                Some(gen_data) =>
                  if data.resume_next {
                    gen_data.state = AsyncGeneratorState::Completed
                    if data.is_reject {
                      async_generator_reject(gen_data, arg)
                    } else {
                      async_generator_resolve(gen_data, arg, true)
                    }
                  } else {
                    let resume_state = if data.is_reject {
                      GenResume::Throw(arg)
                    } else {
                      GenResume::Next(arg)
                    }
                    async_generator_resume_next(obj, Some(resume_state))
                  }
                None => ()
              }
            _ => ()
          }
          Undefined
        }
        None => Undefined
      }
    BuiltinFunction::AsyncFunctionResolveFunction =>
      match async_function_resolve_func_data_get(builtin.id) {
        Some(data) => {
          let arg = if args.is_empty() { Undefined } else { args[0] }
          match data.generator {
            Object(obj) => {
              let resume_state = if data.is_reject {
                GenResume::Throw(arg)
              } else {
                GenResume::Next(arg)
              }
              async_function_resume(obj, resume_state)
            }
            _ => ()
          }
          Undefined
        }
        None => Undefined
      }
    BuiltinFunction::PromiseRejectFunction =>
      call_builtin_with_this(
        BuiltinValue::{
          kind: BuiltinFunction::PromiseResolveFunction,
          id: builtin.id,
          props: builtin.props,
          this_value: builtin.this_value,
          proto: builtin.proto,
          extensible: builtin.extensible,
          is_html_dda: builtin.is_html_dda,
          realm_env: builtin.realm_env,
        },
        args,
        Undefined,
      )
    BuiltinFunction::PromiseResolveThenableJob => {
      let promise = if args.is_empty() { Undefined } else { args[0] }
      let thenable = if args.length() > 1 { args[1] } else { Undefined }
      let then_func = if args.length() > 2 { args[2] } else { Undefined }
      let (resolve, reject) = create_promise_resolving_functions(promise)
      try {
        let _ = call_value_with_this(then_func, [resolve, reject], thenable)

      } catch {
        ThrowSignal(value) => {
          let _ = call_value_with_this(reject, [value], Undefined)

        }
        err => raise err
      }
      Undefined
    }
    BuiltinFunction::PromiseAll => {
      let iterable = if args.is_empty() { Undefined } else { args[0] }
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      promise_all_value(this_value, iterable, 0)
    }
    BuiltinFunction::PromiseAllSettled => {
      let iterable = if args.is_empty() { Undefined } else { args[0] }
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      promise_all_value(this_value, iterable, 1)
    }
    BuiltinFunction::PromiseAny => {
      let iterable = if args.is_empty() { Undefined } else { args[0] }
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      promise_all_value(this_value, iterable, 2)
    }
    BuiltinFunction::PromiseRace => {
      let iterable = if args.is_empty() { Undefined } else { args[0] }
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      promise_race_value(this_value, iterable)
    }
    BuiltinFunction::PromiseTry => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      promise_try_value(this_value, args)
    }
    BuiltinFunction::PromiseWithResolvers => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      promise_with_resolvers_value(this_value)
    }
    BuiltinFunction::PromiseAllResolveElement =>
      match promise_all_element_data_get(builtin.id) {
        Some(data) => {
          if data.shared.already_called {
            return Undefined
          }
          data.shared.already_called = true
          let value = if args.is_empty() { Undefined } else { args[0] }
          let result = if data.mode == 1 {
            let obj = new_object_value()
            let status = if data.is_reject { "rejected" } else { "fulfilled" }
            create_data_property_or_throw(obj, "status", String(status))
            let name = if data.is_reject { "reason" } else { "value" }
            create_data_property_or_throw(obj, name, value)
            obj
          } else {
            value
          }
          set_array_index(data.values, data.index, result)
          if promise_all_remaining_add(data.remaining, -1) {
            if data.mode == 2 {
              let error = new_aggregate_error_value([data.values])
              let _ = call_value_with_this(
                data.result_resolve,
                [error],
                Undefined,
              )

            } else {
              let _ = call_value_with_this(
                data.result_resolve,
                [data.values],
                Undefined,
              )

            }
          }
          Undefined
        }
        None => Undefined
      }
    BuiltinFunction::PromiseThenFinally =>
      match promise_then_finally_data_get(builtin.id) {
        Some(data) => {
          let value = if args.is_empty() { Undefined } else { args[0] }
          let result = call_value_with_this(data.on_finally, [], Undefined)
          let promise = promise_resolve_value(data.ctor, result, false)
          let then_func = if data.is_reject {
            new_promise_finally_thrower(value)
          } else {
            new_promise_finally_value_thunk(value)
          }
          let then_method = property_get(promise, "then")
          if !is_callable(then_method) {
            return throw_type_error("not a function")
          }
          call_value_with_this(then_method, [then_func], promise)
        }
        None => Undefined
      }
    BuiltinFunction::PromiseFinallyValueThunk =>
      match promise_finally_value_data_get(builtin.id) {
        Some(value) => value
        None => Undefined
      }
    BuiltinFunction::PromiseFinallyThrower => {
      let value = match promise_finally_value_data_get(builtin.id) {
        Some(value) => value
        None => Undefined
      }
      raise ThrowSignal(value)
    }
    BuiltinFunction::PromiseCapabilityExecutor => {
      match promise_executor_data_get(builtin.id) {
        Some(data) => {
          let resolve_set = match data.resolve {
            Some(value) => !(value is Undefined)
            None => false
          }
          let reject_set = match data.reject {
            Some(value) => !(value is Undefined)
            None => false
          }
          if resolve_set || reject_set {
            return throw_type_error("resolving function already set")
          }
          let resolve = if args.is_empty() { Undefined } else { args[0] }
          let reject = if args.length() > 1 { args[1] } else { Undefined }
          data.resolve = Some(resolve)
          data.reject = Some(reject)
        }
        None => ()
      }
      Undefined
    }
    BuiltinFunction::ArrayBufferIsView => {
      let value = if args.is_empty() { Undefined } else { args[0] }
      match value {
        Array(arr) => Bool(arr.typed_array_data is Some(_))
        Object(obj) => Bool(obj.dataview_data is Some(_))
        _ => Bool(false)
      }
    }
    BuiltinFunction::DataViewGetBuffer => {
      let (_, data) = require_dataview_data(builtin.this_value)
      Object(data.buffer)
    }
    BuiltinFunction::DataViewGetByteLength => {
      let (_, data) = require_dataview_data(builtin.this_value)
      if dataview_is_oob(data) {
        return throw_type_error("ArrayBuffer is detached or resized")
      }
      Number(Double::from_int(dataview_effective_length(data)))
    }
    BuiltinFunction::DataViewGetByteOffset => {
      let (_, data) = require_dataview_data(builtin.this_value)
      if dataview_is_oob(data) {
        return throw_type_error("ArrayBuffer is detached or resized")
      }
      Number(Double::from_int(data.byte_offset))
    }
    BuiltinFunction::DataViewGetInt8 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_get_value(data, args, DataViewValueKind::Int8)
    }
    BuiltinFunction::DataViewGetUint8 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_get_value(data, args, DataViewValueKind::Uint8)
    }
    BuiltinFunction::DataViewGetInt16 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_get_value(data, args, DataViewValueKind::Int16)
    }
    BuiltinFunction::DataViewGetUint16 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_get_value(data, args, DataViewValueKind::Uint16)
    }
    BuiltinFunction::DataViewGetInt32 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_get_value(data, args, DataViewValueKind::Int32)
    }
    BuiltinFunction::DataViewGetUint32 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_get_value(data, args, DataViewValueKind::Uint32)
    }
    BuiltinFunction::DataViewGetBigInt64 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_get_value(data, args, DataViewValueKind::BigInt64)
    }
    BuiltinFunction::DataViewGetBigUint64 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_get_value(data, args, DataViewValueKind::BigUint64)
    }
    BuiltinFunction::DataViewGetFloat16 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_get_value(data, args, DataViewValueKind::Float16)
    }
    BuiltinFunction::DataViewGetFloat32 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_get_value(data, args, DataViewValueKind::Float32)
    }
    BuiltinFunction::DataViewGetFloat64 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_get_value(data, args, DataViewValueKind::Float64)
    }
    BuiltinFunction::DataViewSetInt8 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_set_value(data, args, DataViewValueKind::Int8)
    }
    BuiltinFunction::DataViewSetUint8 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_set_value(data, args, DataViewValueKind::Uint8)
    }
    BuiltinFunction::DataViewSetInt16 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_set_value(data, args, DataViewValueKind::Int16)
    }
    BuiltinFunction::DataViewSetUint16 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_set_value(data, args, DataViewValueKind::Uint16)
    }
    BuiltinFunction::DataViewSetInt32 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_set_value(data, args, DataViewValueKind::Int32)
    }
    BuiltinFunction::DataViewSetUint32 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_set_value(data, args, DataViewValueKind::Uint32)
    }
    BuiltinFunction::DataViewSetBigInt64 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_set_value(data, args, DataViewValueKind::BigInt64)
    }
    BuiltinFunction::DataViewSetBigUint64 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_set_value(data, args, DataViewValueKind::BigUint64)
    }
    BuiltinFunction::DataViewSetFloat16 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_set_value(data, args, DataViewValueKind::Float16)
    }
    BuiltinFunction::DataViewSetFloat32 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_set_value(data, args, DataViewValueKind::Float32)
    }
    BuiltinFunction::DataViewSetFloat64 => {
      let (_, data) = require_dataview_data(builtin.this_value)
      dataview_set_value(data, args, DataViewValueKind::Float64)
    }
    BuiltinFunction::ArrayBufferByteLength =>
      array_buffer_byte_length_value(builtin.this_value)
    BuiltinFunction::ArrayBufferMaxByteLength =>
      array_buffer_max_byte_length_value(builtin.this_value)
    BuiltinFunction::ArrayBufferResizable =>
      array_buffer_resizable_value(builtin.this_value)
    BuiltinFunction::ArrayBufferDetached =>
      array_buffer_detached_value(builtin.this_value)
    BuiltinFunction::SharedArrayBufferByteLength =>
      shared_array_buffer_byte_length_value(builtin.this_value)
    BuiltinFunction::SharedArrayBufferMaxByteLength =>
      shared_array_buffer_max_byte_length_value(builtin.this_value)
    BuiltinFunction::SharedArrayBufferGrowable =>
      shared_array_buffer_growable_value(builtin.this_value)
    BuiltinFunction::ArrayBufferSlice =>
      array_buffer_slice_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
        false,
      )
    BuiltinFunction::SharedArrayBufferSlice =>
      array_buffer_slice_value(
        match builtin.this_value {
          Some(value) => value
          None => Undefined
        },
        args,
        true,
      )
    BuiltinFunction::ArrayBufferTransfer =>
      array_buffer_transfer_value(builtin.this_value, args, false)
    BuiltinFunction::ArrayBufferTransferToFixedLength =>
      array_buffer_transfer_value(builtin.this_value, args, true)
    BuiltinFunction::ArrayBufferResize => {
      let (obj, data) = require_non_shared_array_buffer(builtin.this_value)
      let size_value = if args.is_empty() { Number(0.0) } else { args[0] }
      let new_len64 = to_index_int64(size_value)
      let max_int = 2147483647
      if new_len64 > Int64::from_int(max_int) {
        return throw_range_error("invalid array buffer length")
      }
      let new_len = Int64::to_int(new_len64)
      array_buffer_resize_value(obj, data, new_len)
    }
    BuiltinFunction::SharedArrayBufferGrow => {
      let (obj, data) = require_shared_array_buffer(builtin.this_value)
      let size_value = if args.is_empty() { Number(0.0) } else { args[0] }
      let new_len64 = to_index_int64(size_value)
      let max_int = 2147483647
      if new_len64 > Int64::from_int(max_int) {
        return throw_range_error("invalid array buffer length")
      }
      let new_len = Int64::to_int(new_len64)
      shared_array_buffer_grow_value(obj, data, new_len)
    }
    BuiltinFunction::AtomicsAdd => atomics_op_value(args, AtomicsOpKind::Add)
    BuiltinFunction::AtomicsAnd => atomics_op_value(args, AtomicsOpKind::And)
    BuiltinFunction::AtomicsOr => atomics_op_value(args, AtomicsOpKind::Or)
    BuiltinFunction::AtomicsSub => atomics_op_value(args, AtomicsOpKind::Sub)
    BuiltinFunction::AtomicsXor => atomics_op_value(args, AtomicsOpKind::Xor)
    BuiltinFunction::AtomicsExchange =>
      atomics_op_value(args, AtomicsOpKind::Exchange)
    BuiltinFunction::AtomicsCompareExchange =>
      atomics_op_value(args, AtomicsOpKind::CompareExchange)
    BuiltinFunction::AtomicsLoad => atomics_op_value(args, AtomicsOpKind::Load)
    BuiltinFunction::AtomicsStore => atomics_store_value(args)
    BuiltinFunction::AtomicsIsLockFree => atomics_is_lock_free_value(args)
    BuiltinFunction::AtomicsPause => atomics_pause_value(args)
    BuiltinFunction::AtomicsWait => atomics_wait_value(args)
    BuiltinFunction::AtomicsNotify => atomics_notify_value(args)
    BuiltinFunction::TypedArrayFrom => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_from_value(this_value, args)
    }
    BuiltinFunction::TypedArrayOf => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_of_value(this_value, args)
    }
    BuiltinFunction::TypedArrayGetLength =>
      typed_array_get_length_value(builtin.this_value)
    BuiltinFunction::TypedArrayGetBuffer =>
      typed_array_get_buffer_value(builtin.this_value)
    BuiltinFunction::TypedArrayGetByteLength =>
      typed_array_get_byte_length_value(builtin.this_value)
    BuiltinFunction::TypedArrayGetByteOffset =>
      typed_array_get_byte_offset_value(builtin.this_value)
    BuiltinFunction::TypedArrayGetToStringTag =>
      typed_array_get_to_string_tag_value(builtin.this_value)
    BuiltinFunction::TypedArrayAt => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_at_value(this_value, args)
    }
    BuiltinFunction::TypedArrayWith => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_with_value(this_value, args)
    }
    BuiltinFunction::TypedArrayValues => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_values_value(this_value)
    }
    BuiltinFunction::TypedArrayKeys => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_keys_value(this_value)
    }
    BuiltinFunction::TypedArrayEntries => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_entries_value(this_value)
    }
    BuiltinFunction::TypedArrayCopyWithin => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_copy_within_value(this_value, args)
    }
    BuiltinFunction::TypedArrayEvery => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let callback = if args.is_empty() { Undefined } else { args[0] }
      let this_arg = if args.length() > 1 { args[1] } else { Undefined }
      typed_array_iterate_value(
        this_value,
        callback,
        this_arg,
        ArrayIterKind::Every,
      )
    }
    BuiltinFunction::TypedArraySome => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let callback = if args.is_empty() { Undefined } else { args[0] }
      let this_arg = if args.length() > 1 { args[1] } else { Undefined }
      typed_array_iterate_value(
        this_value,
        callback,
        this_arg,
        ArrayIterKind::SomeMatch,
      )
    }
    BuiltinFunction::TypedArrayForEach => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      let callback = if args.is_empty() { Undefined } else { args[0] }
      let this_arg = if args.length() > 1 { args[1] } else { Undefined }
      typed_array_iterate_value(
        this_value,
        callback,
        this_arg,
        ArrayIterKind::ForEach,
      )
    }
    BuiltinFunction::TypedArrayMap => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_map_value(this_value, args)
    }
    BuiltinFunction::TypedArrayFilter => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_filter_value(this_value, args)
    }
    BuiltinFunction::TypedArrayReduce => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_reduce_value(this_value, args, false)
    }
    BuiltinFunction::TypedArrayReduceRight => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_reduce_value(this_value, args, true)
    }
    BuiltinFunction::TypedArrayFind => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_find_value(this_value, args, ArrayFindKind::Find)
    }
    BuiltinFunction::TypedArrayFindIndex => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_find_value(this_value, args, ArrayFindKind::FindIndex)
    }
    BuiltinFunction::TypedArrayFindLast => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_find_value(this_value, args, ArrayFindKind::FindLast)
    }
    BuiltinFunction::TypedArrayFindLastIndex => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_find_value(this_value, args, ArrayFindKind::FindLastIndex)
    }
    BuiltinFunction::TypedArrayReverse => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_reverse_value(this_value)
    }
    BuiltinFunction::TypedArrayToReversed => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_to_reversed_value(this_value)
    }
    BuiltinFunction::TypedArraySlice => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_slice_value(this_value, args)
    }
    BuiltinFunction::TypedArraySubarray => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_subarray_value(this_value, args)
    }
    BuiltinFunction::TypedArraySort => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_sort_value(this_value, args)
    }
    BuiltinFunction::TypedArrayToSorted => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_to_sorted_value(this_value, args)
    }
    BuiltinFunction::TypedArrayJoin => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      String(typed_array_join_value(this_value, args))
    }
    BuiltinFunction::TypedArrayToLocaleString => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      String(typed_array_to_locale_string_value(this_value))
    }
    BuiltinFunction::TypedArrayIndexOf => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_index_of_value(this_value, args)
    }
    BuiltinFunction::TypedArrayLastIndexOf => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_last_index_of_value(this_value, args)
    }
    BuiltinFunction::TypedArrayIncludes => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_includes_value(this_value, args)
    }
    BuiltinFunction::TypedArraySet => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_set_value(this_value, args)
    }
    BuiltinFunction::TypedArrayFill => {
      let this_value = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      typed_array_fill_value(this_value, args)
    }
    BuiltinFunction::TypedArrayConstructor =>
      throw_type_error("cannot be called")
    BuiltinFunction::ArrayBufferConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::Uint8ArrayConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::Int8ArrayConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::Uint8ClampedArrayConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::Uint16ArrayConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::Int16ArrayConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::Uint32ArrayConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::Int32ArrayConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::BigInt64ArrayConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::BigUint64ArrayConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::Float16ArrayConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::Float32ArrayConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::Float64ArrayConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::SharedArrayBufferConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::WorkerConstructor =>
      throw_type_error("constructor requires 'new'")
    BuiltinFunction::WorkerPostMessage => {
      let (worker_id, to_main) = worker_port_info(builtin.this_value)
      let payload = if args.is_empty() { Undefined } else { args[0] }
      let cloned = clone_worker_value(payload)
      worker_enqueue(worker_id, to_main, cloned)
      Undefined
    }
    BuiltinFunction::StdSprintf => std_sprintf(args)
    BuiltinFunction::StdLoadScript => {
      if args.is_empty() {
        return throw_type_error("missing filename")
      }
      std_load_script(to_string_value(args[0]))
    }
    BuiltinFunction::StdTmpfile => std_tmpfile()
    BuiltinFunction::StdOpen => {
      if args.is_empty() {
        return Null
      }
      let path = to_string_value(args[0])
      let mode = if args.length() > 1 { to_string_value(args[1]) } else { "r" }
      std_open_file(path, mode)
    }
    BuiltinFunction::StdLoadFile => {
      if args.is_empty() {
        return Null
      }
      std_load_file(to_string_value(args[0]))
    }
    BuiltinFunction::StdPopen => {
      if args.is_empty() {
        return Null
      }
      let command = to_string_value(args[0])
      let mode = if args.length() > 1 { to_string_value(args[1]) } else { "r" }
      std_popen(command, mode)
    }
    BuiltinFunction::StdParseExtJSON => {
      if args.is_empty() {
        return throw_type_error("invalid JSON")
      }
      std_parse_ext_json(to_string_value(args[0]))
    }
    BuiltinFunction::StdFdopen => {
      if args.is_empty() {
        return Null
      }
      let fd = to_int32(to_number(args[0]))
      let mode = if args.length() > 1 { to_string_value(args[1]) } else { "r" }
      std_fdopen(fd, mode)
    }
    BuiltinFunction::FilePuts => {
      let fd = require_file_fd(builtin.this_value)
      let text = if args.is_empty() { "" } else { to_string_value(args[0]) }
      let sep = if args.length() > 1 { to_string_value(args[1]) } else { "" }
      let bytes = bytes_from_string(text + sep)
      let wrote = fd_write_bytes(fd, bytes, 0, bytes.length())
      Number(Double::from_int(wrote))
    }
    BuiltinFunction::FilePutByte => {
      let fd = require_file_fd(builtin.this_value)
      let byte_value = if args.is_empty() { Number(0.0) } else { args[0] }
      let bytes = [byte_from_value(byte_value)]
      let wrote = fd_write_bytes(fd, bytes, 0, bytes.length())
      Number(Double::from_int(wrote))
    }
    BuiltinFunction::FileSeek => {
      let fd = require_file_fd(builtin.this_value)
      let offset_value = if args.is_empty() { Number(0.0) } else { args[0] }
      let offset = to_int32(to_number(offset_value))
      let whence = if args.length() > 1 {
        to_int32(to_number(args[1]))
      } else {
        seek_set
      }
      match fd_seek(fd, offset, whence) {
        Some(pos) => Number(Double::from_int(pos))
        None => Number(-1.0)
      }
    }
    BuiltinFunction::FileTell => {
      let fd = require_file_fd(builtin.this_value)
      match fd_tell(fd) {
        Some(pos) => Number(Double::from_int(pos))
        None => Number(-1.0)
      }
    }
    BuiltinFunction::FileRead => {
      let fd = require_file_fd(builtin.this_value)
      if args.is_empty() {
        return Number(0.0)
      }
      let buffer = args[0]
      let mut offset = 0
      if args.length() > 1 {
        offset = to_int32(to_number(args[1]))
      }
      let buf_len = array_buffer_byte_length(buffer)
      let len = if args.length() > 2 {
        to_int32(to_number(args[2]))
      } else {
        buf_len - offset
      }
      ensure_array_buffer_range(buf_len, offset, len)
      match fd_read_bytes(fd, len) {
        Some(bytes) => {
          let _ = write_bytes_to_array(buffer, offset, bytes)
          Number(Double::from_int(bytes.length()))
        }
        None => Number(-1.0)
      }
    }
    BuiltinFunction::FileReadAsString => {
      let fd = require_file_fd(builtin.this_value)
      match fd_read_bytes(fd, 2147483647) {
        Some(bytes) => String(string_from_bytes(bytes))
        None => String("")
      }
    }
    BuiltinFunction::FileGetByte => {
      let fd = require_file_fd(builtin.this_value)
      match fd_read_bytes(fd, 1) {
        Some(bytes) =>
          if bytes.is_empty() {
            Number(-1.0)
          } else {
            Number(Double::from_int(bytes[0].to_int()))
          }
        None => Number(-1.0)
      }
    }
    BuiltinFunction::FileGetline => {
      let fd = require_file_fd(builtin.this_value)
      match fd_read_line(fd) {
        Some(line) => String(line)
        None => Null
      }
    }
    BuiltinFunction::FileEof => {
      let fd = require_file_fd(builtin.this_value)
      match fd_eof(fd) {
        Some(done) => Bool(done)
        None => Bool(true)
      }
    }
    BuiltinFunction::FileClose => {
      let fd = require_file_fd(builtin.this_value)
      Number(Double::from_int(fd_close(fd)))
    }
    BuiltinFunction::StdGc => {
      run_gc()
      Undefined
    }
    BuiltinFunction::Print => {
      let sb = StringBuilder::new()
      let mut i = 0
      while i < args.length() {
        if i > 0 {
          sb.write_char(' ')
        }
        sb.write_string(to_string_value(args[i]))
        i = i + 1
      }
      let line = sb.to_string()
      record_print_line(line)
      println(line)
      Undefined
    }
    BuiltinFunction::Test262DetachArrayBuffer => {
      if !args.is_empty() {
        detach_array_buffer(args[0])
      }
      Undefined
    }
    BuiltinFunction::Test262EvalScript => {
      let env = realm_env_from_value(builtin.this_value)
      let source = if args.is_empty() {
        "undefined"
      } else {
        to_string_value(args[0])
      }
      let script = parse_script_with_pos(source)
      let result = with_root_env(env, fn() raise { eval_script(env, script) })
      run_pending_timers()
      run_pending_workers()
      result
    }
    BuiltinFunction::Test262CodePointRange => {
      let start = if args.is_empty() {
        UInt::default()
      } else {
        to_uint32(to_number(args[0]))
      }
      let end = if args.length() > 1 {
        to_uint32(to_number(args[1]))
      } else {
        UInt::default()
      }
      String(test262_code_point_range(start, end))
    }
    BuiltinFunction::Test262CreateRealm => {
      let base_env = realm_env_from_value(builtin.this_value)
      let new_env = new_realm_env(base_env)
      install_test262_helpers(new_env)
    }
    BuiltinFunction::Test262Gc => {
      run_gc()
      Undefined
    }
    BuiltinFunction::Test262IsHTMLDDA => Null
    BuiltinFunction::Test262AgentStart => {
      if current_agent_id() is Some(_) {
        return throw_type_error("cannot be called inside an agent")
      }
      let script = if args.is_empty() { "" } else { to_string_value(args[0]) }
      let base_env = match root_env() {
        Some(env) => env
        None => Env::new(None)
      }
      let agent_env = new_realm_env(base_env)
      let _ = install_test262_helpers(agent_env)
      let agent_id = next_agent_id()
      agent_state_set(Test262AgentState::{
        id: agent_id,
        env: agent_env,
        broadcast_callback: None,
      })
      let _ = with_root_env(agent_env, fn() raise {
        with_agent_id(Some(agent_id), fn() raise {
          eval_script(agent_env, parse_script_with_pos(script))
        })
      })
      run_pending_timers()
      run_pending_workers()
      Undefined
    }
    BuiltinFunction::Test262AgentGetReport => {
      if current_agent_id() is Some(_) {
        return throw_type_error("must be called outside of an agent")
      }
      match agent_report_pop() {
        Some(message) => String(message)
        None => Null
      }
    }
    BuiltinFunction::Test262AgentBroadcast => {
      if current_agent_id() is Some(_) {
        return throw_type_error("cannot be called inside an agent")
      }
      if args.is_empty() {
        return Undefined
      }
      let sab = args[0]
      let val = if args.length() > 1 { args[1] } else { Number(0.0) }
      for agent in agent_table_snapshot() {
        match agent.broadcast_callback {
          Some(callback) => {
            let _ = with_root_env(agent.env, fn() raise {
              with_agent_id(Some(agent.id), fn() raise {
                call_value_with_this(callback, [sab, val], Undefined)
              })
            })

          }
          None => ()
        }
      }
      Undefined
    }
    BuiltinFunction::Test262AgentReport => {
      if current_agent_id() is None {
        return throw_type_error("must be called inside an agent")
      }
      let message = if args.is_empty() {
        "undefined"
      } else {
        to_string_value(args[0])
      }
      let waiter_ids = atomics_collect_waiter_ids(message)
      if waiter_ids.is_empty() {
        match current_agent_id() {
          Some(id) =>
            match atomics_agent_last_waiter(id) {
              Some(waiter_id) => waiter_ids.push(waiter_id)
              None => ()
            }
          None => ()
        }
      }
      agent_report_push(message, waiter_ids)
      Undefined
    }
    BuiltinFunction::Test262AgentLeaving => {
      if current_agent_id() is None {
        return throw_type_error("must be called inside an agent")
      }
      Undefined
    }
    BuiltinFunction::Test262AgentReceiveBroadcast => {
      let id = match current_agent_id() {
        Some(value) => value
        None => return throw_type_error("must be called inside an agent")
      }
      if args.is_empty() || !is_callable(args[0]) {
        return throw_type_error("expecting function")
      }
      match agent_state_get(id) {
        Some(state) => {
          state.broadcast_callback = Some(args[0])
          agent_state_set(state)
        }
        None => ()
      }
      Undefined
    }
    BuiltinFunction::Test262AgentSleep => {
      let duration = if args.is_empty() {
        0
      } else {
        to_int32(to_number(args[0]))
      }
      let _ = agent_clock_advance(Int64::from_int(duration))
      Undefined
    }
    BuiltinFunction::Test262AgentMonotonicNow =>
      Number(agent_clock_now().to_double())
    BuiltinFunction::OsSetTimeout => {
      if args.is_empty() {
        return throw_type_error("not a function")
      }
      let callback = args[0]
      if !is_callable(callback) {
        return throw_type_error("not a function")
      }
      let delay = if args.length() > 1 { to_number(args[1]) } else { 0.0 }
      let id = enqueue_timer(callback, Double::to_int64(delay))
      Number(Double::from_int(id))
    }
    BuiltinFunction::OsClearTimeout => {
      if args.is_empty() {
        return Undefined
      }
      let id = to_int32(to_number(args[0]))
      clear_timer(id)
      Undefined
    }
    BuiltinFunction::OsOpen => {
      if args.is_empty() {
        return Number(-1.0)
      }
      let path = resolve_path(to_string_value(args[0]))
      let flags = if args.length() > 1 {
        to_int32(to_number(args[1]))
      } else {
        os_flag_rdonly
      }
      let writable = Int::land(flags, os_flag_wronly) != 0 ||
        Int::land(flags, os_flag_rdwr) != 0
      let readable = !writable || Int::land(flags, os_flag_rdwr) != 0
      let create = Int::land(flags, os_flag_creat) != 0
      let trunc = Int::land(flags, os_flag_trunc) != 0
      match open_file_handle(path, readable, writable, trunc, create) {
        Some(fd) => Number(Double::from_int(fd))
        None => Number(-1.0)
      }
    }
    BuiltinFunction::OsClose => {
      if args.is_empty() {
        return Number(-1.0)
      }
      let fd = to_int32(to_number(args[0]))
      Number(Double::from_int(fd_close(fd)))
    }
    BuiltinFunction::OsRead => {
      if args.length() < 2 {
        return Number(-1.0)
      }
      let fd = to_int32(to_number(args[0]))
      let buffer = args[1]
      let offset = if args.length() > 2 {
        to_int32(to_number(args[2]))
      } else {
        0
      }
      let buf_len = array_buffer_byte_length(buffer)
      let len = if args.length() > 3 {
        to_int32(to_number(args[3]))
      } else {
        buf_len - offset
      }
      ensure_array_buffer_range(buf_len, offset, len)
      match fd_read_bytes(fd, len) {
        Some(bytes) => {
          let _ = write_bytes_to_array(buffer, offset, bytes)
          Number(Double::from_int(bytes.length()))
        }
        None => Number(-1.0)
      }
    }
    BuiltinFunction::OsWrite => {
      if args.length() < 2 {
        return Number(-1.0)
      }
      let fd = to_int32(to_number(args[0]))
      let buffer = args[1]
      let offset = if args.length() > 2 {
        to_int32(to_number(args[2]))
      } else {
        0
      }
      let len = if args.length() > 3 {
        to_int32(to_number(args[3]))
      } else {
        array_buffer_byte_length(buffer) - offset
      }
      let bytes = array_bytes_from_value(buffer, offset, len)
      let wrote = fd_write_bytes(fd, bytes, 0, bytes.length())
      Number(Double::from_int(wrote))
    }
    BuiltinFunction::OsSeek => {
      if args.length() < 2 {
        return Number(-1.0)
      }
      let fd = to_int32(to_number(args[0]))
      let offset_value = args[1]
      let offset = Int64::to_int(
        Double::to_int64(Double::trunc(to_number(offset_value))),
      )
      let whence = if args.length() > 2 {
        to_int32(to_number(args[2]))
      } else {
        seek_set
      }
      let result = match fd_seek(fd, offset, whence) {
        Some(pos) => pos
        None => -1
      }
      match offset_value {
        BigInt(_) => BigInt(@bigint.BigInt::from_int(result))
        _ => Number(Double::from_int(result))
      }
    }
    BuiltinFunction::OsReaddir => {
      if args.is_empty() {
        return new_array_value([Some(Null), Some(Number(-1.0))])
      }
      let path = resolve_path(to_string_value(args[0]))
      try {
        let entries = @fs.read_dir(path)
        let files = string_array_value(entries)
        new_array_value([Some(files), Some(Number(0.0))])
      } catch {
        _ => new_array_value([Some(Null), Some(Number(-1.0))])
      }
    }
    BuiltinFunction::OsStat => {
      if args.is_empty() {
        return new_array_value([Some(Null), Some(Number(-1.0))])
      }
      let path = resolve_path(to_string_value(args[0]))
      if !@fs.path_exists(path) {
        return new_array_value([Some(Null), Some(Number(-1.0))])
      }
      let mode = os_mode_ifreg
      let mtime = match get_mtime(path) {
        Some(value) => value
        None => 0L
      }
      let stat = new_object_value()
      match stat {
        Object(obj) => {
          obj.props.set("mode", property_data(Number(Double::from_int(mode))))
          obj.props.set("mtime", property_data(Number(mtime.to_double())))
        }
        _ => ()
      }
      new_array_value([Some(stat), Some(Number(0.0))])
    }
    BuiltinFunction::OsLstat => {
      if args.is_empty() {
        return new_array_value([Some(Null), Some(Number(-1.0))])
      }
      let path = resolve_path(to_string_value(args[0]))
      let mut mode = 0
      let mut err = 0
      match get_symlink(path) {
        Some(_) => mode = os_mode_iflnk
        None =>
          if @fs.path_exists(path) {
            mode = os_mode_ifreg
          } else {
            err = -1
          }
      }
      let mtime = match get_mtime(path) {
        Some(value) => value
        None => 0L
      }
      let stat = new_object_value()
      match stat {
        Object(obj) => {
          obj.props.set("mode", property_data(Number(Double::from_int(mode))))
          obj.props.set("mtime", property_data(Number(mtime.to_double())))
        }
        _ => ()
      }
      new_array_value([Some(stat), Some(Number(Double::from_int(err)))])
    }
    BuiltinFunction::OsReadlink => {
      if args.is_empty() {
        return new_array_value([Some(Null), Some(Number(-1.0))])
      }
      let path = resolve_path(to_string_value(args[0]))
      match get_symlink(path) {
        Some(target) =>
          new_array_value([Some(String(target)), Some(Number(0.0))])
        None => new_array_value([Some(Null), Some(Number(-1.0))])
      }
    }
    BuiltinFunction::OsSymlink => {
      if args.length() < 2 {
        return Number(-1.0)
      }
      let target = to_string_value(args[0])
      let path = resolve_path(to_string_value(args[1]))
      set_symlink(path, target)
      Number(0.0)
    }
    BuiltinFunction::OsMkdir => {
      if args.is_empty() {
        return Number(-1.0)
      }
      let path = resolve_path(to_string_value(args[0]))
      try {
        let _ = @fs.create_dir(path)
        Number(0.0)
      } catch {
        _ => Number(-1.0)
      }
    }
    BuiltinFunction::OsRemove => {
      if args.is_empty() {
        return Number(-1.0)
      }
      let path = resolve_path(to_string_value(args[0]))
      match get_symlink(path) {
        Some(_) => {
          remove_symlink(path)
          return Number(0.0)
        }
        None => ()
      }
      try {
        let _ = @fs.remove_file(path)
        Number(0.0)
      } catch {
        _ =>
          try {
            let _ = @fs.remove_dir(path)
            Number(0.0)
          } catch {
            _ => Number(-1.0)
          }
      }
    }
    BuiltinFunction::OsUtimes => {
      if args.length() < 3 {
        return Number(-1.0)
      }
      let path = resolve_path(to_string_value(args[0]))
      let mtime = Double::to_int64(Double::trunc(to_number(args[2])))
      set_mtime(path, mtime)
      Number(0.0)
    }
    BuiltinFunction::OsGetcwd =>
      match @env.current_dir() {
        Some(cwd) => new_array_value([Some(String(cwd)), Some(Number(0.0))])
        None => new_array_value([Some(Null), Some(Number(-1.0))])
      }
    BuiltinFunction::OsRealpath => {
      if args.is_empty() {
        return new_array_value([Some(Null), Some(Number(-1.0))])
      }
      let path = resolve_path(to_string_value(args[0]))
      new_array_value([Some(String(path)), Some(Number(0.0))])
    }
    BuiltinFunction::OsIsatty => Bool(false)
    BuiltinFunction::OsExec => {
      if args.is_empty() {
        return Number(-1.0)
      }
      let argv = value_array_to_strings(args[0])
      let options = if args.length() > 1 { args[1] } else { Undefined }
      let block = match property_get(options, "block") {
        Bool(value) => value
        _ => true
      }
      let stdout_fd = match property_get(options, "stdout") {
        Number(num) => Some(to_int32(num))
        _ => None
      }
      let env_value = property_get(options, "env")
      let foo = match env_value {
        Object(obj) =>
          match property_get(Object(obj), "FOO") {
            Undefined => ""
            value => to_string_value(value)
          }
        _ => ""
      }
      let mut exit_code = 0
      let mut output = ""
      if argv.length() > 0 {
        let cmd0 = argv[0]
        if cmd0 == "true" {
          exit_code = 0
        } else if cmd0 == "cat" {
          exit_code = 0
        } else if (cmd0 == "sh" || cmd0 == "/bin/sh") &&
          argv.length() >= 3 &&
          argv[1] == "-c" {
          let cmd = argv[2]
          if cmd == "exit 1" {
            exit_code = 1
          } else if cmd == "test -t 0" {
            exit_code = 1
          } else if cmd == "echo $FOO" {
            output = foo + "\n"
            exit_code = 0
          }
        }
      }
      match stdout_fd {
        Some(fd) =>
          if !output.is_empty() {
            let bytes = bytes_from_string(output)
            let _ = fd_write_bytes(fd, bytes, 0, bytes.length())

          }
        None => ()
      }
      if block {
        return Number(Double::from_int(exit_code))
      }
      let status = if argv.length() > 0 && argv[0] == "cat" {
        None
      } else {
        Some(exit_code << 8)
      }
      let running = match status {
        Some(_) => false
        None => true
      }
      let pid = spawn_process(status, running, stdout_fd)
      Number(Double::from_int(pid))
    }
    BuiltinFunction::OsPipe => {
      let (read_fd, write_fd) = pipe_handle_pair()
      new_array_value([
        Some(Number(Double::from_int(read_fd))),
        Some(Number(Double::from_int(write_fd))),
      ])
    }
    BuiltinFunction::OsWaitpid => {
      if args.is_empty() {
        return new_array_value([Some(Number(-1.0)), Some(Number(0.0))])
      }
      let pid = to_int32(to_number(args[0]))
      match get_process(pid) {
        Some(proc) => {
          let status = match proc.status {
            Some(value) => value
            None => 0
          }
          set_process(pid, None)
          new_array_value([
            Some(Number(Double::from_int(pid))),
            Some(Number(Double::from_int(status))),
          ])
        }
        None => new_array_value([Some(Number(-1.0)), Some(Number(0.0))])
      }
    }
    BuiltinFunction::OsKill => {
      if args.is_empty() {
        return Number(-1.0)
      }
      let pid = to_int32(to_number(args[0]))
      let sig = if args.length() > 1 {
        to_int32(to_number(args[1]))
      } else {
        os_sigterm
      }
      match get_process(pid) {
        Some(proc) => {
          proc.status = Some(sig)
          proc.running = false
          set_process(pid, Some(proc))
          Number(0.0)
        }
        None => Number(-1.0)
      }
    }
    BuiltinFunction::FunctionConstructor =>
      match function_realm_env(Value::Builtin(builtin)) {
        Some(env) => function_from_args_with_env(args, env)
        None => function_from_args(args)
      }
    BuiltinFunction::GeneratorFunctionConstructor =>
      match function_realm_env(Value::Builtin(builtin)) {
        Some(env) => function_from_args_with_env_kind(args, env, true, false)
        None => generator_function_from_args(args)
      }
    BuiltinFunction::AsyncGeneratorFunctionConstructor =>
      match function_realm_env(Value::Builtin(builtin)) {
        Some(env) => function_from_args_with_env_kind(args, env, true, true)
        None => async_generator_function_from_args(args)
      }
    BuiltinFunction::AsyncFunctionConstructor =>
      match function_realm_env(Value::Builtin(builtin)) {
        Some(env) => function_from_args_with_env_kind(args, env, false, true)
        None => async_function_from_args(args)
      }
    BuiltinFunction::ErrorToString => {
      let target = match builtin.this_value {
        Some(value) => value
        None => Undefined
      }
      if !is_object_like(target) {
        return throw_type_error("not an object")
      }
      let obj = to_object(target)
      let name_value = property_get(obj, "name")
      let name = if name_value is Undefined {
        "Error"
      } else {
        to_string_strict(name_value)
      }
      let message_value = property_get(obj, "message")
      let message = if message_value is Undefined {
        ""
      } else {
        to_string_strict(message_value)
      }
      if name.is_empty() {
        String(message)
      } else if message.is_empty() {
        String(name)
      } else {
        String(name + ": " + message)
      }
    }
    BuiltinFunction::ErrorIsError =>
      if args.is_empty() {
        Bool(false)
      } else {
        match args[0] {
          Object(obj) => Bool(obj.is_error)
          _ => Bool(false)
        }
      }
    BuiltinFunction::ErrorConstructor => {
      let message_info = error_message_from_args(args)
      let fallback = match current_env() {
        Some(env) =>
          match error_proto_for_env_name(env, "Error") {
            Some(proto) => Some(proto)
            None => error_proto()
          }
        None => error_proto()
      }
      let proto = error_proto_from_target(Builtin(builtin), fallback)
      let obj = new_error_value(
        proto,
        message_info.message,
        set_message=message_info.has_message,
      )
      if args.length() > 1 {
        match obj {
          Object(value) => install_error_cause(value, args[1])
          _ => ()
        }
      }
      obj
    }
    BuiltinFunction::AggregateErrorConstructor => {
      let fallback = match current_env() {
        Some(env) =>
          match error_proto_for_env_name(env, "AggregateError") {
            Some(proto) => Some(proto)
            None => aggregate_error_proto()
          }
        None => aggregate_error_proto()
      }
      let proto = error_proto_from_target(Builtin(builtin), fallback)
      let target_env = function_realm_env_checked(Builtin(builtin))
      let errors_proto = match
        value_from_object(array_proto_for_env(target_env)) {
        Some(value) => Some(value)
        None => value_from_object(array_proto())
      }
      let obj = new_aggregate_error_value_with_proto(args, proto, errors_proto)
      if args.length() > 2 {
        match obj {
          Object(value) => install_error_cause(value, args[2])
          _ => ()
        }
      }
      obj
    }
    BuiltinFunction::EvalErrorConstructor => {
      let message_info = error_message_from_args(args)
      let fallback = match current_env() {
        Some(env) =>
          match error_proto_for_env_name(env, "EvalError") {
            Some(proto) => Some(proto)
            None => eval_error_proto()
          }
        None => eval_error_proto()
      }
      let proto = error_proto_from_target(Builtin(builtin), fallback)
      let obj = new_error_value(
        proto,
        message_info.message,
        set_message=message_info.has_message,
      )
      if args.length() > 1 {
        match obj {
          Object(value) => install_error_cause(value, args[1])
          _ => ()
        }
      }
      obj
    }
    BuiltinFunction::SyntaxErrorConstructor => {
      let message_info = error_message_from_args(args)
      let fallback = match current_env() {
        Some(env) =>
          match syntax_error_proto_for_env(env) {
            Some(proto) => Some(proto)
            None => syntax_error_proto()
          }
        None => syntax_error_proto()
      }
      let proto = error_proto_from_target(Builtin(builtin), fallback)
      let obj = new_error_value(
        proto,
        message_info.message,
        set_message=message_info.has_message,
      )
      if args.length() > 1 {
        match obj {
          Object(value) => install_error_cause(value, args[1])
          _ => ()
        }
      }
      obj
    }
    BuiltinFunction::RangeErrorConstructor => {
      let message_info = error_message_from_args(args)
      let fallback = match current_env() {
        Some(env) =>
          match range_error_proto_for_env(env) {
            Some(proto) => Some(proto)
            None => range_error_proto()
          }
        None => range_error_proto()
      }
      let proto = error_proto_from_target(Builtin(builtin), fallback)
      let obj = new_error_value(
        proto,
        message_info.message,
        set_message=message_info.has_message,
      )
      if args.length() > 1 {
        match obj {
          Object(value) => install_error_cause(value, args[1])
          _ => ()
        }
      }
      obj
    }
    BuiltinFunction::TypeErrorConstructor => {
      let message_info = error_message_from_args(args)
      let fallback = match current_env() {
        Some(env) =>
          match type_error_proto_for_env(env) {
            Some(proto) => Some(proto)
            None => type_error_proto()
          }
        None => type_error_proto()
      }
      let proto = error_proto_from_target(Builtin(builtin), fallback)
      let obj = new_error_value(
        proto,
        message_info.message,
        set_message=message_info.has_message,
      )
      if args.length() > 1 {
        match obj {
          Object(value) => install_error_cause(value, args[1])
          _ => ()
        }
      }
      obj
    }
    BuiltinFunction::ReferenceErrorConstructor => {
      let message_info = error_message_from_args(args)
      let fallback = match current_env() {
        Some(env) =>
          match reference_error_proto_for_env(env) {
            Some(proto) => Some(proto)
            None => reference_error_proto()
          }
        None => reference_error_proto()
      }
      let proto = error_proto_from_target(Builtin(builtin), fallback)
      let obj = new_error_value(
        proto,
        message_info.message,
        set_message=message_info.has_message,
      )
      if args.length() > 1 {
        match obj {
          Object(value) => install_error_cause(value, args[1])
          _ => ()
        }
      }
      obj
    }
    BuiltinFunction::UriErrorConstructor => {
      let message_info = error_message_from_args(args)
      let fallback = match current_env() {
        Some(env) =>
          match uri_error_proto_for_env(env) {
            Some(proto) => Some(proto)
            None => uri_error_proto()
          }
        None => uri_error_proto()
      }
      let proto = error_proto_from_target(Builtin(builtin), fallback)
      let obj = new_error_value(
        proto,
        message_info.message,
        set_message=message_info.has_message,
      )
      if args.length() > 1 {
        match obj {
          Object(value) => install_error_cause(value, args[1])
          _ => ()
        }
      }
      obj
    }
    BuiltinFunction::ThrowTypeError => {
      if args.is_empty() {
        match builtin.this_value {
          Some(Function(func)) =>
            if !func.is_strict && func.is_constructor {
              return Undefined
            }
          _ => ()
        }
      }
      throw_type_error_for_env(builtin.realm_env, "invalid property access")
    }
  }
}

///|
fn call_builtin_with_this(
  builtin : BuiltinValue,
  args : Array[Value],
  this_value : Value,
) -> Value raise {
  let target = match builtin.this_value {
    Some(_) => builtin
    None =>
      BuiltinValue::{
        kind: builtin.kind,
        id: builtin.id,
        props: builtin.props,
        this_value: Some(this_value),
        proto: builtin.proto,
        extensible: builtin.extensible,
        is_html_dda: builtin.is_html_dda,
        realm_env: builtin.realm_env,
      }
  }
  match builtin.realm_env {
    Some(env) => with_env_value(env, fn() raise { call_builtin(target, args) })
    None => call_builtin(target, args)
  }
}

///|
fn descriptor_is_accessor(desc : Value) -> Bool raise {
  has_property_value(desc, "get") || has_property_value(desc, "set")
}

///|
fn descriptor_is_data(desc : Value) -> Bool raise {
  has_property_value(desc, "value") || has_property_value(desc, "writable")
}

///|
priv struct PropertyDescInfo {
  value : Value
  writable : Bool
  enumerable : Bool
  configurable : Bool
  getter : Value
  setter : Value
  has_value : Bool
  has_writable : Bool
  has_enumerable : Bool
  has_configurable : Bool
  has_get : Bool
  has_set : Bool
}

///|
fn to_property_desc_info(desc : Value) -> PropertyDescInfo raise {
  if !is_object_like(desc) {
    let _ = throw_type_error("property description must be an object")
    return PropertyDescInfo::{
      value: Undefined,
      writable: false,
      enumerable: false,
      configurable: false,
      getter: Undefined,
      setter: Undefined,
      has_value: false,
      has_writable: false,
      has_enumerable: false,
      has_configurable: false,
      has_get: false,
      has_set: false,
    }
  }
  let mut value = Undefined
  let mut writable = false
  let mut enumerable = false
  let mut configurable = false
  let mut getter = Undefined
  let mut setter = Undefined
  let mut has_value = false
  let mut has_writable = false
  let mut has_enumerable = false
  let mut has_configurable = false
  let mut has_get = false
  let mut has_set = false
  if has_property_value(desc, "enumerable") {
    has_enumerable = true
    enumerable = is_truthy(property_get(desc, "enumerable"))
  }
  if has_property_value(desc, "configurable") {
    has_configurable = true
    configurable = is_truthy(property_get(desc, "configurable"))
  }
  if has_property_value(desc, "value") {
    has_value = true
    value = property_get(desc, "value")
  }
  if has_property_value(desc, "writable") {
    has_writable = true
    writable = is_truthy(property_get(desc, "writable"))
  }
  if has_property_value(desc, "get") {
    has_get = true
    let getter_value = property_get(desc, "get")
    if !(getter_value is Undefined) && !is_callable(getter_value) {
      let _ = throw_type_error("get is not callable")
      return PropertyDescInfo::{
        value,
        writable,
        enumerable,
        configurable,
        getter,
        setter,
        has_value,
        has_writable,
        has_enumerable,
        has_configurable,
        has_get,
        has_set,
      }
    }
    getter = getter_value
  }
  if has_property_value(desc, "set") {
    has_set = true
    let setter_value = property_get(desc, "set")
    if !(setter_value is Undefined) && !is_callable(setter_value) {
      let _ = throw_type_error("set is not callable")
      return PropertyDescInfo::{
        value,
        writable,
        enumerable,
        configurable,
        getter,
        setter,
        has_value,
        has_writable,
        has_enumerable,
        has_configurable,
        has_get,
        has_set,
      }
    }
    setter = setter_value
  }
  if (has_get || has_set) && (has_value || has_writable) {
    let _ = throw_type_error("invalid property descriptor")
    return PropertyDescInfo::{
      value,
      writable,
      enumerable,
      configurable,
      getter,
      setter,
      has_value,
      has_writable,
      has_enumerable,
      has_configurable,
      has_get,
      has_set,
    }
  }
  PropertyDescInfo::{
    value,
    writable,
    enumerable,
    configurable,
    getter,
    setter,
    has_value,
    has_writable,
    has_enumerable,
    has_configurable,
    has_get,
    has_set,
  }
}

///|
fn define_property(target : Value, key : Value, desc : Value) -> Value raise {
  let ok = define_property_value(target, key, desc, true)
  if !ok {
    return throw_type_error("cannot define property")
  }
  target
}

///|
fn module_namespace_define_property(
  obj : ObjectValue,
  name : String,
  desc_info : PropertyDescInfo,
  throw_flag : Bool,
) -> Bool raise {
  match obj.props.get(name) {
    None => {
      if throw_flag {
        let _ = throw_type_error("cannot define property")

      }
      false
    }
    Some(prop) => {
      if desc_info.has_get || desc_info.has_set {
        if throw_flag {
          let _ = throw_type_error("cannot redefine property")

        }
        return false
      }
      let current_writable = match module_binding_info(prop.value) {
        Some(_) => true
        None => prop.writable
      }
      if desc_info.has_configurable &&
        desc_info.configurable != prop.configurable {
        if throw_flag {
          let _ = throw_type_error("cannot redefine property")

        }
        return false
      }
      if desc_info.has_enumerable && desc_info.enumerable != prop.enumerable {
        if throw_flag {
          let _ = throw_type_error("cannot redefine property")

        }
        return false
      }
      if desc_info.has_writable && desc_info.writable != current_writable {
        if throw_flag {
          let _ = throw_type_error("cannot redefine property")

        }
        return false
      }
      if desc_info.has_value {
        let current_value = match module_binding_info(prop.value) {
          Some(_) => module_binding_deref(prop.value)
          None => prop.value
        }
        if !same_value(desc_info.value, current_value) {
          if throw_flag {
            let _ = throw_type_error("cannot redefine property")

          }
          return false
        }
      }
      true
    }
  }
}

///|
fn define_property_value(
  target : Value,
  key : Value,
  desc : Value,
  throw_flag : Bool,
) -> Bool raise {
  let name = property_key_name(key)
  if !is_object_like(target) {
    let _ = throw_type_error("not an object")
    return false
  }
  let desc_info = to_property_desc_info(desc)
  let desc_is_data = desc_info.has_value || desc_info.has_writable
  let desc_is_accessor = desc_info.has_get || desc_info.has_set
  match target {
    Object(obj) =>
      match obj.proxy_data {
        Some(data) =>
          return proxy_define_property(data, name, desc_info, throw_flag)
        None => ()
      }
    _ => ()
  }
  match target {
    Object(obj) if obj.is_module_namespace =>
      return module_namespace_define_property(obj, name, desc_info, throw_flag)
    _ => ()
  }
  let skip_validation = match target {
    Array(_) => name == "length"
    _ => false
  }
  if !skip_validation {
    let current_desc = get_own_property_descriptor(target, name)
    match current_desc {
      Undefined =>
        if !is_extensible_value(target) {
          if throw_flag {
            let _ = throw_type_error("object is not extensible")

          }
          return false
        }
      _ =>
        if !is_object_like(current_desc) {
          let _ = throw_type_error("invalid property descriptor")
          return false
        } else {
          let current_info = to_property_desc_info(current_desc)
          let current_configurable = if current_info.has_configurable {
            current_info.configurable
          } else {
            false
          }
          let current_enumerable = if current_info.has_enumerable {
            current_info.enumerable
          } else {
            false
          }
          if !current_configurable {
            if desc_info.has_configurable && desc_info.configurable {
              if throw_flag {
                let _ = throw_type_error("cannot redefine property")

              }
              return false
            }
            if desc_info.has_enumerable &&
              desc_info.enumerable != current_enumerable {
              if throw_flag {
                let _ = throw_type_error("cannot redefine property")

              }
              return false
            }
            let current_is_data = current_info.has_value ||
              current_info.has_writable
            let current_is_accessor = current_info.has_get ||
              current_info.has_set
            if (desc_is_data || desc_is_accessor) &&
              (
                desc_is_data != current_is_data ||
                desc_is_accessor != current_is_accessor
              ) {
              if throw_flag {
                let _ = throw_type_error("cannot redefine property")

              }
              return false
            }
            if current_is_data {
              let current_writable = if current_info.has_writable {
                current_info.writable
              } else {
                false
              }
              if !current_writable {
                if desc_info.has_writable && desc_info.writable {
                  if throw_flag {
                    let _ = throw_type_error("cannot redefine property")

                  }
                  return false
                }
                if desc_info.has_value &&
                  !same_value(desc_info.value, current_info.value) {
                  if throw_flag {
                    let _ = throw_type_error("cannot redefine property")

                  }
                  return false
                }
              }
            } else if current_is_accessor {
              if desc_info.has_get &&
                !same_value(desc_info.getter, current_info.getter) {
                if throw_flag {
                  let _ = throw_type_error("cannot redefine property")

                }
                return false
              }
              if desc_info.has_set &&
                !same_value(desc_info.setter, current_info.setter) {
                if throw_flag {
                  let _ = throw_type_error("cannot redefine property")

                }
                return false
              }
            }
          }
        }
    }
  }
  match target {
    Object(obj) => {
      match obj.string_data {
        Some(value) =>
          match parse_array_index(name) {
            Some(index) =>
              if index >= 0 &&
                index < value.length() &&
                !obj.props.contains(name) {
                obj.props.set(name, Property::{
                  value: String(
                    value.unsafe_substring(start=index, end=index + 1),
                  ),
                  writable: false,
                  configurable: false,
                  enumerable: true,
                  getter: None,
                  setter: None,
                })
              }
            None => ()
          }
        None => ()
      }
      define_property_in(obj.props, name, desc_info)
      true
    }
    Function(func) => {
      if name == "prototype" {
        ensure_function_prototype(func)
      }
      define_property_in(func.props, name, desc_info)
      true
    }
    BoundFunction(bound) => {
      define_property_in(bound.props, name, desc_info)
      true
    }
    Builtin(builtin) => {
      define_property_in(builtin.props, name, desc_info)
      true
    }
    Arguments(args) => {
      arguments_define_property(args, name, desc_info)
      true
    }
    Array(arr) =>
      try {
        define_array_property(arr, name, desc_info)
        true
      } catch {
        err => if throw_flag { raise err } else { false }
      }
    _ => false
  }
}

///|
fn prop_key_value_from_name(name : String) -> Value {
  match symbol_from_prop_key(name) {
    Some(symbol) => Symbol(symbol)
    None => String(name)
  }
}

///|
fn create_data_property(
  target : Value,
  name : String,
  value : Value,
) -> Bool raise {
  if !is_object_like(target) {
    let _ = throw_type_error("not an object")
    return false
  }
  match target {
    Object(obj) =>
      match obj.proxy_data {
        Some(_) => {
          let desc_obj = property_descriptor_object(property_data(value))
          let key_value = prop_key_value_from_name(name)
          return define_property_value(target, key_value, desc_obj, false)
        }
        None => ()
      }
    _ => ()
  }
  let desc = get_own_property_descriptor(target, name)
  match desc {
    Undefined => if !is_extensible_value(target) { return false }
    _ =>
      if !is_object_like(desc) {
        let _ = throw_type_error("invalid property descriptor")
        return false
      } else {
        let configurable = is_truthy(property_get(desc, "configurable"))
        if !configurable {
          return false
        }
      }
  }
  let desc_obj = property_descriptor_object(property_data(value))
  let key_value = prop_key_value_from_name(name)
  let _ = define_property(target, key_value, desc_obj)
  true
}

///|
fn create_data_property_or_throw(
  target : Value,
  name : String,
  value : Value,
) -> Unit raise {
  if !create_data_property(target, name, value) {
    let _ = throw_type_error("cannot define property")

  }
}

///|
fn define_properties_from_object(target : Value, props : Value) -> Unit raise {
  if !is_object_like(target) {
    let _ = throw_type_error("not an object")
    return
  }
  let props_obj = to_object(props)
  match props_obj {
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => {
          let keys = proxy_own_keys_values(data)
          let filtered : Array[Value] = []
          for key in keys {
            match key {
              String(name) => {
                let desc_obj = proxy_get_own_property_descriptor(data, name)
                match desc_obj {
                  Undefined => ()
                  _ =>
                    if !is_object_like(desc_obj) {
                      let _ = throw_type_error("invalid property descriptor")

                    } else if is_truthy(property_get(desc_obj, "enumerable")) {
                      filtered.push(String(name))
                    }
                }
              }
              Symbol(symbol) => {
                let key_name = symbol_prop_key(symbol)
                let desc_obj = proxy_get_own_property_descriptor(data, key_name)
                match desc_obj {
                  Undefined => ()
                  _ =>
                    if !is_object_like(desc_obj) {
                      let _ = throw_type_error("invalid property descriptor")

                    } else if is_truthy(property_get(desc_obj, "enumerable")) {
                      filtered.push(Symbol(symbol))
                    }
                }
              }
              _ => ()
            }
          }
          for key in filtered {
            match key {
              String(name) => {
                let desc = property_get(props_obj, name)
                let _ = define_property(target, String(name), desc)

              }
              Symbol(symbol) => {
                let key_name = symbol_prop_key(symbol)
                let desc = property_get(props_obj, key_name)
                let _ = define_property(target, Symbol(symbol), desc)

              }
              _ => ()
            }
          }
          return
        }
        None => ()
      }
    _ => ()
  }
  let names_value = object_keys(props_obj)
  match names_value {
    Array(arr) => {
      let len = arr.elements.length()
      for i = 0; i < len; i = i + 1 {
        match arr.elements[i] {
          Some(String(name)) => {
            let desc = property_get(props_obj, name)
            let _ = define_property(target, String(name), desc)

          }
          _ => ()
        }
      }
    }
    _ => ()
  }
  let symbols = own_symbol_keys(props_obj, false)
  for symbol in symbols {
    let name = symbol_prop_key(symbol)
    let desc = property_get(props_obj, name)
    let _ = define_property(target, Symbol(symbol), desc)

  }
}

///|
fn arguments_define_property(
  args : ArgumentsValue,
  name : String,
  desc_info : PropertyDescInfo,
) -> Unit raise {
  match parse_array_index(name) {
    Some(index) =>
      if index >= 0 && index < args.elements.length() {
        if !args.props.contains(name) {
          let current = arguments_index_value(args, index)
          args.props.set(name, property_data(current))
        }
        let mut mapped = false
        if index < args.mapped.length() &&
          index < args.params.length() &&
          args.mapped[index] {
          mapped = true
        }
        if mapped &&
          !desc_info.has_value &&
          !(desc_info.has_get || desc_info.has_set) {
          let current = arguments_index_value(args, index)
          match args.props.get(name) {
            Some(prop) =>
              if prop.getter is None && prop.setter is None {
                args.props.set(name, Property::{
                  value: current,
                  writable: prop.writable,
                  configurable: prop.configurable,
                  enumerable: prop.enumerable,
                  getter: None,
                  setter: None,
                })
              }
            None => ()
          }
        }
        define_property_in(args.props, name, desc_info)
        if mapped {
          if desc_info.has_value && !(desc_info.has_get || desc_info.has_set) {
            env_set_local(args.env, args.params[index], desc_info.value)
          }
          if desc_info.has_get ||
            desc_info.has_set ||
            (desc_info.has_writable && !desc_info.writable) {
            args.mapped[index] = false
          }
        }
        args.elements[index] = None
      } else {
        define_property_in(args.props, name, desc_info)
      }
    None => define_property_in(args.props, name, desc_info)
  }
}

///|
fn define_array_property(
  arr : ArrayValue,
  name : String,
  desc_info : PropertyDescInfo,
) -> Unit raise {
  match arr.typed_array_data {
    Some(data) =>
      match canonical_numeric_index_string(name) {
        Some(index) => {
          if desc_info.has_get || desc_info.has_set {
            let _ = throw_type_error("invalid property descriptor")
            return
          }
          if desc_info.has_configurable && !desc_info.configurable {
            let _ = throw_type_error("cannot define property")
            return
          }
          if desc_info.has_enumerable && !desc_info.enumerable {
            let _ = throw_type_error("cannot define property")
            return
          }
          if desc_info.has_writable && !desc_info.writable {
            let _ = throw_type_error("cannot define property")
            return
          }
          if !typed_array_is_valid_integer_index(data, index) {
            let _ = throw_type_error("cannot define property")
            return
          }
          if desc_info.has_value {
            integer_indexed_element_set(data, index, desc_info.value)
          }
          return
        }
        None => {
          define_property_in(arr.props, name, desc_info)
          return
        }
      }
    None => ()
  }
  if name == "length" {
    let mut target_len : Int64? = None
    if desc_info.has_value {
      let new_len_uint = to_uint32(to_number(desc_info.value))
      let number_len = to_number(desc_info.value)
      let new_len_num = UInt::to_double(new_len_uint)
      if Double::is_nan(number_len) || new_len_num != number_len {
        let _ = throw_range_error("invalid array length")
        return
      }
      target_len = Some(Double::to_int64(new_len_num))
    }
    if desc_info.has_get || desc_info.has_set {
      let _ = throw_type_error("invalid property descriptor")
      return
    }
    if desc_info.has_configurable && desc_info.configurable {
      let _ = throw_type_error("cannot redefine property")
      return
    }
    if desc_info.has_enumerable && desc_info.enumerable {
      let _ = throw_type_error("cannot redefine property")
      return
    }
    let mut current_writable = true
    match arr.props.get("length") {
      Some(prop) => current_writable = prop.writable
      None => ()
    }
    if !current_writable && desc_info.has_writable && desc_info.writable {
      let _ = throw_type_error("cannot redefine property")
      return
    }
    let mut writable = current_writable
    if desc_info.has_writable {
      writable = desc_info.writable
    }
    match target_len {
      Some(new_len) => {
        let ok = array_set_length_int64(arr, new_len, true)
        if !ok {
          if desc_info.has_writable && !desc_info.writable {
            let len_value = Number(
              Int64::to_double(array_length_from_props(arr)),
            )
            arr.props.set("length", Property::{
              value: len_value,
              writable: false,
              configurable: false,
              enumerable: false,
              getter: None,
              setter: None,
            })
          }
          let _ = throw_type_error("cannot redefine property")
          return
        }
      }
      None => ()
    }
    let len_value = Number(Int64::to_double(array_length_from_props(arr)))
    arr.props.set("length", Property::{
      value: len_value,
      writable,
      configurable: false,
      enumerable: false,
      getter: None,
      setter: None,
    })
    return
  }
  match array_index_from_name(name) {
    Some(index64) => {
      if index64 >= 0L {
        let current_len = array_length_from_props(arr)
        match arr.props.get("length") {
          Some(prop) =>
            if !prop.writable && index64 >= current_len {
              let _ = throw_type_error("cannot define property")
              return
            }
          None => ()
        }
        let elements_len = arr.elements.length()
        if index64 <= Int64::from_int(elements_len) {
          let index = Int64::to_int(index64)
          if index == elements_len {
            arr.elements.push(None)
          }
        }
        let current_len = array_length_from_props(arr)
        let elem_len = Int64::from_int(arr.elements.length())
        let mut new_len = if elem_len > current_len {
          elem_len
        } else {
          current_len
        }
        let index_len = index64 + 1L
        if index_len > new_len {
          new_len = index_len
        }
        set_length_prop(arr.props, Number(Int64::to_double(new_len)))
      }
      if arr.typed_array_data is None &&
        !arr.props.contains(name) &&
        index64 >= 0L &&
        index64 < Int64::from_int(arr.elements.length()) {
        let index = Int64::to_int(index64)
        match arr.elements[index] {
          Some(value) => arr.props.set(name, property_data(value))
          None => ()
        }
      }
      define_property_in(arr.props, name, desc_info)
    }
    None => define_property_in(arr.props, name, desc_info)
  }
}

///|
fn define_property_in(
  props : Map[String, Property],
  name : String,
  desc_info : PropertyDescInfo,
) -> Unit {
  let mut value = Undefined
  let mut writable = false
  let mut configurable = false
  let mut enumerable = false
  let mut getter : Value? = None
  let mut setter : Value? = None
  let mut has_value = false
  let mut has_writable = false
  let mut has_get = false
  let mut has_set = false
  match props.get(name) {
    Some(existing) => {
      value = existing.value
      writable = existing.writable
      configurable = existing.configurable
      enumerable = existing.enumerable
      getter = existing.getter
      setter = existing.setter
    }
    None => ()
  }
  if desc_info.has_value {
    value = desc_info.value
    has_value = true
  }
  if desc_info.has_writable {
    writable = desc_info.writable
    has_writable = true
  }
  if desc_info.has_configurable {
    configurable = desc_info.configurable
  }
  if desc_info.has_enumerable {
    enumerable = desc_info.enumerable
  }
  if desc_info.has_get {
    has_get = true
    getter = Some(desc_info.getter)
  }
  if desc_info.has_set {
    has_set = true
    setter = Some(desc_info.setter)
  }
  let is_accessor = has_get || has_set
  let is_data = has_value || has_writable
  if is_data && !is_accessor {
    getter = None
    setter = None
  }
  if is_accessor && !is_data {
    value = Undefined
    writable = false
  }
  props.set(name, Property::{
    value,
    writable,
    configurable,
    enumerable,
    getter,
    setter,
  })
}

///|
fn property_descriptor_object(prop : Property) -> Value {
  let desc = new_object_value()
  match desc {
    Object(obj) => {
      if prop.getter is Some(_) || prop.setter is Some(_) {
        let getter = match prop.getter {
          Some(value) => value
          None => Undefined
        }
        let setter = match prop.setter {
          Some(value) => value
          None => Undefined
        }
        obj.props.set("get", property_data(getter))
        obj.props.set("set", property_data(setter))
      } else {
        obj.props.set("value", property_data(prop.value))
        obj.props.set("writable", property_data(Bool(prop.writable)))
      }
      obj.props.set("enumerable", property_data(Bool(prop.enumerable)))
      obj.props.set("configurable", property_data(Bool(prop.configurable)))
    }
    _ => ()
  }
  desc
}

///|
fn property_descriptor_object_from_info(info : PropertyDescInfo) -> Value {
  let desc = new_object_value()
  match desc {
    Object(obj) => {
      if info.has_get {
        obj.props.set("get", property_data(info.getter))
      }
      if info.has_set {
        obj.props.set("set", property_data(info.setter))
      }
      if info.has_value {
        obj.props.set("value", property_data(info.value))
      }
      if info.has_writable {
        obj.props.set("writable", property_data(Bool(info.writable)))
      }
      if info.has_enumerable {
        obj.props.set("enumerable", property_data(Bool(info.enumerable)))
      }
      if info.has_configurable {
        obj.props.set("configurable", property_data(Bool(info.configurable)))
      }
    }
    _ => ()
  }
  desc
}

///|
fn proxy_own_keys(data : ProxyData) -> Array[String] raise {
  let values = proxy_own_keys_values(data)
  let names : Array[String] = []
  for value in values {
    match value {
      String(name) => names.push(name)
      _ => ()
    }
  }
  names
}

///|
fn own_symbol_keys_from_props(
  props : Map[String, Property],
  include_non_enum : Bool,
) -> Array[SymbolValue] {
  let symbols : Array[SymbolValue] = []
  for key, prop in props {
    if !is_symbol_prop_key(key) {
      continue
    }
    if !include_non_enum && !prop.enumerable {
      continue
    }
    match symbol_from_prop_key(key) {
      Some(symbol) => symbols.push(symbol)
      None => ()
    }
  }
  symbols
}

///|
fn own_symbol_keys(
  target : Value,
  include_non_enum : Bool,
) -> Array[SymbolValue] {
  match target {
    Object(obj) =>
      match obj.proxy_data {
        Some(_) => []
        None => own_symbol_keys_from_props(obj.props, include_non_enum)
      }
    _ =>
      match props_map_for_value(target) {
        Some(props) => own_symbol_keys_from_props(props, include_non_enum)
        None => []
      }
  }
}

///|
fn proxy_own_keys_values(data : ProxyData) -> Array[Value] raise {
  proxy_check_revoked(data)
  let handler = data.handler
  let target = data.target
  let trap = property_get(handler, "ownKeys")
  match trap {
    Undefined | Null => own_property_keys_values(target)
    _ => {
      if !is_callable(trap) {
        let _ = throw_type_error("ownKeys is not callable")
        return []
      }
      let result = call_value_with_this(trap, [target], handler)
      let result_obj = to_object(result)
      let length_value = property_get(result_obj, "length")
      let length_uint = to_uint32(to_number(length_value))
      let length = UInt::reinterpret_as_int(length_uint)
      let values : Array[Value] = []
      let seen : Map[String, Bool] = Map::new()
      for i = 0; i < length; i = i + 1 {
        let entry = property_get(result_obj, "\{i}")
        match entry {
          String(name) => {
            if seen.contains(name) {
              let _ = throw_type_error("proxy: duplicate property")
              return []
            }
            seen.set(name, true)
            values.push(String(name))
          }
          Symbol(symbol) => {
            let key = symbol_prop_key(symbol)
            if seen.contains(key) {
              let _ = throw_type_error("proxy: duplicate property")
              return []
            }
            seen.set(key, true)
            values.push(Symbol(symbol))
          }
          _ => {
            let _ = throw_type_error("ownKeys must return strings or symbols")
            return []
          }
        }
      }
      let target_keys = own_property_keys_values(target)
      let target_set : Map[String, Bool] = Map::new()
      for key in target_keys {
        let key_name = match key {
          String(name) => name
          Symbol(symbol) => symbol_prop_key(symbol)
          _ => continue
        }
        target_set.set(key_name, true)
      }
      let extensible = is_extensible_value_checked(target)
      for key in target_keys {
        let key_name = match key {
          String(name) => name
          Symbol(symbol) => symbol_prop_key(symbol)
          _ => continue
        }
        let desc = get_own_property_descriptor(target, key_name)
        match desc {
          Undefined => ()
          _ =>
            if !is_object_like(desc) {
              let _ = throw_type_error("invalid property descriptor")
              return []
            } else {
              let configurable = is_truthy(property_get(desc, "configurable"))
              if !configurable || !extensible {
                if !seen.contains(key_name) {
                  let _ = throw_type_error(
                    "proxy: target property must be present in proxy ownKeys",
                  )
                  return []
                }
              }
            }
        }
      }
      if !extensible {
        for key, _ in seen {
          if !target_set.contains(key) {
            let _ = throw_type_error(
              "proxy: property not present in target were returned by non extensible proxy",
            )
            return []
          }
        }
      }
      values
    }
  }
}

///|
fn proxy_get_own_property_descriptor_info(
  data : ProxyData,
  name : String,
) -> (Value, PropertyDescInfo?) raise {
  proxy_check_revoked(data)
  let handler = data.handler
  let target = data.target
  let trap = property_get(handler, "getOwnPropertyDescriptor")
  match trap {
    Undefined | Null => (get_own_property_descriptor(target, name), None)
    _ => {
      if !is_callable(trap) {
        let _ = throw_type_error("getOwnPropertyDescriptor is not callable")
        return (Undefined, None)
      }
      let key_value = prop_key_value_from_name(name)
      let result = call_value_with_this(trap, [target, key_value], handler)
      if result is Undefined {
        let target_desc = get_own_property_descriptor(target, name)
        match target_desc {
          Undefined => ()
          _ =>
            if !is_object_like(target_desc) {
              let _ = throw_type_error("invalid property descriptor")
              return (Undefined, None)
            } else {
              let configurable = is_truthy(
                property_get(target_desc, "configurable"),
              )
              if !configurable || !is_extensible_value_checked(target) {
                let _ = throw_type_error(
                  "proxy: inconsistent getOwnPropertyDescriptor",
                )
                return (Undefined, None)
              }
            }
        }
        return (Undefined, None)
      }
      if !is_object_like(result) {
        let _ = throw_type_error("proxy: inconsistent getOwnPropertyDescriptor")
        return (Undefined, None)
      }
      let desc_info = to_property_desc_info(result)
      let target_desc = get_own_property_descriptor(target, name)
      let target_ext = is_extensible_value_checked(target)
      let target_exists = !(target_desc is Undefined)
      if target_exists {
        if !is_object_like(target_desc) {
          let _ = throw_type_error("invalid property descriptor")
          return (Undefined, None)
        }
        let target_configurable = is_truthy(
          property_get(target_desc, "configurable"),
        )
        if !target_configurable {
          if desc_info.has_configurable && desc_info.configurable {
            let _ = throw_type_error(
              "proxy: inconsistent getOwnPropertyDescriptor",
            )
            return (Undefined, None)
          }
          if desc_info.has_enumerable &&
            desc_info.enumerable !=
            is_truthy(property_get(target_desc, "enumerable")) {
            let _ = throw_type_error(
              "proxy: inconsistent getOwnPropertyDescriptor",
            )
            return (Undefined, None)
          }
          let target_is_accessor = descriptor_is_accessor(target_desc)
          let desc_has_fields = desc_info.has_value ||
            desc_info.has_writable ||
            desc_info.has_get ||
            desc_info.has_set
          let desc_is_accessor = desc_info.has_get || desc_info.has_set
          if desc_has_fields && desc_is_accessor != target_is_accessor {
            let _ = throw_type_error(
              "proxy: inconsistent getOwnPropertyDescriptor",
            )
            return (Undefined, None)
          }
          if !target_is_accessor {
            let target_writable = is_truthy(
              property_get(target_desc, "writable"),
            )
            if !target_writable {
              if desc_info.has_writable && desc_info.writable {
                let _ = throw_type_error(
                  "proxy: inconsistent getOwnPropertyDescriptor",
                )
                return (Undefined, None)
              }
            }
          }
        }
      } else if !target_ext {
        let _ = throw_type_error("proxy: inconsistent getOwnPropertyDescriptor")
        return (Undefined, None)
      }
      let result_configurable = desc_info.has_configurable &&
        desc_info.configurable
      if !result_configurable {
        if !target_exists {
          let _ = throw_type_error(
            "proxy: inconsistent getOwnPropertyDescriptor",
          )
          return (Undefined, None)
        }
        let target_configurable = is_truthy(
          property_get(target_desc, "configurable"),
        )
        if target_configurable {
          let _ = throw_type_error(
            "proxy: inconsistent getOwnPropertyDescriptor",
          )
          return (Undefined, None)
        }
        let target_is_accessor = descriptor_is_accessor(target_desc)
        if !target_is_accessor {
          let result_has_accessor = desc_info.has_get || desc_info.has_set
          if !result_has_accessor {
            let result_writable = desc_info.has_writable && desc_info.writable
            if !result_writable {
              let target_writable = is_truthy(
                property_get(target_desc, "writable"),
              )
              if target_writable {
                let _ = throw_type_error(
                  "proxy: inconsistent getOwnPropertyDescriptor",
                )
                return (Undefined, None)
              }
            }
          }
        }
      }
      (result, Some(desc_info))
    }
  }
}

///|
fn proxy_get_own_property_descriptor(
  data : ProxyData,
  name : String,
) -> Value raise {
  let (result, _) = proxy_get_own_property_descriptor_info(data, name)
  result
}

///|
fn get_own_property_descriptor(target : Value, name : String) -> Value raise {
  match target {
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => proxy_get_own_property_descriptor(data, name)
        None =>
          match obj.props.get(name) {
            Some(prop) =>
              if obj.is_module_namespace {
                match module_binding_info(prop.value) {
                  Some(_) =>
                    property_descriptor_object(Property::{
                      value: module_binding_deref(prop.value),
                      writable: true,
                      configurable: prop.configurable,
                      enumerable: prop.enumerable,
                      getter: prop.getter,
                      setter: prop.setter,
                    })
                  None => property_descriptor_object(prop)
                }
              } else {
                property_descriptor_object(prop)
              }
            None =>
              match obj.string_data {
                Some(value) =>
                  if name == "length" {
                    property_descriptor_object(
                      property_data_const(
                        Number(Double::from_int(value.length())),
                      ),
                    )
                  } else {
                    match parse_array_index(name) {
                      Some(index) =>
                        if index >= 0 && index < value.length() {
                          property_descriptor_object(Property::{
                            value: String(
                              value.unsafe_substring(start=index, end=index + 1),
                            ),
                            writable: false,
                            configurable: false,
                            enumerable: true,
                            getter: None,
                            setter: None,
                          })
                        } else {
                          Undefined
                        }
                      None => Undefined
                    }
                  }
                None => Undefined
              }
          }
      }
    Function(func) => {
      if name == "prototype" && !func.props.contains(name) {
        ensure_function_prototype(func)
      }
      match func.props.get(name) {
        Some(prop) => property_descriptor_object(prop)
        None => Undefined
      }
    }
    BoundFunction(bound) =>
      match bound.props.get(name) {
        Some(prop) => property_descriptor_object(prop)
        None => Undefined
      }
    Builtin(builtin) =>
      match builtin.props.get(name) {
        Some(prop) => property_descriptor_object(prop)
        None => Undefined
      }
    Array(arr) =>
      match arr.typed_array_data {
        Some(data) =>
          match canonical_numeric_index_string(name) {
            Some(index) =>
              if typed_array_is_valid_integer_index(data, index) {
                let value = typed_array_get_index(data, Double::to_int(index))
                property_descriptor_object(Property::{
                  value,
                  writable: true,
                  configurable: true,
                  enumerable: true,
                  getter: None,
                  setter: None,
                })
              } else {
                Undefined
              }
            None =>
              match arr.props.get(name) {
                Some(prop) => property_descriptor_object(prop)
                None => Undefined
              }
          }
        None =>
          match arr.props.get(name) {
            Some(prop) => property_descriptor_object(prop)
            None =>
              match parse_array_index(name) {
                Some(index) =>
                  if index >= 0 && index < arr.elements.length() {
                    match arr.elements[index] {
                      Some(value) =>
                        property_descriptor_object(property_data(value))
                      None => Undefined
                    }
                  } else {
                    Undefined
                  }
                None => Undefined
              }
          }
      }
    Arguments(args) =>
      match args.props.get(name) {
        Some(prop) =>
          match parse_array_index(name) {
            Some(index) =>
              if index < args.mapped.length() &&
                index < args.params.length() &&
                args.mapped[index] &&
                prop.getter is None &&
                prop.setter is None {
                let value = arguments_index_value(args, index)
                property_descriptor_object(Property::{
                  value,
                  writable: prop.writable,
                  configurable: prop.configurable,
                  enumerable: prop.enumerable,
                  getter: None,
                  setter: None,
                })
              } else {
                property_descriptor_object(prop)
              }
            None => property_descriptor_object(prop)
          }
        None =>
          match parse_array_index(name) {
            Some(index) =>
              if arguments_has_index(args, index) {
                property_descriptor_object(
                  property_data(arguments_index_value(args, index)),
                )
              } else {
                Undefined
              }
            None => Undefined
          }
      }
    _ => Undefined
  }
}

///|
fn get_own_property_descriptor_with_info(
  target : Value,
  name : String,
) -> (Value, PropertyDescInfo?) raise {
  match target {
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => proxy_get_own_property_descriptor_info(data, name)
        None => {
          let desc = get_own_property_descriptor(target, name)
          match desc {
            Undefined => (Undefined, None)
            _ =>
              if !is_object_like(desc) {
                (desc, None)
              } else {
                (desc, Some(to_property_desc_info(desc)))
              }
          }
        }
      }
    _ => {
      let desc = get_own_property_descriptor(target, name)
      match desc {
        Undefined => (Undefined, None)
        _ =>
          if !is_object_like(desc) {
            (desc, None)
          } else {
            (desc, Some(to_property_desc_info(desc)))
          }
      }
    }
  }
}

///|
fn object_get_own_property_names(target : Value) -> Value raise {
  match target {
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => names_to_array_value(proxy_own_keys(data))
        None =>
          match obj.string_data {
            Some(_) => names_to_array_value(string_own_keys(obj, true))
            None =>
              if obj.is_module_namespace {
                names_to_array_value(
                  module_namespace_prop_keys(obj.props, true),
                )
              } else {
                names_to_array_value(ordered_prop_keys(obj.props, true))
              }
          }
      }
    Function(func) => names_to_array_value(ordered_prop_keys(func.props, true))
    BoundFunction(bound) =>
      names_to_array_value(ordered_prop_keys(bound.props, true))
    Builtin(builtin) =>
      names_to_array_value(ordered_prop_keys(builtin.props, true))
    Array(arr) => names_to_array_value(array_own_keys(arr, true))
    Arguments(args) => names_to_array_value(arguments_own_keys(args, true))
    _ => new_array_value([])
  }
}

///|
fn object_keys(target : Value) -> Value raise {
  match target {
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => {
          let keys = proxy_own_keys_values(data)
          let names : Array[String] = []
          for key in keys {
            match key {
              String(name) => {
                let desc = proxy_get_own_property_descriptor(data, name)
                match desc {
                  Undefined => ()
                  _ =>
                    if !is_object_like(desc) {
                      let _ = throw_type_error("invalid property descriptor")

                    } else if is_truthy(property_get(desc, "enumerable")) {
                      names.push(name)
                    }
                }
              }
              _ => ()
            }
          }
          names_to_array_value(names)
        }
        None => {
          let names_value = object_get_own_property_names(target)
          match names_value {
            Array(arr) => {
              let names : Array[String] = []
              for entry in arr.elements {
                match entry {
                  Some(String(name)) => {
                    let desc = get_own_property_descriptor(target, name)
                    match desc {
                      Undefined => ()
                      _ =>
                        if !is_object_like(desc) {
                          let _ = throw_type_error(
                            "invalid property descriptor",
                          )

                        } else if is_truthy(property_get(desc, "enumerable")) {
                          names.push(name)
                        }
                    }
                  }
                  _ => ()
                }
              }
              names_to_array_value(names)
            }
            _ => new_array_value([])
          }
        }
      }
    _ => {
      let names_value = object_get_own_property_names(target)
      match names_value {
        Array(arr) => {
          let names : Array[String] = []
          for entry in arr.elements {
            match entry {
              Some(String(name)) => {
                let desc = get_own_property_descriptor(target, name)
                match desc {
                  Undefined => ()
                  _ =>
                    if !is_object_like(desc) {
                      let _ = throw_type_error("invalid property descriptor")

                    } else if is_truthy(property_get(desc, "enumerable")) {
                      names.push(name)
                    }
                }
              }
              _ => ()
            }
          }
          names_to_array_value(names)
        }
        _ => new_array_value([])
      }
    }
  }
}

///|
const OBJECT_KEYS_KIND_KEYS : Int = 0

///|
const OBJECT_KEYS_KIND_VALUES : Int = 1

///|
const OBJECT_KEYS_KIND_ENTRIES : Int = 2

///|
fn object_key_values(target : Value, kind : Int) -> Value raise {
  let entries : Array[Value?] = []
  fn push_entry(
    entries : Array[Value?],
    name : String,
    value : Value,
    kind : Int,
  ) -> Unit {
    match kind {
      OBJECT_KEYS_KIND_KEYS => entries.push(Some(String(name)))
      OBJECT_KEYS_KIND_VALUES => entries.push(Some(value))
      _ => {
        let pair = new_array_value([Some(String(name)), Some(value)])
        entries.push(Some(pair))
      }
    }
  }

  match target {
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => {
          let keys = proxy_own_keys_values(data)
          for key in keys {
            match key {
              String(name) => {
                let desc = proxy_get_own_property_descriptor(data, name)
                match desc {
                  Undefined => ()
                  _ =>
                    if !is_object_like(desc) {
                      let _ = throw_type_error("invalid property descriptor")

                    } else if is_truthy(property_get(desc, "enumerable")) {
                      if kind == OBJECT_KEYS_KIND_KEYS {
                        entries.push(Some(String(name)))
                      } else {
                        let value = property_get(target, name)
                        push_entry(entries, name, value, kind)
                      }
                    }
                }
              }
              _ => ()
            }
          }
        }
        None => {
          let names_value = object_get_own_property_names(target)
          match names_value {
            Array(arr) =>
              for entry in arr.elements {
                match entry {
                  Some(String(name)) => {
                    let desc = get_own_property_descriptor(target, name)
                    match desc {
                      Undefined => ()
                      _ =>
                        if !is_object_like(desc) {
                          let _ = throw_type_error(
                            "invalid property descriptor",
                          )

                        } else if is_truthy(property_get(desc, "enumerable")) {
                          if kind == OBJECT_KEYS_KIND_KEYS {
                            entries.push(Some(String(name)))
                          } else {
                            let value = property_get(target, name)
                            push_entry(entries, name, value, kind)
                          }
                        }
                    }
                  }
                  _ => ()
                }
              }
            _ => ()
          }
        }
      }
    _ => {
      let names_value = object_get_own_property_names(target)
      match names_value {
        Array(arr) =>
          for entry in arr.elements {
            match entry {
              Some(String(name)) => {
                let desc = get_own_property_descriptor(target, name)
                match desc {
                  Undefined => ()
                  _ =>
                    if !is_object_like(desc) {
                      let _ = throw_type_error("invalid property descriptor")

                    } else if is_truthy(property_get(desc, "enumerable")) {
                      if kind == OBJECT_KEYS_KIND_KEYS {
                        entries.push(Some(String(name)))
                      } else {
                        let value = property_get(target, name)
                        push_entry(entries, name, value, kind)
                      }
                    }
                }
              }
              _ => ()
            }
          }
        _ => ()
      }
    }
  }
  new_array_value(entries)
}

///|
fn object_get_own_property_descriptors(target : Value) -> Value raise {
  let result = new_object_value()
  match result {
    Object(obj) => {
      let mut keys : Array[Value] = []
      match target {
        Object(raw) =>
          match raw.proxy_data {
            Some(data) => keys = proxy_own_keys_values(data)
            None => {
              let names = object_get_own_property_names(target)
              match names {
                Array(arr) =>
                  for entry in arr.elements {
                    match entry {
                      Some(String(name)) => keys.push(String(name))
                      _ => ()
                    }
                  }
                _ => ()
              }
              let symbols = own_symbol_keys(target, true)
              for symbol in symbols {
                keys.push(Symbol(symbol))
              }
            }
          }
        _ => {
          let names = object_get_own_property_names(target)
          match names {
            Array(arr) =>
              for entry in arr.elements {
                match entry {
                  Some(String(name)) => keys.push(String(name))
                  _ => ()
                }
              }
            _ => ()
          }
          let symbols = own_symbol_keys(target, true)
          for symbol in symbols {
            keys.push(Symbol(symbol))
          }
        }
      }
      for key in keys {
        match key {
          String(name) => {
            let desc = get_own_property_descriptor(target, name)
            if !(desc is Undefined) {
              let desc_prop = property_descriptor_object(property_data(desc))
              let _ = define_property(Object(obj), String(name), desc_prop)

            }
          }
          Symbol(symbol) => {
            let name = symbol_prop_key(symbol)
            let desc = get_own_property_descriptor(target, name)
            if !(desc is Undefined) {
              let desc_prop = property_descriptor_object(property_data(desc))
              let _ = define_property(Object(obj), Symbol(symbol), desc_prop)

            }
          }
          _ => ()
        }
      }
    }
    _ => ()
  }
  result
}

///|
fn own_property_keys_values(target : Value) -> Array[Value] raise {
  let mut keys : Array[Value] = []
  match target {
    Object(raw) =>
      match raw.proxy_data {
        Some(data) => keys = proxy_own_keys_values(data)
        None => {
          let names = object_get_own_property_names(target)
          match names {
            Array(arr) =>
              for entry in arr.elements {
                match entry {
                  Some(String(name)) => keys.push(String(name))
                  _ => ()
                }
              }
            _ => ()
          }
          let symbols = own_symbol_keys(target, true)
          for symbol in symbols {
            keys.push(Symbol(symbol))
          }
        }
      }
    _ => {
      let names = object_get_own_property_names(target)
      match names {
        Array(arr) =>
          for entry in arr.elements {
            match entry {
              Some(String(name)) => keys.push(String(name))
              _ => ()
            }
          }
        _ => ()
      }
      let symbols = own_symbol_keys(target, true)
      for symbol in symbols {
        keys.push(Symbol(symbol))
      }
    }
  }
  keys
}

///|
fn object_from_entries(iterable : Value) -> Value raise {
  let obj = new_object_value()
  let (iterator, next_method) = get_iterator_from_value(iterable)
  while true {
    let (done, item) = iterator_step_value(iterator, next_method) catch {
      err => raise err
    }
    if done {
      break
    }
    try {
      if !is_object_like(item) {
        let _ = throw_type_error("not an object")

      }
      let key = property_get(item, "0")
      let value = property_get(item, "1")
      let name = property_key_name(key)
      create_data_property_or_throw(obj, name, value)
    } catch {
      err => {
        iterator_close_on_error(iterator)
        raise err
      }
    }
  }
  obj
}

///|
fn object_group_by(iterable : Value, callback : Value) -> Value raise {
  if !is_callable(callback) {
    let _ = throw_type_error("not a function")
    return Undefined
  }
  let (iterator, next_method) = get_iterator_from_value(iterable)
  let groups = new_object_value_with_proto(None)
  let mut index : Int64 = 0
  let max_safe : Int64 = 9007199254740991L
  let this_arg = match current_env() {
    Some(env) =>
      match global_object(env) {
        Some(obj) => Object(obj)
        None => Undefined
      }
    None => Undefined
  }
  try {
    while true {
      if index >= max_safe {
        let _ = throw_type_error("too many elements")

      }
      let (done, item) = iterator_step_value(iterator, next_method)
      if done {
        break
      }
      let key = call_value_with_this(
        callback,
        [item, Number(Int64::to_double(index))],
        this_arg,
      )
      let name = property_key_name(key)
      let mut bucket = property_get(groups, name)
      if bucket is Undefined {
        bucket = new_array_value([])
        let _ = create_data_property(groups, name, bucket)

      }
      let _ = array_push_value(bucket, [item])
      index = index + 1L
    }
  } catch {
    err => {
      iterator_close_on_error(iterator)
      raise err
    }
  }
  groups
}

///|
fn map_group_by(iterable : Value, callback : Value) -> Value raise {
  if !is_callable(callback) {
    let _ = throw_type_error("not a function")
    return Undefined
  }
  let (iterator, next_method) = get_iterator_from_value(iterable)
  let mut data = MapData::{ entries: [] }
  let proto = match current_env() {
    Some(env) =>
      match value_from_object(map_proto_for_env(env)) {
        Some(value) => Some(value)
        None => value_from_object(map_proto())
      }
    None => value_from_object(map_proto())
  }
  let groups = new_map_value_with_proto(proto)
  match groups {
    Object(obj) =>
      match obj.map_data {
        Some(map_data) => data = map_data
        None => ()
      }
    _ => ()
  }
  let mut index : Int64 = 0
  let max_safe : Int64 = 9007199254740991L
  let this_arg = match current_env() {
    Some(env) =>
      match global_object(env) {
        Some(obj) => Object(obj)
        None => Undefined
      }
    None => Undefined
  }
  try {
    while true {
      if index >= max_safe {
        let _ = throw_type_error("too many elements")

      }
      let (done, item) = iterator_step_value(iterator, next_method)
      if done {
        break
      }
      let key = call_value_with_this(
        callback,
        [item, Number(Int64::to_double(index))],
        this_arg,
      )
      let normalized = map_normalize_key(key)
      let mut bucket = Undefined
      match map_find_index(data.entries, normalized) {
        Some(entry_index) =>
          match data.entries[entry_index] {
            Some((_, value)) => bucket = value
            None => ()
          }
        None => {
          bucket = new_array_value([])
          map_set_value(data, normalized, bucket)
        }
      }
      let _ = array_push_value(bucket, [item])
      index = index + 1L
    }
  } catch {
    err => {
      iterator_close_on_error(iterator)
      raise err
    }
  }
  groups
}

///|
fn object_define_accessor(
  this_value : Value,
  name_value : Value,
  func_value : Value,
  is_setter : Bool,
) -> Value raise {
  let obj = to_object(this_value)
  if !is_callable(func_value) {
    let _ = throw_type_error("not a function")
    return Undefined
  }
  let name = property_key_name(name_value)
  let desc = new_object_value()
  match desc {
    Object(desc_obj) => {
      if is_setter {
        desc_obj.props.set("set", property_data(func_value))
      } else {
        desc_obj.props.set("get", property_data(func_value))
      }
      desc_obj.props.set("enumerable", property_data(Bool(true)))
      desc_obj.props.set("configurable", property_data(Bool(true)))
    }
    _ => ()
  }
  let _ = define_property(obj, String(name), desc)
  Undefined
}

///|
fn object_lookup_accessor(
  this_value : Value,
  name_value : Value,
  is_setter : Bool,
) -> Value raise {
  let obj = to_object(this_value)
  let name = property_key_name(name_value)
  let mut current : Value? = Some(obj)
  while true {
    match current {
      Some(value) => {
        let desc = get_own_property_descriptor(value, name)
        match desc {
          Undefined => current = get_proto_of_value_checked(value)
          _ =>
            if !is_object_like(desc) {
              let _ = throw_type_error("invalid property descriptor")
              return Undefined
            } else if descriptor_is_accessor(desc) {
              let key = if is_setter { "set" } else { "get" }
              return property_get(desc, key)
            } else {
              return Undefined
            }
        }
      }
      None => return Undefined
    }
  }
  Undefined
}

///|
fn object_proto_get(this_value : Value) -> Value raise {
  let obj = to_object(this_value)
  match get_proto_of_value_checked(obj) {
    Some(proto) => proto
    None => Null
  }
}

///|
fn object_proto_set(this_value : Value, proto_value : Value) -> Value raise {
  match this_value {
    Undefined | Null => {
      let _ = throw_type_error("not an object")
      return Undefined
    }
    _ => ()
  }
  if !is_object_like(proto_value) && !(proto_value is Null) {
    return Undefined
  }
  if is_object_like(this_value) {
    let proto = if proto_value is Null { None } else { Some(proto_value) }
    let _ = set_proto_of_value(this_value, proto, true)

  }
  Undefined
}

///|
fn string_own_keys(obj : ObjectValue, include_non_enum : Bool) -> Array[String] {
  match obj.string_data {
    None => ordered_prop_keys(obj.props, include_non_enum)
    Some(value) => {
      let indices : Array[Int64] = []
      let non_indices : Array[String] = []
      let seen : Map[Int64, Bool] = Map::new()
      let len = value.length()
      for i = 0; i < len; i = i + 1 {
        let index = Int64::from_int(i)
        seen.set(index, true)
        indices.push(index)
      }
      for key, prop in obj.props {
        if is_symbol_prop_key(key) || is_private_prop_key(key) {
          continue
        }
        if include_non_enum || prop.enumerable {
          match array_index_from_name(key) {
            Some(index) =>
              if !seen.contains(index) {
                seen.set(index, true)
                indices.push(index)
              }
            None => non_indices.push(key)
          }
        }
      }
      sort_int64s(indices)
      let names : Array[String] = []
      for index in indices {
        names.push(Int64::to_string(index))
      }
      if include_non_enum && !obj.props.contains("length") {
        names.push("length")
      }
      for name in non_indices {
        names.push(name)
      }
      names
    }
  }
}

///|
fn array_own_keys(arr : ArrayValue, include_non_enum : Bool) -> Array[String] {
  let indices : Array[Int64] = []
  let non_indices : Array[String] = []
  let seen : Map[Int64, Bool] = Map::new()
  let mut use_typed_indices = false
  let mut len = arr.elements.length()
  match arr.typed_array_data {
    Some(data) => {
      use_typed_indices = true
      len = typed_array_effective_length(data)
    }
    None => ()
  }
  for i = 0; i < len; i = i + 1 {
    if use_typed_indices {
      let index = Int64::from_int(i)
      seen.set(index, true)
      indices.push(index)
    } else {
      let name = Int::to_string(i)
      match arr.props.get(name) {
        Some(prop) =>
          if include_non_enum || prop.enumerable {
            let index = Int64::from_int(i)
            seen.set(index, true)
            indices.push(index)
          }
        None =>
          match arr.elements[i] {
            Some(_) => {
              let index = Int64::from_int(i)
              seen.set(index, true)
              indices.push(index)
            }
            None => ()
          }
      }
    }
  }
  for key, prop in arr.props {
    if is_symbol_prop_key(key) || is_private_prop_key(key) {
      continue
    }
    if include_non_enum || prop.enumerable {
      match array_index_from_name(key) {
        Some(index) =>
          if !seen.contains(index) {
            seen.set(index, true)
            indices.push(index)
          }
        None => non_indices.push(key)
      }
    }
  }
  sort_int64s(indices)
  let names : Array[String] = []
  for index in indices {
    names.push(Int64::to_string(index))
  }
  for name in non_indices {
    names.push(name)
  }
  names
}

///|
fn arguments_own_keys(
  args : ArgumentsValue,
  include_non_enum : Bool,
) -> Array[String] {
  let indices : Array[Int64] = []
  let non_indices : Array[String] = []
  let seen : Map[Int64, Bool] = Map::new()
  let len = args.elements.length()
  for i = 0; i < len; i = i + 1 {
    let name = Int::to_string(i)
    match args.props.get(name) {
      Some(prop) =>
        if include_non_enum || prop.enumerable {
          let index = Int64::from_int(i)
          seen.set(index, true)
          indices.push(index)
        }
      None =>
        if arguments_has_index(args, i) {
          let index = Int64::from_int(i)
          seen.set(index, true)
          indices.push(index)
        }
    }
  }
  for key, prop in args.props {
    if is_symbol_prop_key(key) || is_private_prop_key(key) {
      continue
    }
    if include_non_enum || prop.enumerable {
      match array_index_from_name(key) {
        Some(index) =>
          if !seen.contains(index) {
            seen.set(index, true)
            indices.push(index)
          }
        None => non_indices.push(key)
      }
    }
  }
  sort_int64s(indices)
  let names : Array[String] = []
  for index in indices {
    names.push(Int64::to_string(index))
  }
  for name in non_indices {
    names.push(name)
  }
  names
}

///|
priv struct JsonStringifyState {
  gap : String
  mut indent : String
  mut replacer : Value
  mut property_list : Array[String]?
  stack : Array[Int]
}

///|
fn json_gap_from_space(value : Value) -> String raise {
  match value {
    Number(num) =>
      if Double::is_nan(num) || Double::is_inf(num) {
        ""
      } else {
        let count = Double::to_int(Double::trunc(num))
        let clamped = if count < 0 {
          0
        } else if count > 10 {
          10
        } else {
          count
        }
        " ".repeat(clamped)
      }
    String(s) => {
      let len = s.length()
      let max_len = if len > 10 { 10 } else { len }
      s.unsafe_substring(start=0, end=max_len)
    }
    Object(obj) =>
      match obj.number_data {
        Some(_) => {
          let num = to_number(value)
          if Double::is_nan(num) || Double::is_inf(num) {
            ""
          } else {
            let count = Double::to_int(Double::trunc(num))
            let clamped = if count < 0 {
              0
            } else if count > 10 {
              10
            } else {
              count
            }
            " ".repeat(clamped)
          }
        }
        None =>
          match obj.string_data {
            Some(_) => {
              let text = to_string_strict(value)
              let len = text.length()
              let max_len = if len > 10 { 10 } else { len }
              text.unsafe_substring(start=0, end=max_len)
            }
            None => ""
          }
      }
    _ => ""
  }
}

///|
fn json_replacer_item_name(value : Value) -> String? raise {
  match value {
    String(s) => Some(s)
    Number(num) => Some(to_string_value(Number(num)))
    Object(obj) =>
      if obj.string_data is Some(_) || obj.number_data is Some(_) {
        Some(to_string_strict(value))
      } else {
        None
      }
    _ => None
  }
}

///|
fn json_replacer_property_list(value : Value) -> Array[String] raise {
  let list : Array[String] = []
  let seen : Map[String, Bool] = Map::new()
  let len_value = property_get(value, "length")
  let len = to_length_int64(to_number(len_value))
  let mut i : Int64 = 0
  while i < len {
    let key = Int64::to_string(i)
    let item = property_get(value, key)
    match json_replacer_item_name(item) {
      Some(name) =>
        if !seen.contains(name) {
          seen.set(name, true)
          list.push(name)
        }
      None => ()
    }
    i = i + 1
  }
  list
}

///|
fn json_unwrap_object_value(value : Value) -> Value raise {
  match value {
    Object(obj) =>
      match obj.number_data {
        Some(_) => Number(to_number(value))
        None =>
          match obj.string_data {
            Some(_) => String(to_string_strict(value))
            None =>
              match obj.bool_data {
                Some(flag) => Bool(flag)
                None =>
                  match obj.bigint_data {
                    Some(bigint) => BigInt(bigint)
                    None => value
                  }
              }
          }
      }
    _ => value
  }
}

///|
fn json_number_string(value : Double) -> String {
  if Double::is_nan(value) || Double::is_inf(value) {
    "null"
  } else {
    Double::to_string(value)
  }
}

///|
fn json_stack_contains(stack : Array[Int], id : Int) -> Bool {
  for entry in stack {
    if entry == id {
      return true
    }
  }
  false
}

///|
fn json_stack_push(state : JsonStringifyState, value : Value) -> Bool raise {
  match value_id(value) {
    Some(id) =>
      if json_stack_contains(state.stack, id) {
        let _ = throw_type_error("cyclic object value")
        false
      } else {
        state.stack.push(id)
        true
      }
    None => false
  }
}

///|
fn json_serialize_array(
  value : Value,
  state : JsonStringifyState,
) -> String raise {
  let pushed = json_stack_push(state, value)
  let stepback = state.indent
  state.indent = stepback + state.gap
  let len_value = property_get(value, "length")
  let len = to_length_int64(to_number(len_value))
  let parts : Array[String] = []
  let mut i : Int64 = 0
  while i < len {
    let key = Int64::to_string(i)
    let part = json_serialize_property(key, value, state)
    match part {
      Some(text) => parts.push(text)
      None => parts.push("null")
    }
    i = i + 1
  }
  let result = if parts.is_empty() {
    "[]"
  } else if state.gap.is_empty() {
    "[" + parts.join(",") + "]"
  } else {
    let inner_indent = state.indent
    let outer_indent = stepback
    let formatted : Array[String] = parts.map(fn(part) { inner_indent + part })
    "[\n" + formatted.join(",\n") + "\n" + outer_indent + "]"
  }
  state.indent = stepback
  if pushed {
    let _ = state.stack.pop()

  }
  result
}

///|
fn json_serialize_object(
  value : Value,
  state : JsonStringifyState,
) -> String raise {
  let pushed = json_stack_push(state, value)
  let stepback = state.indent
  state.indent = stepback + state.gap
  let keys = match state.property_list {
    Some(list) => list
    None => own_enumerable_string_keys(value)
  }
  let parts : Array[String] = []
  for key in keys {
    let rendered = json_serialize_property(key, value, state)
    match rendered {
      Some(text) => {
        let name = json_escape(key)
        if state.gap.is_empty() {
          parts.push("\"" + name + "\":" + text)
        } else {
          parts.push("\"" + name + "\": " + text)
        }
      }
      None => ()
    }
  }
  let result = if parts.is_empty() {
    "{}"
  } else if state.gap.is_empty() {
    "{" + parts.join(",") + "}"
  } else {
    let inner_indent = state.indent
    let outer_indent = stepback
    let formatted : Array[String] = parts.map(fn(part) { inner_indent + part })
    "{\n" + formatted.join(",\n") + "\n" + outer_indent + "}"
  }
  state.indent = stepback
  if pushed {
    let _ = state.stack.pop()

  }
  result
}

///|
fn json_serialize_property(
  key : String,
  holder : Value,
  state : JsonStringifyState,
) -> String? raise {
  let mut value = property_get(holder, key)
  if is_object_like(value) || value is BigInt(_) {
    let to_json = property_get(value, "toJSON")
    if is_callable(to_json) {
      value = call_value_with_this(to_json, [String(key)], value)
    }
  }
  if is_callable(state.replacer) {
    value = call_value_with_this(state.replacer, [String(key), value], holder)
  }
  value = json_unwrap_object_value(value)
  match value {
    Undefined => return None
    Symbol(_) => return None
    BigInt(_) => {
      let _ = throw_type_error("cannot convert BigInt to JSON")
      return None
    }
    _ => ()
  }
  if is_callable(value) {
    return None
  }
  match value {
    Null => Some("null")
    Bool(v) => Some(if v { "true" } else { "false" })
    Number(num) => Some(json_number_string(num))
    String(text) => Some("\"" + json_escape(text) + "\"")
    _ =>
      if is_array_value(value) {
        Some(json_serialize_array(value, state))
      } else {
        Some(json_serialize_object(value, state))
      }
  }
}

///|
fn json_stringify_with_replacer(
  value : Value,
  replacer : Value,
  space : Value,
) -> Value raise {
  let gap = json_gap_from_space(space)
  let state = JsonStringifyState::{
    gap,
    indent: "",
    replacer: Undefined,
    property_list: None,
    stack: [],
  }
  if is_callable(replacer) {
    state.replacer = replacer
  } else if is_object_like(replacer) {
    if is_array_value(replacer) {
      state.property_list = Some(json_replacer_property_list(replacer))
    }
  }
  let wrapper = new_object_value()
  create_data_property_or_throw(wrapper, "", value)
  match json_serialize_property("", wrapper, state) {
    Some(text) => String(text)
    None => Undefined
  }
}

///|
fn json_stringify_value(value : Value) -> String raise {
  match value {
    Null => "null"
    Bool(v) => if v { "true" } else { "false" }
    Number(v) =>
      if Double::is_nan(v) || Double::is_inf(v) {
        "null"
      } else {
        Double::to_string(v)
      }
    String(s) => "\"\{json_escape(s)}\""
    Object(obj) => json_stringify_object(obj)
    Array(arr) => json_stringify_array(arr)
    Arguments(args) => json_stringify_arguments(args)
    Function(_) => "null"
    BoundFunction(_) => "null"
    Builtin(_) => "null"
    _ => "null"
  }
}

///|
fn json_indent_prefix(indent : String, level : Int) -> String {
  if indent.is_empty() || level <= 0 {
    ""
  } else {
    indent.repeat(level)
  }
}

///|
fn json_stringify_value_with_indent(
  value : Value,
  indent : String,
  level : Int,
) -> String raise {
  match value {
    Null => "null"
    Bool(v) => if v { "true" } else { "false" }
    Number(v) =>
      if Double::is_nan(v) || Double::is_inf(v) {
        "null"
      } else {
        Double::to_string(v)
      }
    String(s) => "\"\{json_escape(s)}\""
    Object(obj) => json_stringify_object_with_indent(obj, indent, level)
    Array(arr) => json_stringify_array_with_indent(arr, indent, level)
    Arguments(args) => json_stringify_arguments_with_indent(args, indent, level)
    Function(_) => "null"
    BoundFunction(_) => "null"
    Builtin(_) => "null"
    _ => "null"
  }
}

///|
fn json_stringify_array(arr : ArrayValue) -> String raise {
  let parts : Array[String] = []
  let len = arr.elements.length()
  for i = 0; i < len; i = i + 1 {
    let name = Int::to_string(i)
    let mut value_opt : Value? = None
    match arr.props.get(name) {
      Some(prop) => value_opt = Some(prop.value)
      None => ()
    }
    match value_opt {
      Some(value) =>
        match value {
          Undefined => parts.push("null")
          Function(_) => parts.push("null")
          Builtin(_) => parts.push("null")
          _ => parts.push(json_stringify_value(value))
        }
      None =>
        match arr.elements[i] {
          None => parts.push("null")
          Some(value) =>
            match value {
              Undefined => parts.push("null")
              Function(_) => parts.push("null")
              Builtin(_) => parts.push("null")
              _ => parts.push(json_stringify_value(value))
            }
        }
    }
  }
  "[" + parts.join(",") + "]"
}

///|
fn json_stringify_array_with_indent(
  arr : ArrayValue,
  indent : String,
  level : Int,
) -> String raise {
  if indent.is_empty() {
    return json_stringify_array(arr)
  }
  let parts : Array[String] = []
  let len = arr.elements.length()
  for i = 0; i < len; i = i + 1 {
    let name = Int::to_string(i)
    let mut value_opt : Value? = None
    match arr.props.get(name) {
      Some(prop) => value_opt = Some(prop.value)
      None => ()
    }
    match value_opt {
      Some(value) =>
        match value {
          Undefined => parts.push("null")
          Function(_) => parts.push("null")
          Builtin(_) => parts.push("null")
          _ =>
            parts.push(
              json_stringify_value_with_indent(value, indent, level + 1),
            )
        }
      None =>
        match arr.elements[i] {
          None => parts.push("null")
          Some(value) =>
            match value {
              Undefined => parts.push("null")
              Function(_) => parts.push("null")
              Builtin(_) => parts.push("null")
              _ =>
                parts.push(
                  json_stringify_value_with_indent(value, indent, level + 1),
                )
            }
        }
    }
  }
  if parts.is_empty() {
    return "[]"
  }
  let inner_indent = json_indent_prefix(indent, level + 1)
  let outer_indent = json_indent_prefix(indent, level)
  let formatted : Array[String] = parts.map(fn(part) { inner_indent + part })
  "[\n" + formatted.join(",\n") + "\n" + outer_indent + "]"
}

///|
fn json_stringify_object(obj : ObjectValue) -> String raise {
  let parts : Array[String] = []
  let target = Object(obj)
  let keys = own_enumerable_string_keys(target)
  for key in keys {
    match json_stringify_member(property_get(target, key)) {
      Some(rendered) => parts.push("\"\{json_escape(key)}\":\{rendered}")
      None => ()
    }
  }
  "{" + parts.join(",") + "}"
}

///|
fn json_stringify_object_with_indent(
  obj : ObjectValue,
  indent : String,
  level : Int,
) -> String raise {
  if indent.is_empty() {
    return json_stringify_object(obj)
  }
  let parts : Array[String] = []
  let inner_indent = json_indent_prefix(indent, level + 1)
  let target = Object(obj)
  let keys = own_enumerable_string_keys(target)
  for key in keys {
    match
      json_stringify_member_with_indent(
        property_get(target, key),
        indent,
        level + 1,
      ) {
      Some(rendered) =>
        parts.push(inner_indent + "\"" + json_escape(key) + "\": " + rendered)
      None => ()
    }
  }
  if parts.is_empty() {
    return "{}"
  }
  let outer_indent = json_indent_prefix(indent, level)
  "{\n" + parts.join(",\n") + "\n" + outer_indent + "}"
}

///|
fn json_stringify_arguments(args : ArgumentsValue) -> String raise {
  let parts : Array[String] = []
  let len = args.elements.length()
  for i = 0; i < len; i = i + 1 {
    if arguments_has_index(args, i) {
      let value = arguments_index_value(args, i)
      match json_stringify_member(value) {
        Some(rendered) => parts.push("\"\{Int::to_string(i)}\":\{rendered}")
        None => ()
      }
    }
  }
  for key, prop in args.props {
    if is_symbol_prop_key(key) || is_private_prop_key(key) {
      continue
    }
    if !prop.enumerable {
      continue
    }
    match parse_array_index(key) {
      Some(index) =>
        if index >= 0 && index < len {
          ()
        } else {
          match json_stringify_member(prop.value) {
            Some(rendered) => parts.push("\"\{json_escape(key)}\":\{rendered}")
            None => ()
          }
        }
      None =>
        match json_stringify_member(prop.value) {
          Some(rendered) => parts.push("\"\{json_escape(key)}\":\{rendered}")
          None => ()
        }
    }
  }
  "{" + parts.join(",") + "}"
}

///|
fn json_stringify_arguments_with_indent(
  args : ArgumentsValue,
  indent : String,
  level : Int,
) -> String raise {
  if indent.is_empty() {
    return json_stringify_arguments(args)
  }
  let parts : Array[String] = []
  let len = args.elements.length()
  let inner_indent = json_indent_prefix(indent, level + 1)
  for i = 0; i < len; i = i + 1 {
    if arguments_has_index(args, i) {
      let value = arguments_index_value(args, i)
      match json_stringify_member_with_indent(value, indent, level + 1) {
        Some(rendered) =>
          parts.push(
            inner_indent + "\"" + Int::to_string(i) + "\": " + rendered,
          )
        None => ()
      }
    }
  }
  for key, prop in args.props {
    if is_symbol_prop_key(key) || is_private_prop_key(key) {
      continue
    }
    if !prop.enumerable {
      continue
    }
    match parse_array_index(key) {
      Some(index) =>
        if index >= 0 && index < len {
          ()
        } else {
          match
            json_stringify_member_with_indent(prop.value, indent, level + 1) {
            Some(rendered) =>
              parts.push(
                inner_indent + "\"" + json_escape(key) + "\": " + rendered,
              )
            None => ()
          }
        }
      None =>
        match json_stringify_member_with_indent(prop.value, indent, level + 1) {
          Some(rendered) =>
            parts.push(
              inner_indent + "\"" + json_escape(key) + "\": " + rendered,
            )
          None => ()
        }
    }
  }
  if parts.is_empty() {
    return "{}"
  }
  let outer_indent = json_indent_prefix(indent, level)
  "{\n" + parts.join(",\n") + "\n" + outer_indent + "}"
}

///|
fn json_stringify_member(value : Value) -> String? raise {
  match value {
    Undefined => None
    Function(_) => None
    BoundFunction(_) => None
    Builtin(_) => None
    Symbol(_) => None
    _ => Some(json_stringify_value(value))
  }
}

///|
fn json_stringify_member_with_indent(
  value : Value,
  indent : String,
  level : Int,
) -> String? raise {
  match value {
    Undefined => None
    Function(_) => None
    BoundFunction(_) => None
    Builtin(_) => None
    Symbol(_) => None
    _ => Some(json_stringify_value_with_indent(value, indent, level))
  }
}

///|
fn json_escape(value : String) -> String {
  let sb = StringBuilder::new()
  let len = value.length()
  let mut i = 0
  while i < len {
    let unit = UInt16::to_int(value.code_unit_at(i))
    if unit == 0x22 {
      sb.write_string("\\\"")
      i = i + 1
      continue
    }
    if unit == 0x5c {
      sb.write_string("\\\\")
      i = i + 1
      continue
    }
    if unit == 0x08 {
      sb.write_string("\\b")
      i = i + 1
      continue
    }
    if unit == 0x0c {
      sb.write_string("\\f")
      i = i + 1
      continue
    }
    if unit == 0x0a {
      sb.write_string("\\n")
      i = i + 1
      continue
    }
    if unit == 0x0d {
      sb.write_string("\\r")
      i = i + 1
      continue
    }
    if unit == 0x09 {
      sb.write_string("\\t")
      i = i + 1
      continue
    }
    if is_lead_surrogate(unit) {
      if i + 1 < len {
        let next = UInt16::to_int(value.code_unit_at(i + 1))
        if is_trail_surrogate(next) {
          sb.write_string(value.unsafe_substring(start=i, end=i + 2))
          i = i + 2
          continue
        }
      }
      sb.write_string(unicode_escape(unit))
      i = i + 1
      continue
    }
    if is_trail_surrogate(unit) {
      sb.write_string(unicode_escape(unit))
      i = i + 1
      continue
    }
    if unit < 0x20 {
      sb.write_string(unicode_escape(unit))
      i = i + 1
      continue
    }
    sb.write_string(value.unsafe_substring(start=i, end=i + 1))
    i = i + 1
  }
  sb.to_string()
}

///|
fn unicode_escape(code : Int) -> String {
  let sb = StringBuilder::new()
  sb.write_string("\\u")
  sb.write_char(hex_digit((code >> 12) & 0x0f))
  sb.write_char(hex_digit((code >> 8) & 0x0f))
  sb.write_char(hex_digit((code >> 4) & 0x0f))
  sb.write_char(hex_digit(code & 0x0f))
  sb.to_string()
}

///|
fn build_spread_list(value : Value) -> Array[Value] raise {
  let (iterator, next_method) = get_iterator_from_value(value)
  let args : Array[Value] = []
  while true {
    try {
      let (done, item) = iterator_step_value(iterator, next_method)
      if done {
        break
      }
      args.push(item)
    } catch {
      err => {
        iterator_close_on_error(iterator)
        raise err
      }
    }
  }
  args
}

///|
fn build_arg_list(value : Value) -> Array[Value] raise {
  let target = to_object(value)
  let len_value = property_get(target, "length")
  let len_num = to_number(len_value)
  let mut len = 0
  if !(Double::is_nan(len_num) || len_num < 0.0) {
    len = Int::max(0, Int64::to_int(Double::to_int64(Double::trunc(len_num))))
  }
  let args : Array[Value] = []
  for i = 0; i < len; i = i + 1 {
    args.push(property_get(target, Int::to_string(i)))
  }
  args
}

///|
fn call_user_function(func : FunctionValue, args : Array[Value]) -> Value raise {
  call_user_function_with_this(func, args, Undefined, Undefined)
}

///|
fn has_param_expressions(func : FunctionValue) -> Bool {
  for i = 0; i < func.params.length(); i = i + 1 {
    match func.param_inits[i] {
      Some(_) => return true
      None => ()
    }
    if var_binding_has_default(func.params[i].binding) {
      return true
    }
  }
  false
}

///|
fn has_simple_parameter_list(func : FunctionValue) -> Bool {
  for i = 0; i < func.params.length(); i = i + 1 {
    let param = func.params[i]
    if param.is_rest {
      return false
    }
    match param.binding {
      @engine.VarBinding::Name(_) => ()
      _ => return false
    }
    match func.param_inits[i] {
      Some(_) => return false
      None => ()
    }
  }
  true
}

///|
fn var_binding_has_default(binding : @engine.VarBinding) -> Bool {
  match binding {
    @engine.VarBinding::Name(_) => false
    @engine.VarBinding::ArrayPattern(pattern) => {
      for elem in pattern {
        match elem {
          @engine.ArrayPatternElem::Bind(_, Some(_)) => return true
          @engine.ArrayPatternElem::Bind(inner, None) =>
            if var_binding_has_default(inner) {
              return true
            }
          @engine.ArrayPatternElem::Rest(inner) =>
            if var_binding_has_default(inner) {
              return true
            }
          @engine.ArrayPatternElem::Hole => ()
        }
      }
      false
    }
    @engine.VarBinding::ObjectPattern(pattern) => {
      for elem in pattern {
        match elem {
          @engine.ObjectPatternElem::Bind(_, _, Some(_)) => return true
          @engine.ObjectPatternElem::Bind(_, inner, None) =>
            if var_binding_has_default(inner) {
              return true
            }
          @engine.ObjectPatternElem::Rest(inner) =>
            if var_binding_has_default(inner) {
              return true
            }
        }
      }
      false
    }
    @engine.VarBinding::Target(_) => false
  }
}

///|
fn var_binding_contains_name(
  binding : @engine.VarBinding,
  target : String,
) -> Bool {
  match binding {
    @engine.VarBinding::Name(name) => name == target
    @engine.VarBinding::ArrayPattern(pattern) => {
      for elem in pattern {
        match elem {
          @engine.ArrayPatternElem::Bind(inner, _) =>
            if var_binding_contains_name(inner, target) {
              return true
            }
          @engine.ArrayPatternElem::Rest(inner) =>
            if var_binding_contains_name(inner, target) {
              return true
            }
          @engine.ArrayPatternElem::Hole => ()
        }
      }
      false
    }
    @engine.VarBinding::ObjectPattern(pattern) => {
      for elem in pattern {
        match elem {
          @engine.ObjectPatternElem::Bind(_, inner, _) =>
            if var_binding_contains_name(inner, target) {
              return true
            }
          @engine.ObjectPatternElem::Rest(inner) =>
            if var_binding_contains_name(inner, target) {
              return true
            }
        }
      }
      false
    }
    @engine.VarBinding::Target(_) => false
  }
}

///|
fn params_contains_name(
  params : Array[@engine.ParamBinding],
  target : String,
) -> Bool {
  for param in params {
    if var_binding_contains_name(param.binding, target) {
      return true
    }
  }
  false
}

///|
fn collect_binding_names(
  binding : @engine.VarBinding,
  names : @hashmap.HashMap[String, Bool],
) -> Unit {
  match binding {
    @engine.VarBinding::Name(name) => names.set(name, true)
    @engine.VarBinding::ArrayPattern(pattern) =>
      for elem in pattern {
        match elem {
          @engine.ArrayPatternElem::Bind(inner, _) =>
            collect_binding_names(inner, names)
          @engine.ArrayPatternElem::Rest(inner) =>
            collect_binding_names(inner, names)
          @engine.ArrayPatternElem::Hole => ()
        }
      }
    @engine.VarBinding::ObjectPattern(pattern) =>
      for elem in pattern {
        match elem {
          @engine.ObjectPatternElem::Bind(_, inner, _) =>
            collect_binding_names(inner, names)
          @engine.ObjectPatternElem::Rest(inner) =>
            collect_binding_names(inner, names)
        }
      }
    @engine.VarBinding::Target(_) => ()
  }
}

///|
fn annex_b_param_names_for_func(
  func : FunctionValue,
) -> @hashmap.HashMap[String, Bool] {
  let names : @hashmap.HashMap[String, Bool] = @hashmap.new()
  for param in func.params {
    collect_binding_names(param.binding, names)
  }
  names
}

///|
fn init_param_binding_names(
  env : Env,
  func : FunctionValue,
  has_arguments_binding : Bool,
) -> Unit {
  env.is_param_env = true
  for param in func.params {
    collect_binding_names(param.binding, env.param_binding_names)
  }
  match func.name {
    Some(name) =>
      if func.local_name_binding {
        env.param_binding_names.set(name, true)
      }
    None => ()
  }
  if has_arguments_binding {
    env.param_binding_names.set("arguments", true)
  }
}

///|
fn declare_param_bindings_uninitialized(
  env : Env,
  func : FunctionValue,
) -> Unit {
  for param in func.params {
    declare_binding_uninitialized(env, param.binding)
  }
}

///|
fn class_constructor_result(
  func : FunctionValue,
  result : Value,
  frame : Env,
  this_bound : Value,
  new_target : Value,
) -> Value raise {
  if !func.is_class_constructor || new_target is Undefined {
    return result
  }
  let is_derived = match func.super_constructor {
    Some(_) => true
    None => false
  }
  if is_derived {
    if is_object_like(result) {
      return result
    }
    if result is Undefined {
      if frame.this_uninitialized {
        return throw_reference_error("this is not initialized")
      }
      match frame.bindings.get("this") {
        Some(value) => value
        None => Undefined
      }
    } else {
      return throw_type_error("derived constructor returned non-object")
    }
  } else {
    if is_object_like(result) {
      return result
    }
    return this_bound
  }
}

///|
fn init_instance_fields(
  func : FunctionValue,
  env : Env,
  this_value : Value,
) -> Unit raise {
  if !func.private_instance_props.is_empty() {
    for entry in func.private_instance_props {
      let (key, prop) = entry
      define_private_property(this_value, key, prop)
    }
  }
  if !func.instance_fields.is_empty() {
    for field in func.instance_fields {
      let should_set_name = match field.init {
        Some(expr) => is_anonymous_function_definition(expr)
        None => false
      }
      let value = match field.init {
        Some(expr) => eval_class_field_initializer(env, expr)
        None => Undefined
      }
      if should_set_name {
        set_anonymous_function_name(value, field.display_name, None)
      }
      if field.is_private {
        define_private_property(this_value, field.name, property_data(value))
      } else {
        let _ = create_data_property_or_throw(this_value, field.name, value)

      }
    }
  }
}

///|
fn prepare_function_body_env(var_env : Env, func : FunctionValue) -> Env raise {
  let body_env = if func.is_strict {
    var_env
  } else {
    let lex_env = Env::new(Some(var_env))
    lex_env.var_env = Some(var_env)
    lex_env.strict = var_env.strict
    lex_env
  }
  eval_predeclare_lexical_decls(body_env, func.body)
  body_env
}

///|
fn call_user_function_body_impl(
  func : FunctionValue,
  args : Array[Value],
  this_value : Value,
  new_target : Value,
) -> Value raise {
  let is_derived_constructor = func.is_class_constructor &&
    func.super_constructor is Some(_)
  let init_fields_before_params = func.is_class_constructor &&
    !is_derived_constructor
  let has_param_expr = has_param_expressions(func)
  let this_bound = if func.is_arrow {
    Undefined
  } else if is_derived_constructor {
    Undefined
  } else if func.is_strict {
    this_value
  } else {
    coerce_this(func.env, this_value)
  }
  let arg_len = args.length()
  let simple_params = has_simple_parameter_list(func)
  if has_param_expr {
    let func_env = Env::new(Some(func.env))
    func_env.strict = func.is_strict
    if !func.is_arrow {
      func_env.new_target = new_target
      func_env.allow_new_target = true
      func_env.allow_super = func.home_object is Some(_)
      func_env.allow_super_call = func.is_class_constructor &&
        func.super_constructor is Some(_)
    }
    if is_derived_constructor {
      func_env.this_uninitialized = true
    }
    if !func.is_arrow {
      env_set_local(func_env, "this", this_bound)
    }
    match func.name {
      Some(name) =>
        if func.local_name_binding {
          env_define_readonly(func_env, name, Value::Function(func), false)
        }
      None => ()
    }
    let arguments_binding = !func.is_arrow &&
      !params_contains_name(func.params, "arguments")
    if arguments_binding {
      let args_value = new_arguments_value(
        func,
        func_env,
        args,
        func.is_strict,
        false,
      )
      env_set_local(func_env, "arguments", args_value)
    }
    let arg_env = Env::new(Some(func_env))
    arg_env.var_env = Some(arg_env)
    let param_env = Env::new(Some(arg_env))
    param_env.strict = func.is_strict
    param_env.var_env = Some(arg_env)
    let var_env = Env::new(Some(param_env))
    var_env.var_env = Some(var_env)
    func_env.var_env = Some(var_env)
    init_param_binding_names(param_env, func, arguments_binding)
    declare_param_bindings_uninitialized(param_env, func)
    let _ = with_current_function(func, fn() raise {
      if init_fields_before_params {
        init_instance_fields(func, param_env, this_bound)
      }
      with_env_value(param_env, fn() raise {
        for i, param in func.params {
          if param.is_rest {
            let rest_values : Array[Value?] = []
            let mut j = i
            while j < arg_len {
              rest_values.push(Some(args[j]))
              j = j + 1
            }
            initialize_var_binding(
              param_env,
              param.binding,
              new_array_value(rest_values),
            )
            break
          } else {
            let mut value = if i < arg_len { args[i] } else { Undefined }
            match func.param_inits[i] {
              Some(init) =>
                if value is Undefined {
                  value = match param.binding {
                    @engine.VarBinding::Name(name) =>
                      eval_named_expr(param_env, init, name, None)
                    _ => eval_expr(param_env, init)
                  }
                }
              None => ()
            }
            initialize_var_binding(param_env, param.binding, value)
          }
        }
        Undefined
      })
    })
    let result = with_current_function(func, fn() raise {
      if !is_derived_constructor && !init_fields_before_params {
        init_instance_fields(func, func_env, this_bound)
      }
      let body_env = prepare_function_body_env(var_env, func)
      let top_level_func_decls = collect_top_level_function_decls(func.body)
      let func_var_names = compute_annex_b_var_func_decls(
        func.body,
        body_env.strict,
        annex_b_param_names_for_func(func),
        !func.is_arrow,
      )
      with_top_level_function_decls(top_level_func_decls, fn() raise {
        with_annex_b_var_func_decls(func_var_names, fn() raise {
          hoist_decls(body_env, func.body, false, false)
          merge_arg_env_bindings(arg_env, var_env)
          with_env_value(body_env, fn() raise {
            try {
              for stmt in func.body {
                let _ = eval_stmt(body_env, stmt)

              }
              Undefined
            } catch {
              ReturnSignal(value) => value
              BreakSignal((_, _)) => fail("illegal break")
              ContinueSignal((_, _)) => fail("illegal continue")
              ThrowSignal(value) => raise ThrowSignal(value)
              err => raise err
            }
          })
        })
      })
    })
    class_constructor_result(func, result, func_env, this_bound, new_target)
  } else {
    let frame = Env::new(Some(func.env))
    frame.var_env = Some(frame)
    frame.strict = func.is_strict
    if !func.is_arrow {
      frame.new_target = new_target
      frame.allow_new_target = true
      frame.allow_super = func.home_object is Some(_)
      frame.allow_super_call = func.is_class_constructor &&
        func.super_constructor is Some(_)
    }
    if is_derived_constructor {
      frame.this_uninitialized = true
    }
    if !func.is_arrow {
      env_set_local(frame, "this", this_bound)
    }
    match func.name {
      Some(name) =>
        if func.local_name_binding {
          env_define_readonly(frame, name, Value::Function(func), false)
        }
      None => ()
    }
    if !func.is_arrow && !params_contains_name(func.params, "arguments") {
      env_set_local(
        frame,
        "arguments",
        new_arguments_value(func, frame, args, func.is_strict, simple_params),
      )
    }
    if init_fields_before_params {
      let _ = with_current_function(func, fn() raise {
        init_instance_fields(func, frame, this_bound)
        Undefined
      })

    }
    let _ = with_env_value(frame, fn() raise {
      for i, param in func.params {
        if param.is_rest {
          let rest_values : Array[Value?] = []
          let mut j = i
          while j < arg_len {
            rest_values.push(Some(args[j]))
            j = j + 1
          }
          assign_var_binding(
            frame,
            param.binding,
            new_array_value(rest_values),
            false,
          )
          break
        } else {
          let mut value = if i < arg_len { args[i] } else { Undefined }
          match func.param_inits[i] {
            Some(init) =>
              if value is Undefined {
                value = match param.binding {
                  @engine.VarBinding::Name(name) =>
                    eval_named_expr(frame, init, name, None)
                  _ => eval_expr(frame, init)
                }
              }
            None => ()
          }
          assign_var_binding(frame, param.binding, value, false)
        }
      }
      Undefined
    })
    let result = with_current_function(func, fn() raise {
      if !is_derived_constructor && !init_fields_before_params {
        init_instance_fields(func, frame, this_bound)
      }
      let body_env = prepare_function_body_env(frame, func)
      let top_level_func_decls = collect_top_level_function_decls(func.body)
      let func_var_names = compute_annex_b_var_func_decls(
        func.body,
        body_env.strict,
        annex_b_param_names_for_func(func),
        !func.is_arrow,
      )
      with_top_level_function_decls(top_level_func_decls, fn() raise {
        with_annex_b_var_func_decls(func_var_names, fn() raise {
          hoist_decls(body_env, func.body, false, false)
          with_env_value(body_env, fn() raise {
            try {
              for stmt in func.body {
                let _ = eval_stmt(body_env, stmt)

              }
              Undefined
            } catch {
              ReturnSignal(value) => value
              BreakSignal((_, _)) => fail("illegal break")
              ContinueSignal((_, _)) => fail("illegal continue")
              ThrowSignal(value) => raise ThrowSignal(value)
              err => raise err
            }
          })
        })
      })
    })
    class_constructor_result(func, result, frame, this_bound, new_target)
  }
}

///|
fn call_user_function_body(
  func : FunctionValue,
  args : Array[Value],
  this_value : Value,
  new_target : Value,
) -> Value raise {
  with_function_source(func, fn() raise {
    call_user_function_body_impl(func, args, this_value, new_target)
  })
}

///|
fn call_user_function_with_this(
  func : FunctionValue,
  args : Array[Value],
  this_value : Value,
  new_target : Value,
) -> Value raise {
  if func.is_class_constructor && new_target is Undefined {
    return with_env_value(func.env, fn() raise {
      throw_type_error("class constructor cannot be invoked without 'new'")
    })
  }
  if func.is_generator {
    if func.is_async {
      return new_async_generator_value(func, args, this_value, new_target)
    }
    return new_generator_value(func, args, this_value, new_target)
  }
  if func.is_async {
    return call_async_function(func, args, this_value, new_target)
  }
  call_user_function_body(func, args, this_value, new_target)
}

///|
fn call_async_function(
  func : FunctionValue,
  args : Array[Value],
  this_value : Value,
  new_target : Value,
) -> Value raise {
  let (promise, resolve, reject) = new_promise_capability(Undefined)
  try {
    let gen_value = new_generator_value(func, args, this_value, new_target)
    match gen_value {
      Object(obj) => {
        async_function_data_set(obj.id, AsyncFunctionData::{ resolve, reject })
        async_function_resume(obj, GenResume::Next(Undefined))
      }
      _ => {
        let _ = call_value_with_this(
          reject,
          [type_error_value("async function setup failed")],
          Undefined,
        )

      }
    }
  } catch {
    ThrowSignal(err) => {
      let _ = call_value_with_this(reject, [err], Undefined)

    }
    err => raise err
  }
  promise
}

///|
fn new_async_generator_value(
  func : FunctionValue,
  args : Array[Value],
  this_value : Value,
  new_target : Value,
) -> Value raise {
  let value = new_generator_value(func, args, this_value, new_target)
  match value {
    Object(obj) => {
      obj.async_generator_data = Some(AsyncGeneratorData::{
        state: AsyncGeneratorState::SuspendedStart,
        queue_index: 0,
        queue: [],
      })
      value
    }
    _ => value
  }
}

///|
fn new_generator_value(
  func : FunctionValue,
  args : Array[Value],
  this_value : Value,
  new_target : Value,
) -> Value raise {
  let has_param_expr = has_param_expressions(func)
  let simple_params = has_simple_parameter_list(func)
  let this_bound = if func.is_arrow {
    Undefined
  } else if func.is_strict {
    this_value
  } else {
    coerce_this(func.env, this_value)
  }
  let arg_len = args.length()
  let mut arg_env_opt : Env? = None
  let frame = if has_param_expr {
    let func_env = Env::new(Some(func.env))
    func_env.strict = func.is_strict
    if !func.is_arrow {
      func_env.new_target = new_target
      func_env.allow_new_target = true
      func_env.allow_super = func.home_object is Some(_)
      func_env.allow_super_call = func.is_class_constructor &&
        func.super_constructor is Some(_)
    }
    if !func.is_arrow {
      env_set_local(func_env, "this", this_bound)
    }
    match func.name {
      Some(name) =>
        if func.local_name_binding {
          env_define_readonly(func_env, name, Value::Function(func), false)
        }
      None => ()
    }
    let arguments_binding = !func.is_arrow &&
      !params_contains_name(func.params, "arguments")
    if arguments_binding {
      let args_value = new_arguments_value(
        func,
        func_env,
        args,
        func.is_strict,
        simple_params,
      )
      env_set_local(func_env, "arguments", args_value)
    }
    let arg_env = Env::new(Some(func_env))
    arg_env.var_env = Some(arg_env)
    let param_env = Env::new(Some(arg_env))
    param_env.strict = func.is_strict
    param_env.var_env = Some(arg_env)
    arg_env_opt = Some(arg_env)
    let var_env = Env::new(Some(param_env))
    var_env.var_env = Some(var_env)
    func_env.var_env = Some(var_env)
    init_param_binding_names(param_env, func, arguments_binding)
    declare_param_bindings_uninitialized(param_env, func)
    let _ = with_current_function(func, fn() raise {
      with_env_value(param_env, fn() raise {
        for i, param in func.params {
          if param.is_rest {
            let rest_values : Array[Value?] = []
            let mut j = i
            while j < arg_len {
              rest_values.push(Some(args[j]))
              j = j + 1
            }
            initialize_var_binding(
              param_env,
              param.binding,
              new_array_value(rest_values),
            )
            break
          } else {
            let mut value = if i < arg_len { args[i] } else { Undefined }
            match func.param_inits[i] {
              Some(init) =>
                if value is Undefined {
                  value = match param.binding {
                    @engine.VarBinding::Name(name) =>
                      eval_named_expr(param_env, init, name, None)
                    _ => eval_expr(param_env, init)
                  }
                }
              None => ()
            }
            initialize_var_binding(param_env, param.binding, value)
          }
        }
        Undefined
      })
    })
    var_env
  } else {
    let frame = Env::new(Some(func.env))
    frame.var_env = Some(frame)
    frame.strict = func.is_strict
    if !func.is_arrow {
      frame.new_target = new_target
      frame.allow_new_target = true
      frame.allow_super = func.home_object is Some(_)
      frame.allow_super_call = func.is_class_constructor &&
        func.super_constructor is Some(_)
    }
    if !func.is_arrow {
      env_set_local(frame, "this", this_bound)
    }
    match func.name {
      Some(name) =>
        if func.local_name_binding {
          env_define_readonly(frame, name, Value::Function(func), false)
        }
      None => ()
    }
    if !func.is_arrow && !params_contains_name(func.params, "arguments") {
      env_set_local(
        frame,
        "arguments",
        new_arguments_value(func, frame, args, func.is_strict, simple_params),
      )
    }
    let _ = with_current_function(func, fn() raise {
      with_env_value(frame, fn() raise {
        for i, param in func.params {
          if param.is_rest {
            let rest_values : Array[Value?] = []
            let mut j = i
            while j < arg_len {
              rest_values.push(Some(args[j]))
              j = j + 1
            }
            assign_var_binding(
              frame,
              param.binding,
              new_array_value(rest_values),
              false,
            )
            break
          } else {
            let mut value = if i < arg_len { args[i] } else { Undefined }
            match func.param_inits[i] {
              Some(init) =>
                if value is Undefined {
                  value = match param.binding {
                    @engine.VarBinding::Name(name) =>
                      eval_named_expr(frame, init, name, None)
                    _ => eval_expr(frame, init)
                  }
                }
              None => ()
            }
            assign_var_binding(frame, param.binding, value, false)
          }
        }
        Undefined
      })
    })
    frame
  }
  let func_var_names = compute_annex_b_var_func_decls(
    func.body,
    frame.strict,
    annex_b_param_names_for_func(func),
    !func.is_arrow,
  )
  let _ = with_annex_b_var_func_decls(func_var_names, fn() raise {
    hoist_decls(frame, func.body, false, false)
    match arg_env_opt {
      Some(arg_env) => merge_arg_env_bindings(arg_env, frame)
      None => ()
    }
    Undefined
  })
  let body_env = prepare_function_body_env(frame, func)
  let top_level_func_decls = collect_top_level_function_decls(func.body)
  let next_step = fn(_ : GenResume) raise {
    let step = with_top_level_function_decls_step(top_level_func_decls, fn() raise {
      gen_eval_stmt_seq(body_env, func.body, 0)
    })
    top_level_function_decls_wrap_step(step, top_level_func_decls)
  }
  let data = GeneratorData::{
    state: GeneratorState::SuspendedStart,
    env: body_env,
    func,
    next_step,
    roots: [],
  }
  ensure_function_prototype(func)
  let fallback_proto = if func.is_async {
    match value_from_object(async_generator_proto_for_env(func.env)) {
      Some(value) => Some(value)
      None => value_from_object(async_generator_proto())
    }
  } else {
    match value_from_object(generator_proto_for_env(func.env)) {
      Some(value) => Some(value)
      None => value_from_object(generator_proto())
    }
  }
  let proto_value = match func.props.get("prototype") {
    Some(prop) =>
      if is_object_like(prop.value) {
        Some(prop.value)
      } else {
        fallback_proto
      }
    None => fallback_proto
  }
  let obj = register_object_value(ObjectValue::{
    id: alloc_id(),
    props: Map::new(),
    proto: proto_value,
    string_data: None,
    number_data: None,
    bool_data: None,
    bigint_data: None,
    symbol_data: None,
    regexp_data: None,
    generator_data: Some(data),
    async_generator_data: None,
    proxy_data: None,
    map_data: None,
    set_data: None,
    map_iter_data: None,
    set_iter_data: None,
    iterator_wrap_data: None,
    iterator_concat_data: None,
    iterator_helper_data: None,
    weakmap_data: None,
    weakset_data: None,
    weakref_data: None,
    finreg_data: None,
    date_data: None,
    array_buffer_data: None,
    dataview_data: None,
    is_html_dda: false,
    is_error: false,
    is_module_namespace: false,
    realm_env: None,
    immutable_proto: false,
    extensible: true,
  })
  Object(obj)
}

///|
fn eval_var_decls(
  env : Env,
  kind : @engine.VarKind,
  decls : Array[(@engine.VarBinding, @engine.Expr?)],
) -> Unit raise {
  let assign = fn(name : String, value : Value) raise {
    match kind {
      @engine.VarKind::ConstDecl => env_define_readonly(env, name, value, true)
      @engine.VarKind::Var => env_set(env, name, value)
      _ => env_initialize_binding(env, name, value)
    }
  }
  for decl in decls {
    let (binding, init) = decl
    match binding {
      @engine.VarBinding::Name(name) =>
        match init {
          Some(expr) =>
            if kind is @engine.VarKind::Var {
              let target = resolve_binding_target(env, name)
              let value = eval_named_expr(env, expr, name, None)
              match target {
                BindingTarget::WithObject(obj) => {
                  let _ = property_set(obj, name, value, env.strict)

                }
                BindingTarget::Env(target_env) =>
                  env_set_local(target_env, name, value)
                BindingTarget::Unbound =>
                  env_set_with_strict_no_with(
                    var_env_for(env),
                    name,
                    value,
                    env.strict,
                  )
              }
            } else {
              let value = eval_named_expr(env, expr, name, None)
              assign(name, value)
            }
          None =>
            if kind is @engine.VarKind::ConstDecl {
              let _ = throw_syntax_error(
                "missing initializer in const declaration",
              )

            } else if !(kind is @engine.VarKind::Var) {
              env_initialize_binding(env, name, Undefined)
            }
        }
      @engine.VarBinding::ArrayPattern(pattern) =>
        match init {
          Some(expr) => {
            let value = eval_expr(env, expr)
            destructure_array_pattern(env, pattern, value, fn(name, v) raise {
              assign(name, v)
            })
          }
          None =>
            if kind is @engine.VarKind::ConstDecl {
              let _ = throw_syntax_error(
                "missing initializer in const declaration",
              )

            } else if !(kind is @engine.VarKind::Var) {
              declare_binding_names(env, binding)
            }
        }
      @engine.VarBinding::ObjectPattern(pattern) =>
        match init {
          Some(expr) => {
            let value = eval_expr(env, expr)
            destructure_object_pattern(env, pattern, value, fn(name, v) raise {
              assign(name, v)
            })
          }
          None =>
            if kind is @engine.VarKind::ConstDecl {
              let _ = throw_syntax_error(
                "missing initializer in const declaration",
              )

            } else if !(kind is @engine.VarKind::Var) {
              declare_binding_names(env, binding)
            }
        }
      @engine.VarBinding::Target(_) => {
        let _ = throw_syntax_error("invalid binding")

      }
    }
  }
}

///|
fn eval_var_decls_no_name(
  env : Env,
  kind : @engine.VarKind,
  decls : Array[(@engine.VarBinding, @engine.Expr?)],
) -> Unit raise {
  let assign = fn(name : String, value : Value) raise {
    match kind {
      @engine.VarKind::ConstDecl => env_define_readonly(env, name, value, true)
      @engine.VarKind::Var => env_set(env, name, value)
      _ => env_initialize_binding(env, name, value)
    }
  }
  for decl in decls {
    let (binding, init) = decl
    match binding {
      @engine.VarBinding::Name(name) =>
        match init {
          Some(expr) =>
            if kind is @engine.VarKind::Var {
              let target = resolve_binding_target(env, name)
              let value = eval_expr(env, expr)
              match target {
                BindingTarget::WithObject(obj) => {
                  let _ = property_set(obj, name, value, env.strict)

                }
                BindingTarget::Env(target_env) =>
                  env_set_local(target_env, name, value)
                BindingTarget::Unbound =>
                  env_set_with_strict_no_with(
                    var_env_for(env),
                    name,
                    value,
                    env.strict,
                  )
              }
            } else {
              let value = eval_named_expr(env, expr, name, None)
              assign(name, value)
            }
          None =>
            if kind is @engine.VarKind::ConstDecl {
              let _ = throw_syntax_error(
                "missing initializer in const declaration",
              )

            } else if !(kind is @engine.VarKind::Var) {
              env_initialize_binding(env, name, Undefined)
            }
        }
      @engine.VarBinding::ArrayPattern(pattern) =>
        match init {
          Some(expr) => {
            let value = eval_expr(env, expr)
            destructure_array_pattern(env, pattern, value, fn(name, v) raise {
              assign(name, v)
            })
          }
          None =>
            if kind is @engine.VarKind::ConstDecl {
              let _ = throw_syntax_error(
                "missing initializer in const declaration",
              )

            } else if !(kind is @engine.VarKind::Var) {
              declare_binding_names(env, binding)
            }
        }
      @engine.VarBinding::ObjectPattern(pattern) =>
        match init {
          Some(expr) => {
            let value = eval_expr(env, expr)
            destructure_object_pattern(env, pattern, value, fn(name, v) raise {
              assign(name, v)
            })
          }
          None =>
            if kind is @engine.VarKind::ConstDecl {
              let _ = throw_syntax_error(
                "missing initializer in const declaration",
              )

            } else if !(kind is @engine.VarKind::Var) {
              declare_binding_names(env, binding)
            }
        }
      @engine.VarBinding::Target(_) => {
        let _ = throw_syntax_error("invalid binding")

      }
    }
  }
}

///|
fn eval_for_init(env : Env, init : @engine.ForInit) -> Unit raise {
  match init {
    @engine.ForInit::None => ()
    @engine.ForInit::Var(kind, decls) => eval_var_decls(env, kind, decls)
    @engine.ForInit::Expr(expr) => {
      let _ = eval_expr(env, expr)

    }
  }
}

///|
fn eval_block_control(env : Env, body : @engine.Stmt) -> GenControl raise {
  try {
    let result = with_env_value(env, fn() raise { eval_stmt(env, body) })
    Normal(result)
  } catch {
    ThrowSignal(value) => Throw(value)
    ReturnSignal(value) => Return(value)
    BreakSignal((label, value_opt)) => Break(label, value_opt)
    ContinueSignal((label, value_opt)) => Continue(label, value_opt)
    err => raise err
  }
}

///|
fn eval_block_control_stmts(
  env : Env,
  body : Array[@engine.Stmt],
) -> GenControl raise {
  try {
    let result = with_env_value(env, fn() raise { eval_block(env, body) })
    Normal(result)
  } catch {
    ThrowSignal(value) => Throw(value)
    ReturnSignal(value) => Return(value)
    BreakSignal((label, value_opt)) => Break(label, value_opt)
    ContinueSignal((label, value_opt)) => Continue(label, value_opt)
    err => raise err
  }
}

///|
fn eval_block_raw_control_with_last(
  env : Env,
  body : Array[@engine.Stmt],
) -> (GenControl, Value) raise {
  let mut last = Undefined
  for stmt in body {
    try {
      let value = eval_stmt(env, stmt)
      if stmt_updates_completion(stmt) {
        last = value
      }
    } catch {
      BreakSignal((label, value_opt)) => {
        let updated = update_empty(value_opt, last)
        return (Break(label, Some(updated)), last)
      }
      ContinueSignal((label, value_opt)) => {
        let updated = update_empty(value_opt, last)
        return (Continue(label, Some(updated)), last)
      }
      ReturnSignal(value) => return (Return(value), last)
      ThrowSignal(value) => return (Throw(value), last)
      err => raise err
    }
  }
  (Normal(last), last)
}

///|
fn eval_block_control_with_last_stmts(
  env : Env,
  body : Array[@engine.Stmt],
) -> (GenControl, Value) raise {
  if current_module_env_id() is Some(_) && block_is_export_wrapper(body) {
    return eval_block_raw_control_with_last(env, body)
  }
  if block_needs_lex_env(body, env.strict) {
    let block_env = Env::new(Some(env))
    hoist_block_functions(block_env, body)
    eval_predeclare_lexical_decls(block_env, body)
    push_env(block_env)
    try {
      let result = eval_block_raw_control_with_last(block_env, body)
      pop_env()
      return result
    } catch {
      err => {
        pop_env()
        raise err
      }
    }
  }
  eval_block_raw_control_with_last(env, body)
}

///|
fn apply_finally_control(
  pending : GenControl,
  final_control : GenControl,
) -> GenControl {
  match final_control {
    Normal(_) => pending
    _ => final_control
  }
}

///|
fn slice_source_range(source : String, start : Int, end : Int) -> String {
  let len = source.length()
  let start_idx = if start < 0 { 0 } else if start > len { len } else { start }
  let end_idx = if end < start_idx {
    start_idx
  } else if end > len {
    len
  } else {
    end
  }
  source.view(start_offset=start_idx, end_offset=end_idx).to_string()
}

///|
fn function_body_has_use_strict(body : Array[@engine.Stmt]) -> Bool {
  for stmt in body {
    match stmt {
      @engine.Stmt::ExprStmt(@engine.Expr::String(value, has_escape, _)) =>
        if value == "use strict" && !has_escape {
          return true
        }
      @engine.Stmt::ExprStmt(_) => break
      _ => break
    }
  }
  false
}

///|
fn to_function_value(
  env : Env,
  func : @engine.FunctionDef,
  local_name_binding : Bool,
) -> FunctionValue {
  let props = Map::new()
  let mut len = 0
  for i = 0; i < func.params.length(); i = i + 1 {
    if func.params[i].is_rest {
      break
    }
    match func.param_inits[i] {
      Some(_) => break
      None => len = len + 1
    }
  }
  props.set("length", property_data_readonly(Number(Double::from_int(len))))
  let name = match func.name {
    Some(value) => value
    None => ""
  }
  props.set("name", property_data_readonly(String(name)))
  let mut source_text : String? = None
  let mut source_root : String? = None
  let mut source_path : String? = None
  let mut line_number : Int? = None
  let mut column_number : Int? = None
  let mut source_value : String? = None
  match current_source() {
    Some(source) => source_value = Some(source)
    None =>
      match current_function() {
        Some(func) => source_value = func.source_root
        None => ()
      }
  }
  match source_value {
    Some(source) => {
      source_root = Some(source)
      let end_offset = if func.end_offset > func.offset {
        func.end_offset
      } else {
        func.offset
      }
      source_text = Some(slice_source_range(source, func.offset, end_offset))
      let (line, column) = offset_to_line_column(source, func.offset)
      line_number = Some(line)
      column_number = Some(column)
    }
    None => ()
  }
  match current_source_path() {
    Some(path) => source_path = Some(path)
    None =>
      match current_function() {
        Some(func) => source_path = func.source_path
        None => ()
      }
  }
  let mut in_class_field_init = false
  let mut home_object : Value? = None
  let mut super_constructor : Value? = None
  if func.is_arrow {
    match current_function() {
      Some(current) => in_class_field_init = current.in_class_field_init
      None => ()
    }
    match current_super_function() {
      Some(current) => {
        home_object = current.home_object
        super_constructor = current.super_constructor
      }
      None => ()
    }
  }
  register_function_value(FunctionValue::{
    name: func.name,
    source: source_text,
    source_root,
    source_path,
    line_number,
    column_number,
    local_name_binding,
    params: func.params,
    param_inits: func.param_inits,
    body: func.body,
    env,
    id: alloc_id(),
    props,
    proto: if func.is_generator && func.is_async {
      match value_from_object(async_generator_function_proto_for_env(env)) {
        Some(value) => Some(value)
        None => value_from_object(async_generator_function_proto())
      }
    } else if func.is_generator {
      match value_from_object(generator_function_proto_for_env(env)) {
        Some(value) => Some(value)
        None => value_from_object(generator_function_proto())
      }
    } else if func.is_async {
      match value_from_object(async_function_proto_for_env(env)) {
        Some(value) => Some(value)
        None => value_from_object(async_function_proto())
      }
    } else {
      match function_proto_for_env(env) {
        Some(value) => Some(value)
        None => function_proto()
      }
    },
    home_object,
    super_constructor,
    instance_fields: [],
    private_instance_fields: [],
    private_instance_props: Map::new(),
    is_constructor: !func.is_generator && !func.is_async && !func.is_arrow,
    is_class_constructor: false,
    is_default_constructor: false,
    extensible: true,
    is_strict: func.is_strict ||
    env.strict ||
    function_body_has_use_strict(func.body),
    is_generator: func.is_generator,
    is_async: func.is_async,
    is_arrow: func.is_arrow,
    in_class_field_init,
  })
}

///|
fn new_bound_function(
  target : Value,
  bound_this : Value,
  bound_args : Array[Value],
) -> Value raise {
  let mut target_len = 0.0
  if has_own_property(target, "length") {
    let len_value = property_get(target, "length")
    match len_value {
      Number(len_num) =>
        if Double::is_nan(len_num) || len_num == 0.0 {
          target_len = 0.0
        } else if Double::is_inf(len_num) {
          if len_num > 0.0 {
            target_len = len_num
          } else {
            target_len = 0.0
          }
        } else {
          let truncated = Double::trunc(len_num)
          if truncated == 0.0 {
            target_len = 0.0
          } else {
            target_len = truncated
          }
        }
      _ => target_len = 0.0
    }
  }
  let mut new_len_num = if Double::is_inf(target_len) {
    target_len
  } else {
    target_len - Double::from_int(bound_args.length())
  }
  if new_len_num < 0.0 {
    new_len_num = 0.0
  }
  let name_value = property_get(target, "name")
  let name = match name_value {
    String(s) => s
    _ => ""
  }
  let props = Map::new()
  props.set("length", property_data_readonly(Number(new_len_num)))
  props.set("name", property_data_readonly(String("bound " + name)))
  let proto = match function_realm_env(target) {
    Some(env) =>
      match function_proto_for_env(env) {
        Some(value) => Some(value)
        None => function_proto()
      }
    None => function_proto()
  }
  let bound = register_bound_function_value(BoundFunctionValue::{
    id: alloc_id(),
    target,
    bound_this,
    bound_args,
    props,
    proto,
    is_constructor: is_constructor_value(target),
    extensible: true,
  })
  BoundFunction(bound)
}

///|
fn clone_name_set(
  source : @hashmap.HashMap[String, Bool],
) -> @hashmap.HashMap[String, Bool] {
  let next : @hashmap.HashMap[String, Bool] = @hashmap.new()
  for name, _ in source {
    next.set(name, true)
  }
  next
}

///|
fn merge_name_sets(
  base : @hashmap.HashMap[String, Bool],
  extra : @hashmap.HashMap[String, Bool],
) -> @hashmap.HashMap[String, Bool] {
  let merged = clone_name_set(base)
  for name, _ in extra {
    merged.set(name, true)
  }
  merged
}

///|
fn lex_name_contains(
  outer : @hashmap.HashMap[String, Bool],
  local_set : @hashmap.HashMap[String, Bool],
  name : String,
) -> Bool {
  if local_set.contains(name) {
    true
  } else {
    outer.contains(name)
  }
}

///|
fn collect_global_lex_names(
  body : Array[@engine.Stmt],
) -> @hashmap.HashMap[String, Bool] {
  let names : @hashmap.HashMap[String, Bool] = @hashmap.new()
  for stmt in body {
    collect_global_lex_names_in_stmt(stmt, names)
  }
  names
}

///|
fn collect_global_lex_names_in_stmt(
  stmt : @engine.Stmt,
  out : @hashmap.HashMap[String, Bool],
) -> Unit {
  match stmt {
    @engine.Stmt::VarDecl(kind, decls) =>
      if !(kind is @engine.VarKind::Var) {
        for decl in decls {
          let (binding, _) = decl
          collect_binding_names(binding, out)
        }
      }
    @engine.Stmt::ClassDecl(class_def) =>
      match class_def.name {
        Some(name) => out.set(name, true)
        None => ()
      }
    _ => ()
  }
}

///|
fn collect_annex_b_var_func_names_in_stmt(
  stmt : @engine.Stmt,
  out : @hashmap.HashMap[Int, Bool],
  outer_lex : @hashmap.HashMap[String, Bool],
  local_lex : @hashmap.HashMap[String, Bool],
  blocked : @hashmap.HashMap[String, Bool],
  in_block : Bool,
  is_strict : Bool,
  has_arguments_binding : Bool,
) -> Unit {
  match stmt {
    @engine.Stmt::FunctionDecl(func) =>
      match func.name {
        Some(name) => {
          if !in_block {
            out.set(func.offset, true)
          } else if !is_strict && !func.is_async && !func.is_generator {
            if !blocked.contains(name) &&
              !lex_name_contains(outer_lex, local_lex, name) &&
              !(has_arguments_binding && name == "arguments") {
              out.set(func.offset, true)
            }
          }
          if in_block {
            local_lex.set(name, true)
          }
        }
        None => ()
      }
    @engine.Stmt::VarDecl(kind, decls) =>
      if !(kind is @engine.VarKind::Var) {
        for decl in decls {
          let (binding, _) = decl
          collect_binding_names(binding, local_lex)
        }
      }
    @engine.Stmt::ClassDecl(class_def) =>
      match class_def.name {
        Some(name) => local_lex.set(name, true)
        None => ()
      }
    @engine.Stmt::Block(stmts) => {
      let block_outer = merge_name_sets(outer_lex, local_lex)
      let block_local : @hashmap.HashMap[String, Bool] = @hashmap.new()
      for inner in stmts {
        collect_annex_b_var_func_names_in_stmt(
          inner, out, block_outer, block_local, blocked, true, is_strict, has_arguments_binding,
        )
      }
    }
    @engine.Stmt::Label(_, inner) =>
      collect_annex_b_var_func_names_in_stmt(
        inner, out, outer_lex, local_lex, blocked, in_block, is_strict, has_arguments_binding,
      )
    @engine.Stmt::With(_, body) => {
      let with_outer = merge_name_sets(outer_lex, local_lex)
      let with_local : @hashmap.HashMap[String, Bool] = @hashmap.new()
      collect_annex_b_var_func_names_in_stmt(
        body, out, with_outer, with_local, blocked, true, is_strict, has_arguments_binding,
      )
    }
    @engine.Stmt::If(_, conseq, alt) => {
      let if_outer = merge_name_sets(outer_lex, local_lex)
      let if_local : @hashmap.HashMap[String, Bool] = @hashmap.new()
      collect_annex_b_var_func_names_in_stmt(
        conseq, out, if_outer, if_local, blocked, true, is_strict, has_arguments_binding,
      )
      match alt {
        Some(inner) =>
          collect_annex_b_var_func_names_in_stmt(
            inner, out, if_outer, if_local, blocked, true, is_strict, has_arguments_binding,
          )
        None => ()
      }
    }
    @engine.Stmt::While(_, body) =>
      collect_annex_b_var_func_names_in_stmt(
        body, out, outer_lex, local_lex, blocked, true, is_strict, has_arguments_binding,
      )
    @engine.Stmt::For(init, _, _, body) => {
      let for_outer = merge_name_sets(outer_lex, local_lex)
      let for_local : @hashmap.HashMap[String, Bool] = @hashmap.new()
      match init {
        @engine.ForInit::Var(kind, decls) =>
          if !(kind is @engine.VarKind::Var) {
            for decl in decls {
              let (binding, _) = decl
              collect_binding_names(binding, for_local)
            }
          }
        _ => ()
      }
      collect_annex_b_var_func_names_in_stmt(
        body, out, for_outer, for_local, blocked, true, is_strict, has_arguments_binding,
      )
    }
    @engine.Stmt::ForIn(init, _, body)
    | @engine.Stmt::ForOf(init, _, body)
    | @engine.Stmt::ForAwaitOf(init, _, body) => {
      let for_outer = merge_name_sets(outer_lex, local_lex)
      let for_local : @hashmap.HashMap[String, Bool] = @hashmap.new()
      match init {
        @engine.ForInit::Var(kind, decls) =>
          if !(kind is @engine.VarKind::Var) {
            for decl in decls {
              let (binding, _) = decl
              collect_binding_names(binding, for_local)
            }
          }
        _ => ()
      }
      collect_annex_b_var_func_names_in_stmt(
        body, out, for_outer, for_local, blocked, true, is_strict, has_arguments_binding,
      )
    }
    @engine.Stmt::DoWhile(body, _) =>
      collect_annex_b_var_func_names_in_stmt(
        body, out, outer_lex, local_lex, blocked, true, is_strict, has_arguments_binding,
      )
    @engine.Stmt::Switch(_, cases) => {
      let switch_outer = merge_name_sets(outer_lex, local_lex)
      let switch_local : @hashmap.HashMap[String, Bool] = @hashmap.new()
      for clause in cases {
        let body = match clause {
          @engine.SwitchCase::Case(_, stmts) => stmts
          @engine.SwitchCase::Default(stmts) => stmts
        }
        for inner in body {
          collect_annex_b_var_func_names_in_stmt(
            inner, out, switch_outer, switch_local, blocked, true, is_strict, has_arguments_binding,
          )
        }
      }
    }
    @engine.Stmt::Try(try_body, catch_clause, finally_body) => {
      collect_annex_b_var_func_names_in_stmt(
        try_body, out, outer_lex, local_lex, blocked, true, is_strict, has_arguments_binding,
      )
      match catch_clause {
        Some(clause) =>
          collect_annex_b_var_func_names_in_stmt(
            clause.body,
            out,
            outer_lex,
            local_lex,
            blocked,
            true,
            is_strict,
            has_arguments_binding,
          )
        None => ()
      }
      match finally_body {
        Some(inner) =>
          collect_annex_b_var_func_names_in_stmt(
            inner, out, outer_lex, local_lex, blocked, true, is_strict, has_arguments_binding,
          )
        None => ()
      }
    }
    _ => ()
  }
}

///|
fn compute_annex_b_var_func_decls(
  body : Array[@engine.Stmt],
  is_strict : Bool,
  param_names : @hashmap.HashMap[String, Bool],
  has_arguments_binding : Bool,
) -> @hashmap.HashMap[Int, Bool] {
  if is_strict {
    return @hashmap.new()
  }
  let out : @hashmap.HashMap[Int, Bool] = @hashmap.new()
  let blocked : @hashmap.HashMap[String, Bool] = clone_name_set(param_names)
  let outer_lex : @hashmap.HashMap[String, Bool] = @hashmap.new()
  let local_lex : @hashmap.HashMap[String, Bool] = @hashmap.new()
  for stmt in body {
    collect_annex_b_var_func_names_in_stmt(
      stmt, out, outer_lex, local_lex, blocked, false, is_strict, has_arguments_binding,
    )
  }
  out
}

///|
fn hoist_decls(
  env : Env,
  body : Array[@engine.Stmt],
  configurable : Bool,
  eval_skip_outer_var : Bool,
) -> Unit raise {
  for stmt in body {
    hoist_functions(env, stmt, false, configurable)
  }
  for stmt in body {
    hoist_vars(env, stmt, configurable, eval_skip_outer_var)
  }
}

///|
fn hoist_functions(
  env : Env,
  stmt : @engine.Stmt,
  in_block : Bool,
  configurable : Bool,
) -> Unit raise {
  match stmt {
    FunctionDecl(func) => {
      if env.strict && in_block {
        return
      }
      if in_block && (func.is_async || func.is_generator) {
        return
      }
      match func.name {
        Some(name) => {
          ensure_strict_binding_name(env, name)
          let target_env = var_env_for(env)
          if in_block {
            if annex_b_var_func_decl_contains(func) {
              env_declare_var(target_env, name, configurable)
            }
          } else {
            let value = Value::Function(to_function_value(env, func, false))
            let is_new = target_env.bindings.get(name) is None
            match target_env.parent {
              None =>
                global_create_function_binding(
                  target_env, name, value, configurable,
                )
              Some(_) =>
                if target_env.var_object is Some(_) {
                  env_set_local_or_var_object(
                    target_env, name, value, configurable,
                  )
                } else {
                  if configurable && is_new {
                    target_env.deletable_bindings.set(name, true)
                  }
                  env_set_local(target_env, name, value)
                }
            }
          }
        }
        None => ()
      }
    }
    Block(stmts) =>
      if current_module_env_id() is Some(_) && block_is_export_wrapper(stmts) {
        for inner in stmts {
          hoist_functions(env, inner, in_block, configurable)
        }
      } else {
        for inner in stmts {
          hoist_functions(env, inner, true, configurable)
        }
      }
    Label(_, body) => hoist_functions(env, body, in_block, configurable)
    With(_, body) => hoist_functions(env, body, true, configurable)
    If(_, conseq, alt) => {
      hoist_functions(env, conseq, true, configurable)
      match alt {
        Some(stmt) => hoist_functions(env, stmt, true, configurable)
        None => ()
      }
    }
    While(_, body) => hoist_functions(env, body, true, configurable)
    For(_, _, _, body) => hoist_functions(env, body, true, configurable)
    ForIn(_, _, body) => hoist_functions(env, body, true, configurable)
    ForOf(_, _, body) => hoist_functions(env, body, true, configurable)
    ForAwaitOf(_, _, body) => hoist_functions(env, body, true, configurable)
    DoWhile(body, _) => hoist_functions(env, body, true, configurable)
    Switch(_, cases) =>
      for clause in cases {
        let body = match clause {
          @engine.SwitchCase::Case(_, stmts) => stmts
          @engine.SwitchCase::Default(stmts) => stmts
        }
        for stmt in body {
          hoist_functions(env, stmt, true, configurable)
        }
      }
    Try(try_body, catch_clause, finally_body) => {
      hoist_functions(env, try_body, true, configurable)
      match catch_clause {
        Some(clause) => hoist_functions(env, clause.body, true, configurable)
        None => ()
      }
      match finally_body {
        Some(stmt) => hoist_functions(env, stmt, true, configurable)
        None => ()
      }
    }
    _ => ()
  }
}

///|
fn ensure_strict_binding_name(env : Env, name : String) -> Unit raise {
  if env.strict && (name == "eval" || name == "arguments") {
    let _ = throw_syntax_error("invalid identifier")

  }
}

///|
fn declare_binding_names(env : Env, binding : @engine.VarBinding) -> Unit raise {
  match binding {
    @engine.VarBinding::Name(name) => {
      ensure_strict_binding_name(env, name)
      env_declare(env, name, Undefined)
    }
    @engine.VarBinding::ArrayPattern(pattern) =>
      for elem in pattern {
        match elem {
          @engine.ArrayPatternElem::Bind(inner, _) =>
            declare_binding_names(env, inner)
          @engine.ArrayPatternElem::Rest(inner) =>
            declare_binding_names(env, inner)
          @engine.ArrayPatternElem::Hole => ()
        }
      }
    @engine.VarBinding::ObjectPattern(pattern) =>
      for elem in pattern {
        match elem {
          @engine.ObjectPatternElem::Bind(_, inner, _) =>
            declare_binding_names(env, inner)
          @engine.ObjectPatternElem::Rest(inner) =>
            declare_binding_names(env, inner)
        }
      }
    @engine.VarBinding::Target(_) => ()
  }
}

///|
fn declare_var_binding_names(
  env : Env,
  binding : @engine.VarBinding,
  configurable : Bool,
) -> Unit raise {
  match binding {
    @engine.VarBinding::Name(name) => {
      ensure_strict_binding_name(env, name)
      env_declare_var(env, name, configurable)
    }
    @engine.VarBinding::ArrayPattern(pattern) =>
      for elem in pattern {
        match elem {
          @engine.ArrayPatternElem::Bind(inner, _) =>
            declare_var_binding_names(env, inner, configurable)
          @engine.ArrayPatternElem::Rest(inner) =>
            declare_var_binding_names(env, inner, configurable)
          @engine.ArrayPatternElem::Hole => ()
        }
      }
    @engine.VarBinding::ObjectPattern(pattern) =>
      for elem in pattern {
        match elem {
          @engine.ObjectPatternElem::Bind(_, inner, _) =>
            declare_var_binding_names(env, inner, configurable)
          @engine.ObjectPatternElem::Rest(inner) =>
            declare_var_binding_names(env, inner, configurable)
        }
      }
    @engine.VarBinding::Target(_) => ()
  }
}

///|
fn has_outer_non_global_var_binding(env : Env, name : String) -> Bool {
  let mut current : Env? = Some(env)
  while true {
    match current {
      Some(frame) => {
        if frame.is_catch_env && frame.bindings.get(name) is Some(_) {
          return true
        }
        match frame.var_env {
          Some(var_env) =>
            if var_env.id == frame.id && frame.parent is Some(_) {
              if frame.bindings.get(name) is Some(_) {
                return true
              }
            }
          None => ()
        }
        current = frame.parent
      }
      None => break
    }
  }
  false
}

///|
fn declare_var_binding_names_skip_outer_var(
  origin_env : Env,
  env : Env,
  binding : @engine.VarBinding,
  configurable : Bool,
) -> Unit raise {
  match binding {
    @engine.VarBinding::Name(name) => {
      ensure_strict_binding_name(env, name)
      if !has_outer_non_global_var_binding(origin_env, name) {
        env_declare_var(env, name, configurable)
      }
    }
    @engine.VarBinding::ArrayPattern(pattern) =>
      for elem in pattern {
        match elem {
          @engine.ArrayPatternElem::Bind(inner, _) =>
            declare_var_binding_names_skip_outer_var(
              origin_env, env, inner, configurable,
            )
          @engine.ArrayPatternElem::Rest(inner) =>
            declare_var_binding_names_skip_outer_var(
              origin_env, env, inner, configurable,
            )
          @engine.ArrayPatternElem::Hole => ()
        }
      }
    @engine.VarBinding::ObjectPattern(pattern) =>
      for elem in pattern {
        match elem {
          @engine.ObjectPatternElem::Bind(_, inner, _) =>
            declare_var_binding_names_skip_outer_var(
              origin_env, env, inner, configurable,
            )
          @engine.ObjectPatternElem::Rest(inner) =>
            declare_var_binding_names_skip_outer_var(
              origin_env, env, inner, configurable,
            )
        }
      }
    @engine.VarBinding::Target(_) => ()
  }
}

///|
fn declare_binding_uninitialized(
  env : Env,
  binding : @engine.VarBinding,
) -> Unit {
  match binding {
    @engine.VarBinding::Name(name) => env_declare_uninitialized(env, name)
    @engine.VarBinding::ArrayPattern(pattern) =>
      for elem in pattern {
        match elem {
          @engine.ArrayPatternElem::Bind(inner, _) =>
            declare_binding_uninitialized(env, inner)
          @engine.ArrayPatternElem::Rest(inner) =>
            declare_binding_uninitialized(env, inner)
          @engine.ArrayPatternElem::Hole => ()
        }
      }
    @engine.VarBinding::ObjectPattern(pattern) =>
      for elem in pattern {
        match elem {
          @engine.ObjectPatternElem::Bind(_, inner, _) =>
            declare_binding_uninitialized(env, inner)
          @engine.ObjectPatternElem::Rest(inner) =>
            declare_binding_uninitialized(env, inner)
        }
      }
    @engine.VarBinding::Target(_) => ()
  }
}

///|
fn hoist_vars(
  env : Env,
  stmt : @engine.Stmt,
  configurable : Bool,
  eval_skip_outer_var : Bool,
) -> Unit raise {
  match stmt {
    VarDecl(kind, decls) =>
      if kind is @engine.VarKind::Var {
        let target_env = var_env_for(env)
        for decl in decls {
          let (binding, _) = decl
          if eval_skip_outer_var {
            declare_var_binding_names_skip_outer_var(
              env, target_env, binding, configurable,
            )
          } else {
            declare_var_binding_names(target_env, binding, configurable)
          }
        }
      }
    Block(stmts) =>
      for inner in stmts {
        hoist_vars(env, inner, configurable, eval_skip_outer_var)
      }
    Label(_, body) => hoist_vars(env, body, configurable, eval_skip_outer_var)
    With(_, body) => hoist_vars(env, body, configurable, eval_skip_outer_var)
    If(_, conseq, alt) => {
      hoist_vars(env, conseq, configurable, eval_skip_outer_var)
      match alt {
        Some(stmt) => hoist_vars(env, stmt, configurable, eval_skip_outer_var)
        None => ()
      }
    }
    While(_, body) => hoist_vars(env, body, configurable, eval_skip_outer_var)
    For(init, _, _, body) => {
      match init {
        @engine.ForInit::Var(kind, decls) =>
          if kind is @engine.VarKind::Var {
            let target_env = var_env_for(env)
            for decl in decls {
              let (binding, _) = decl
              if eval_skip_outer_var {
                declare_var_binding_names_skip_outer_var(
                  env, target_env, binding, configurable,
                )
              } else {
                declare_var_binding_names(target_env, binding, configurable)
              }
            }
          }
        _ => ()
      }
      hoist_vars(env, body, configurable, eval_skip_outer_var)
    }
    ForIn(init, _, body) => {
      match init {
        @engine.ForInit::Var(kind, decls) =>
          if kind is @engine.VarKind::Var {
            let target_env = var_env_for(env)
            for decl in decls {
              let (binding, _) = decl
              if eval_skip_outer_var {
                declare_var_binding_names_skip_outer_var(
                  env, target_env, binding, configurable,
                )
              } else {
                declare_var_binding_names(target_env, binding, configurable)
              }
            }
          }
        _ => ()
      }
      hoist_vars(env, body, configurable, eval_skip_outer_var)
    }
    ForOf(init, _, body) => {
      match init {
        @engine.ForInit::Var(kind, decls) =>
          if kind is @engine.VarKind::Var {
            let target_env = var_env_for(env)
            for decl in decls {
              let (binding, _) = decl
              if eval_skip_outer_var {
                declare_var_binding_names_skip_outer_var(
                  env, target_env, binding, configurable,
                )
              } else {
                declare_var_binding_names(target_env, binding, configurable)
              }
            }
          }
        _ => ()
      }
      hoist_vars(env, body, configurable, eval_skip_outer_var)
    }
    ForAwaitOf(init, _, body) => {
      match init {
        @engine.ForInit::Var(kind, decls) =>
          if kind is @engine.VarKind::Var {
            let target_env = var_env_for(env)
            for decl in decls {
              let (binding, _) = decl
              if eval_skip_outer_var {
                declare_var_binding_names_skip_outer_var(
                  env, target_env, binding, configurable,
                )
              } else {
                declare_var_binding_names(target_env, binding, configurable)
              }
            }
          }
        _ => ()
      }
      hoist_vars(env, body, configurable, eval_skip_outer_var)
    }
    DoWhile(body, _) => hoist_vars(env, body, configurable, eval_skip_outer_var)
    Switch(_, cases) =>
      for clause in cases {
        let body = match clause {
          @engine.SwitchCase::Case(_, stmts) => stmts
          @engine.SwitchCase::Default(stmts) => stmts
        }
        for stmt in body {
          hoist_vars(env, stmt, configurable, eval_skip_outer_var)
        }
      }
    Try(try_body, catch_clause, finally_body) => {
      hoist_vars(env, try_body, configurable, eval_skip_outer_var)
      match catch_clause {
        Some(clause) =>
          hoist_vars(env, clause.body, configurable, eval_skip_outer_var)
        None => ()
      }
      match finally_body {
        Some(stmt) => hoist_vars(env, stmt, configurable, eval_skip_outer_var)
        None => ()
      }
    }
    Throw(_) => ()
    FunctionDecl(_) => ()
    ClassDecl(_) => ()
    Return(_) => ()
    ExprStmt(_) => ()
    Break(_) => ()
    Continue(_) => ()
    Empty => ()
  }
}

///|
fn is_unscopable(obj : Value, name : String) -> Bool raise {
  match symbol_unscopables_key() {
    Some(key) =>
      match property_get(obj, key) {
        Undefined | Null => false
        target =>
          if is_object_like(target) {
            is_truthy(property_get(target, name))
          } else {
            false
          }
      }
    None => false
  }
}

///|
priv enum BindingTarget {
  WithObject(Value)
  Env(Env)
  Unbound
}

///|
fn resolve_binding_target(env : Env, name : String) -> BindingTarget raise {
  match env.with_object {
    Some(obj) =>
      if has_property_value(obj, name) && !is_unscopable(obj, name) {
        return BindingTarget::WithObject(obj)
      }
    None => ()
  }
  match env.bindings.get(name) {
    Some(_) => BindingTarget::Env(env)
    None =>
      match env.parent {
        Some(parent) => resolve_binding_target(parent, name)
        None => BindingTarget::Unbound
      }
  }
}

///|
fn env_get_binding_value(env : Env, name : String) -> Value raise {
  match env.bindings.get(name) {
    Some(value) =>
      if env.uninitialized_bindings.contains(name) {
        throw_reference_error("undefined variable")
      } else if name == "this" && env.this_uninitialized {
        throw_reference_error("this is not initialized")
      } else {
        module_binding_deref(value)
      }
    None => throw_reference_error("undefined variable")
  }
}

///|
fn get_binding_value_from_target(
  env : Env,
  name : String,
  target : BindingTarget,
  strict : Bool,
) -> Value raise {
  match target {
    BindingTarget::WithObject(obj) =>
      if has_property_value(obj, name) {
        property_get(obj, name)
      } else if strict {
        throw_reference_error("undefined variable")
      } else {
        Undefined
      }
    BindingTarget::Env(target_env) => env_get_binding_value(target_env, name)
    BindingTarget::Unbound =>
      match global_object(env) {
        Some(obj) =>
          if has_property_in_chain(obj.props, obj.proto, name) {
            property_get_from_chain(
              obj.props,
              obj.proto,
              name,
              Value::Object(obj),
            )
          } else {
            throw_reference_error("undefined variable")
          }
        None => throw_reference_error("undefined variable")
      }
  }
}

///|
fn assign_binding_value_to_target(
  env : Env,
  name : String,
  target : BindingTarget,
  value : Value,
  strict : Bool,
) -> Unit raise {
  match target {
    BindingTarget::WithObject(obj) =>
      if has_property_value(obj, name) {
        let _ = property_set(obj, name, value, strict)

      } else if strict {
        let _ = throw_reference_error("undefined variable")

      } else {
        let _ = property_set(obj, name, value, false)

      }
    BindingTarget::Env(target_env) =>
      env_set_with_strict_no_with(target_env, name, value, strict)
    BindingTarget::Unbound =>
      env_set_with_strict_no_with(env, name, value, strict)
  }
}

///|
fn env_get(env : Env, name : String) -> Value raise {
  let target = resolve_binding_target(env, name)
  get_binding_value_from_target(env, name, target, env.strict)
}

///|
fn find_this_env(env : Env) -> Env {
  let mut current : Env? = Some(env)
  while true {
    match current {
      Some(scope) =>
        if scope.bindings.contains("this") {
          return scope
        } else {
          current = scope.parent
        }
      None => return env
    }
  }
  env
}

///|
fn env_get_call_reference(env : Env, name : String) -> (Value, Value) raise {
  let target = resolve_binding_target(env, name)
  let value = get_binding_value_from_target(env, name, target, env.strict)
  let this_value = match target {
    BindingTarget::WithObject(obj) => obj
    _ => Undefined
  }
  (value, this_value)
}

///|
fn env_define_private_name(env : Env, name : String) -> String raise {
  match env.private_bindings.get(name) {
    Some(_) => {
      let _ = throw_syntax_error("duplicate private name")
      ""
    }
    None => {
      let key = private_prop_key(alloc_id())
      env.private_bindings.set(name, key)
      key
    }
  }
}

///|
fn env_private_key(env : Env, name : String) -> String? {
  match env.private_bindings.get(name) {
    Some(key) => Some(key)
    None =>
      match env.parent {
        Some(parent) => env_private_key(parent, name)
        None => None
      }
  }
}

///|
fn env_private_key_checked(env : Env, name : String) -> String raise {
  match env_private_key(env, name) {
    Some(key) => key
    None => {
      let _ = throw_syntax_error("invalid private reference")
      ""
    }
  }
}

///|
fn var_env_for(env : Env) -> Env {
  match env.var_env {
    Some(var_env) => if var_env.id == env.id { env } else { var_env }
    None =>
      match env.parent {
        Some(parent) => var_env_for(parent)
        None => env
      }
  }
}

///|
fn merge_arg_env_bindings(arg_env : Env, var_env : Env) -> Unit {
  for name, value in arg_env.bindings {
    if var_env.bindings.get(name) is None {
      var_env.bindings.set(name, value)
      if arg_env.deletable_bindings.get(name) is Some(_) {
        var_env.deletable_bindings.set(name, true)
      }
      if arg_env.readonly_bindings.get(name) is Some(_) {
        var_env.readonly_bindings.set(name, true)
      }
    }
  }
}

///|
fn env_declare(env : Env, name : String, value : Value) -> Unit {
  match env.with_object {
    Some(_) =>
      match env.parent {
        Some(parent) => env_declare(parent, name, value)
        None => env.bindings.set(name, value)
      }
    None =>
      match env.parent {
        Some(_) =>
          match env.bindings.get(name) {
            Some(_) => ()
            None => env.bindings.set(name, value)
          }
        None =>
          match global_object(env) {
            Some(obj) =>
              if !obj.props.contains(name) {
                obj.props.set(name, property_data_non_enum(value))
              }
            None => env.bindings.set(name, value)
          }
      }
  }
}

///|
fn property_data_global(value : Value, configurable : Bool) -> Property {
  Property::{
    value,
    writable: true,
    configurable,
    enumerable: true,
    getter: None,
    setter: None,
  }
}

///|
fn is_data_property(prop : Property) -> Bool {
  prop.getter is None && prop.setter is None
}

///|
fn global_has_lexical_declaration(env : Env, name : String) -> Bool {
  match env.bindings.get(name) {
    Some(_) => true
    None => false
  }
}

///|
fn global_can_declare_var(env : Env, name : String) -> Bool {
  match global_object(env) {
    Some(obj) =>
      match obj.props.get(name) {
        Some(_) => true
        None => obj.extensible
      }
    None => true
  }
}

///|
fn global_can_declare_function(env : Env, name : String) -> Bool {
  if global_has_lexical_declaration(env, name) {
    return false
  }
  match global_object(env) {
    Some(obj) =>
      match obj.props.get(name) {
        Some(prop) =>
          if prop.configurable {
            true
          } else {
            is_data_property(prop) && prop.writable && prop.enumerable
          }
        None => obj.extensible
      }
    None => true
  }
}

///|
fn global_has_restricted_property(env : Env, name : String) -> Bool {
  match global_object(env) {
    Some(obj) =>
      match obj.props.get(name) {
        Some(prop) => !prop.configurable
        None => false
      }
    None => false
  }
}

///|
fn global_create_var_binding(
  env : Env,
  name : String,
  configurable : Bool,
) -> Unit raise {
  match global_object(env) {
    Some(obj) =>
      match obj.props.get(name) {
        Some(_) => ()
        None =>
          if !obj.extensible {
            let _ = throw_type_error("cannot define property")

          } else {
            obj.props.set(name, property_data_global(Undefined, configurable))
          }
      }
    None => env.bindings.set(name, Undefined)
  }
}

///|
fn global_create_function_binding(
  env : Env,
  name : String,
  value : Value,
  configurable : Bool,
) -> Unit raise {
  match global_object(env) {
    Some(obj) =>
      match obj.props.get(name) {
        Some(prop) =>
          if prop.configurable {
            obj.props.set(name, property_data_global(value, configurable))
          } else if !is_data_property(prop) {
            let _ = throw_type_error("cannot redefine property")

          } else {
            obj.props.set(name, Property::{
              value,
              writable: prop.writable,
              configurable: prop.configurable,
              enumerable: prop.enumerable,
              getter: prop.getter,
              setter: prop.setter,
            })
          }
        None =>
          if !obj.extensible {
            let _ = throw_type_error("cannot define property")

          } else {
            obj.props.set(name, property_data_global(value, configurable))
          }
      }
    None => env.bindings.set(name, value)
  }
}

///|
fn env_declare_var(env : Env, name : String, configurable : Bool) -> Unit raise {
  match env.var_object {
    Some(Object(obj)) => {
      match obj.props.get(name) {
        Some(_) => ()
        None =>
          if !obj.extensible {
            let _ = throw_type_error("cannot define property")

          } else {
            obj.props.set(name, property_data_global(Undefined, configurable))
          }
      }
      return
    }
    Some(_) => return
    None => ()
  }
  match env.with_object {
    Some(_) =>
      match env.parent {
        Some(parent) => env_declare_var(parent, name, configurable)
        None =>
          if env.bindings.get(name) is None {
            env.bindings.set(name, Undefined)
            if configurable {
              env.deletable_bindings.set(name, true)
            }
          }
      }
    None =>
      match env.parent {
        Some(_) =>
          match env.bindings.get(name) {
            Some(_) => ()
            None => {
              env.bindings.set(name, Undefined)
              if configurable {
                env.deletable_bindings.set(name, true)
              }
            }
          }
        None => global_create_var_binding(env, name, configurable)
      }
  }
}

///|
fn env_set_local_or_var_object(
  env : Env,
  name : String,
  value : Value,
  configurable : Bool,
) -> Unit raise {
  match env.var_object {
    Some(Object(obj)) =>
      match obj.props.get(name) {
        Some(_) => {
          let _ = property_set(Value::Object(obj), name, value, env.strict)

        }
        None =>
          if !obj.extensible {
            let _ = throw_type_error("cannot define property")

          } else {
            obj.props.set(name, property_data_global(value, configurable))
          }
      }
    Some(_) => ()
    None => env_set_local(env, name, value)
  }
}

///|
fn env_declare_uninitialized(env : Env, name : String) -> Unit {
  env.bindings.set(name, Undefined)
  env.uninitialized_bindings.set(name, true)
}

///|
fn env_define_readonly(
  env : Env,
  name : String,
  value : Value,
  always_throw : Bool,
) -> Unit {
  env.bindings.set(name, value)
  env.uninitialized_bindings.remove(name)
  env.readonly_bindings.set(name, always_throw)
  update_module_export_binding(env, name, value)
  sync_module_env(env)
}

///|
fn env_initialize_binding(env : Env, name : String, value : Value) -> Unit {
  env.uninitialized_bindings.remove(name)
  env.bindings.set(name, value)
  update_module_export_binding(env, name, value)
  sync_module_env(env)
}

///|
fn env_set_local(env : Env, name : String, value : Value) -> Unit raise {
  match env.with_object {
    Some(_) =>
      match env.parent {
        Some(parent) => env_set_local(parent, name, value)
        None => {
          if env.uninitialized_bindings.contains(name) {
            let _ = throw_reference_error("undefined variable")
            return
          }
          env.bindings.set(name, value)
          update_module_export_binding(env, name, value)
        }
      }
    None =>
      match env.parent {
        Some(_) => {
          if env.uninitialized_bindings.contains(name) {
            let _ = throw_reference_error("undefined variable")
            return
          }
          env.bindings.set(name, value)
          update_module_export_binding(env, name, value)
        }
        None =>
          match global_object(env) {
            Some(obj) => {
              if env.uninitialized_bindings.contains(name) {
                let _ = throw_reference_error("undefined variable")
                return
              }
              let _ = set_property_in(
                obj.props,
                name,
                value,
                Value::Object(obj),
              )

            }
            None => env.bindings.set(name, value)
          }
      }
  }
}

///|
fn env_set(env : Env, name : String, value : Value) -> Unit raise {
  env_set_with_strict(env, name, value, env.strict)
}

///|
fn env_set_with_strict(
  env : Env,
  name : String,
  value : Value,
  strict : Bool,
) -> Unit raise {
  match env.with_object {
    Some(obj) =>
      if has_property_value(obj, name) && !is_unscopable(obj, name) {
        let _ = property_set(obj, name, value, strict)
        return
      }
    None => ()
  }
  match env.bindings.get(name) {
    Some(_) => {
      if env.uninitialized_bindings.contains(name) {
        let _ = throw_reference_error("undefined variable")
        return
      }
      match env.readonly_bindings.get(name) {
        Some(always_throw) =>
          if always_throw || strict {
            let _ = throw_type_error("invalid assignment")

          } else {
            ()
          }
        None => {
          env.bindings.set(name, value)
          update_module_export_binding(env, name, value)
        }
      }
    }
    None =>
      match env.parent {
        Some(parent) => env_set_with_strict(parent, name, value, strict)
        None =>
          match global_object(env) {
            Some(obj) =>
              if has_property_in_chain(obj.props, obj.proto, name) {
                let _ = property_set(Value::Object(obj), name, value, strict)

              } else if strict {
                let _ = throw_reference_error("undefined variable")

              } else {
                let _ = property_set(Value::Object(obj), name, value, false)

              }
            None => env.bindings.set(name, value)
          }
      }
  }
}

///|
fn env_set_with_strict_no_with(
  env : Env,
  name : String,
  value : Value,
  strict : Bool,
) -> Unit raise {
  match env.bindings.get(name) {
    Some(_) => {
      if env.uninitialized_bindings.contains(name) {
        let _ = throw_reference_error("undefined variable")
        return
      }
      match env.readonly_bindings.get(name) {
        Some(always_throw) =>
          if always_throw || strict {
            let _ = throw_type_error("invalid assignment")

          } else {
            ()
          }
        None => {
          env.bindings.set(name, value)
          update_module_export_binding(env, name, value)
        }
      }
    }
    None =>
      match env.parent {
        Some(parent) => env_set_with_strict_no_with(parent, name, value, strict)
        None =>
          match global_object(env) {
            Some(obj) =>
              if has_property_in_chain(obj.props, obj.proto, name) {
                let _ = property_set(Value::Object(obj), name, value, strict)

              } else if strict {
                let _ = throw_reference_error("undefined variable")

              } else {
                let _ = property_set(Value::Object(obj), name, value, false)

              }
            None => env.bindings.set(name, value)
          }
      }
  }
}

///|
fn global_object(env : Env) -> ObjectValue? {
  match env.parent {
    Some(parent) => global_object(parent)
    None =>
      match env.bindings.get("this") {
        Some(Object(obj)) => Some(obj)
        _ => None
      }
  }
}

///|
fn global_object_value(env : Env) -> Value {
  match global_object(env) {
    Some(obj) => Object(obj)
    None => Undefined
  }
}

///|
fn object_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("Object") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn function_proto_for_env(env : Env) -> Value? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("Function") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) => Some(proto_prop.value)
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn array_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("Array") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn error_proto_for_env_name(env : Env, name : String) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get(name) {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn type_error_proto_for_env(env : Env) -> ObjectValue? {
  error_proto_for_env_name(env, "TypeError")
}

///|
fn reference_error_proto_for_env(env : Env) -> ObjectValue? {
  error_proto_for_env_name(env, "ReferenceError")
}

///|
fn syntax_error_proto_for_env(env : Env) -> ObjectValue? {
  error_proto_for_env_name(env, "SyntaxError")
}

///|
fn range_error_proto_for_env(env : Env) -> ObjectValue? {
  error_proto_for_env_name(env, "RangeError")
}

///|
fn uri_error_proto_for_env(env : Env) -> ObjectValue? {
  error_proto_for_env_name(env, "URIError")
}

///|
fn string_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("String") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn number_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("Number") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn bool_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("Boolean") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn bigint_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("BigInt") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn symbol_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("Symbol") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn date_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("Date") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn array_buffer_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("ArrayBuffer") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn shared_array_buffer_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("SharedArrayBuffer") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn dataview_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("DataView") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn typed_array_ctor_for_env(env : Env) -> Value? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("TypedArray") {
        Some(prop) => Some(prop.value)
        None => None
      }
    None => None
  }
}

///|
fn function_ctor_for_env(env : Env) -> Value? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("Function") {
        Some(prop) => Some(prop.value)
        None => None
      }
    None => None
  }
}

///|
fn typed_array_proto_for_kind_env(
  env : Env,
  kind : TypedArrayKind,
) -> ObjectValue? {
  let name = typed_array_constructor_name(kind)
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get(name) {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn typed_array_ctor_for_kind_env(env : Env, kind : TypedArrayKind) -> Value? {
  let name = typed_array_constructor_name(kind)
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get(name) {
        Some(prop) => Some(prop.value)
        None => None
      }
    None => None
  }
}

///|
fn map_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("Map") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn iterator_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("Iterator") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => {
                      match object_proto_for_env(env) {
                        Some(obj_proto) =>
                          proto_obj.proto = Some(Object(obj_proto))
                        None => ()
                      }
                      Some(proto_obj)
                    }
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => {
                      match object_proto_for_env(env) {
                        Some(obj_proto) =>
                          proto_obj.proto = Some(Object(obj_proto))
                        None => ()
                      }
                      Some(proto_obj)
                    }
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn set_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("Set") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn weakmap_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("WeakMap") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn weakset_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("WeakSet") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn weakref_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("WeakRef") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn finreg_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("FinalizationRegistry") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn promise_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("Promise") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            Function(func) =>
              match func.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn promise_ctor_env_id(env : Env) -> Int {
  match global_object(env) {
    Some(obj) => obj.id
    None => env.id
  }
}

///|
fn register_promise_ctor_for_env(env : Env, ctor : BuiltinValue) -> Unit {
  let realm_id = promise_ctor_env_id(env)
  promise_ctor_env_ref.update(fn(table) {
    table.set(realm_id, ctor)
    table
  })
}

///|
fn promise_ctor_for_env(env : Env) -> Value? {
  let mut value : BuiltinValue? = None
  let realm_id = promise_ctor_env_id(env)
  promise_ctor_env_ref.update(fn(table) {
    match table.get(realm_id) {
      Some(ctor) => {
        value = Some(ctor)
        table
      }
      None => table
    }
  })
  match value {
    Some(ctor) => Some(Builtin(ctor))
    None => None
  }
}

///|
fn promise_ctor_from_global_env(env : Env) -> Value? {
  match global_object(env) {
    Some(obj) =>
      match obj.props.get("Promise") {
        Some(prop) => Some(prop.value)
        None => None
      }
    None => None
  }
}

///|
fn register_promise_ctor_from_global(env : Env) -> Unit {
  match promise_ctor_from_global_env(env) {
    Some(Builtin(builtin)) => register_promise_ctor_for_env(env, builtin)
    _ => ()
  }
}

///|
fn promise_ctor_value_for_env(env : Env) -> Value {
  match promise_ctor_for_env(env) {
    Some(value) => value
    None =>
      match promise_ctor_from_global_env(env) {
        Some(value) => value
        None => new_builtin_value(BuiltinFunction::PromiseConstructor)
      }
  }
}

///|
fn promise_ctor_value_for_current_env() -> Value {
  match current_env() {
    Some(env) => promise_ctor_value_for_env(env)
    None =>
      match root_env() {
        Some(env) => promise_ctor_value_for_env(env)
        None => new_builtin_value(BuiltinFunction::PromiseConstructor)
      }
  }
}

///|
fn generator_function_ctor_for_env(env : Env) -> BuiltinValue? {
  let mut value : BuiltinValue? = None
  let realm_id = match global_object(env) {
    Some(obj) => obj.id
    None => env.id
  }
  generator_function_ctor_env_ref.update(fn(table) {
    match table.get(realm_id) {
      Some(ctor) => {
        value = Some(ctor)
        table
      }
      None =>
        match generator_function_proto() {
          Some(proto_obj) =>
            match proto_obj.props.get("constructor") {
              Some(prop) =>
                match prop.value {
                  Builtin(builtin) => {
                    let clone = clone_builtin_value_for_env(builtin, env)
                    table.set(realm_id, clone)
                    value = Some(clone)
                    table
                  }
                  _ => table
                }
              None => table
            }
          None => table
        }
    }
  })
  value
}

///|
fn generator_function_proto_for_env(env : Env) -> ObjectValue? {
  match generator_function_ctor_for_env(env) {
    Some(ctor) =>
      match ctor.props.get("prototype") {
        Some(proto_prop) =>
          match proto_prop.value {
            Object(proto_obj) => {
              let _ = generator_proto_for_env_with_ctor(env, Some(proto_obj))
              Some(proto_obj)
            }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn async_function_ctor_for_env(env : Env) -> BuiltinValue? {
  let mut value : BuiltinValue? = None
  let realm_id = match global_object(env) {
    Some(obj) => obj.id
    None => env.id
  }
  async_function_ctor_env_ref.update(fn(table) {
    match table.get(realm_id) {
      Some(ctor) => {
        value = Some(ctor)
        table
      }
      None =>
        match async_function_proto() {
          Some(proto_obj) =>
            match proto_obj.props.get("constructor") {
              Some(prop) =>
                match prop.value {
                  Builtin(builtin) => {
                    let clone = clone_builtin_value_for_env(builtin, env)
                    table.set(realm_id, clone)
                    value = Some(clone)
                    table
                  }
                  _ => table
                }
              None => table
            }
          None => table
        }
    }
  })
  value
}

///|
fn async_function_proto_for_env(env : Env) -> ObjectValue? {
  match async_function_ctor_for_env(env) {
    Some(ctor) =>
      match ctor.props.get("prototype") {
        Some(proto_prop) =>
          match proto_prop.value {
            Object(proto_obj) => Some(proto_obj)
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn async_generator_function_ctor_for_env(env : Env) -> BuiltinValue? {
  let mut value : BuiltinValue? = None
  let realm_id = match global_object(env) {
    Some(obj) => obj.id
    None => env.id
  }
  async_generator_function_ctor_env_ref.update(fn(table) {
    match table.get(realm_id) {
      Some(ctor) => {
        value = Some(ctor)
        table
      }
      None =>
        match async_generator_function_proto() {
          Some(proto_obj) =>
            match proto_obj.props.get("constructor") {
              Some(prop) =>
                match prop.value {
                  Builtin(builtin) => {
                    let clone = clone_builtin_value_for_env(builtin, env)
                    table.set(realm_id, clone)
                    value = Some(clone)
                    table
                  }
                  _ => table
                }
              None => table
            }
          None => table
        }
    }
  })
  value
}

///|
fn async_generator_function_proto_for_env(env : Env) -> ObjectValue? {
  match async_generator_function_ctor_for_env(env) {
    Some(ctor) =>
      match ctor.props.get("prototype") {
        Some(proto_prop) =>
          match proto_prop.value {
            Object(proto_obj) => {
              let _ = async_generator_proto_for_env_with_ctor(
                env,
                Some(proto_obj),
              )
              Some(proto_obj)
            }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn async_iterator_proto_for_env(env : Env) -> ObjectValue? {
  let mut value : ObjectValue? = None
  let realm_id = match global_object(env) {
    Some(obj) => obj.id
    None => env.id
  }
  async_iterator_proto_env_ref.update(fn(table) {
    match table.get(realm_id) {
      Some(obj) => {
        value = Some(obj)
        table
      }
      None =>
        match async_iterator_proto() {
          Some(obj) => {
            let clone = clone_object_value_for_env(obj, env, None)
            let proto_value = match object_proto_for_env(env) {
              Some(obj_proto) => Some(Object(obj_proto))
              None => value_from_object(object_proto())
            }
            clone.proto = proto_value
            table.set(realm_id, clone)
            value = Some(clone)
            table
          }
          None => table
        }
    }
  })
  value
}

///|
fn set_function_proto_prototype(
  func_proto : ObjectValue,
  proto_obj : ObjectValue,
) -> Unit {
  let proto_prop = match func_proto.props.get("prototype") {
    Some(prop) =>
      Property::{
        value: Object(proto_obj),
        writable: prop.writable,
        configurable: prop.configurable,
        enumerable: prop.enumerable,
        getter: prop.getter,
        setter: prop.setter,
      }
    None => property_data_readonly(Object(proto_obj))
  }
  func_proto.props.set("prototype", proto_prop)
}

///|
fn generator_proto_for_env_with_ctor(
  env : Env,
  func_proto : ObjectValue?,
) -> ObjectValue? {
  let mut value : ObjectValue? = None
  let realm_id = match global_object(env) {
    Some(obj) => obj.id
    None => env.id
  }
  generator_proto_env_ref.update(fn(table) {
    match table.get(realm_id) {
      Some(obj) => {
        value = Some(obj)
        table
      }
      None =>
        match generator_proto() {
          Some(obj) => {
            let ctor_override = match func_proto {
              Some(proto_obj) => Some(Object(proto_obj))
              None => value_from_object(generator_function_proto())
            }
            let clone = clone_object_value_for_env(obj, env, ctor_override)
            let proto_value = match iterator_proto_for_env(env) {
              Some(iter_proto) => Some(Object(iter_proto))
              None => value_from_object(iterator_proto())
            }
            clone.proto = proto_value
            table.set(realm_id, clone)
            value = Some(clone)
            table
          }
          None => table
        }
    }
  })
  match (value, func_proto) {
    (Some(gen_proto), Some(func_proto_obj)) =>
      set_function_proto_prototype(func_proto_obj, gen_proto)
    _ => ()
  }
  value
}

///|
fn generator_proto_for_env(env : Env) -> ObjectValue? {
  match generator_function_proto_for_env(env) {
    Some(func_proto) => generator_proto_for_env_with_ctor(env, Some(func_proto))
    None => generator_proto_for_env_with_ctor(env, None)
  }
}

///|
fn async_generator_proto_for_env_with_ctor(
  env : Env,
  func_proto : ObjectValue?,
) -> ObjectValue? {
  let mut value : ObjectValue? = None
  let realm_id = match global_object(env) {
    Some(obj) => obj.id
    None => env.id
  }
  async_generator_proto_env_ref.update(fn(table) {
    match table.get(realm_id) {
      Some(obj) => {
        value = Some(obj)
        table
      }
      None =>
        match async_generator_proto() {
          Some(obj) => {
            let ctor_override = match func_proto {
              Some(proto_obj) => Some(Object(proto_obj))
              None => value_from_object(async_generator_function_proto())
            }
            let clone = clone_object_value_for_env(obj, env, ctor_override)
            let proto_value = match async_iterator_proto_for_env(env) {
              Some(iter_proto) => Some(Object(iter_proto))
              None => value_from_object(async_iterator_proto())
            }
            clone.proto = proto_value
            table.set(realm_id, clone)
            value = Some(clone)
            table
          }
          None => table
        }
    }
  })
  match (value, func_proto) {
    (Some(gen_proto), Some(func_proto_obj)) =>
      set_function_proto_prototype(func_proto_obj, gen_proto)
    _ => ()
  }
  value
}

///|
fn async_generator_proto_for_env(env : Env) -> ObjectValue? {
  match async_generator_function_proto_for_env(env) {
    Some(func_proto) =>
      async_generator_proto_for_env_with_ctor(env, Some(func_proto))
    None => async_generator_proto_for_env_with_ctor(env, None)
  }
}

///|
fn clone_global_object(obj : ObjectValue, env : Env) -> ObjectValue {
  let props : Map[String, Property] = Map::new()
  for name, prop in obj.props {
    let value = clone_realm_value(prop.value, env)
    let getter = match prop.getter {
      Some(getter_value) => Some(clone_realm_value(getter_value, env))
      None => None
    }
    let setter = match prop.setter {
      Some(setter_value) => Some(clone_realm_value(setter_value, env))
      None => None
    }
    props.set(name, Property::{
      value,
      writable: prop.writable,
      configurable: prop.configurable,
      enumerable: prop.enumerable,
      getter,
      setter,
    })
  }
  register_object_value(ObjectValue::{
    id: alloc_id(),
    props,
    proto: obj.proto,
    string_data: None,
    number_data: None,
    bool_data: None,
    bigint_data: None,
    symbol_data: None,
    regexp_data: None,
    generator_data: None,
    async_generator_data: None,
    proxy_data: None,
    map_data: None,
    set_data: None,
    map_iter_data: None,
    set_iter_data: None,
    iterator_wrap_data: None,
    iterator_concat_data: None,
    iterator_helper_data: None,
    weakmap_data: None,
    weakset_data: None,
    weakref_data: None,
    finreg_data: None,
    date_data: None,
    array_buffer_data: None,
    dataview_data: None,
    is_html_dda: false,
    is_error: false,
    is_module_namespace: false,
    realm_env: Some(env),
    immutable_proto: false,
    extensible: obj.extensible,
  })
}

///|
fn clone_object_value_for_env(
  obj : ObjectValue,
  env : Env,
  constructor_override : Value?,
) -> ObjectValue {
  let props : Map[String, Property] = Map::new()
  for name, prop in obj.props {
    let value = if name == "constructor" {
      match constructor_override {
        Some(ctor_value) => ctor_value
        None => clone_realm_value(prop.value, env)
      }
    } else {
      clone_realm_value(prop.value, env)
    }
    let getter = match prop.getter {
      Some(getter_value) => Some(clone_realm_value(getter_value, env))
      None => None
    }
    let setter = match prop.setter {
      Some(setter_value) => Some(clone_realm_value(setter_value, env))
      None => None
    }
    props.set(name, Property::{
      value,
      writable: prop.writable,
      configurable: prop.configurable,
      enumerable: prop.enumerable,
      getter,
      setter,
    })
  }
  register_object_value(ObjectValue::{
    id: alloc_id(),
    props,
    proto: obj.proto,
    string_data: obj.string_data,
    number_data: obj.number_data,
    bool_data: obj.bool_data,
    bigint_data: obj.bigint_data,
    symbol_data: obj.symbol_data,
    regexp_data: obj.regexp_data,
    generator_data: obj.generator_data,
    async_generator_data: obj.async_generator_data,
    proxy_data: obj.proxy_data,
    map_data: obj.map_data,
    set_data: obj.set_data,
    map_iter_data: obj.map_iter_data,
    set_iter_data: obj.set_iter_data,
    iterator_wrap_data: obj.iterator_wrap_data,
    iterator_concat_data: obj.iterator_concat_data,
    iterator_helper_data: obj.iterator_helper_data,
    weakmap_data: obj.weakmap_data,
    weakset_data: obj.weakset_data,
    weakref_data: obj.weakref_data,
    finreg_data: obj.finreg_data,
    date_data: obj.date_data,
    array_buffer_data: obj.array_buffer_data,
    dataview_data: obj.dataview_data,
    is_html_dda: obj.is_html_dda,
    is_error: obj.is_error,
    is_module_namespace: obj.is_module_namespace,
    realm_env: Some(env),
    immutable_proto: obj.immutable_proto,
    extensible: obj.extensible,
  })
}

///|
fn clone_function_value_for_env(
  func : FunctionValue,
  env : Env,
  constructor_override : Value?,
  proto_override : Value?,
) -> FunctionValue {
  let props : Map[String, Property] = Map::new()
  for name, prop in func.props {
    let value = if name == "constructor" {
      match constructor_override {
        Some(ctor_value) => ctor_value
        None => clone_realm_value(prop.value, env)
      }
    } else {
      clone_realm_value(prop.value, env)
    }
    let getter = match prop.getter {
      Some(getter_value) => Some(clone_realm_value(getter_value, env))
      None => None
    }
    let setter = match prop.setter {
      Some(setter_value) => Some(clone_realm_value(setter_value, env))
      None => None
    }
    props.set(name, Property::{
      value,
      writable: prop.writable,
      configurable: prop.configurable,
      enumerable: prop.enumerable,
      getter,
      setter,
    })
  }
  let proto = match proto_override {
    Some(value) => Some(value)
    None => func.proto
  }
  register_function_value(FunctionValue::{
    name: func.name,
    source: func.source,
    source_root: func.source_root,
    source_path: func.source_path,
    line_number: func.line_number,
    column_number: func.column_number,
    local_name_binding: func.local_name_binding,
    params: func.params,
    param_inits: func.param_inits,
    body: func.body,
    env,
    id: alloc_id(),
    props,
    proto,
    home_object: func.home_object,
    super_constructor: func.super_constructor,
    instance_fields: func.instance_fields,
    private_instance_fields: func.private_instance_fields,
    private_instance_props: func.private_instance_props,
    is_constructor: func.is_constructor,
    is_class_constructor: func.is_class_constructor,
    is_default_constructor: func.is_default_constructor,
    extensible: func.extensible,
    is_strict: func.is_strict,
    is_generator: func.is_generator,
    is_async: func.is_async,
    is_arrow: func.is_arrow,
    in_class_field_init: func.in_class_field_init,
  })
}

///|
fn clone_realm_value(value : Value, env : Env) -> Value {
  match value {
    Builtin(builtin) => Builtin(clone_builtin_value_for_env(builtin, env))
    _ => value
  }
}

///|
fn clone_builtin_value_for_env(
  builtin : BuiltinValue,
  env : Env,
) -> BuiltinValue {
  let props : Map[String, Property] = Map::new()
  let proto = match builtin.kind {
    BuiltinFunction::GeneratorFunctionConstructor
    | BuiltinFunction::AsyncGeneratorFunctionConstructor
    | BuiltinFunction::AsyncFunctionConstructor =>
      match function_ctor_for_env(env) {
        Some(value) => Some(value)
        None => builtin.proto
      }
    BuiltinFunction::Uint8ArrayConstructor
    | BuiltinFunction::Int8ArrayConstructor
    | BuiltinFunction::Uint8ClampedArrayConstructor
    | BuiltinFunction::Uint16ArrayConstructor
    | BuiltinFunction::Int16ArrayConstructor
    | BuiltinFunction::Uint32ArrayConstructor
    | BuiltinFunction::Int32ArrayConstructor
    | BuiltinFunction::BigInt64ArrayConstructor
    | BuiltinFunction::BigUint64ArrayConstructor
    | BuiltinFunction::Float16ArrayConstructor
    | BuiltinFunction::Float32ArrayConstructor
    | BuiltinFunction::Float64ArrayConstructor =>
      match typed_array_ctor_for_env(env) {
        Some(value) => Some(value)
        None =>
          match function_proto_for_env(env) {
            Some(value) => Some(value)
            None => builtin.proto
          }
      }
    _ =>
      match function_proto_for_env(env) {
        Some(value) => Some(value)
        None => builtin.proto
      }
  }
  let clone = register_builtin_value(BuiltinValue::{
    kind: builtin.kind,
    id: alloc_id(),
    props,
    this_value: builtin.this_value,
    proto,
    extensible: builtin.extensible,
    is_html_dda: builtin.is_html_dda,
    realm_env: Some(env),
  })
  let clone_value = Builtin(clone)
  for name, prop in builtin.props {
    if name == "prototype" {
      match prop.value {
        Object(obj) => {
          let proto_obj = clone_object_value_for_env(
            obj,
            env,
            Some(clone_value),
          )
          let proto_value = Object(proto_obj)
          clone.props.set(name, Property::{
            value: proto_value,
            writable: prop.writable,
            configurable: prop.configurable,
            enumerable: prop.enumerable,
            getter: match prop.getter {
              Some(getter_value) => Some(clone_realm_value(getter_value, env))
              None => None
            },
            setter: match prop.setter {
              Some(setter_value) => Some(clone_realm_value(setter_value, env))
              None => None
            },
          })
          continue
        }
        Function(func) => {
          let proto_override = match object_proto_for_env(env) {
            Some(obj) => Some(Object(obj))
            None => None
          }
          let proto_func = clone_function_value_for_env(
            func,
            env,
            Some(clone_value),
            proto_override,
          )
          let proto_value = Function(proto_func)
          clone.props.set(name, Property::{
            value: proto_value,
            writable: prop.writable,
            configurable: prop.configurable,
            enumerable: prop.enumerable,
            getter: match prop.getter {
              Some(getter_value) => Some(clone_realm_value(getter_value, env))
              None => None
            },
            setter: match prop.setter {
              Some(setter_value) => Some(clone_realm_value(setter_value, env))
              None => None
            },
          })
          continue
        }
        _ => ()
      }
    }
    clone.props.set(name, Property::{
      value: clone_realm_value(prop.value, env),
      writable: prop.writable,
      configurable: prop.configurable,
      enumerable: prop.enumerable,
      getter: match prop.getter {
        Some(getter_value) => Some(clone_realm_value(getter_value, env))
        None => None
      },
      setter: match prop.setter {
        Some(setter_value) => Some(clone_realm_value(setter_value, env))
        None => None
      },
    })
  }
  clone
}

///|
fn builtin_proto_for_env(
  kind : BuiltinFunction,
  env : Env,
  fallback : Value?,
) -> Value? {
  match kind {
    BuiltinFunction::GeneratorFunctionConstructor
    | BuiltinFunction::AsyncGeneratorFunctionConstructor
    | BuiltinFunction::AsyncFunctionConstructor =>
      match function_ctor_for_env(env) {
        Some(value) => Some(value)
        None => fallback
      }
    BuiltinFunction::Uint8ArrayConstructor
    | BuiltinFunction::Int8ArrayConstructor
    | BuiltinFunction::Uint8ClampedArrayConstructor
    | BuiltinFunction::Uint16ArrayConstructor
    | BuiltinFunction::Int16ArrayConstructor
    | BuiltinFunction::Uint32ArrayConstructor
    | BuiltinFunction::Int32ArrayConstructor
    | BuiltinFunction::BigInt64ArrayConstructor
    | BuiltinFunction::BigUint64ArrayConstructor
    | BuiltinFunction::Float16ArrayConstructor
    | BuiltinFunction::Float32ArrayConstructor
    | BuiltinFunction::Float64ArrayConstructor =>
      match typed_array_ctor_for_env(env) {
        Some(value) => Some(value)
        None =>
          match function_proto_for_env(env) {
            Some(value) => Some(value)
            None => fallback
          }
      }
    _ =>
      match function_proto_for_env(env) {
        Some(value) => Some(value)
        None => fallback
      }
  }
}

///|
fn fixup_realm_value(
  value : Value,
  env : Env,
  seen_objects : Map[Int, Bool],
  seen_builtins : Map[Int, Bool],
) -> Unit {
  match value {
    Builtin(builtin) => {
      if seen_builtins.contains(builtin.id) {
        return
      }
      seen_builtins.set(builtin.id, true)
      match builtin.realm_env {
        Some(realm_env) => if realm_env.id != env.id { return }
        None => ()
      }
      builtin.proto = builtin_proto_for_env(builtin.kind, env, builtin.proto)
      match builtin.this_value {
        Some(inner) =>
          fixup_realm_value(inner, env, seen_objects, seen_builtins)
        None => ()
      }
      for _, prop in builtin.props {
        fixup_realm_value(prop.value, env, seen_objects, seen_builtins)
        match prop.getter {
          Some(getter_value) =>
            fixup_realm_value(getter_value, env, seen_objects, seen_builtins)
          None => ()
        }
        match prop.setter {
          Some(setter_value) =>
            fixup_realm_value(setter_value, env, seen_objects, seen_builtins)
          None => ()
        }
      }
    }
    Function(func) => {
      if seen_objects.contains(func.id) {
        return
      }
      seen_objects.set(func.id, true)
      match func.proto {
        Some(proto_value) =>
          fixup_realm_value(proto_value, env, seen_objects, seen_builtins)
        None => ()
      }
      for _, prop in func.props {
        fixup_realm_value(prop.value, env, seen_objects, seen_builtins)
        match prop.getter {
          Some(getter_value) =>
            fixup_realm_value(getter_value, env, seen_objects, seen_builtins)
          None => ()
        }
        match prop.setter {
          Some(setter_value) =>
            fixup_realm_value(setter_value, env, seen_objects, seen_builtins)
          None => ()
        }
      }
    }
    BoundFunction(bound) => {
      if seen_objects.contains(bound.id) {
        return
      }
      seen_objects.set(bound.id, true)
      match bound.proto {
        Some(proto_value) =>
          fixup_realm_value(proto_value, env, seen_objects, seen_builtins)
        None => ()
      }
      fixup_realm_value(bound.target, env, seen_objects, seen_builtins)
      for value in bound.bound_args {
        fixup_realm_value(value, env, seen_objects, seen_builtins)
      }
      for _, prop in bound.props {
        fixup_realm_value(prop.value, env, seen_objects, seen_builtins)
        match prop.getter {
          Some(getter_value) =>
            fixup_realm_value(getter_value, env, seen_objects, seen_builtins)
          None => ()
        }
        match prop.setter {
          Some(setter_value) =>
            fixup_realm_value(setter_value, env, seen_objects, seen_builtins)
          None => ()
        }
      }
    }
    Object(obj) => {
      if seen_objects.contains(obj.id) {
        return
      }
      seen_objects.set(obj.id, true)
      match obj.proto {
        Some(proto_value) =>
          fixup_realm_value(proto_value, env, seen_objects, seen_builtins)
        None => ()
      }
      for _, prop in obj.props {
        fixup_realm_value(prop.value, env, seen_objects, seen_builtins)
        match prop.getter {
          Some(getter_value) =>
            fixup_realm_value(getter_value, env, seen_objects, seen_builtins)
          None => ()
        }
        match prop.setter {
          Some(setter_value) =>
            fixup_realm_value(setter_value, env, seen_objects, seen_builtins)
          None => ()
        }
      }
    }
    Array(arr) => {
      if seen_objects.contains(arr.id) {
        return
      }
      seen_objects.set(arr.id, true)
      match arr.proto {
        Some(proto_value) =>
          fixup_realm_value(proto_value, env, seen_objects, seen_builtins)
        None => ()
      }
      for entry in arr.elements {
        match entry {
          Some(inner) =>
            fixup_realm_value(inner, env, seen_objects, seen_builtins)
          None => ()
        }
      }
      for _, prop in arr.props {
        fixup_realm_value(prop.value, env, seen_objects, seen_builtins)
        match prop.getter {
          Some(getter_value) =>
            fixup_realm_value(getter_value, env, seen_objects, seen_builtins)
          None => ()
        }
        match prop.setter {
          Some(setter_value) =>
            fixup_realm_value(setter_value, env, seen_objects, seen_builtins)
          None => ()
        }
      }
    }
    Arguments(args) => {
      if seen_objects.contains(args.id) {
        return
      }
      seen_objects.set(args.id, true)
      match args.proto {
        Some(proto_value) =>
          fixup_realm_value(proto_value, env, seen_objects, seen_builtins)
        None => ()
      }
      for entry in args.elements {
        match entry {
          Some(inner) =>
            fixup_realm_value(inner, env, seen_objects, seen_builtins)
          None => ()
        }
      }
      for _, prop in args.props {
        fixup_realm_value(prop.value, env, seen_objects, seen_builtins)
        match prop.getter {
          Some(getter_value) =>
            fixup_realm_value(getter_value, env, seen_objects, seen_builtins)
          None => ()
        }
        match prop.setter {
          Some(setter_value) =>
            fixup_realm_value(setter_value, env, seen_objects, seen_builtins)
          None => ()
        }
      }
    }
    _ => ()
  }
}

///|
fn fixup_realm_builtins(env : Env) -> Unit {
  let seen_objects : Map[Int, Bool] = Map::new()
  let seen_builtins : Map[Int, Bool] = Map::new()
  match global_object_value(env) {
    Undefined => ()
    value => fixup_realm_value(value, env, seen_objects, seen_builtins)
  }
}

///|
fn new_realm_env(base_env : Env) -> Env {
  let env = Env::new(None)
  let global_obj = match global_object(base_env) {
    Some(obj) => clone_global_object(obj, env)
    None => {
      let obj = new_object_struct(value_from_object(object_proto()))
      obj.realm_env = Some(env)
      obj
    }
  }
  let global_value = Object(global_obj)
  env.bindings.set("this", global_value)
  global_obj.props.set("globalThis", property_data(global_value))
  match function_proto_for_env(env) {
    Some(Function(func)) =>
      match object_proto_for_env(env) {
        Some(obj) => func.proto = Some(Object(obj))
        None => ()
      }
    _ => ()
  }
  fixup_realm_builtins(env)
  register_promise_ctor_from_global(env)
  env
}

///|
fn realm_env_from_value(value : Value?) -> Env {
  match value {
    Some(Object(obj)) =>
      match obj.realm_env {
        Some(env) => env
        None =>
          match root_env() {
            Some(env) => env
            None => Env::new(None)
          }
      }
    _ =>
      match root_env() {
        Some(env) => env
        None => Env::new(None)
      }
  }
}

///|
fn new_test262_agent_object() -> Value {
  let obj_value = new_object_value_with_proto(value_from_object(object_proto()))
  match obj_value {
    Object(obj) => {
      obj.props.set(
        "start",
        property_data(new_builtin_value(BuiltinFunction::Test262AgentStart)),
      )
      obj.props.set(
        "getReport",
        property_data(new_builtin_value(BuiltinFunction::Test262AgentGetReport)),
      )
      obj.props.set(
        "broadcast",
        property_data(new_builtin_value(BuiltinFunction::Test262AgentBroadcast)),
      )
      obj.props.set(
        "report",
        property_data(new_builtin_value(BuiltinFunction::Test262AgentReport)),
      )
      obj.props.set(
        "leaving",
        property_data(new_builtin_value(BuiltinFunction::Test262AgentLeaving)),
      )
      obj.props.set(
        "receiveBroadcast",
        property_data(
          new_builtin_value(BuiltinFunction::Test262AgentReceiveBroadcast),
        ),
      )
      obj.props.set(
        "sleep",
        property_data(new_builtin_value(BuiltinFunction::Test262AgentSleep)),
      )
      obj.props.set(
        "monotonicNow",
        property_data(
          new_builtin_value(BuiltinFunction::Test262AgentMonotonicNow),
        ),
      )
    }
    _ => ()
  }
  obj_value
}

///|
fn new_test262_object(env : Env) -> Value {
  let obj_value = new_object_value_with_proto(value_from_object(object_proto()))
  match obj_value {
    Object(obj) => {
      obj.realm_env = Some(env)
      obj.props.set(
        "detachArrayBuffer",
        property_data(
          new_builtin_value(BuiltinFunction::Test262DetachArrayBuffer),
        ),
      )
      obj.props.set(
        "evalScript",
        property_data(new_builtin_value(BuiltinFunction::Test262EvalScript)),
      )
      obj.props.set(
        "codePointRange",
        property_data(new_builtin_value(BuiltinFunction::Test262CodePointRange)),
      )
      obj.props.set("global", property_data(global_object_value(env)))
      obj.props.set(
        "createRealm",
        property_data(new_builtin_value(BuiltinFunction::Test262CreateRealm)),
      )
      obj.props.set(
        "IsHTMLDDA",
        property_data(new_html_dda_builtin(BuiltinFunction::Test262IsHTMLDDA)),
      )
      obj.props.set(
        "gc",
        property_data(new_builtin_value(BuiltinFunction::Test262Gc)),
      )
      obj.props.set("agent", property_data(new_test262_agent_object()))
    }
    _ => ()
  }
  obj_value
}

///|
fn install_test262_helpers(env : Env) -> Value {
  let global_value = global_object_value(env)
  let obj262 = new_test262_object(env)
  match global_value {
    Object(obj) => {
      obj.props.set(
        "print",
        property_data(new_builtin_value(BuiltinFunction::Print)),
      )
      obj.props.set("$262", property_data(obj262))
    }
    _ => ()
  }
  obj262
}

///|
fn eval_unary(op : @engine.UnaryOp, value : Value) -> Value raise {
  match op {
    Plus =>
      match value {
        BigInt(_) => throw_type_error("cannot convert BigInt to number")
        _ => Number(to_number(value))
      }
    Minus =>
      match to_numeric(value) {
        BigInt(v) => BigInt(v.neg())
        Number(num) =>
          if num == 0.0 {
            if is_negative_zero(num) {
              Number(0.0)
            } else {
              Number(negative_zero())
            }
          } else {
            Number(0.0 - num)
          }
        _ => fail("unreachable")
      }
    BitNot =>
      match to_numeric(value) {
        BigInt(v) => BigInt(v.neg().sub(@bigint.BigInt::from_int(1)))
        Number(num) => {
          let v = to_int32(num)
          Number(Double::from_int(Int::lnot(v)))
        }
        _ => fail("unreachable")
      }
    Not => Bool(!is_truthy(value))
    Typeof => String(typeof_value(value))
    Void => Undefined
    Delete => Bool(true)
  }
}

///|
fn eval_update(
  env : Env,
  op : @engine.UpdateOp,
  expr : @engine.Expr,
  kind : @engine.UpdateKind,
) -> Value raise {
  match unwrap_paren(expr) {
    Ident(name, _) => {
      let target = resolve_binding_target(env, name)
      let current = get_binding_value_from_target(env, name, target, env.strict)
      let (old_value, new_value) = update_values(op, current)
      assign_binding_value_to_target(env, name, target, new_value, env.strict)
      update_result(kind, old_value, new_value)
    }
    Member(obj_expr, key, _) =>
      match obj_expr {
        @engine.Expr::Super =>
          match key {
            @engine.MemberKey::Private(_) =>
              throw_syntax_error("private class field forbidden after super")
            @engine.MemberKey::Computed(expr) => {
              let (base, receiver) = super_base_and_receiver(env)
              let key_value = eval_expr(env, expr)
              let name = property_key_name(key_value)
              let base_obj = to_object(base)
              let current = property_get_with_receiver(base_obj, name, receiver)
              let (old_value, new_value) = update_values(op, current)
              super_set_property(env, base, receiver, name, new_value)
              update_result(kind, old_value, new_value)
            }
            _ => {
              let (base, receiver) = super_base_and_receiver(env)
              let name = member_key_name(env, key)
              let base_obj = to_object(base)
              let current = property_get_with_receiver(base_obj, name, receiver)
              let (old_value, new_value) = update_values(op, current)
              super_set_property(env, base, receiver, name, new_value)
              update_result(kind, old_value, new_value)
            }
          }
        _ =>
          match key {
            @engine.MemberKey::Private(name) => {
              let target = eval_expr(env, obj_expr)
              let key_name = env_private_key_checked(env, name)
              let current = private_property_get(target, key_name, name)
              let (old_value, new_value) = update_values(op, current)
              private_property_set(target, key_name, name, new_value)
              update_result(kind, old_value, new_value)
            }
            @engine.MemberKey::Computed(expr) => {
              let target_value = eval_expr(env, obj_expr)
              let key_value = eval_expr(env, expr)
              let target_obj = to_object(target_value)
              let name = property_key_name(key_value)
              let current = property_get_with_receiver(
                target_obj, name, target_value,
              )
              let (old_value, new_value) = update_values(op, current)
              let _ = set_property_for_value(
                target_value,
                name,
                new_value,
                env.strict,
              )
              update_result(kind, old_value, new_value)
            }
            _ => {
              let target_value = eval_expr(env, obj_expr)
              let name = member_key_name(env, key)
              let target_obj = to_object(target_value)
              let current = property_get_with_receiver(
                target_obj, name, target_value,
              )
              let (old_value, new_value) = update_values(op, current)
              let _ = set_property_for_value(
                target_value,
                name,
                new_value,
                env.strict,
              )
              update_result(kind, old_value, new_value)
            }
          }
      }
    Call(_, _, _) =>
      if !env.strict {
        let _ = eval_expr(env, expr)
        throw_reference_error("invalid update target")
      } else {
        fail("invalid update target")
      }
    _ => fail("invalid update target")
  }
}

///|
fn eval_new(
  env : Env,
  callee : @engine.Expr,
  args : Array[@engine.Expr],
) -> Value raise {
  let ctor = eval_expr(env, callee)
  let argv = eval_args(env, args)
  call_constructor(ctor, argv)
}

///|
fn constructor_proto_from_target(
  target : Value,
  fallback : Value?,
) -> Value? raise {
  let proto_value = property_get(target, "prototype")
  if is_object_like(proto_value) {
    Some(proto_value)
  } else {
    let _ = function_realm_env_checked(target)
    fallback
  }
}

///|
fn call_constructor(
  callee : Value,
  args : Array[Value],
  new_target? : Value = Undefined,
) -> Value raise {
  let target_value = if new_target is Undefined { callee } else { new_target }
  match callee {
    Function(func) => {
      if !func.is_constructor {
        let _ = throw_not_constructor(Value::Function(func))

      }
      if func.is_default_constructor {
        match func.super_constructor {
          Some(_) => {
            let super_ctor = match get_proto_of_value(Value::Function(func)) {
              Some(value) => value
              None => Null
            }
            if !is_constructor_value(super_ctor) {
              return throw_not_constructor(super_ctor)
            }
            let result = call_constructor(
              super_ctor,
              args,
              new_target=target_value,
            )
            if is_object_like(result) &&
              (
                !func.private_instance_props.is_empty() ||
                !func.instance_fields.is_empty()
              ) {
              let frame = Env::new(Some(func.env))
              frame.var_env = Some(frame)
              frame.strict = func.is_strict
              frame.new_target = target_value
              env_set_local(frame, "this", result)
              let _ = with_current_function(func, fn() raise {
                init_instance_fields(func, frame, result)
                result
              })

            }
            return result
          }
          None => ()
        }
      }
      if func.is_class_constructor && func.super_constructor is Some(_) {
        return call_user_function_with_this(func, args, Undefined, target_value)
      }
      let realm_env = function_realm_env_checked(target_value)
      let default_proto = match
        value_from_object(object_proto_for_env(realm_env)) {
        Some(value) => Some(value)
        None => value_from_object(object_proto())
      }
      let proto = constructor_proto_from_target(target_value, default_proto)
      let instance = new_object_value_with_proto(proto)
      let result = call_user_function_with_this(
        func, args, instance, target_value,
      )
      if func.is_class_constructor {
        result
      } else if is_object_like(result) {
        result
      } else {
        instance
      }
    }
    BoundFunction(bound) => {
      if !bound.is_constructor {
        let _ = throw_not_constructor(Value::BoundFunction(bound))
        return Undefined
      }
      let final_args : Array[Value] = []
      for value in bound.bound_args {
        final_args.push(value)
      }
      for value in args {
        final_args.push(value)
      }
      let bound_self = Value::BoundFunction(bound)
      let bound_target = if new_target is Undefined {
        bound_self
      } else {
        new_target
      }
      let final_new_target = if same_value(bound_target, bound_self) {
        bound.target
      } else {
        bound_target
      }
      call_constructor(bound.target, final_args, new_target=final_new_target)
    }
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => proxy_construct_value(data, args, target_value)
        None => {
          let _ = throw_not_constructor(Value::Object(obj))
          Undefined
        }
      }
    Builtin(builtin) =>
      if !is_constructor_builtin(builtin.kind) {
        let _ = throw_not_constructor(Value::Builtin(builtin))
        Undefined
      } else {
        match builtin.kind {
          BuiltinFunction::ObjectConstructor =>
            if !(new_target is Undefined) &&
              !same_value(Value::Builtin(builtin), new_target) {
              let realm_env = function_realm_env_checked(new_target)
              let default_proto = match
                value_from_object(object_proto_for_env(realm_env)) {
                Some(value) => Some(value)
                None => value_from_object(object_proto())
              }
              let proto = constructor_proto_from_target(
                new_target, default_proto,
              )
              new_object_value_with_proto(proto)
            } else if args.is_empty() {
              new_object_value()
            } else {
              match args[0] {
                Undefined => new_object_value()
                Null => new_object_value()
                _ => to_object(args[0])
              }
            }
          BuiltinFunction::ProxyConstructor =>
            if args.length() < 2 {
              throw_type_error("invalid Proxy arguments")
            } else {
              new_proxy_value(args[0], args[1])
            }
          BuiltinFunction::ArrayConstructor => {
            let realm_env = function_realm_env_checked(target_value)
            let default_proto = match
              value_from_object(array_proto_for_env(realm_env)) {
              Some(value) => Some(value)
              None => value_from_object(array_proto())
            }
            let proto = constructor_proto_from_target(
              target_value, default_proto,
            )
            array_from_args_with_proto(args, proto)
          }
          BuiltinFunction::IteratorConstructor => {
            if same_value(Value::Builtin(builtin), target_value) {
              return throw_type_error("abstract class not constructable")
            }
            let realm_env = function_realm_env_checked(target_value)
            let default_proto = match
              value_from_object(iterator_proto_for_env(realm_env)) {
              Some(value) => Some(value)
              None => value_from_object(iterator_proto())
            }
            let proto = constructor_proto_from_target(
              target_value, default_proto,
            )
            new_object_value_with_proto(proto)
          }
          BuiltinFunction::FunctionConstructor => {
            let ctor_env = match function_realm_env(Value::Builtin(builtin)) {
              Some(env) => env
              None =>
                match root_env() {
                  Some(env) => env
                  None => Env::new(None)
                }
            }
            let func_value = function_from_args_with_env(args, ctor_env)
            if !(new_target is Undefined) {
              let fallback_env = function_realm_env_checked(new_target)
              let fallback_proto = match function_proto_for_env(fallback_env) {
                Some(value) => Some(value)
                None => function_proto()
              }
              let proto = constructor_proto_from_target(
                new_target, fallback_proto,
              )
              match func_value {
                Function(func) => func.proto = proto
                _ => ()
              }
            }
            func_value
          }
          BuiltinFunction::GeneratorFunctionConstructor => {
            let ctor_env = match function_realm_env(Value::Builtin(builtin)) {
              Some(env) => env
              None =>
                match root_env() {
                  Some(env) => env
                  None => Env::new(None)
                }
            }
            let func_value = function_from_args_with_env_kind(
              args, ctor_env, true, false,
            )
            if !(new_target is Undefined) {
              let fallback_proto = match
                value_from_object(
                  generator_function_proto_for_env(
                    function_realm_env_checked(new_target),
                  ),
                ) {
                Some(value) => Some(value)
                None => value_from_object(generator_function_proto())
              }
              let proto = constructor_proto_from_target(
                new_target, fallback_proto,
              )
              match func_value {
                Function(func) => func.proto = proto
                _ => ()
              }
            }
            func_value
          }
          BuiltinFunction::AsyncGeneratorFunctionConstructor => {
            let ctor_env = match function_realm_env(Value::Builtin(builtin)) {
              Some(env) => env
              None =>
                match root_env() {
                  Some(env) => env
                  None => Env::new(None)
                }
            }
            let func_value = function_from_args_with_env_kind(
              args, ctor_env, true, true,
            )
            if !(new_target is Undefined) {
              let fallback_proto = match
                value_from_object(
                  async_generator_function_proto_for_env(
                    function_realm_env_checked(new_target),
                  ),
                ) {
                Some(value) => Some(value)
                None => value_from_object(async_generator_function_proto())
              }
              let proto = constructor_proto_from_target(
                new_target, fallback_proto,
              )
              match func_value {
                Function(func) => func.proto = proto
                _ => ()
              }
            }
            func_value
          }
          BuiltinFunction::AsyncFunctionConstructor => {
            let ctor_env = match function_realm_env(Value::Builtin(builtin)) {
              Some(env) => env
              None =>
                match root_env() {
                  Some(env) => env
                  None => Env::new(None)
                }
            }
            let func_value = function_from_args_with_env_kind(
              args, ctor_env, false, true,
            )
            if !(new_target is Undefined) {
              let fallback_proto = match
                value_from_object(
                  async_function_proto_for_env(
                    function_realm_env_checked(new_target),
                  ),
                ) {
                Some(value) => Some(value)
                None => value_from_object(async_function_proto())
              }
              let proto = constructor_proto_from_target(
                new_target, fallback_proto,
              )
              match func_value {
                Function(func) => func.proto = proto
                _ => ()
              }
            }
            func_value
          }
          BuiltinFunction::StringConstructor => {
            let proto_value = property_get(target_value, "prototype")
            let default_proto = {
              let realm_env = function_realm_env_checked(target_value)
              match value_from_object(string_proto_for_env(realm_env)) {
                Some(value) => Some(value)
                None => value_from_object(string_proto())
              }
            }
            let proto = if is_object_like(proto_value) {
              Some(proto_value)
            } else {
              default_proto
            }
            if args.is_empty() {
              new_string_object("", proto~)
            } else if is_symbol_like(args[0]) {
              throw_type_error("cannot convert symbol to string")
            } else {
              new_string_object(to_string_strict(args[0]), proto~)
            }
          }
          BuiltinFunction::NumberConstructor => {
            let proto_value = property_get(target_value, "prototype")
            let default_proto = {
              let realm_env = function_realm_env_checked(target_value)
              match value_from_object(number_proto_for_env(realm_env)) {
                Some(value) => Some(value)
                None => value_from_object(number_proto())
              }
            }
            let proto = if is_object_like(proto_value) {
              Some(proto_value)
            } else {
              default_proto
            }
            if args.is_empty() {
              new_number_object(0.0, proto~)
            } else {
              let prim = if is_object_like(args[0]) {
                to_primitive(args[0], false)
              } else {
                args[0]
              }
              match prim {
                Symbol(_) => throw_type_error("cannot convert symbol to number")
                BigInt(b) => new_number_object(bigint_to_number(b), proto~)
                _ => new_number_object(to_number(prim), proto~)
              }
            }
          }
          BuiltinFunction::BooleanConstructor => {
            let proto_value = property_get(target_value, "prototype")
            let default_proto = {
              let realm_env = function_realm_env_checked(target_value)
              match value_from_object(bool_proto_for_env(realm_env)) {
                Some(value) => Some(value)
                None => value_from_object(bool_proto())
              }
            }
            let proto = if is_object_like(proto_value) {
              Some(proto_value)
            } else {
              default_proto
            }
            if args.is_empty() {
              new_bool_object(false, proto~)
            } else {
              new_bool_object(is_truthy(args[0]), proto~)
            }
          }
          BuiltinFunction::BigIntConstructor =>
            throw_type_error("BigInt is not a constructor")
          BuiltinFunction::SymbolConstructor =>
            throw_type_error("Symbol is not a constructor")
          BuiltinFunction::RegExpConstructor =>
            regexp_from_args(args, true, new_target=target_value)
          BuiltinFunction::DateConstructor => {
            let proto_value = property_get(target_value, "prototype")
            let default_proto = {
              let realm_env = function_realm_env_checked(target_value)
              match value_from_object(date_proto_for_env(realm_env)) {
                Some(value) => Some(value)
                None => value_from_object(date_proto())
              }
            }
            let proto = if is_object_like(proto_value) {
              Some(proto_value)
            } else {
              default_proto
            }
            new_date_value(date_from_args(args), proto~)
          }
          BuiltinFunction::ArrayBufferConstructor => {
            let len64 = if args.is_empty() {
              0L
            } else {
              to_index_int64(args[0])
            }
            let mut max_len64 = len64
            let mut resizable = false
            if args.length() > 1 {
              match args[1] {
                Undefined => ()
                Null => ()
                _ => {
                  let opts = to_object(args[1])
                  let max_value = property_get(opts, "maxByteLength")
                  if max_value is Undefined {
                    ()
                  } else {
                    let next_max_len64 = to_index_int64(max_value)
                    if len64 > next_max_len64 {
                      return throw_range_error(
                        "invalid array buffer max length",
                      )
                    }
                    max_len64 = next_max_len64
                    resizable = true
                  }
                }
              }
            }
            let default_proto = {
              let realm_env = function_realm_env_checked(target_value)
              match value_from_object(array_buffer_proto_for_env(realm_env)) {
                Some(value) => Some(value)
                None => value_from_object(array_buffer_proto())
              }
            }
            let proto = constructor_proto_from_target(
              target_value, default_proto,
            )
            let max_int = 2147483647
            if len64 > Int64::from_int(max_int) {
              return throw_range_error("invalid array buffer length")
            }
            if max_len64 > Int64::from_int(max_int) {
              return throw_range_error("invalid max array buffer length")
            }
            let len = Int64::to_int(len64)
            let max_len = Int64::to_int(max_len64)
            new_array_buffer_value_with_options(len, max_len, resizable, proto~)
          }
          BuiltinFunction::SharedArrayBufferConstructor => {
            let len64 = if args.is_empty() {
              0L
            } else {
              to_index_int64(args[0])
            }
            let mut max_len64 = len64
            let mut resizable = false
            if args.length() > 1 {
              match args[1] {
                Undefined => ()
                Null => ()
                _ => {
                  let opts = to_object(args[1])
                  let max_value = property_get(opts, "maxByteLength")
                  if max_value is Undefined {
                    ()
                  } else {
                    let next_max_len64 = to_index_int64(max_value)
                    if len64 > next_max_len64 {
                      return throw_range_error(
                        "invalid array buffer max length",
                      )
                    }
                    max_len64 = next_max_len64
                    resizable = true
                  }
                }
              }
            }
            let default_proto = {
              let realm_env = function_realm_env_checked(target_value)
              match
                value_from_object(shared_array_buffer_proto_for_env(realm_env)) {
                Some(value) => Some(value)
                None => value_from_object(shared_array_buffer_proto())
              }
            }
            let proto = constructor_proto_from_target(
              target_value, default_proto,
            )
            let max_int = 2147483647
            if len64 > Int64::from_int(max_int) {
              return throw_range_error("invalid array buffer length")
            }
            if max_len64 > Int64::from_int(max_int) {
              return throw_range_error("invalid max array buffer length")
            }
            let len = Int64::to_int(len64)
            let max_len = Int64::to_int(max_len64)
            new_shared_array_buffer_value_with_options(
              len, max_len, resizable, proto,
            )
          }
          BuiltinFunction::DataViewConstructor =>
            new_dataview_from_args(args, target_value)
          BuiltinFunction::TypedArrayConstructor =>
            throw_type_error("cannot be called")
          BuiltinFunction::Uint8ArrayConstructor =>
            new_typed_array_from_args(TypedArrayKind::Uint8, args, target_value)
          BuiltinFunction::Int8ArrayConstructor =>
            new_typed_array_from_args(TypedArrayKind::Int8, args, target_value)
          BuiltinFunction::Uint8ClampedArrayConstructor =>
            new_typed_array_from_args(
              TypedArrayKind::Uint8Clamped,
              args,
              target_value,
            )
          BuiltinFunction::Uint16ArrayConstructor =>
            new_typed_array_from_args(
              TypedArrayKind::Uint16,
              args,
              target_value,
            )
          BuiltinFunction::Int16ArrayConstructor =>
            new_typed_array_from_args(TypedArrayKind::Int16, args, target_value)
          BuiltinFunction::Uint32ArrayConstructor =>
            new_typed_array_from_args(
              TypedArrayKind::Uint32,
              args,
              target_value,
            )
          BuiltinFunction::Int32ArrayConstructor =>
            new_typed_array_from_args(TypedArrayKind::Int32, args, target_value)
          BuiltinFunction::BigInt64ArrayConstructor =>
            new_typed_array_from_args(
              TypedArrayKind::BigInt64,
              args,
              target_value,
            )
          BuiltinFunction::BigUint64ArrayConstructor =>
            new_typed_array_from_args(
              TypedArrayKind::BigUint64,
              args,
              target_value,
            )
          BuiltinFunction::Float16ArrayConstructor =>
            new_typed_array_from_args(
              TypedArrayKind::Float16,
              args,
              target_value,
            )
          BuiltinFunction::Float32ArrayConstructor =>
            new_typed_array_from_args(
              TypedArrayKind::Float32,
              args,
              target_value,
            )
          BuiltinFunction::Float64ArrayConstructor =>
            new_typed_array_from_args(
              TypedArrayKind::Float64,
              args,
              target_value,
            )
          BuiltinFunction::MapConstructor => {
            let target_env = function_realm_env_checked(target_value)
            let fallback_proto = match
              value_from_object(map_proto_for_env(target_env)) {
              Some(value) => Some(value)
              None => value_from_object(map_proto())
            }
            let proto = constructor_proto_from_target(
              target_value, fallback_proto,
            )
            let obj = new_map_value_with_proto(proto)
            if !args.is_empty() {
              init_map_or_set_from_iterable(obj, args[0], false)
            }
            obj
          }
          BuiltinFunction::SetConstructor => {
            let target_env = function_realm_env_checked(target_value)
            let fallback_proto = match
              value_from_object(set_proto_for_env(target_env)) {
              Some(value) => Some(value)
              None => value_from_object(set_proto())
            }
            let proto = constructor_proto_from_target(
              target_value, fallback_proto,
            )
            let obj = new_set_value_with_proto(proto)
            if !args.is_empty() {
              init_map_or_set_from_iterable(obj, args[0], true)
            }
            obj
          }
          BuiltinFunction::WeakMapConstructor => {
            let target_env = function_realm_env_checked(target_value)
            let fallback_proto = match
              value_from_object(weakmap_proto_for_env(target_env)) {
              Some(value) => Some(value)
              None => value_from_object(weakmap_proto())
            }
            let proto = constructor_proto_from_target(
              target_value, fallback_proto,
            )
            let obj = new_weakmap_value_with_proto(proto)
            if !args.is_empty() {
              init_map_or_set_from_iterable(obj, args[0], false)
            }
            obj
          }
          BuiltinFunction::WeakSetConstructor => {
            let target_env = function_realm_env_checked(target_value)
            let fallback_proto = match
              value_from_object(weakset_proto_for_env(target_env)) {
              Some(value) => Some(value)
              None => value_from_object(weakset_proto())
            }
            let proto = constructor_proto_from_target(
              target_value, fallback_proto,
            )
            let obj = new_weakset_value_with_proto(proto)
            if !args.is_empty() {
              init_map_or_set_from_iterable(obj, args[0], true)
            }
            obj
          }
          BuiltinFunction::WeakRefConstructor => {
            if args.is_empty() || !is_weakref_target(args[0]) {
              return throw_type_error("invalid target")
            }
            let target_env = function_realm_env_checked(target_value)
            let fallback_proto = match
              value_from_object(weakref_proto_for_env(target_env)) {
              Some(value) => Some(value)
              None => value_from_object(weakref_proto())
            }
            let proto = constructor_proto_from_target(
              target_value, fallback_proto,
            )
            new_weakref_value(args[0], proto)
          }
          BuiltinFunction::FinalizationRegistryConstructor => {
            if args.is_empty() || !is_callable(args[0]) {
              return throw_type_error("argument must be a function")
            }
            let target_env = function_realm_env_checked(target_value)
            let fallback_proto = match
              value_from_object(finreg_proto_for_env(target_env)) {
              Some(value) => Some(value)
              None => value_from_object(finreg_proto())
            }
            let proto = constructor_proto_from_target(
              target_value, fallback_proto,
            )
            new_finreg_value(args[0], target_env, proto)
          }
          BuiltinFunction::PromiseConstructor => {
            if args.is_empty() || !is_callable(args[0]) {
              return throw_type_error("argument must be a function")
            }
            let target_env = function_realm_env_checked(target_value)
            let fallback_proto = match
              value_from_object(promise_proto_for_env(target_env)) {
              Some(value) => Some(value)
              None => value_from_object(promise_proto())
            }
            let proto = constructor_proto_from_target(
              target_value, fallback_proto,
            )
            let obj = new_promise_value_with_proto(proto)
            let (resolve, reject) = create_promise_resolving_functions(obj)
            try {
              let _ = call_value_with_this(
                args[0],
                [resolve, reject],
                Undefined,
              )

            } catch {
              ThrowSignal(value) => {
                let _ = call_value_with_this(reject, [value], Undefined)

              }
              err => raise err
            }
            obj
          }
          BuiltinFunction::WorkerConstructor => create_worker_from_args(args)
          BuiltinFunction::ErrorConstructor => {
            let target_env = function_realm_env_checked(target_value)
            let fallback = match error_proto_for_env_name(target_env, "Error") {
              Some(proto) => Some(proto)
              None => error_proto()
            }
            let proto = error_proto_from_target(target_value, fallback)
            let message_info = error_message_from_args(args)
            let obj = new_error_value(
              proto,
              message_info.message,
              set_message=message_info.has_message,
            )
            if args.length() > 1 {
              match obj {
                Object(value) => install_error_cause(value, args[1])
                _ => ()
              }
            }
            obj
          }
          BuiltinFunction::AggregateErrorConstructor => {
            let target_env = function_realm_env_checked(target_value)
            let fallback = match
              error_proto_for_env_name(target_env, "AggregateError") {
              Some(proto) => Some(proto)
              None => aggregate_error_proto()
            }
            let proto = error_proto_from_target(target_value, fallback)
            let errors_proto = match
              value_from_object(array_proto_for_env(target_env)) {
              Some(value) => Some(value)
              None => value_from_object(array_proto())
            }
            let obj = new_aggregate_error_value_with_proto(
              args, proto, errors_proto,
            )
            if args.length() > 2 {
              match obj {
                Object(value) => install_error_cause(value, args[2])
                _ => ()
              }
            }
            obj
          }
          BuiltinFunction::EvalErrorConstructor => {
            let target_env = function_realm_env_checked(target_value)
            let fallback = match
              error_proto_for_env_name(target_env, "EvalError") {
              Some(proto) => Some(proto)
              None => eval_error_proto()
            }
            let proto = error_proto_from_target(target_value, fallback)
            let message_info = error_message_from_args(args)
            let obj = new_error_value(
              proto,
              message_info.message,
              set_message=message_info.has_message,
            )
            if args.length() > 1 {
              match obj {
                Object(value) => install_error_cause(value, args[1])
                _ => ()
              }
            }
            obj
          }
          BuiltinFunction::SyntaxErrorConstructor => {
            let target_env = function_realm_env_checked(target_value)
            let fallback = match syntax_error_proto_for_env(target_env) {
              Some(proto) => Some(proto)
              None => syntax_error_proto()
            }
            let proto = error_proto_from_target(target_value, fallback)
            let message_info = error_message_from_args(args)
            let obj = new_error_value(
              proto,
              message_info.message,
              set_message=message_info.has_message,
            )
            if args.length() > 1 {
              match obj {
                Object(value) => install_error_cause(value, args[1])
                _ => ()
              }
            }
            obj
          }
          BuiltinFunction::RangeErrorConstructor => {
            let target_env = function_realm_env_checked(target_value)
            let fallback = match range_error_proto_for_env(target_env) {
              Some(proto) => Some(proto)
              None => range_error_proto()
            }
            let proto = error_proto_from_target(target_value, fallback)
            let message_info = error_message_from_args(args)
            let obj = new_error_value(
              proto,
              message_info.message,
              set_message=message_info.has_message,
            )
            if args.length() > 1 {
              match obj {
                Object(value) => install_error_cause(value, args[1])
                _ => ()
              }
            }
            obj
          }
          BuiltinFunction::TypeErrorConstructor => {
            let target_env = function_realm_env_checked(target_value)
            let fallback = match type_error_proto_for_env(target_env) {
              Some(proto) => Some(proto)
              None => type_error_proto()
            }
            let proto = error_proto_from_target(target_value, fallback)
            let message_info = error_message_from_args(args)
            let obj = new_error_value(
              proto,
              message_info.message,
              set_message=message_info.has_message,
            )
            if args.length() > 1 {
              match obj {
                Object(value) => install_error_cause(value, args[1])
                _ => ()
              }
            }
            obj
          }
          BuiltinFunction::ReferenceErrorConstructor => {
            let target_env = function_realm_env_checked(target_value)
            let fallback = match reference_error_proto_for_env(target_env) {
              Some(proto) => Some(proto)
              None => reference_error_proto()
            }
            let proto = error_proto_from_target(target_value, fallback)
            let message_info = error_message_from_args(args)
            let obj = new_error_value(
              proto,
              message_info.message,
              set_message=message_info.has_message,
            )
            if args.length() > 1 {
              match obj {
                Object(value) => install_error_cause(value, args[1])
                _ => ()
              }
            }
            obj
          }
          BuiltinFunction::UriErrorConstructor => {
            let target_env = function_realm_env_checked(target_value)
            let fallback = match uri_error_proto_for_env(target_env) {
              Some(proto) => Some(proto)
              None => uri_error_proto()
            }
            let proto = error_proto_from_target(target_value, fallback)
            let message_info = error_message_from_args(args)
            let obj = new_error_value(
              proto,
              message_info.message,
              set_message=message_info.has_message,
            )
            if args.length() > 1 {
              match obj {
                Object(value) => install_error_cause(value, args[1])
                _ => ()
              }
            }
            obj
          }
          _ => {
            let instance = new_object_value()
            let result = call_builtin_with_this(builtin, args, instance)
            if is_object_like(result) {
              result
            } else {
              instance
            }
          }
        }
      }
    _ => {
      let _ = throw_not_constructor(callee)
      Undefined
    }
  }
}

///|
fn is_constructor_builtin(kind : BuiltinFunction) -> Bool {
  match kind {
    BuiltinFunction::ObjectConstructor => true
    BuiltinFunction::ProxyConstructor => true
    BuiltinFunction::ArrayConstructor => true
    BuiltinFunction::FunctionConstructor => true
    BuiltinFunction::GeneratorFunctionConstructor => true
    BuiltinFunction::AsyncFunctionConstructor => true
    BuiltinFunction::AsyncGeneratorFunctionConstructor => true
    BuiltinFunction::StringConstructor => true
    BuiltinFunction::NumberConstructor => true
    BuiltinFunction::BooleanConstructor => true
    BuiltinFunction::BigIntConstructor => true
    BuiltinFunction::SymbolConstructor => true
    BuiltinFunction::IteratorConstructor => true
    BuiltinFunction::RegExpConstructor => true
    BuiltinFunction::DateConstructor => true
    BuiltinFunction::ArrayBufferConstructor => true
    BuiltinFunction::SharedArrayBufferConstructor => true
    BuiltinFunction::DataViewConstructor => true
    BuiltinFunction::TypedArrayConstructor => true
    BuiltinFunction::Uint8ArrayConstructor => true
    BuiltinFunction::Int8ArrayConstructor => true
    BuiltinFunction::Uint8ClampedArrayConstructor => true
    BuiltinFunction::Uint16ArrayConstructor => true
    BuiltinFunction::Int16ArrayConstructor => true
    BuiltinFunction::Uint32ArrayConstructor => true
    BuiltinFunction::Int32ArrayConstructor => true
    BuiltinFunction::BigInt64ArrayConstructor => true
    BuiltinFunction::BigUint64ArrayConstructor => true
    BuiltinFunction::Float16ArrayConstructor => true
    BuiltinFunction::Float32ArrayConstructor => true
    BuiltinFunction::Float64ArrayConstructor => true
    BuiltinFunction::MapConstructor => true
    BuiltinFunction::SetConstructor => true
    BuiltinFunction::WeakMapConstructor => true
    BuiltinFunction::WeakSetConstructor => true
    BuiltinFunction::WeakRefConstructor => true
    BuiltinFunction::FinalizationRegistryConstructor => true
    BuiltinFunction::PromiseConstructor => true
    BuiltinFunction::WorkerConstructor => true
    BuiltinFunction::ErrorConstructor => true
    BuiltinFunction::AggregateErrorConstructor => true
    BuiltinFunction::EvalErrorConstructor => true
    BuiltinFunction::SyntaxErrorConstructor => true
    BuiltinFunction::RangeErrorConstructor => true
    BuiltinFunction::TypeErrorConstructor => true
    BuiltinFunction::ReferenceErrorConstructor => true
    BuiltinFunction::UriErrorConstructor => true
    _ => false
  }
}

///|
fn is_constructor_value(value : Value) -> Bool {
  match value {
    Function(func) => func.is_constructor
    BoundFunction(bound) => bound.is_constructor
    Builtin(builtin) => is_constructor_builtin(builtin.kind)
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => data.constructable
        None => false
      }
    _ => false
  }
}

///|
fn function_realm_env(value : Value) -> Env? {
  match value {
    Function(func) => Some(func.env)
    BoundFunction(bound) => function_realm_env(bound.target)
    Builtin(builtin) =>
      match builtin.realm_env {
        Some(env) => Some(env)
        None => root_env()
      }
    Object(obj) =>
      match obj.proxy_data {
        Some(data) =>
          if data.handler is Null {
            None
          } else {
            function_realm_env(data.target)
          }
        None => None
      }
    _ => None
  }
}

///|
fn function_realm_env_checked(value : Value) -> Env raise {
  match value {
    Function(func) => func.env
    BoundFunction(bound) => function_realm_env_checked(bound.target)
    Builtin(builtin) =>
      match builtin.realm_env {
        Some(env) => env
        None =>
          match root_env() {
            Some(env) => env
            None => Env::new(None)
          }
      }
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => {
          proxy_check_revoked(data)
          function_realm_env_checked(data.target)
        }
        None =>
          match root_env() {
            Some(env) => env
            None => Env::new(None)
          }
      }
    _ =>
      match root_env() {
        Some(env) => env
        None => Env::new(None)
      }
  }
}

///|
fn constructor_name(value : Value) -> String? {
  match value {
    Function(func) => func.name
    BoundFunction(bound) =>
      match bound.props.get("name") {
        Some(prop) =>
          match prop.value {
            String(name) => Some(name)
            _ => None
          }
        None => None
      }
    Builtin(builtin) => Some(builtin_name(builtin.kind))
    _ => None
  }
}

///|
fn throw_not_constructor(value : Value) -> Value raise {
  match constructor_name(value) {
    Some(name) => throw_type_error("\{name} is not a constructor")
    None => throw_type_error("not a constructor")
  }
}

///|
fn is_object_like(value : Value) -> Bool {
  match value {
    Object(_) => true
    Function(_) => true
    BoundFunction(_) => true
    Builtin(_) => true
    Array(_) => true
    Arguments(_) => true
    _ => false
  }
}

///|
fn is_array_proto_object(obj : ObjectValue) -> Bool {
  match array_proto() {
    Some(proto) => proto.id == obj.id
    None => false
  }
}

///|
fn proxy_check_revoked(data : ProxyData) -> Unit raise {
  if data.handler is Null {
    let _ = throw_type_error("revoked proxy")

  }
}

///|
fn is_array_value(value : Value) -> Bool raise {
  match value {
    Array(arr) => arr.typed_array_data is None
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => {
          proxy_check_revoked(data)
          is_array_value(data.target)
        }
        None => is_array_proto_object(obj)
      }
    _ => false
  }
}

///|
fn update_values(op : @engine.UpdateOp, value : Value) -> (Value, Value) raise {
  match value {
    BigInt(v) => {
      let one = @bigint.BigInt::from_int(1)
      let new_value = match op {
        @engine.UpdateOp::Inc => v.add(one)
        @engine.UpdateOp::Dec => v.sub(one)
      }
      (BigInt(v), BigInt(new_value))
    }
    _ => {
      let old_num = to_number(value)
      let new_num = match op {
        @engine.UpdateOp::Inc => old_num + 1.0
        @engine.UpdateOp::Dec => old_num - 1.0
      }
      (Number(old_num), Number(new_num))
    }
  }
}

///|
fn update_result(
  kind : @engine.UpdateKind,
  old_value : Value,
  new_value : Value,
) -> Value {
  match kind {
    @engine.UpdateKind::Prefix => new_value
    @engine.UpdateKind::Postfix => old_value
  }
}

///|
fn eval_delete(env : Env, expr : @engine.Expr) -> Value raise {
  match unwrap_paren(expr) {
    Ident(name, _) => delete_ident(env, name, env.strict)
    Member(_, @engine.MemberKey::Private(_), _) =>
      throw_syntax_error("cannot delete a private class field")
    Member(@engine.Expr::Super, key, _) =>
      match key {
        @engine.MemberKey::Private(_) =>
          throw_syntax_error("cannot delete a private class field")
        @engine.MemberKey::Computed(expr) => {
          let _ = super_base_and_receiver(env)
          let _ = eval_expr(env, expr)
          throw_reference_error("unsupported reference to 'super'")
        }
        _ => {
          let _ = super_base_and_receiver(env)
          throw_reference_error("unsupported reference to 'super'")
        }
      }
    Member(obj_expr, key, _) => {
      let target = eval_expr(env, obj_expr)
      let name = member_key_name(env, key)
      delete_property(env, target, name)
    }
    OptionalChain(base, segments) => {
      for segment in segments {
        match segment {
          @engine.ChainSegment::Member(@engine.MemberKey::Private(_), _, _) =>
            return throw_syntax_error("cannot delete a private class field")
          _ => ()
        }
      }
      eval_delete_optional_chain(env, base, segments)
    }
    _ => {
      let _ = eval_expr(env, expr)
      Bool(true)
    }
  }
}

///|
fn delete_ident(env : Env, name : String, strict : Bool) -> Value raise {
  match env.with_object {
    Some(obj) =>
      if has_property_value(obj, name) && !is_unscopable(obj, name) {
        return delete_property_with_strict(strict, obj, name)
      }
    None => ()
  }
  match env.bindings.get(name) {
    Some(_) =>
      if env.deletable_bindings.contains(name) {
        env.bindings.remove(name)
        env.readonly_bindings.remove(name)
        env.uninitialized_bindings.remove(name)
        env.deletable_bindings.remove(name)
        Bool(true)
      } else {
        Bool(false)
      }
    None =>
      match env.parent {
        Some(parent) => delete_ident(parent, name, strict)
        None =>
          match global_object(env) {
            Some(obj) =>
              delete_property_with_strict(strict, Value::Object(obj), name)
            None => Bool(true)
          }
      }
  }
}

///|
fn delete_property_with_strict(
  strict : Bool,
  target : Value,
  name : String,
) -> Value raise {
  let ok = delete_property_value(target, name)
  if !ok && strict {
    return throw_type_error("cannot delete property")
  }
  Bool(ok)
}

///|
fn delete_property(env : Env, target : Value, name : String) -> Value raise {
  let ok = delete_property_value(target, name)
  if !ok && env.strict {
    return throw_type_error("cannot delete property")
  }
  Bool(ok)
}

///|
fn delete_property_value(target : Value, name : String) -> Bool raise {
  match target {
    Null => {
      let _ = throw_type_error("cannot delete property")
      false
    }
    Undefined => {
      let _ = throw_type_error("cannot delete property")
      false
    }
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => proxy_delete_property(data, name)
        None => {
          match obj.string_data {
            Some(value) => {
              if name == "length" {
                return false
              }
              match parse_array_index(name) {
                Some(index) =>
                  if index >= 0 && index < value.length() {
                    return false
                  }
                None => ()
              }
            }
            None => ()
          }
          let ok = match obj.props.get(name) {
            Some(prop) =>
              if !prop.configurable {
                false
              } else {
                obj.props.remove(name)
                true
              }
            None => true
          }
          ok
        }
      }
    Function(func) => {
      if name == "prototype" && !func.props.contains(name) {
        ensure_function_prototype(func)
      }
      let ok = match func.props.get(name) {
        Some(prop) =>
          if !prop.configurable {
            false
          } else {
            func.props.remove(name)
            true
          }
        None => true
      }
      ok
    }
    BoundFunction(bound) => {
      let ok = match bound.props.get(name) {
        Some(prop) =>
          if !prop.configurable {
            false
          } else {
            bound.props.remove(name)
            true
          }
        None => true
      }
      ok
    }
    Builtin(builtin) => {
      let ok = match builtin.props.get(name) {
        Some(prop) =>
          if !prop.configurable {
            false
          } else {
            builtin.props.remove(name)
            true
          }
        None => true
      }
      ok
    }
    Array(arr) =>
      match arr.typed_array_data {
        Some(data) =>
          match canonical_numeric_index_string(name) {
            Some(index) => !typed_array_is_valid_integer_index(data, index)
            None => {
              let mut ok = true
              match arr.props.get(name) {
                Some(prop) =>
                  if !prop.configurable {
                    ok = false
                  } else {
                    arr.props.remove(name)
                  }
                None => ()
              }
              ok
            }
          }
        None => {
          let mut ok = true
          match parse_array_index(name) {
            Some(index) =>
              if index >= 0 {
                match arr.props.get(name) {
                  Some(prop) =>
                    if !prop.configurable {
                      ok = false
                    } else {
                      arr.props.remove(name)
                    }
                  None => ()
                }
                if ok && index < arr.elements.length() {
                  arr.elements[index] = None
                }
              }
            None =>
              match arr.props.get(name) {
                Some(prop) =>
                  if !prop.configurable {
                    ok = false
                  } else {
                    arr.props.remove(name)
                  }
                None => ()
              }
          }
          ok
        }
      }
    Arguments(args) => {
      let mut ok = true
      match parse_array_index(name) {
        Some(index) =>
          if index >= 0 {
            match args.props.get(name) {
              Some(prop) =>
                if !prop.configurable {
                  ok = false
                } else {
                  args.props.remove(name)
                }
              None => ()
            }
            if ok && index < args.elements.length() {
              args.elements[index] = None
              if index < args.mapped.length() {
                args.mapped[index] = false
              }
            }
          }
        None =>
          match args.props.get(name) {
            Some(prop) =>
              if !prop.configurable {
                ok = false
              } else {
                args.props.remove(name)
              }
            None => ()
          }
      }
      ok
    }
    String(_) | Number(_) | Bool(_) | BigInt(_) | Symbol(_) => {
      let obj = to_object(target)
      delete_property_value(obj, name)
    }
  }
}

///|
fn delete_property_or_throw(target : Value, name : String) -> Unit raise {
  let ok = delete_property_value(target, name)
  if !ok {
    let _ = throw_type_error("cannot delete property")

  }
}

///|
fn eval_delete_optional_chain(
  env : Env,
  base : @engine.Expr,
  segments : Array[@engine.ChainSegment],
) -> Value raise {
  if segments.is_empty() {
    return Bool(true)
  }
  let mut current = eval_expr(env, base)
  let mut this_value : Value? = None
  for index, segment in segments {
    let is_last = index == segments.length() - 1
    match segment {
      @engine.ChainSegment::Member(key, optional, offset) => {
        if optional && is_nullish(current) {
          return Bool(true)
        }
        if is_last {
          let name = member_key_name(env, key)
          return delete_property(env, current, name)
        }
        let next = with_expr_pos(offset, fn() raise {
          let name = member_key_name(env, key)
          let target = to_object(current)
          property_get(target, name)
        })
        this_value = Some(current)
        current = next
      }
      @engine.ChainSegment::Call(args, optional, offset) => {
        if optional && is_nullish(current) {
          return Bool(true)
        }
        let argv = eval_args(env, args)
        let result = with_expr_pos(offset, fn() raise {
          match this_value {
            Some(this_obj) => call_value_with_this(current, argv, this_obj)
            None => call_value(current, argv)
          }
        })
        current = result
        this_value = None
        if is_last {
          return Bool(true)
        }
      }
    }
  }
  Bool(true)
}

///|
fn env_has(env : Env, name : String) -> Bool raise {
  match env.with_object {
    Some(obj) => if has_property_value(obj, name) { return true }
    None => ()
  }
  match env.bindings.get(name) {
    Some(_) => true
    None =>
      match env.parent {
        Some(parent) => env_has(parent, name)
        None =>
          match global_object(env) {
            Some(obj) => has_property_in_chain(obj.props, obj.proto, name)
            None => false
          }
      }
  }
}

///|
fn typeof_value(value : Value) -> String {
  if is_html_dda_value(value) {
    return "undefined"
  }
  match value {
    Undefined => "undefined"
    Null => "object"
    Bool(_) => "boolean"
    Number(_) => "number"
    String(_) => "string"
    BigInt(_) => "bigint"
    Symbol(_) => "symbol"
    Builtin(_) => "function"
    Function(_) => "function"
    BoundFunction(_) => "function"
    Object(obj) =>
      match obj.proxy_data {
        Some(_) => if is_callable(value) { "function" } else { "object" }
        None => "object"
      }
    Array(_) => "object"
    Arguments(_) => "object"
  }
}

///|
fn builtin_name(func : BuiltinFunction) -> String {
  match func {
    BuiltinFunction::JsonStringify => "stringify"
    BuiltinFunction::JsonParse => "parse"
    BuiltinFunction::BjsonRead => "read"
    BuiltinFunction::BjsonWrite => "write"
    BuiltinFunction::ObjectConstructor => "Object"
    BuiltinFunction::ProxyConstructor => "Proxy"
    BuiltinFunction::ProxyRevocable => "revocable"
    BuiltinFunction::ProxyRevoke => "revoke"
    BuiltinFunction::ObjectDefineProperty => "defineProperty"
    BuiltinFunction::ObjectDefineProperties => "defineProperties"
    BuiltinFunction::ObjectGetOwnPropertyDescriptor =>
      "getOwnPropertyDescriptor"
    BuiltinFunction::ObjectGetOwnPropertyNames => "getOwnPropertyNames"
    BuiltinFunction::ObjectGetOwnPropertySymbols => "getOwnPropertySymbols"
    BuiltinFunction::ObjectGetPrototypeOf => "getPrototypeOf"
    BuiltinFunction::ObjectSetPrototypeOf => "setPrototypeOf"
    BuiltinFunction::ObjectCreate => "create"
    BuiltinFunction::ObjectKeys => "keys"
    BuiltinFunction::ObjectValues => "values"
    BuiltinFunction::ObjectEntries => "entries"
    BuiltinFunction::ObjectGroupBy => "groupBy"
    BuiltinFunction::ObjectIs => "is"
    BuiltinFunction::ObjectIsExtensible => "isExtensible"
    BuiltinFunction::ObjectPreventExtensions => "preventExtensions"
    BuiltinFunction::ObjectSeal => "seal"
    BuiltinFunction::ObjectIsSealed => "isSealed"
    BuiltinFunction::ObjectIsFrozen => "isFrozen"
    BuiltinFunction::ObjectFreeze => "freeze"
    BuiltinFunction::ObjectGetOwnPropertyDescriptors =>
      "getOwnPropertyDescriptors"
    BuiltinFunction::ObjectFromEntries => "fromEntries"
    BuiltinFunction::ObjectAssign => "assign"
    BuiltinFunction::ObjectHasOwn => "hasOwn"
    BuiltinFunction::ObjectToString => "toString"
    BuiltinFunction::ObjectToLocaleString => "toLocaleString"
    BuiltinFunction::ObjectValueOf => "valueOf"
    BuiltinFunction::ObjectHasOwnProperty => "hasOwnProperty"
    BuiltinFunction::ObjectPropertyIsEnumerable => "propertyIsEnumerable"
    BuiltinFunction::ObjectIsPrototypeOf => "isPrototypeOf"
    BuiltinFunction::ObjectProtoGet => "get __proto__"
    BuiltinFunction::ObjectProtoSet => "set __proto__"
    BuiltinFunction::ObjectDefineGetter => "__defineGetter__"
    BuiltinFunction::ObjectDefineSetter => "__defineSetter__"
    BuiltinFunction::ObjectLookupGetter => "__lookupGetter__"
    BuiltinFunction::ObjectLookupSetter => "__lookupSetter__"
    BuiltinFunction::ArrayToString => "toString"
    BuiltinFunction::ArrayToLocaleString => "toLocaleString"
    BuiltinFunction::ArrayConstructor => "Array"
    BuiltinFunction::ArrayIsArray => "isArray"
    BuiltinFunction::ArrayFrom => "from"
    BuiltinFunction::ArrayOf => "of"
    BuiltinFunction::ArrayAt => "at"
    BuiltinFunction::ArrayPush => "push"
    BuiltinFunction::ArrayPop => "pop"
    BuiltinFunction::ArrayShift => "shift"
    BuiltinFunction::ArrayUnshift => "unshift"
    BuiltinFunction::ArraySplice => "splice"
    BuiltinFunction::ArraySlice => "slice"
    BuiltinFunction::ArrayReverse => "reverse"
    BuiltinFunction::ArrayConcat => "concat"
    BuiltinFunction::ArrayJoin => "join"
    BuiltinFunction::ArrayIndexOf => "indexOf"
    BuiltinFunction::ArrayLastIndexOf => "lastIndexOf"
    BuiltinFunction::ArrayIncludes => "includes"
    BuiltinFunction::ArrayCopyWithin => "copyWithin"
    BuiltinFunction::ArrayFill => "fill"
    BuiltinFunction::ArrayFind => "find"
    BuiltinFunction::ArrayFindIndex => "findIndex"
    BuiltinFunction::ArrayFindLast => "findLast"
    BuiltinFunction::ArrayFindLastIndex => "findLastIndex"
    BuiltinFunction::ArrayFlat => "flat"
    BuiltinFunction::ArrayFlatMap => "flatMap"
    BuiltinFunction::ArrayToReversed => "toReversed"
    BuiltinFunction::ArrayToSorted => "toSorted"
    BuiltinFunction::ArrayToSpliced => "toSpliced"
    BuiltinFunction::ArrayWith => "with"
    BuiltinFunction::ArrayMap => "map"
    BuiltinFunction::ArrayForEach => "forEach"
    BuiltinFunction::ArrayFilter => "filter"
    BuiltinFunction::ArrayEvery => "every"
    BuiltinFunction::ArraySome => "some"
    BuiltinFunction::ArrayReduce => "reduce"
    BuiltinFunction::ArrayReduceRight => "reduceRight"
    BuiltinFunction::ArraySort => "sort"
    BuiltinFunction::ArrayValues => "values"
    BuiltinFunction::ArrayKeys => "keys"
    BuiltinFunction::ArrayEntries => "entries"
    BuiltinFunction::ArrayIteratorNext => "next"
    BuiltinFunction::IteratorReturnSelf => "[Symbol.iterator]"
    BuiltinFunction::AsyncIteratorReturnSelf => "[Symbol.asyncIterator]"
    BuiltinFunction::AsyncFromSyncIteratorNext => "next"
    BuiltinFunction::AsyncFromSyncIteratorReturn => "return"
    BuiltinFunction::AsyncFromSyncIteratorThrow => "throw"
    BuiltinFunction::AsyncFromSyncIteratorUnwrap => ""
    BuiltinFunction::AsyncFromSyncIteratorCloseWrap => ""
    BuiltinFunction::IteratorConstructor => "Iterator"
    BuiltinFunction::IteratorFrom => "from"
    BuiltinFunction::IteratorConcat => "concat"
    BuiltinFunction::IteratorConcatNext => "next"
    BuiltinFunction::IteratorConcatReturn => "return"
    BuiltinFunction::IteratorWrapNext => "next"
    BuiltinFunction::IteratorWrapReturn => "return"
    BuiltinFunction::IteratorHelperNext => "next"
    BuiltinFunction::IteratorHelperReturn => "return"
    BuiltinFunction::IteratorDrop => "drop"
    BuiltinFunction::IteratorFilter => "filter"
    BuiltinFunction::IteratorFlatMap => "flatMap"
    BuiltinFunction::IteratorMap => "map"
    BuiltinFunction::IteratorTake => "take"
    BuiltinFunction::IteratorEvery => "every"
    BuiltinFunction::IteratorFind => "find"
    BuiltinFunction::IteratorForEach => "forEach"
    BuiltinFunction::IteratorSome => "some"
    BuiltinFunction::IteratorReduce => "reduce"
    BuiltinFunction::IteratorToArray => "toArray"
    BuiltinFunction::IteratorConstructorGetter => "get constructor"
    BuiltinFunction::IteratorConstructorSetter => "set constructor"
    BuiltinFunction::IteratorToStringTagGetter => "get [Symbol.toStringTag]"
    BuiltinFunction::IteratorToStringTagSetter => "set [Symbol.toStringTag]"
    BuiltinFunction::FunctionCall => "call"
    BuiltinFunction::FunctionApply => "apply"
    BuiltinFunction::FunctionBind => "bind"
    BuiltinFunction::FunctionToString => "toString"
    BuiltinFunction::FunctionProtoLineNumber => "get lineNumber"
    BuiltinFunction::FunctionProtoColumnNumber => "get columnNumber"
    BuiltinFunction::FunctionSymbolHasInstance => "[Symbol.hasInstance]"
    BuiltinFunction::FunctionConstructor => "Function"
    BuiltinFunction::GeneratorFunctionConstructor => "GeneratorFunction"
    BuiltinFunction::AsyncFunctionConstructor => "AsyncFunction"
    BuiltinFunction::AsyncGeneratorFunctionConstructor =>
      "AsyncGeneratorFunction"
    BuiltinFunction::BooleanConstructor => "Boolean"
    BuiltinFunction::BooleanToString => "toString"
    BuiltinFunction::BooleanValueOf => "valueOf"
    BuiltinFunction::StringConstructor => "String"
    BuiltinFunction::StringFromCharCode => "fromCharCode"
    BuiltinFunction::StringFromCodePoint => "fromCodePoint"
    BuiltinFunction::StringRaw => "raw"
    BuiltinFunction::StringCharCodeAt => "charCodeAt"
    BuiltinFunction::StringCharAt => "charAt"
    BuiltinFunction::StringCodePointAt => "codePointAt"
    BuiltinFunction::StringConcat => "concat"
    BuiltinFunction::StringSubstring => "substring"
    BuiltinFunction::StringSubstr => "substr"
    BuiltinFunction::StringSlice => "slice"
    BuiltinFunction::StringIndexOf => "indexOf"
    BuiltinFunction::StringLastIndexOf => "lastIndexOf"
    BuiltinFunction::StringSplit => "split"
    BuiltinFunction::StringPadStart => "padStart"
    BuiltinFunction::StringReplace => "replace"
    BuiltinFunction::StringReplaceAll => "replaceAll"
    BuiltinFunction::StringToString => "toString"
    BuiltinFunction::StringValueOf => "valueOf"
    BuiltinFunction::StringAt => "at"
    BuiltinFunction::StringIncludes => "includes"
    BuiltinFunction::StringEndsWith => "endsWith"
    BuiltinFunction::StringStartsWith => "startsWith"
    BuiltinFunction::StringRepeat => "repeat"
    BuiltinFunction::StringPadEnd => "padEnd"
    BuiltinFunction::StringTrim => "trim"
    BuiltinFunction::StringTrimStart => "trimStart"
    BuiltinFunction::StringTrimEnd => "trimEnd"
    BuiltinFunction::StringToLowerCase => "toLowerCase"
    BuiltinFunction::StringToUpperCase => "toUpperCase"
    BuiltinFunction::StringToLocaleLowerCase => "toLocaleLowerCase"
    BuiltinFunction::StringToLocaleUpperCase => "toLocaleUpperCase"
    BuiltinFunction::StringLocaleCompare => "localeCompare"
    BuiltinFunction::StringNormalize => "normalize"
    BuiltinFunction::StringIsWellFormed => "isWellFormed"
    BuiltinFunction::StringToWellFormed => "toWellFormed"
    BuiltinFunction::StringMatch => "match"
    BuiltinFunction::StringMatchAll => "matchAll"
    BuiltinFunction::StringSearch => "search"
    BuiltinFunction::StringIterator => "[Symbol.iterator]"
    BuiltinFunction::StringIteratorNext => "next"
    BuiltinFunction::StringAnchor => "anchor"
    BuiltinFunction::StringBig => "big"
    BuiltinFunction::StringBlink => "blink"
    BuiltinFunction::StringBold => "bold"
    BuiltinFunction::StringFixed => "fixed"
    BuiltinFunction::StringFontcolor => "fontcolor"
    BuiltinFunction::StringFontsize => "fontsize"
    BuiltinFunction::StringItalics => "italics"
    BuiltinFunction::StringLink => "link"
    BuiltinFunction::StringSmall => "small"
    BuiltinFunction::StringStrike => "strike"
    BuiltinFunction::StringSub => "sub"
    BuiltinFunction::StringSup => "sup"
    BuiltinFunction::NumberConstructor => "Number"
    BuiltinFunction::NumberIsNaN => "isNaN"
    BuiltinFunction::NumberIsFinite => "isFinite"
    BuiltinFunction::NumberIsInteger => "isInteger"
    BuiltinFunction::NumberIsSafeInteger => "isSafeInteger"
    BuiltinFunction::NumberToString => "toString"
    BuiltinFunction::NumberToLocaleString => "toLocaleString"
    BuiltinFunction::NumberToFixed => "toFixed"
    BuiltinFunction::NumberToExponential => "toExponential"
    BuiltinFunction::NumberToPrecision => "toPrecision"
    BuiltinFunction::NumberValueOf => "valueOf"
    BuiltinFunction::BigIntConstructor => "BigInt"
    BuiltinFunction::BigIntToString => "toString"
    BuiltinFunction::BigIntValueOf => "valueOf"
    BuiltinFunction::BigIntAsIntN => "asIntN"
    BuiltinFunction::BigIntAsUintN => "asUintN"
    BuiltinFunction::SymbolConstructor => "Symbol"
    BuiltinFunction::SymbolFor => "for"
    BuiltinFunction::SymbolKeyFor => "keyFor"
    BuiltinFunction::SymbolToString => "toString"
    BuiltinFunction::SymbolValueOf => "valueOf"
    BuiltinFunction::SymbolToPrimitive => "[Symbol.toPrimitive]"
    BuiltinFunction::SymbolDescription => "description"
    BuiltinFunction::ParseInt => "parseInt"
    BuiltinFunction::ParseFloat => "parseFloat"
    BuiltinFunction::DecodeURI => "decodeURI"
    BuiltinFunction::DecodeURIComponent => "decodeURIComponent"
    BuiltinFunction::EncodeURI => "encodeURI"
    BuiltinFunction::EncodeURIComponent => "encodeURIComponent"
    BuiltinFunction::Escape => "escape"
    BuiltinFunction::Unescape => "unescape"
    BuiltinFunction::MathAbs => "abs"
    BuiltinFunction::MathAcos => "acos"
    BuiltinFunction::MathAcosh => "acosh"
    BuiltinFunction::MathAsin => "asin"
    BuiltinFunction::MathAsinh => "asinh"
    BuiltinFunction::MathAtan => "atan"
    BuiltinFunction::MathAtan2 => "atan2"
    BuiltinFunction::MathAtanh => "atanh"
    BuiltinFunction::MathCbrt => "cbrt"
    BuiltinFunction::MathCeil => "ceil"
    BuiltinFunction::MathClz32 => "clz32"
    BuiltinFunction::MathCos => "cos"
    BuiltinFunction::MathCosh => "cosh"
    BuiltinFunction::MathExp => "exp"
    BuiltinFunction::MathExpm1 => "expm1"
    BuiltinFunction::MathFloor => "floor"
    BuiltinFunction::MathFround => "fround"
    BuiltinFunction::MathF16Round => "f16round"
    BuiltinFunction::MathHypot => "hypot"
    BuiltinFunction::MathImul => "imul"
    BuiltinFunction::MathLog => "log"
    BuiltinFunction::MathLog1p => "log1p"
    BuiltinFunction::MathLog2 => "log2"
    BuiltinFunction::MathLog10 => "log10"
    BuiltinFunction::MathMax => "max"
    BuiltinFunction::MathMin => "min"
    BuiltinFunction::MathPow => "pow"
    BuiltinFunction::MathRandom => "random"
    BuiltinFunction::MathRound => "round"
    BuiltinFunction::MathSign => "sign"
    BuiltinFunction::MathSin => "sin"
    BuiltinFunction::MathSinh => "sinh"
    BuiltinFunction::MathSqrt => "sqrt"
    BuiltinFunction::MathTan => "tan"
    BuiltinFunction::MathTanh => "tanh"
    BuiltinFunction::MathTrunc => "trunc"
    BuiltinFunction::MathSumPrecise => "sumPrecise"
    BuiltinFunction::RegExpConstructor => "RegExp"
    BuiltinFunction::RegExpExec => "exec"
    BuiltinFunction::RegExpTest => "test"
    BuiltinFunction::RegExpToString => "toString"
    BuiltinFunction::RegExpCompile => "compile"
    BuiltinFunction::RegExpEscape => "escape"
    BuiltinFunction::RegExpGetFlags => "get flags"
    BuiltinFunction::RegExpGetSource => "get source"
    BuiltinFunction::RegExpGetGlobal => "get global"
    BuiltinFunction::RegExpGetIgnoreCase => "get ignoreCase"
    BuiltinFunction::RegExpGetMultiline => "get multiline"
    BuiltinFunction::RegExpGetDotAll => "get dotAll"
    BuiltinFunction::RegExpGetUnicode => "get unicode"
    BuiltinFunction::RegExpGetUnicodeSets => "get unicodeSets"
    BuiltinFunction::RegExpGetSticky => "get sticky"
    BuiltinFunction::RegExpGetHasIndices => "get hasIndices"
    BuiltinFunction::RegExpSymbolMatch => "[Symbol.match]"
    BuiltinFunction::RegExpSymbolMatchAll => "[Symbol.matchAll]"
    BuiltinFunction::RegExpSymbolReplace => "[Symbol.replace]"
    BuiltinFunction::RegExpSymbolSearch => "[Symbol.search]"
    BuiltinFunction::RegExpSymbolSplit => "[Symbol.split]"
    BuiltinFunction::RegExpStringIteratorNext => "next"
    BuiltinFunction::SpeciesGetter => "get [Symbol.species]"
    BuiltinFunction::DateConstructor => "Date"
    BuiltinFunction::DateParse => "parse"
    BuiltinFunction::DateUTC => "UTC"
    BuiltinFunction::DateNow => "now"
    BuiltinFunction::DateToISOString => "toISOString"
    BuiltinFunction::DateToString => "toString"
    BuiltinFunction::DateSymbolToPrimitive => "[Symbol.toPrimitive]"
    BuiltinFunction::DateValueOf => "valueOf"
    BuiltinFunction::DateToUTCString => "toUTCString"
    BuiltinFunction::DateToDateString => "toDateString"
    BuiltinFunction::DateToTimeString => "toTimeString"
    BuiltinFunction::DateToLocaleString => "toLocaleString"
    BuiltinFunction::DateToLocaleDateString => "toLocaleDateString"
    BuiltinFunction::DateToLocaleTimeString => "toLocaleTimeString"
    BuiltinFunction::DateToJSON => "toJSON"
    BuiltinFunction::DateGetTimezoneOffset => "getTimezoneOffset"
    BuiltinFunction::DateGetTime => "getTime"
    BuiltinFunction::DateGetYear => "getYear"
    BuiltinFunction::DateGetFullYear => "getFullYear"
    BuiltinFunction::DateGetUTCFullYear => "getUTCFullYear"
    BuiltinFunction::DateGetMonth => "getMonth"
    BuiltinFunction::DateGetUTCMonth => "getUTCMonth"
    BuiltinFunction::DateGetDate => "getDate"
    BuiltinFunction::DateGetUTCDate => "getUTCDate"
    BuiltinFunction::DateGetDay => "getDay"
    BuiltinFunction::DateGetUTCDay => "getUTCDay"
    BuiltinFunction::DateGetHours => "getHours"
    BuiltinFunction::DateGetUTCHours => "getUTCHours"
    BuiltinFunction::DateGetMinutes => "getMinutes"
    BuiltinFunction::DateGetUTCMinutes => "getUTCMinutes"
    BuiltinFunction::DateGetSeconds => "getSeconds"
    BuiltinFunction::DateGetUTCSeconds => "getUTCSeconds"
    BuiltinFunction::DateGetMilliseconds => "getMilliseconds"
    BuiltinFunction::DateGetUTCMilliseconds => "getUTCMilliseconds"
    BuiltinFunction::DateSetTime => "setTime"
    BuiltinFunction::DateSetMilliseconds => "setMilliseconds"
    BuiltinFunction::DateSetUTCMilliseconds => "setUTCMilliseconds"
    BuiltinFunction::DateSetSeconds => "setSeconds"
    BuiltinFunction::DateSetUTCSeconds => "setUTCSeconds"
    BuiltinFunction::DateSetMinutes => "setMinutes"
    BuiltinFunction::DateSetUTCMinutes => "setUTCMinutes"
    BuiltinFunction::DateSetHours => "setHours"
    BuiltinFunction::DateSetUTCHours => "setUTCHours"
    BuiltinFunction::DateSetDate => "setDate"
    BuiltinFunction::DateSetUTCDate => "setUTCDate"
    BuiltinFunction::DateSetMonth => "setMonth"
    BuiltinFunction::DateSetUTCMonth => "setUTCMonth"
    BuiltinFunction::DateSetYear => "setYear"
    BuiltinFunction::DateSetFullYear => "setFullYear"
    BuiltinFunction::DateSetUTCFullYear => "setUTCFullYear"
    BuiltinFunction::PromiseConstructor => "Promise"
    BuiltinFunction::PromiseResolve => "resolve"
    BuiltinFunction::PromiseReject => "reject"
    BuiltinFunction::PromiseThen => "then"
    BuiltinFunction::PromiseCatch => "catch"
    BuiltinFunction::PromiseFinally => "finally"
    BuiltinFunction::PromiseAll => "all"
    BuiltinFunction::PromiseAllSettled => "allSettled"
    BuiltinFunction::PromiseAny => "any"
    BuiltinFunction::PromiseRace => "race"
    BuiltinFunction::PromiseTry => "try"
    BuiltinFunction::PromiseWithResolvers => "withResolvers"
    BuiltinFunction::PromiseReactionJob => ""
    BuiltinFunction::PromiseResolveFunction => ""
    BuiltinFunction::PromiseRejectFunction => ""
    BuiltinFunction::PromiseResolveThenableJob => ""
    BuiltinFunction::PromiseAllResolveElement => ""
    BuiltinFunction::PromiseThenFinally => ""
    BuiltinFunction::PromiseFinallyValueThunk => ""
    BuiltinFunction::PromiseFinallyThrower => ""
    BuiltinFunction::PromiseCapabilityExecutor => ""
    BuiltinFunction::ReflectApply => "apply"
    BuiltinFunction::ReflectConstruct => "construct"
    BuiltinFunction::ReflectGet => "get"
    BuiltinFunction::ReflectGetOwnPropertyDescriptor =>
      "getOwnPropertyDescriptor"
    BuiltinFunction::ReflectGetPrototypeOf => "getPrototypeOf"
    BuiltinFunction::ReflectDefineProperty => "defineProperty"
    BuiltinFunction::ReflectHas => "has"
    BuiltinFunction::ReflectIsExtensible => "isExtensible"
    BuiltinFunction::ReflectSet => "set"
    BuiltinFunction::ReflectSetPrototypeOf => "setPrototypeOf"
    BuiltinFunction::ReflectDeleteProperty => "deleteProperty"
    BuiltinFunction::ReflectPreventExtensions => "preventExtensions"
    BuiltinFunction::ReflectOwnKeys => "ownKeys"
    BuiltinFunction::Eval => "eval"
    BuiltinFunction::ModuleImport => "__import"
    BuiltinFunction::ModuleImportDynamic => "__import_dynamic"
    BuiltinFunction::ModuleImportDynamicJob => ""
    BuiltinFunction::ModuleImportBinding => "__import_binding"
    BuiltinFunction::ModuleBinding => "__binding"
    BuiltinFunction::ModuleExport => "__export"
    BuiltinFunction::ModuleExportStar => "__export_star"
    BuiltinFunction::ModuleAsyncFulfilled => ""
    BuiltinFunction::ModuleAsyncRejected => ""
    BuiltinFunction::IsNaN => "isNaN"
    BuiltinFunction::IsFinite => "isFinite"
    BuiltinFunction::GeneratorNext => "next"
    BuiltinFunction::GeneratorReturn => "return"
    BuiltinFunction::GeneratorThrow => "throw"
    BuiltinFunction::AsyncGeneratorNext => "next"
    BuiltinFunction::AsyncGeneratorReturn => "return"
    BuiltinFunction::AsyncGeneratorThrow => "throw"
    BuiltinFunction::AsyncFunctionResolveFunction => ""
    BuiltinFunction::AsyncGeneratorResolveFunction => ""
    BuiltinFunction::MapConstructor => "Map"
    BuiltinFunction::MapGroupBy => "groupBy"
    BuiltinFunction::MapGet => "get"
    BuiltinFunction::MapGetOrInsert => "getOrInsert"
    BuiltinFunction::MapGetOrInsertComputed => "getOrInsertComputed"
    BuiltinFunction::MapSet => "set"
    BuiltinFunction::MapHas => "has"
    BuiltinFunction::MapDelete => "delete"
    BuiltinFunction::MapClear => "clear"
    BuiltinFunction::MapForEach => "forEach"
    BuiltinFunction::MapSize => "get size"
    BuiltinFunction::MapKeys => "keys"
    BuiltinFunction::MapValues => "values"
    BuiltinFunction::MapEntries => "entries"
    BuiltinFunction::MapIteratorNext => "next"
    BuiltinFunction::SetConstructor => "Set"
    BuiltinFunction::SetAdd => "add"
    BuiltinFunction::SetHas => "has"
    BuiltinFunction::SetDelete => "delete"
    BuiltinFunction::SetClear => "clear"
    BuiltinFunction::SetForEach => "forEach"
    BuiltinFunction::SetSize => "get size"
    BuiltinFunction::SetValues => "values"
    BuiltinFunction::SetEntries => "entries"
    BuiltinFunction::SetIsDisjointFrom => "isDisjointFrom"
    BuiltinFunction::SetIsSubsetOf => "isSubsetOf"
    BuiltinFunction::SetIsSupersetOf => "isSupersetOf"
    BuiltinFunction::SetIntersection => "intersection"
    BuiltinFunction::SetDifference => "difference"
    BuiltinFunction::SetSymmetricDifference => "symmetricDifference"
    BuiltinFunction::SetUnion => "union"
    BuiltinFunction::SetIteratorNext => "next"
    BuiltinFunction::WeakMapConstructor => "WeakMap"
    BuiltinFunction::WeakMapGet => "get"
    BuiltinFunction::WeakMapGetOrInsert => "getOrInsert"
    BuiltinFunction::WeakMapGetOrInsertComputed => "getOrInsertComputed"
    BuiltinFunction::WeakMapSet => "set"
    BuiltinFunction::WeakMapHas => "has"
    BuiltinFunction::WeakMapDelete => "delete"
    BuiltinFunction::WeakSetConstructor => "WeakSet"
    BuiltinFunction::WeakSetAdd => "add"
    BuiltinFunction::WeakSetHas => "has"
    BuiltinFunction::WeakSetDelete => "delete"
    BuiltinFunction::WeakRefConstructor => "WeakRef"
    BuiltinFunction::WeakRefDeref => "deref"
    BuiltinFunction::FinalizationRegistryConstructor => "FinalizationRegistry"
    BuiltinFunction::FinalizationRegistryRegister => "register"
    BuiltinFunction::FinalizationRegistryUnregister => "unregister"
    BuiltinFunction::ArrayBufferIsView => "isView"
    BuiltinFunction::ArrayBufferByteLength => "get byteLength"
    BuiltinFunction::ArrayBufferMaxByteLength => "get maxByteLength"
    BuiltinFunction::ArrayBufferResizable => "get resizable"
    BuiltinFunction::ArrayBufferDetached => "get detached"
    BuiltinFunction::ArrayBufferConstructor => "ArrayBuffer"
    BuiltinFunction::SharedArrayBufferConstructor => "SharedArrayBuffer"
    BuiltinFunction::ArrayBufferSlice => "slice"
    BuiltinFunction::ArrayBufferTransfer => "transfer"
    BuiltinFunction::ArrayBufferTransferToFixedLength => "transferToFixedLength"
    BuiltinFunction::ArrayBufferResize => "resize"
    BuiltinFunction::SharedArrayBufferByteLength => "get byteLength"
    BuiltinFunction::SharedArrayBufferMaxByteLength => "get maxByteLength"
    BuiltinFunction::SharedArrayBufferGrowable => "get growable"
    BuiltinFunction::SharedArrayBufferGrow => "grow"
    BuiltinFunction::SharedArrayBufferSlice => "slice"
    BuiltinFunction::AtomicsAdd => "add"
    BuiltinFunction::AtomicsAnd => "and"
    BuiltinFunction::AtomicsOr => "or"
    BuiltinFunction::AtomicsSub => "sub"
    BuiltinFunction::AtomicsXor => "xor"
    BuiltinFunction::AtomicsExchange => "exchange"
    BuiltinFunction::AtomicsCompareExchange => "compareExchange"
    BuiltinFunction::AtomicsLoad => "load"
    BuiltinFunction::AtomicsStore => "store"
    BuiltinFunction::AtomicsIsLockFree => "isLockFree"
    BuiltinFunction::AtomicsPause => "pause"
    BuiltinFunction::AtomicsWait => "wait"
    BuiltinFunction::AtomicsNotify => "notify"
    BuiltinFunction::DataViewConstructor => "DataView"
    BuiltinFunction::DataViewGetBuffer => "get buffer"
    BuiltinFunction::DataViewGetByteLength => "get byteLength"
    BuiltinFunction::DataViewGetByteOffset => "get byteOffset"
    BuiltinFunction::DataViewGetInt8 => "getInt8"
    BuiltinFunction::DataViewGetUint8 => "getUint8"
    BuiltinFunction::DataViewGetInt16 => "getInt16"
    BuiltinFunction::DataViewGetUint16 => "getUint16"
    BuiltinFunction::DataViewGetInt32 => "getInt32"
    BuiltinFunction::DataViewGetUint32 => "getUint32"
    BuiltinFunction::DataViewGetBigInt64 => "getBigInt64"
    BuiltinFunction::DataViewGetBigUint64 => "getBigUint64"
    BuiltinFunction::DataViewGetFloat16 => "getFloat16"
    BuiltinFunction::DataViewGetFloat32 => "getFloat32"
    BuiltinFunction::DataViewGetFloat64 => "getFloat64"
    BuiltinFunction::DataViewSetInt8 => "setInt8"
    BuiltinFunction::DataViewSetUint8 => "setUint8"
    BuiltinFunction::DataViewSetInt16 => "setInt16"
    BuiltinFunction::DataViewSetUint16 => "setUint16"
    BuiltinFunction::DataViewSetInt32 => "setInt32"
    BuiltinFunction::DataViewSetUint32 => "setUint32"
    BuiltinFunction::DataViewSetBigInt64 => "setBigInt64"
    BuiltinFunction::DataViewSetBigUint64 => "setBigUint64"
    BuiltinFunction::DataViewSetFloat16 => "setFloat16"
    BuiltinFunction::DataViewSetFloat32 => "setFloat32"
    BuiltinFunction::DataViewSetFloat64 => "setFloat64"
    BuiltinFunction::TypedArrayConstructor => "TypedArray"
    BuiltinFunction::TypedArrayFrom => "from"
    BuiltinFunction::TypedArrayOf => "of"
    BuiltinFunction::TypedArrayGetLength => "get length"
    BuiltinFunction::TypedArrayGetBuffer => "get buffer"
    BuiltinFunction::TypedArrayGetByteLength => "get byteLength"
    BuiltinFunction::TypedArrayGetByteOffset => "get byteOffset"
    BuiltinFunction::TypedArrayGetToStringTag => "get [Symbol.toStringTag]"
    BuiltinFunction::TypedArrayAt => "at"
    BuiltinFunction::TypedArrayWith => "with"
    BuiltinFunction::TypedArrayValues => "values"
    BuiltinFunction::TypedArrayKeys => "keys"
    BuiltinFunction::TypedArrayEntries => "entries"
    BuiltinFunction::TypedArrayCopyWithin => "copyWithin"
    BuiltinFunction::TypedArrayEvery => "every"
    BuiltinFunction::TypedArraySome => "some"
    BuiltinFunction::TypedArrayForEach => "forEach"
    BuiltinFunction::TypedArrayMap => "map"
    BuiltinFunction::TypedArrayFilter => "filter"
    BuiltinFunction::TypedArrayReduce => "reduce"
    BuiltinFunction::TypedArrayReduceRight => "reduceRight"
    BuiltinFunction::TypedArrayFind => "find"
    BuiltinFunction::TypedArrayFindIndex => "findIndex"
    BuiltinFunction::TypedArrayFindLast => "findLast"
    BuiltinFunction::TypedArrayFindLastIndex => "findLastIndex"
    BuiltinFunction::TypedArrayReverse => "reverse"
    BuiltinFunction::TypedArrayToReversed => "toReversed"
    BuiltinFunction::TypedArraySlice => "slice"
    BuiltinFunction::TypedArraySubarray => "subarray"
    BuiltinFunction::TypedArraySort => "sort"
    BuiltinFunction::TypedArrayToSorted => "toSorted"
    BuiltinFunction::TypedArrayJoin => "join"
    BuiltinFunction::TypedArrayToLocaleString => "toLocaleString"
    BuiltinFunction::TypedArrayIndexOf => "indexOf"
    BuiltinFunction::TypedArrayLastIndexOf => "lastIndexOf"
    BuiltinFunction::TypedArrayIncludes => "includes"
    BuiltinFunction::Uint8ArrayConstructor => "Uint8Array"
    BuiltinFunction::Int8ArrayConstructor => "Int8Array"
    BuiltinFunction::Uint8ClampedArrayConstructor => "Uint8ClampedArray"
    BuiltinFunction::Uint16ArrayConstructor => "Uint16Array"
    BuiltinFunction::Int16ArrayConstructor => "Int16Array"
    BuiltinFunction::Uint32ArrayConstructor => "Uint32Array"
    BuiltinFunction::Int32ArrayConstructor => "Int32Array"
    BuiltinFunction::BigInt64ArrayConstructor => "BigInt64Array"
    BuiltinFunction::BigUint64ArrayConstructor => "BigUint64Array"
    BuiltinFunction::Float16ArrayConstructor => "Float16Array"
    BuiltinFunction::Float32ArrayConstructor => "Float32Array"
    BuiltinFunction::Float64ArrayConstructor => "Float64Array"
    BuiltinFunction::WorkerConstructor => "Worker"
    BuiltinFunction::WorkerPostMessage => "postMessage"
    BuiltinFunction::TypedArraySet => "set"
    BuiltinFunction::TypedArrayFill => "fill"
    BuiltinFunction::StdSprintf => "sprintf"
    BuiltinFunction::StdLoadScript => "loadScript"
    BuiltinFunction::StdTmpfile => "tmpfile"
    BuiltinFunction::StdOpen => "open"
    BuiltinFunction::StdLoadFile => "loadFile"
    BuiltinFunction::StdPopen => "popen"
    BuiltinFunction::StdParseExtJSON => "parseExtJSON"
    BuiltinFunction::StdFdopen => "fdopen"
    BuiltinFunction::FilePuts => "puts"
    BuiltinFunction::FilePutByte => "putByte"
    BuiltinFunction::FileSeek => "seek"
    BuiltinFunction::FileTell => "tell"
    BuiltinFunction::FileRead => "read"
    BuiltinFunction::FileReadAsString => "readAsString"
    BuiltinFunction::FileGetByte => "getByte"
    BuiltinFunction::FileGetline => "getline"
    BuiltinFunction::FileEof => "eof"
    BuiltinFunction::FileClose => "close"
    BuiltinFunction::StdGc => "gc"
    BuiltinFunction::Print => "print"
    BuiltinFunction::Test262DetachArrayBuffer => "detachArrayBuffer"
    BuiltinFunction::Test262EvalScript => "evalScript"
    BuiltinFunction::Test262CodePointRange => "codePointRange"
    BuiltinFunction::Test262CreateRealm => "createRealm"
    BuiltinFunction::Test262Gc => "gc"
    BuiltinFunction::Test262IsHTMLDDA => "IsHTMLDDA"
    BuiltinFunction::Test262AgentStart => "start"
    BuiltinFunction::Test262AgentGetReport => "getReport"
    BuiltinFunction::Test262AgentBroadcast => "broadcast"
    BuiltinFunction::Test262AgentReport => "report"
    BuiltinFunction::Test262AgentLeaving => "leaving"
    BuiltinFunction::Test262AgentReceiveBroadcast => "receiveBroadcast"
    BuiltinFunction::Test262AgentSleep => "sleep"
    BuiltinFunction::Test262AgentMonotonicNow => "monotonicNow"
    BuiltinFunction::OsSetTimeout => "setTimeout"
    BuiltinFunction::OsClearTimeout => "clearTimeout"
    BuiltinFunction::OsOpen => "open"
    BuiltinFunction::OsClose => "close"
    BuiltinFunction::OsRead => "read"
    BuiltinFunction::OsWrite => "write"
    BuiltinFunction::OsSeek => "seek"
    BuiltinFunction::OsReaddir => "readdir"
    BuiltinFunction::OsStat => "stat"
    BuiltinFunction::OsLstat => "lstat"
    BuiltinFunction::OsReadlink => "readlink"
    BuiltinFunction::OsSymlink => "symlink"
    BuiltinFunction::OsMkdir => "mkdir"
    BuiltinFunction::OsRemove => "remove"
    BuiltinFunction::OsUtimes => "utimes"
    BuiltinFunction::OsGetcwd => "getcwd"
    BuiltinFunction::OsRealpath => "realpath"
    BuiltinFunction::OsIsatty => "isatty"
    BuiltinFunction::OsExec => "exec"
    BuiltinFunction::OsPipe => "pipe"
    BuiltinFunction::OsWaitpid => "waitpid"
    BuiltinFunction::OsKill => "kill"
    BuiltinFunction::ErrorToString => "toString"
    BuiltinFunction::ErrorIsError => "isError"
    BuiltinFunction::ErrorConstructor => "Error"
    BuiltinFunction::AggregateErrorConstructor => "AggregateError"
    BuiltinFunction::EvalErrorConstructor => "EvalError"
    BuiltinFunction::SyntaxErrorConstructor => "SyntaxError"
    BuiltinFunction::RangeErrorConstructor => "RangeError"
    BuiltinFunction::TypeErrorConstructor => "TypeError"
    BuiltinFunction::ReferenceErrorConstructor => "ReferenceError"
    BuiltinFunction::UriErrorConstructor => "URIError"
    BuiltinFunction::ThrowTypeError => ""
  }
}

///|
fn builtin_length(func : BuiltinFunction) -> Int {
  match func {
    BuiltinFunction::JsonStringify => 3
    BuiltinFunction::JsonParse => 2
    BuiltinFunction::BjsonRead => 4
    BuiltinFunction::BjsonWrite => 2
    BuiltinFunction::ObjectConstructor => 1
    BuiltinFunction::ProxyConstructor => 2
    BuiltinFunction::ProxyRevocable => 2
    BuiltinFunction::ProxyRevoke => 0
    BuiltinFunction::ObjectDefineProperty => 3
    BuiltinFunction::ObjectDefineProperties => 2
    BuiltinFunction::ObjectGetOwnPropertyDescriptor => 2
    BuiltinFunction::ObjectGetOwnPropertyNames => 1
    BuiltinFunction::ObjectGetOwnPropertySymbols => 1
    BuiltinFunction::ObjectGetPrototypeOf => 1
    BuiltinFunction::ObjectSetPrototypeOf => 2
    BuiltinFunction::ObjectCreate => 2
    BuiltinFunction::ObjectKeys => 1
    BuiltinFunction::ObjectValues => 1
    BuiltinFunction::ObjectEntries => 1
    BuiltinFunction::ObjectGroupBy => 2
    BuiltinFunction::ObjectIs => 2
    BuiltinFunction::ObjectIsExtensible => 1
    BuiltinFunction::ObjectPreventExtensions => 1
    BuiltinFunction::ObjectSeal => 1
    BuiltinFunction::ObjectIsSealed => 1
    BuiltinFunction::ObjectIsFrozen => 1
    BuiltinFunction::ObjectFreeze => 1
    BuiltinFunction::ObjectGetOwnPropertyDescriptors => 1
    BuiltinFunction::ObjectFromEntries => 1
    BuiltinFunction::ObjectAssign => 2
    BuiltinFunction::ObjectHasOwn => 2
    BuiltinFunction::ObjectToString => 0
    BuiltinFunction::ObjectToLocaleString => 0
    BuiltinFunction::ObjectValueOf => 0
    BuiltinFunction::ObjectHasOwnProperty => 1
    BuiltinFunction::ObjectPropertyIsEnumerable => 1
    BuiltinFunction::ObjectIsPrototypeOf => 1
    BuiltinFunction::ObjectProtoGet => 0
    BuiltinFunction::ObjectProtoSet => 1
    BuiltinFunction::ObjectDefineGetter => 2
    BuiltinFunction::ObjectDefineSetter => 2
    BuiltinFunction::ObjectLookupGetter => 1
    BuiltinFunction::ObjectLookupSetter => 1
    BuiltinFunction::ArrayToString => 0
    BuiltinFunction::ArrayToLocaleString => 0
    BuiltinFunction::ArrayConstructor => 1
    BuiltinFunction::ArrayIsArray => 1
    BuiltinFunction::ArrayFrom => 1
    BuiltinFunction::ArrayOf => 0
    BuiltinFunction::ArrayAt => 1
    BuiltinFunction::ArrayPush => 1
    BuiltinFunction::ArrayPop => 0
    BuiltinFunction::ArrayShift => 0
    BuiltinFunction::ArrayUnshift => 1
    BuiltinFunction::ArraySplice => 2
    BuiltinFunction::ArraySlice => 2
    BuiltinFunction::ArrayReverse => 0
    BuiltinFunction::ArrayConcat => 1
    BuiltinFunction::ArrayJoin => 1
    BuiltinFunction::ArrayIndexOf => 1
    BuiltinFunction::ArrayLastIndexOf => 1
    BuiltinFunction::ArrayIncludes => 1
    BuiltinFunction::ArrayCopyWithin => 2
    BuiltinFunction::ArrayFill => 1
    BuiltinFunction::ArrayFind => 1
    BuiltinFunction::ArrayFindIndex => 1
    BuiltinFunction::ArrayFindLast => 1
    BuiltinFunction::ArrayFindLastIndex => 1
    BuiltinFunction::ArrayFlat => 0
    BuiltinFunction::ArrayFlatMap => 1
    BuiltinFunction::ArrayToReversed => 0
    BuiltinFunction::ArrayToSorted => 1
    BuiltinFunction::ArrayToSpliced => 2
    BuiltinFunction::ArrayWith => 2
    BuiltinFunction::ArrayMap => 1
    BuiltinFunction::ArrayForEach => 1
    BuiltinFunction::ArrayFilter => 1
    BuiltinFunction::ArrayEvery => 1
    BuiltinFunction::ArraySome => 1
    BuiltinFunction::ArrayReduce => 1
    BuiltinFunction::ArrayReduceRight => 1
    BuiltinFunction::ArraySort => 1
    BuiltinFunction::ArrayValues => 0
    BuiltinFunction::ArrayKeys => 0
    BuiltinFunction::ArrayEntries => 0
    BuiltinFunction::ArrayIteratorNext => 0
    BuiltinFunction::IteratorReturnSelf => 0
    BuiltinFunction::AsyncIteratorReturnSelf => 0
    BuiltinFunction::AsyncFromSyncIteratorNext => 1
    BuiltinFunction::AsyncFromSyncIteratorReturn => 1
    BuiltinFunction::AsyncFromSyncIteratorThrow => 1
    BuiltinFunction::AsyncFromSyncIteratorUnwrap => 1
    BuiltinFunction::AsyncFromSyncIteratorCloseWrap => 1
    BuiltinFunction::IteratorConstructor => 0
    BuiltinFunction::IteratorFrom => 1
    BuiltinFunction::IteratorConcat => 0
    BuiltinFunction::IteratorConcatNext => 0
    BuiltinFunction::IteratorConcatReturn => 0
    BuiltinFunction::IteratorWrapNext => 0
    BuiltinFunction::IteratorWrapReturn => 0
    BuiltinFunction::IteratorHelperNext => 0
    BuiltinFunction::IteratorHelperReturn => 0
    BuiltinFunction::IteratorDrop => 1
    BuiltinFunction::IteratorFilter => 1
    BuiltinFunction::IteratorFlatMap => 1
    BuiltinFunction::IteratorMap => 1
    BuiltinFunction::IteratorTake => 1
    BuiltinFunction::IteratorEvery => 1
    BuiltinFunction::IteratorFind => 1
    BuiltinFunction::IteratorForEach => 1
    BuiltinFunction::IteratorSome => 1
    BuiltinFunction::IteratorReduce => 1
    BuiltinFunction::IteratorToArray => 0
    BuiltinFunction::IteratorConstructorGetter => 0
    BuiltinFunction::IteratorConstructorSetter => 1
    BuiltinFunction::IteratorToStringTagGetter => 0
    BuiltinFunction::IteratorToStringTagSetter => 1
    BuiltinFunction::FunctionCall => 1
    BuiltinFunction::FunctionApply => 2
    BuiltinFunction::FunctionBind => 1
    BuiltinFunction::FunctionToString => 0
    BuiltinFunction::FunctionProtoLineNumber => 0
    BuiltinFunction::FunctionProtoColumnNumber => 0
    BuiltinFunction::FunctionSymbolHasInstance => 1
    BuiltinFunction::FunctionConstructor => 1
    BuiltinFunction::GeneratorFunctionConstructor => 1
    BuiltinFunction::AsyncFunctionConstructor => 1
    BuiltinFunction::AsyncGeneratorFunctionConstructor => 1
    BuiltinFunction::BooleanConstructor => 1
    BuiltinFunction::BooleanToString => 0
    BuiltinFunction::BooleanValueOf => 0
    BuiltinFunction::StringConstructor => 1
    BuiltinFunction::StringFromCharCode => 1
    BuiltinFunction::StringFromCodePoint => 1
    BuiltinFunction::StringRaw => 1
    BuiltinFunction::StringCharCodeAt => 1
    BuiltinFunction::StringCharAt => 1
    BuiltinFunction::StringCodePointAt => 1
    BuiltinFunction::StringConcat => 1
    BuiltinFunction::StringSubstring => 2
    BuiltinFunction::StringSubstr => 2
    BuiltinFunction::StringSlice => 2
    BuiltinFunction::StringIndexOf => 1
    BuiltinFunction::StringLastIndexOf => 1
    BuiltinFunction::StringSplit => 2
    BuiltinFunction::StringPadStart => 1
    BuiltinFunction::StringReplace => 2
    BuiltinFunction::StringReplaceAll => 2
    BuiltinFunction::StringToString => 0
    BuiltinFunction::StringValueOf => 0
    BuiltinFunction::StringAt => 1
    BuiltinFunction::StringIncludes => 1
    BuiltinFunction::StringEndsWith => 1
    BuiltinFunction::StringStartsWith => 1
    BuiltinFunction::StringRepeat => 1
    BuiltinFunction::StringPadEnd => 1
    BuiltinFunction::StringTrim => 0
    BuiltinFunction::StringTrimStart => 0
    BuiltinFunction::StringTrimEnd => 0
    BuiltinFunction::StringToLowerCase => 0
    BuiltinFunction::StringToUpperCase => 0
    BuiltinFunction::StringToLocaleLowerCase => 0
    BuiltinFunction::StringToLocaleUpperCase => 0
    BuiltinFunction::StringLocaleCompare => 1
    BuiltinFunction::StringNormalize => 0
    BuiltinFunction::StringIsWellFormed => 0
    BuiltinFunction::StringToWellFormed => 0
    BuiltinFunction::StringMatch => 1
    BuiltinFunction::StringMatchAll => 1
    BuiltinFunction::StringSearch => 1
    BuiltinFunction::StringIterator => 0
    BuiltinFunction::StringIteratorNext => 0
    BuiltinFunction::StringAnchor => 1
    BuiltinFunction::StringBig => 0
    BuiltinFunction::StringBlink => 0
    BuiltinFunction::StringBold => 0
    BuiltinFunction::StringFixed => 0
    BuiltinFunction::StringFontcolor => 1
    BuiltinFunction::StringFontsize => 1
    BuiltinFunction::StringItalics => 0
    BuiltinFunction::StringLink => 1
    BuiltinFunction::StringSmall => 0
    BuiltinFunction::StringStrike => 0
    BuiltinFunction::StringSub => 0
    BuiltinFunction::StringSup => 0
    BuiltinFunction::NumberConstructor => 1
    BuiltinFunction::NumberIsNaN => 1
    BuiltinFunction::NumberIsFinite => 1
    BuiltinFunction::NumberIsInteger => 1
    BuiltinFunction::NumberIsSafeInteger => 1
    BuiltinFunction::NumberToString => 1
    BuiltinFunction::NumberToLocaleString => 0
    BuiltinFunction::NumberToFixed => 1
    BuiltinFunction::NumberToExponential => 1
    BuiltinFunction::NumberToPrecision => 1
    BuiltinFunction::NumberValueOf => 0
    BuiltinFunction::BigIntConstructor => 1
    BuiltinFunction::BigIntToString => 0
    BuiltinFunction::BigIntValueOf => 0
    BuiltinFunction::BigIntAsIntN => 2
    BuiltinFunction::BigIntAsUintN => 2
    BuiltinFunction::SymbolConstructor => 0
    BuiltinFunction::SymbolFor => 1
    BuiltinFunction::SymbolKeyFor => 1
    BuiltinFunction::SymbolToString => 0
    BuiltinFunction::SymbolValueOf => 0
    BuiltinFunction::SymbolToPrimitive => 1
    BuiltinFunction::SymbolDescription => 0
    BuiltinFunction::ParseInt => 2
    BuiltinFunction::ParseFloat => 1
    BuiltinFunction::DecodeURI => 1
    BuiltinFunction::DecodeURIComponent => 1
    BuiltinFunction::EncodeURI => 1
    BuiltinFunction::EncodeURIComponent => 1
    BuiltinFunction::Escape => 1
    BuiltinFunction::Unescape => 1
    BuiltinFunction::MathAbs => 1
    BuiltinFunction::MathAcos => 1
    BuiltinFunction::MathAcosh => 1
    BuiltinFunction::MathAsin => 1
    BuiltinFunction::MathAsinh => 1
    BuiltinFunction::MathAtan => 1
    BuiltinFunction::MathAtan2 => 2
    BuiltinFunction::MathAtanh => 1
    BuiltinFunction::MathCbrt => 1
    BuiltinFunction::MathCeil => 1
    BuiltinFunction::MathClz32 => 1
    BuiltinFunction::MathCos => 1
    BuiltinFunction::MathCosh => 1
    BuiltinFunction::MathExp => 1
    BuiltinFunction::MathExpm1 => 1
    BuiltinFunction::MathFloor => 1
    BuiltinFunction::MathFround => 1
    BuiltinFunction::MathF16Round => 1
    BuiltinFunction::MathHypot => 2
    BuiltinFunction::MathImul => 2
    BuiltinFunction::MathLog => 1
    BuiltinFunction::MathLog1p => 1
    BuiltinFunction::MathLog2 => 1
    BuiltinFunction::MathLog10 => 1
    BuiltinFunction::MathMax => 2
    BuiltinFunction::MathMin => 2
    BuiltinFunction::MathPow => 2
    BuiltinFunction::MathRandom => 0
    BuiltinFunction::MathRound => 1
    BuiltinFunction::MathSign => 1
    BuiltinFunction::MathSin => 1
    BuiltinFunction::MathSinh => 1
    BuiltinFunction::MathSqrt => 1
    BuiltinFunction::MathTan => 1
    BuiltinFunction::MathTanh => 1
    BuiltinFunction::MathTrunc => 1
    BuiltinFunction::MathSumPrecise => 1
    BuiltinFunction::RegExpConstructor => 2
    BuiltinFunction::RegExpExec => 1
    BuiltinFunction::RegExpTest => 1
    BuiltinFunction::RegExpToString => 0
    BuiltinFunction::RegExpCompile => 2
    BuiltinFunction::RegExpEscape => 1
    BuiltinFunction::RegExpGetFlags => 0
    BuiltinFunction::RegExpGetSource => 0
    BuiltinFunction::RegExpGetGlobal => 0
    BuiltinFunction::RegExpGetIgnoreCase => 0
    BuiltinFunction::RegExpGetMultiline => 0
    BuiltinFunction::RegExpGetDotAll => 0
    BuiltinFunction::RegExpGetUnicode => 0
    BuiltinFunction::RegExpGetUnicodeSets => 0
    BuiltinFunction::RegExpGetSticky => 0
    BuiltinFunction::RegExpGetHasIndices => 0
    BuiltinFunction::RegExpSymbolMatch => 1
    BuiltinFunction::RegExpSymbolMatchAll => 1
    BuiltinFunction::RegExpSymbolReplace => 2
    BuiltinFunction::RegExpSymbolSearch => 1
    BuiltinFunction::RegExpSymbolSplit => 2
    BuiltinFunction::RegExpStringIteratorNext => 0
    BuiltinFunction::SpeciesGetter => 0
    BuiltinFunction::DateConstructor => 7
    BuiltinFunction::DateParse => 1
    BuiltinFunction::DateUTC => 7
    BuiltinFunction::DateNow => 0
    BuiltinFunction::DateToISOString => 0
    BuiltinFunction::DateToString => 0
    BuiltinFunction::DateSymbolToPrimitive => 1
    BuiltinFunction::DateValueOf => 0
    BuiltinFunction::DateToUTCString => 0
    BuiltinFunction::DateToDateString => 0
    BuiltinFunction::DateToTimeString => 0
    BuiltinFunction::DateToLocaleString => 0
    BuiltinFunction::DateToLocaleDateString => 0
    BuiltinFunction::DateToLocaleTimeString => 0
    BuiltinFunction::DateToJSON => 1
    BuiltinFunction::DateGetTimezoneOffset => 0
    BuiltinFunction::DateGetTime => 0
    BuiltinFunction::DateGetYear => 0
    BuiltinFunction::DateGetFullYear => 0
    BuiltinFunction::DateGetUTCFullYear => 0
    BuiltinFunction::DateGetMonth => 0
    BuiltinFunction::DateGetUTCMonth => 0
    BuiltinFunction::DateGetDate => 0
    BuiltinFunction::DateGetUTCDate => 0
    BuiltinFunction::DateGetDay => 0
    BuiltinFunction::DateGetUTCDay => 0
    BuiltinFunction::DateGetHours => 0
    BuiltinFunction::DateGetUTCHours => 0
    BuiltinFunction::DateGetMinutes => 0
    BuiltinFunction::DateGetUTCMinutes => 0
    BuiltinFunction::DateGetSeconds => 0
    BuiltinFunction::DateGetUTCSeconds => 0
    BuiltinFunction::DateGetMilliseconds => 0
    BuiltinFunction::DateGetUTCMilliseconds => 0
    BuiltinFunction::DateSetTime => 1
    BuiltinFunction::DateSetMilliseconds => 1
    BuiltinFunction::DateSetUTCMilliseconds => 1
    BuiltinFunction::DateSetSeconds => 2
    BuiltinFunction::DateSetUTCSeconds => 2
    BuiltinFunction::DateSetMinutes => 3
    BuiltinFunction::DateSetUTCMinutes => 3
    BuiltinFunction::DateSetHours => 4
    BuiltinFunction::DateSetUTCHours => 4
    BuiltinFunction::DateSetDate => 1
    BuiltinFunction::DateSetUTCDate => 1
    BuiltinFunction::DateSetMonth => 2
    BuiltinFunction::DateSetUTCMonth => 2
    BuiltinFunction::DateSetYear => 1
    BuiltinFunction::DateSetFullYear => 3
    BuiltinFunction::DateSetUTCFullYear => 3
    BuiltinFunction::PromiseConstructor => 1
    BuiltinFunction::PromiseResolve => 1
    BuiltinFunction::PromiseReject => 1
    BuiltinFunction::PromiseThen => 2
    BuiltinFunction::PromiseCatch => 1
    BuiltinFunction::PromiseFinally => 1
    BuiltinFunction::PromiseAll => 1
    BuiltinFunction::PromiseAllSettled => 1
    BuiltinFunction::PromiseAny => 1
    BuiltinFunction::PromiseRace => 1
    BuiltinFunction::PromiseTry => 1
    BuiltinFunction::PromiseWithResolvers => 0
    BuiltinFunction::PromiseReactionJob => 0
    BuiltinFunction::PromiseResolveFunction => 1
    BuiltinFunction::PromiseRejectFunction => 1
    BuiltinFunction::PromiseResolveThenableJob => 0
    BuiltinFunction::PromiseAllResolveElement => 1
    BuiltinFunction::PromiseThenFinally => 1
    BuiltinFunction::PromiseFinallyValueThunk => 0
    BuiltinFunction::PromiseFinallyThrower => 0
    BuiltinFunction::PromiseCapabilityExecutor => 2
    BuiltinFunction::ReflectApply => 3
    BuiltinFunction::ReflectConstruct => 2
    BuiltinFunction::ReflectGet => 2
    BuiltinFunction::ReflectGetOwnPropertyDescriptor => 2
    BuiltinFunction::ReflectGetPrototypeOf => 1
    BuiltinFunction::ReflectDefineProperty => 3
    BuiltinFunction::ReflectHas => 2
    BuiltinFunction::ReflectIsExtensible => 1
    BuiltinFunction::ReflectSet => 3
    BuiltinFunction::ReflectSetPrototypeOf => 2
    BuiltinFunction::ReflectDeleteProperty => 2
    BuiltinFunction::ReflectPreventExtensions => 1
    BuiltinFunction::ReflectOwnKeys => 1
    BuiltinFunction::Eval => 1
    BuiltinFunction::ModuleImport => 1
    BuiltinFunction::ModuleImportDynamic => 1
    BuiltinFunction::ModuleImportDynamicJob => 0
    BuiltinFunction::ModuleImportBinding => 2
    BuiltinFunction::ModuleBinding => 1
    BuiltinFunction::ModuleExport => 2
    BuiltinFunction::ModuleExportStar => 1
    BuiltinFunction::ModuleAsyncFulfilled => 1
    BuiltinFunction::ModuleAsyncRejected => 1
    BuiltinFunction::IsNaN => 1
    BuiltinFunction::IsFinite => 1
    BuiltinFunction::GeneratorNext => 1
    BuiltinFunction::GeneratorReturn => 1
    BuiltinFunction::GeneratorThrow => 1
    BuiltinFunction::AsyncGeneratorNext => 1
    BuiltinFunction::AsyncGeneratorReturn => 1
    BuiltinFunction::AsyncGeneratorThrow => 1
    BuiltinFunction::AsyncFunctionResolveFunction => 1
    BuiltinFunction::AsyncGeneratorResolveFunction => 1
    BuiltinFunction::MapConstructor => 0
    BuiltinFunction::MapGroupBy => 2
    BuiltinFunction::MapGet => 1
    BuiltinFunction::MapGetOrInsert => 2
    BuiltinFunction::MapGetOrInsertComputed => 2
    BuiltinFunction::MapSet => 2
    BuiltinFunction::MapHas => 1
    BuiltinFunction::MapDelete => 1
    BuiltinFunction::MapClear => 0
    BuiltinFunction::MapForEach => 1
    BuiltinFunction::MapSize => 0
    BuiltinFunction::MapKeys => 0
    BuiltinFunction::MapValues => 0
    BuiltinFunction::MapEntries => 0
    BuiltinFunction::MapIteratorNext => 0
    BuiltinFunction::SetConstructor => 0
    BuiltinFunction::SetAdd => 1
    BuiltinFunction::SetHas => 1
    BuiltinFunction::SetDelete => 1
    BuiltinFunction::SetClear => 0
    BuiltinFunction::SetForEach => 1
    BuiltinFunction::SetSize => 0
    BuiltinFunction::SetValues => 0
    BuiltinFunction::SetEntries => 0
    BuiltinFunction::SetIsDisjointFrom => 1
    BuiltinFunction::SetIsSubsetOf => 1
    BuiltinFunction::SetIsSupersetOf => 1
    BuiltinFunction::SetIntersection => 1
    BuiltinFunction::SetDifference => 1
    BuiltinFunction::SetSymmetricDifference => 1
    BuiltinFunction::SetUnion => 1
    BuiltinFunction::SetIteratorNext => 0
    BuiltinFunction::WeakMapConstructor => 0
    BuiltinFunction::WeakMapGet => 1
    BuiltinFunction::WeakMapGetOrInsert => 2
    BuiltinFunction::WeakMapGetOrInsertComputed => 2
    BuiltinFunction::WeakMapSet => 2
    BuiltinFunction::WeakMapHas => 1
    BuiltinFunction::WeakMapDelete => 1
    BuiltinFunction::WeakSetConstructor => 0
    BuiltinFunction::WeakSetAdd => 1
    BuiltinFunction::WeakSetHas => 1
    BuiltinFunction::WeakSetDelete => 1
    BuiltinFunction::WeakRefConstructor => 1
    BuiltinFunction::WeakRefDeref => 0
    BuiltinFunction::FinalizationRegistryConstructor => 1
    BuiltinFunction::FinalizationRegistryRegister => 2
    BuiltinFunction::FinalizationRegistryUnregister => 1
    BuiltinFunction::ArrayBufferIsView => 1
    BuiltinFunction::ArrayBufferByteLength => 0
    BuiltinFunction::ArrayBufferMaxByteLength => 0
    BuiltinFunction::ArrayBufferResizable => 0
    BuiltinFunction::ArrayBufferDetached => 0
    BuiltinFunction::ArrayBufferConstructor => 1
    BuiltinFunction::SharedArrayBufferConstructor => 1
    BuiltinFunction::ArrayBufferSlice => 2
    BuiltinFunction::ArrayBufferTransfer => 0
    BuiltinFunction::ArrayBufferTransferToFixedLength => 0
    BuiltinFunction::ArrayBufferResize => 1
    BuiltinFunction::SharedArrayBufferByteLength => 0
    BuiltinFunction::SharedArrayBufferMaxByteLength => 0
    BuiltinFunction::SharedArrayBufferGrowable => 0
    BuiltinFunction::SharedArrayBufferGrow => 1
    BuiltinFunction::SharedArrayBufferSlice => 2
    BuiltinFunction::AtomicsAdd => 3
    BuiltinFunction::AtomicsAnd => 3
    BuiltinFunction::AtomicsOr => 3
    BuiltinFunction::AtomicsSub => 3
    BuiltinFunction::AtomicsXor => 3
    BuiltinFunction::AtomicsExchange => 3
    BuiltinFunction::AtomicsCompareExchange => 4
    BuiltinFunction::AtomicsLoad => 2
    BuiltinFunction::AtomicsStore => 3
    BuiltinFunction::AtomicsIsLockFree => 1
    BuiltinFunction::AtomicsPause => 0
    BuiltinFunction::AtomicsWait => 4
    BuiltinFunction::AtomicsNotify => 3
    BuiltinFunction::DataViewConstructor => 1
    BuiltinFunction::DataViewGetBuffer => 0
    BuiltinFunction::DataViewGetByteLength => 0
    BuiltinFunction::DataViewGetByteOffset => 0
    BuiltinFunction::DataViewGetInt8 => 1
    BuiltinFunction::DataViewGetUint8 => 1
    BuiltinFunction::DataViewGetInt16 => 1
    BuiltinFunction::DataViewGetUint16 => 1
    BuiltinFunction::DataViewGetInt32 => 1
    BuiltinFunction::DataViewGetUint32 => 1
    BuiltinFunction::DataViewGetBigInt64 => 1
    BuiltinFunction::DataViewGetBigUint64 => 1
    BuiltinFunction::DataViewGetFloat16 => 1
    BuiltinFunction::DataViewGetFloat32 => 1
    BuiltinFunction::DataViewGetFloat64 => 1
    BuiltinFunction::DataViewSetInt8 => 2
    BuiltinFunction::DataViewSetUint8 => 2
    BuiltinFunction::DataViewSetInt16 => 2
    BuiltinFunction::DataViewSetUint16 => 2
    BuiltinFunction::DataViewSetInt32 => 2
    BuiltinFunction::DataViewSetUint32 => 2
    BuiltinFunction::DataViewSetBigInt64 => 2
    BuiltinFunction::DataViewSetBigUint64 => 2
    BuiltinFunction::DataViewSetFloat16 => 2
    BuiltinFunction::DataViewSetFloat32 => 2
    BuiltinFunction::DataViewSetFloat64 => 2
    BuiltinFunction::TypedArrayConstructor => 0
    BuiltinFunction::TypedArrayFrom => 1
    BuiltinFunction::TypedArrayOf => 0
    BuiltinFunction::TypedArrayGetLength => 0
    BuiltinFunction::TypedArrayGetBuffer => 0
    BuiltinFunction::TypedArrayGetByteLength => 0
    BuiltinFunction::TypedArrayGetByteOffset => 0
    BuiltinFunction::TypedArrayGetToStringTag => 0
    BuiltinFunction::TypedArrayAt => 1
    BuiltinFunction::TypedArrayWith => 2
    BuiltinFunction::TypedArrayValues => 0
    BuiltinFunction::TypedArrayKeys => 0
    BuiltinFunction::TypedArrayEntries => 0
    BuiltinFunction::TypedArrayCopyWithin => 2
    BuiltinFunction::TypedArrayEvery => 1
    BuiltinFunction::TypedArraySome => 1
    BuiltinFunction::TypedArrayForEach => 1
    BuiltinFunction::TypedArrayMap => 1
    BuiltinFunction::TypedArrayFilter => 1
    BuiltinFunction::TypedArrayReduce => 1
    BuiltinFunction::TypedArrayReduceRight => 1
    BuiltinFunction::TypedArrayFind => 1
    BuiltinFunction::TypedArrayFindIndex => 1
    BuiltinFunction::TypedArrayFindLast => 1
    BuiltinFunction::TypedArrayFindLastIndex => 1
    BuiltinFunction::TypedArrayReverse => 0
    BuiltinFunction::TypedArrayToReversed => 0
    BuiltinFunction::TypedArraySlice => 2
    BuiltinFunction::TypedArraySubarray => 2
    BuiltinFunction::TypedArraySort => 1
    BuiltinFunction::TypedArrayToSorted => 1
    BuiltinFunction::TypedArrayJoin => 1
    BuiltinFunction::TypedArrayToLocaleString => 0
    BuiltinFunction::TypedArrayIndexOf => 1
    BuiltinFunction::TypedArrayLastIndexOf => 1
    BuiltinFunction::TypedArrayIncludes => 1
    BuiltinFunction::Uint8ArrayConstructor => 3
    BuiltinFunction::Int8ArrayConstructor => 3
    BuiltinFunction::Uint8ClampedArrayConstructor => 3
    BuiltinFunction::Uint16ArrayConstructor => 3
    BuiltinFunction::Int16ArrayConstructor => 3
    BuiltinFunction::Uint32ArrayConstructor => 3
    BuiltinFunction::Int32ArrayConstructor => 3
    BuiltinFunction::BigInt64ArrayConstructor => 3
    BuiltinFunction::BigUint64ArrayConstructor => 3
    BuiltinFunction::Float16ArrayConstructor => 3
    BuiltinFunction::Float32ArrayConstructor => 3
    BuiltinFunction::Float64ArrayConstructor => 3
    BuiltinFunction::WorkerConstructor => 1
    BuiltinFunction::WorkerPostMessage => 1
    BuiltinFunction::TypedArraySet => 1
    BuiltinFunction::TypedArrayFill => 1
    BuiltinFunction::StdSprintf => 1
    BuiltinFunction::StdLoadScript => 1
    BuiltinFunction::StdTmpfile => 0
    BuiltinFunction::StdOpen => 2
    BuiltinFunction::StdLoadFile => 1
    BuiltinFunction::StdPopen => 2
    BuiltinFunction::StdParseExtJSON => 1
    BuiltinFunction::StdFdopen => 2
    BuiltinFunction::FilePuts => 1
    BuiltinFunction::FilePutByte => 1
    BuiltinFunction::FileSeek => 2
    BuiltinFunction::FileTell => 0
    BuiltinFunction::FileRead => 3
    BuiltinFunction::FileReadAsString => 0
    BuiltinFunction::FileGetByte => 0
    BuiltinFunction::FileGetline => 0
    BuiltinFunction::FileEof => 0
    BuiltinFunction::FileClose => 0
    BuiltinFunction::StdGc => 0
    BuiltinFunction::Print => 1
    BuiltinFunction::Test262DetachArrayBuffer => 1
    BuiltinFunction::Test262EvalScript => 1
    BuiltinFunction::Test262CodePointRange => 2
    BuiltinFunction::Test262CreateRealm => 0
    BuiltinFunction::Test262Gc => 0
    BuiltinFunction::Test262IsHTMLDDA => 0
    BuiltinFunction::Test262AgentStart => 1
    BuiltinFunction::Test262AgentGetReport => 0
    BuiltinFunction::Test262AgentBroadcast => 2
    BuiltinFunction::Test262AgentReport => 1
    BuiltinFunction::Test262AgentLeaving => 0
    BuiltinFunction::Test262AgentReceiveBroadcast => 1
    BuiltinFunction::Test262AgentSleep => 1
    BuiltinFunction::Test262AgentMonotonicNow => 0
    BuiltinFunction::OsSetTimeout => 2
    BuiltinFunction::OsClearTimeout => 1
    BuiltinFunction::OsOpen => 2
    BuiltinFunction::OsClose => 1
    BuiltinFunction::OsRead => 4
    BuiltinFunction::OsWrite => 4
    BuiltinFunction::OsSeek => 3
    BuiltinFunction::OsReaddir => 1
    BuiltinFunction::OsStat => 1
    BuiltinFunction::OsLstat => 1
    BuiltinFunction::OsReadlink => 1
    BuiltinFunction::OsSymlink => 2
    BuiltinFunction::OsMkdir => 2
    BuiltinFunction::OsRemove => 1
    BuiltinFunction::OsUtimes => 3
    BuiltinFunction::OsGetcwd => 0
    BuiltinFunction::OsRealpath => 1
    BuiltinFunction::OsIsatty => 1
    BuiltinFunction::OsExec => 2
    BuiltinFunction::OsPipe => 0
    BuiltinFunction::OsWaitpid => 2
    BuiltinFunction::OsKill => 2
    BuiltinFunction::ErrorToString => 0
    BuiltinFunction::ErrorIsError => 1
    BuiltinFunction::ErrorConstructor => 1
    BuiltinFunction::AggregateErrorConstructor => 2
    BuiltinFunction::EvalErrorConstructor => 1
    BuiltinFunction::SyntaxErrorConstructor => 1
    BuiltinFunction::RangeErrorConstructor => 1
    BuiltinFunction::TypeErrorConstructor => 1
    BuiltinFunction::ReferenceErrorConstructor => 1
    BuiltinFunction::UriErrorConstructor => 1
    BuiltinFunction::ThrowTypeError => 0
  }
}

///|
fn bigint_bitwise_digit(op_kind : Int, x_digit : Int, y_digit : Int) -> Int {
  match op_kind {
    0 => if x_digit != 0 && y_digit != 0 { 1 } else { 0 }
    1 => if x_digit != 0 || y_digit != 0 { 1 } else { 0 }
    _ => if x_digit != y_digit { 1 } else { 0 }
  }
}

///|
fn bigint_mod2(value : @bigint.BigInt, two : @bigint.BigInt) -> Int {
  let mut rem = value.mod(two)
  if rem.compare_int(0) < 0 {
    rem = rem.add(two)
  }
  rem.to_int()
}

///|
fn bigint_is_terminal(value : @bigint.BigInt) -> Bool {
  value.compare_int(0) == 0 || value.compare_int(-1) == 0
}

///|
fn bigint_bitwise_op(
  left : @bigint.BigInt,
  right : @bigint.BigInt,
  op_kind : Int,
) -> @bigint.BigInt {
  let one = @bigint.BigInt::from_int(1)
  let two = @bigint.BigInt::from_int(2)
  let mut x = left
  let mut y = right
  let mut result = @bigint.BigInt::from_int(0)
  let mut pow2 = @bigint.BigInt::from_int(1)
  while !(bigint_is_terminal(x) && bigint_is_terminal(y)) {
    let x_digit = bigint_mod2(x, two)
    let y_digit = bigint_mod2(y, two)
    let digit = bigint_bitwise_digit(op_kind, x_digit, y_digit)
    if digit != 0 {
      result = result.add(pow2)
    }
    if x_digit != 0 {
      x = x.sub(one)
    }
    if y_digit != 0 {
      y = y.sub(one)
    }
    x = x.div(two)
    y = y.div(two)
    pow2 = pow2.mul(two)
  }
  let x_digit = bigint_mod2(x, two)
  let y_digit = bigint_mod2(y, two)
  let digit = bigint_bitwise_digit(op_kind, x_digit, y_digit)
  if digit != 0 {
    result = result.sub(pow2)
  }
  result
}

///|
fn eval_binary(
  op : @engine.BinaryOp,
  left : Value,
  right : Value,
) -> Value raise {
  match op {
    Add => eval_add(left, right)
    Sub => {
      let l = to_numeric(left)
      let r = to_numeric(right)
      match (l, r) {
        (BigInt(a), BigInt(b)) => BigInt(a.sub(b))
        (BigInt(_), _) => throw_type_error("cannot mix BigInt and other types")
        (_, BigInt(_)) => throw_type_error("cannot mix BigInt and other types")
        (Number(a), Number(b)) => Number(a - b)
        _ => Number(to_number(l) - to_number(r))
      }
    }
    Mul => {
      let l = to_numeric(left)
      let r = to_numeric(right)
      match (l, r) {
        (BigInt(a), BigInt(b)) => BigInt(a.mul(b))
        (BigInt(_), _) => throw_type_error("cannot mix BigInt and other types")
        (_, BigInt(_)) => throw_type_error("cannot mix BigInt and other types")
        (Number(a), Number(b)) => Number(a * b)
        _ => Number(to_number(l) * to_number(r))
      }
    }
    Div => {
      let l = to_numeric(left)
      let r = to_numeric(right)
      match (l, r) {
        (BigInt(a), BigInt(b)) =>
          if b.is_zero() {
            throw_range_error("BigInt division by zero")
          } else {
            BigInt(a.div(b))
          }
        (BigInt(_), _) => throw_type_error("cannot mix BigInt and other types")
        (_, BigInt(_)) => throw_type_error("cannot mix BigInt and other types")
        (Number(a), Number(b)) => Number(a / b)
        _ => Number(to_number(l) / to_number(r))
      }
    }
    Mod => {
      let l = to_numeric(left)
      let r = to_numeric(right)
      match (l, r) {
        (BigInt(a), BigInt(b)) =>
          if b.is_zero() {
            throw_range_error("BigInt division by zero")
          } else {
            BigInt(a.mod(b))
          }
        (BigInt(_), _) => throw_type_error("cannot mix BigInt and other types")
        (_, BigInt(_)) => throw_type_error("cannot mix BigInt and other types")
        (Number(a), Number(b)) => Number(Double::mod(a, b))
        _ => Number(Double::mod(to_number(l), to_number(r)))
      }
    }
    Pow => {
      let l = to_numeric(left)
      let r = to_numeric(right)
      match (l, r) {
        (BigInt(a), BigInt(b)) =>
          if b.compare_int(0) < 0 {
            throw_range_error("BigInt negative exponent")
          } else {
            BigInt(@bigint.BigInt::pow(a, b))
          }
        (BigInt(_), _) => throw_type_error("cannot mix BigInt and other types")
        (_, BigInt(_)) => throw_type_error("cannot mix BigInt and other types")
        (Number(a), Number(b)) => Number(@math.pow(a, b))
        _ => Number(@math.pow(to_number(l), to_number(r)))
      }
    }
    Shl => {
      let l = to_numeric(left)
      let r = to_numeric(right)
      match (l, r) {
        (BigInt(a), BigInt(b)) => {
          let shift = bigint_shift_count(b)
          if shift >= 0 {
            BigInt(a << shift)
          } else {
            BigInt(bigint_shift_right_floor(a, -shift))
          }
        }
        (BigInt(_), _) => throw_type_error("cannot mix BigInt and other types")
        (_, BigInt(_)) => throw_type_error("cannot mix BigInt and other types")
        _ => {
          let l = to_int32(to_number(l))
          let r = shift_count(r)
          Number(Double::from_int(l << r))
        }
      }
    }
    Sar => {
      let l = to_numeric(left)
      let r = to_numeric(right)
      match (l, r) {
        (BigInt(a), BigInt(b)) => {
          let shift = bigint_shift_count(b)
          if shift >= 0 {
            BigInt(bigint_shift_right_floor(a, shift))
          } else {
            BigInt(a << -shift)
          }
        }
        (BigInt(_), _) => throw_type_error("cannot mix BigInt and other types")
        (_, BigInt(_)) => throw_type_error("cannot mix BigInt and other types")
        _ => {
          let l = to_int32(to_number(l))
          let r = shift_count(r)
          Number(Double::from_int(l >> r))
        }
      }
    }
    Shr => {
      let l = to_numeric(left)
      let r = to_numeric(right)
      match (l, r) {
        (BigInt(_), _) => throw_type_error("cannot mix BigInt and other types")
        (_, BigInt(_)) => throw_type_error("cannot mix BigInt and other types")
        _ => {
          let l = to_uint32(to_number(l))
          let r = shift_count(r)
          let shifted = l >> r
          Number(UInt::to_double(shifted))
        }
      }
    }
    Lt => Bool(compare_values(left, right, CmpLt))
    Lte => Bool(compare_values(left, right, CmpLte))
    Gt => Bool(compare_values(left, right, CmpGt))
    Gte => Bool(compare_values(left, right, CmpGte))
    In => Bool(eval_in(left, right))
    Instanceof => Bool(eval_instanceof(left, right))
    Eq => Bool(loose_eq(left, right))
    Neq => Bool(!loose_eq(left, right))
    StrictEq => Bool(strict_eq(left, right))
    StrictNeq => Bool(!strict_eq(left, right))
    BitAnd => {
      let l = to_numeric(left)
      let r = to_numeric(right)
      match (l, r) {
        (BigInt(a), BigInt(b)) => BigInt(bigint_bitwise_op(a, b, 0))
        (BigInt(_), _) => throw_type_error("cannot mix BigInt and other types")
        (_, BigInt(_)) => throw_type_error("cannot mix BigInt and other types")
        _ => {
          let l = to_int32(to_number(l))
          let r = to_int32(to_number(r))
          Number(Double::from_int(Int::land(l, r)))
        }
      }
    }
    BitXor => {
      let l = to_numeric(left)
      let r = to_numeric(right)
      match (l, r) {
        (BigInt(a), BigInt(b)) => BigInt(bigint_bitwise_op(a, b, 2))
        (BigInt(_), _) => throw_type_error("cannot mix BigInt and other types")
        (_, BigInt(_)) => throw_type_error("cannot mix BigInt and other types")
        _ => {
          let l = to_int32(to_number(l))
          let r = to_int32(to_number(r))
          Number(Double::from_int(Int::lxor(l, r)))
        }
      }
    }
    BitOr => {
      let l = to_numeric(left)
      let r = to_numeric(right)
      match (l, r) {
        (BigInt(a), BigInt(b)) => BigInt(bigint_bitwise_op(a, b, 1))
        (BigInt(_), _) => throw_type_error("cannot mix BigInt and other types")
        (_, BigInt(_)) => throw_type_error("cannot mix BigInt and other types")
        _ => {
          let l = to_int32(to_number(l))
          let r = to_int32(to_number(r))
          Number(Double::from_int(Int::lor(l, r)))
        }
      }
    }
    LogicalAnd => left
    LogicalOr => left
    Coalesce => left
  }
}

///|
fn eval_add(left : Value, right : Value) -> Value raise {
  let mut l = left
  let mut r = right
  if is_object_like(l) {
    l = to_primitive_default(l)
  }
  if is_object_like(r) {
    r = to_primitive_default(r)
  }
  match (l, r) {
    (String(a), String(b)) => String(a + b)
    (String(a), b) =>
      if is_symbol_like(b) {
        throw_type_error("cannot convert symbol to string")
      } else {
        String(a + to_string_strict(b))
      }
    (a, String(b)) =>
      if is_symbol_like(a) {
        throw_type_error("cannot convert symbol to string")
      } else {
        String(to_string_strict(a) + b)
      }
    (BigInt(a), BigInt(b)) => BigInt(a.add(b))
    (BigInt(_), _) => throw_type_error("cannot mix BigInt and other types")
    (_, BigInt(_)) => throw_type_error("cannot mix BigInt and other types")
    (a, b) =>
      if is_symbol_like(a) || is_symbol_like(b) {
        throw_type_error("cannot convert symbol to number")
      } else {
        Number(to_number(a) + to_number(b))
      }
  }
}

///|
fn eval_in(left : Value, right : Value) -> Bool raise {
  if !is_object_like(right) {
    let _ = throw_type_error("invalid 'in' operand")
    return false
  }
  let name = property_key_name(left)
  has_property_value(right, name)
}

///|
fn eval_private_in(env : Env, name : String, target : Value) -> Bool raise {
  if !is_object_like(target) {
    let _ = throw_type_error("invalid 'in' operand")
    return false
  }
  let key_name = env_private_key_checked(env, name)
  match props_map_for_value(target) {
    Some(props) =>
      match props.get(key_name) {
        Some(_) => true
        None => false
      }
    None => false
  }
}

///|
fn eval_instanceof(left : Value, right : Value) -> Bool raise {
  if !is_object_like(right) {
    let _ = throw_type_error("invalid 'instanceof' right operand")
    return false
  }
  match symbol_has_instance_key() {
    Some(key) =>
      match property_get(right, key) {
        Undefined | Null => ()
        method_value => {
          if !is_callable(method_value) {
            let _ = throw_type_error("invalid 'instanceof' right operand")
            return false
          }
          let result = call_value_with_this(method_value, [left], right)
          return is_truthy(result)
        }
      }
    None => ()
  }
  if !is_callable(right) {
    let _ = throw_type_error("invalid 'instanceof' right operand")
    return false
  }
  ordinary_instanceof(left, right)
}

///|
fn is_callable(value : Value) -> Bool {
  match value {
    Function(_) => true
    BoundFunction(_) => true
    Builtin(_) => true
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => data.callable
        None => false
      }
    _ => false
  }
}

///|
fn has_property(value : Value, name : String) -> Bool raise {
  match value {
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => proxy_has_value(data, name)
        None =>
          match obj.string_data {
            Some(string_value) => {
              if name == "length" {
                return true
              }
              match parse_array_index(name) {
                Some(index) =>
                  if index >= 0 && index < string_value.length() {
                    return true
                  }
                None => ()
              }
              has_property_in_chain(obj.props, obj.proto, name)
            }
            None => has_property_in_chain(obj.props, obj.proto, name)
          }
      }
    Function(func) => {
      if name == "prototype" && !func.props.contains(name) {
        ensure_function_prototype(func)
      }
      has_property_in_chain(func.props, func.proto, name)
    }
    BoundFunction(bound) =>
      has_property_in_chain(bound.props, bound.proto, name)
    Builtin(builtin) =>
      has_property_in_chain(builtin.props, builtin.proto, name)
    Array(arr) => array_has_property(arr, name)
    Arguments(args) => arguments_has_property(args, name)
    String(value) => {
      if name == "length" {
        return true
      }
      match parse_array_index(name) {
        Some(index) => if index >= 0 && index < value.length() { return true }
        None => ()
      }
      match string_proto() {
        Some(proto) => has_property_in_chain(proto.props, proto.proto, name)
        None => false
      }
    }
    Number(_) =>
      match number_proto() {
        Some(proto) => has_property_in_chain(proto.props, proto.proto, name)
        None => false
      }
    BigInt(_) =>
      match bigint_proto() {
        Some(proto) => has_property_in_chain(proto.props, proto.proto, name)
        None => false
      }
    _ => false
  }
}

///|
fn has_property_value(value : Value, name : String) -> Bool raise {
  match value {
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => proxy_has_value(data, name)
        None => has_property(value, name)
      }
    _ => has_property(value, name)
  }
}

///|
fn arguments_has_property(args : ArgumentsValue, name : String) -> Bool raise {
  match parse_array_index(name) {
    Some(index) =>
      if index >= 0 && index < args.elements.length() {
        return arguments_has_index(args, index)
      }
    None => ()
  }
  if args.props.contains(name) {
    return true
  }
  match args.proto {
    Some(proto) => has_property(proto, name)
    None => false
  }
}

///|
fn has_property_in_chain(
  props : Map[String, Property],
  proto : Value?,
  name : String,
) -> Bool raise {
  if props.contains(name) {
    return true
  }
  match proto {
    Some(parent) => has_property(parent, name)
    None => false
  }
}

///|
fn get_proto_of_value(value : Value) -> Value? {
  match value {
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => get_proto_of_value(data.target)
        None => obj.proto
      }
    Function(func) => func.proto
    BoundFunction(bound) => bound.proto
    Builtin(builtin) => builtin.proto
    Array(arr) => arr.proto
    Arguments(args) => args.proto
    _ => None
  }
}

///|
fn get_proto_of_value_checked(value : Value) -> Value? raise {
  match value {
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => proxy_get_prototype(data)
        None => obj.proto
      }
    Function(func) => func.proto
    BoundFunction(bound) => bound.proto
    Builtin(builtin) => builtin.proto
    Array(arr) => arr.proto
    Arguments(args) => args.proto
    _ => None
  }
}

///|
fn same_proto(left : Value?, right : Value?) -> Bool {
  match (left, right) {
    (None, None) => true
    (Some(left_val), Some(right_val)) =>
      match (value_id(left_val), value_id(right_val)) {
        (Some(left_id), Some(right_id)) => left_id == right_id
        _ => false
      }
    _ => false
  }
}

///|
fn proto_chain_contains(start : Value?, target_id : Int) -> Bool {
  let seen : Map[Int, Bool] = Map::new()
  fn walk(current : Value?) -> Bool {
    match current {
      None => false
      Some(value) => {
        match value {
          Object(obj) => if obj.proxy_data is Some(_) { return false }
          _ => ()
        }
        match value_id(value) {
          None => false
          Some(id) => {
            if seen.contains(id) {
              return false
            }
            if id == target_id {
              return true
            }
            seen.set(id, true)
            walk(get_proto_of_value(value))
          }
        }
      }
    }
  }

  walk(start)
}

///|
fn set_proto_of_object(
  obj : ObjectValue,
  proto : Value?,
  throw_flag : Bool,
) -> Bool raise {
  if same_proto(obj.proto, proto) {
    return true
  }
  if obj.immutable_proto {
    if throw_flag {
      let _ = throw_type_error("prototype is immutable")

    }
    return false
  }
  if !obj.extensible {
    if throw_flag {
      let _ = throw_type_error("object is not extensible")

    }
    return false
  }
  if proto_chain_contains(proto, obj.id) {
    if throw_flag {
      let _ = throw_type_error("circular prototype chain")

    }
    return false
  }
  obj.proto = proto
  true
}

///|
fn set_proto_of_value(
  value : Value,
  proto : Value?,
  throw_flag : Bool,
) -> Bool raise {
  match value {
    Null | Undefined => {
      if throw_flag {
        let _ = throw_type_error("not an object")

      }
      false
    }
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => proxy_set_prototype(data, proto, throw_flag)
        None => set_proto_of_object(obj, proto, throw_flag)
      }
    Function(func) => {
      if same_proto(func.proto, proto) {
        return true
      }
      if !func.extensible {
        if throw_flag {
          let _ = throw_type_error("object is not extensible")

        }
        return false
      }
      func.proto = proto
      true
    }
    BoundFunction(bound) => {
      if same_proto(bound.proto, proto) {
        return true
      }
      if !bound.extensible {
        if throw_flag {
          let _ = throw_type_error("object is not extensible")

        }
        return false
      }
      bound.proto = proto
      true
    }
    Builtin(builtin) => {
      if same_proto(builtin.proto, proto) {
        return true
      }
      if !builtin.extensible {
        if throw_flag {
          let _ = throw_type_error("object is not extensible")

        }
        return false
      }
      builtin.proto = proto
      true
    }
    Array(arr) => {
      if same_proto(arr.proto, proto) {
        return true
      }
      if !arr.extensible {
        if throw_flag {
          let _ = throw_type_error("object is not extensible")

        }
        return false
      }
      arr.proto = proto
      true
    }
    Arguments(args) => {
      if same_proto(args.proto, proto) {
        return true
      }
      if !args.extensible {
        if throw_flag {
          let _ = throw_type_error("object is not extensible")

        }
        return false
      }
      args.proto = proto
      true
    }
    _ => true
  }
}

///|
fn object_seal(target : Value, freeze_flag : Bool) -> Value raise {
  if !is_object_like(target) {
    return target
  }
  let ok = prevent_extensions_value(target)
  if !ok {
    let _ = throw_type_error("proxy preventExtensions handler returned false")
    return target
  }
  let keys = own_property_keys_values(target)
  for key in keys {
    let name = match key {
      String(prop) => prop
      Symbol(symbol) => symbol_prop_key(symbol)
      _ => continue
    }
    let current = get_own_property_descriptor(target, name)
    match current {
      Undefined => ()
      _ =>
        if !is_object_like(current) {
          let _ = throw_type_error("invalid property descriptor")

        } else {
          let seal_desc = new_object_value()
          match seal_desc {
            Object(desc_obj) => {
              desc_obj.props.set("configurable", property_data(Bool(false)))
              if freeze_flag &&
                descriptor_is_data(current) &&
                is_truthy(property_get(current, "writable")) {
                desc_obj.props.set("writable", property_data(Bool(false)))
              }
            }
            _ => ()
          }
          let _ = define_property_value(target, key, seal_desc, true)

        }
    }
  }
  target
}

///|
fn object_is_sealed(target : Value, freeze_flag : Bool) -> Bool raise {
  if !is_object_like(target) {
    return true
  }
  let keys = own_property_keys_values(target)
  for key in keys {
    let name = match key {
      String(prop) => prop
      Symbol(symbol) => symbol_prop_key(symbol)
      _ => continue
    }
    let desc = get_own_property_descriptor(target, name)
    match desc {
      Undefined => ()
      _ =>
        if !is_object_like(desc) {
          let _ = throw_type_error("invalid property descriptor")
          return false
        } else {
          if is_truthy(property_get(desc, "configurable")) {
            return false
          }
          if freeze_flag &&
            descriptor_is_data(desc) &&
            is_truthy(property_get(desc, "writable")) {
            return false
          }
        }
    }
  }
  !is_extensible_value_checked(target)
}

///|
fn object_freeze(target : Value) -> Value raise {
  object_seal(target, true)
}

///|
fn ordinary_instanceof(left : Value, right : Value) -> Bool raise {
  if !is_object_like(left) {
    return false
  }
  match right {
    BoundFunction(bound) => return ordinary_instanceof(left, bound.target)
    _ => ()
  }
  let proto_value = property_get(right, "prototype")
  if !is_object_like(proto_value) {
    let _ = throw_type_error("operand 'prototype' property is not an object")
    return false
  }
  let proto_id = match value_id(proto_value) {
    Some(id) => id
    None => {
      let _ = throw_type_error("operand 'prototype' property is not an object")
      return false
    }
  }
  let mut current = get_proto_of_value_checked(left)
  for {
    match current {
      Some(obj) =>
        if value_id(obj) is Some(current_id) && current_id == proto_id {
          return true
        } else {
          current = get_proto_of_value_checked(obj)
          continue
        }
      None => return false
    }
  }
  false
}

///|
fn array_has_property(arr : ArrayValue, name : String) -> Bool raise {
  if name == "length" {
    return true
  }
  match arr.typed_array_data {
    Some(data) =>
      match canonical_numeric_index_string(name) {
        Some(index) => return typed_array_is_valid_integer_index(data, index)
        None => {
          if arr.props.contains(name) {
            return true
          }
          match arr.proto {
            Some(proto) => return has_property(proto, name)
            None => return false
          }
        }
      }
    None => ()
  }
  if arr.props.contains(name) {
    return true
  }
  match parse_array_index(name) {
    Some(index) =>
      if index >= 0 && index < arr.elements.length() {
        match arr.elements[index] {
          Some(_) => true
          None =>
            match arr.proto {
              Some(proto) => has_property(proto, name)
              None => false
            }
        }
      } else {
        match arr.proto {
          Some(proto) => has_property(proto, name)
          None => false
        }
      }
    None =>
      match arr.proto {
        Some(proto) => has_property(proto, name)
        None => false
      }
  }
}

///|
fn is_html_dda_value(value : Value) -> Bool {
  match value {
    Builtin(builtin) => builtin.is_html_dda
    Object(obj) => obj.is_html_dda
    _ => false
  }
}

///|
fn is_truthy(value : Value) -> Bool {
  if is_html_dda_value(value) {
    return false
  }
  match value {
    Undefined => false
    Null => false
    Bool(v) => v
    Number(v) => !Double::is_nan(v) && v != 0.0
    String(s) => !s.is_empty()
    BigInt(v) => !v.is_zero()
    Symbol(_) => true
    Builtin(_) => true
    Function(_) => true
    BoundFunction(_) => true
    Object(_) => true
    Array(_) => true
    Arguments(_) => true
  }
}

///|
fn is_nullish(value : Value) -> Bool {
  match value {
    Undefined => true
    Null => true
    _ => false
  }
}

///|
fn to_object(value : Value) -> Value raise {
  let env = current_env()
  match value {
    Object(_) => value
    Function(_) => value
    BoundFunction(_) => value
    Builtin(_) => value
    Array(_) => value
    Arguments(_) => value
    String(s) => {
      let proto = match env {
        Some(env) =>
          match value_from_object(string_proto_for_env(env)) {
            Some(value) => Some(value)
            None => value_from_object(string_proto())
          }
        None => value_from_object(string_proto())
      }
      new_string_object(s, proto~)
    }
    Number(n) => {
      let proto = match env {
        Some(env) =>
          match value_from_object(number_proto_for_env(env)) {
            Some(value) => Some(value)
            None => value_from_object(number_proto())
          }
        None => value_from_object(number_proto())
      }
      new_number_object(n, proto~)
    }
    Bool(b) => {
      let proto = match env {
        Some(env) =>
          match value_from_object(bool_proto_for_env(env)) {
            Some(value) => Some(value)
            None => value_from_object(bool_proto())
          }
        None => value_from_object(bool_proto())
      }
      new_bool_object(b, proto~)
    }
    BigInt(b) => {
      let proto = match env {
        Some(env) =>
          match value_from_object(bigint_proto_for_env(env)) {
            Some(value) => Some(value)
            None => value_from_object(bigint_proto())
          }
        None => value_from_object(bigint_proto())
      }
      new_bigint_object(b, proto~)
    }
    Symbol(symbol) => {
      let proto = match env {
        Some(env) =>
          match value_from_object(symbol_proto_for_env(env)) {
            Some(value) => Some(value)
            None => value_from_object(symbol_proto())
          }
        None => value_from_object(symbol_proto())
      }
      new_symbol_object(symbol, proto~)
    }
    Null => throw_type_error("cannot convert to object")
    Undefined => throw_type_error("cannot convert to object")
  }
}

///|
fn coerce_this(env : Env, value : Value) -> Value {
  match value {
    Undefined => global_object_value(env)
    Null => global_object_value(env)
    String(s) => {
      let proto = match value_from_object(string_proto_for_env(env)) {
        Some(value) => Some(value)
        None => value_from_object(string_proto())
      }
      new_string_object(s, proto~)
    }
    Number(n) => {
      let proto = match value_from_object(number_proto_for_env(env)) {
        Some(value) => Some(value)
        None => value_from_object(number_proto())
      }
      new_number_object(n, proto~)
    }
    Bool(b) => {
      let proto = match value_from_object(bool_proto_for_env(env)) {
        Some(value) => Some(value)
        None => value_from_object(bool_proto())
      }
      new_bool_object(b, proto~)
    }
    BigInt(b) => {
      let proto = match value_from_object(bigint_proto_for_env(env)) {
        Some(value) => Some(value)
        None => value_from_object(bigint_proto())
      }
      new_bigint_object(b, proto~)
    }
    Symbol(symbol) => {
      let proto = match value_from_object(symbol_proto_for_env(env)) {
        Some(value) => Some(value)
        None => value_from_object(symbol_proto())
      }
      new_symbol_object(symbol, proto~)
    }
    _ => value
  }
}

///|
fn bigint_to_number(value : @bigint.BigInt) -> Double {
  let text = value.to_string()
  try @strconv.parse_double(text) catch {
    _ => if text.has_prefix("-") { 0.0 - inf() } else { inf() }
  } noraise {
    value => value
  }
}

///|
fn bigint_from_double(value : Double) -> @bigint.BigInt? {
  if Double::is_nan(value) || Double::is_inf(value) {
    return None
  }
  let negative = value < 0.0
  let abs_value = Double::abs(value)
  let (mantissa, exp2) = double_to_parts(abs_value)
  let (num, den) = parts_to_fraction(mantissa, exp2)
  if den.is_zero() {
    return None
  }
  if !num.mod(den).is_zero() {
    return None
  }
  let mut result = num.div(den)
  if negative && !result.is_zero() {
    result = result.neg()
  }
  Some(result)
}

///|
fn bigint_from_value(value : Value) -> @bigint.BigInt raise {
  match value {
    BigInt(b) => b
    Bool(v) => @bigint.BigInt::from_int(if v { 1 } else { 0 })
    Number(n) =>
      match bigint_from_double(n) {
        Some(b) => b
        None => {
          let _ = throw_range_error("cannot convert to BigInt")
          @bigint.BigInt::from_int(0)
        }
      }
    String(s) => parse_bigint_string(s)
    Object(_) => {
      let prim = to_primitive(value, false)
      bigint_from_value(prim)
    }
    Null => {
      let _ = throw_type_error("cannot convert to BigInt")
      @bigint.BigInt::from_int(0)
    }
    Undefined => {
      let _ = throw_type_error("cannot convert to BigInt")
      @bigint.BigInt::from_int(0)
    }
    Array(_) | Builtin(_) | Function(_) | BoundFunction(_) | Arguments(_) => {
      let prim = to_primitive(value, false)
      bigint_from_value(prim)
    }
    _ => {
      let _ = throw_type_error("cannot convert to BigInt")
      @bigint.BigInt::from_int(0)
    }
  }
}

///|
fn to_bigint(value : Value) -> @bigint.BigInt raise {
  match value {
    BigInt(b) => b
    Bool(v) => @bigint.BigInt::from_int(if v { 1 } else { 0 })
    String(s) => parse_bigint_string(s)
    Object(_)
    | Array(_)
    | Builtin(_)
    | Function(_)
    | BoundFunction(_)
    | Arguments(_) => {
      let prim = to_primitive(value, false)
      to_bigint(prim)
    }
    _ => {
      let _ = throw_type_error("cannot convert to bigint")
      @bigint.BigInt::from_int(0)
    }
  }
}

///|
fn bigint_as_n(
  bits_value : Value,
  bigint_value : Value,
  as_int : Bool,
) -> Value raise {
  let bits64 = to_index_int64(bits_value)
  let value = to_bigint(bigint_value)
  let max_int = 2147483647
  if bits64 > Int64::from_int(max_int) {
    let _ = throw_range_error("invalid bit length")
    return BigInt(@bigint.BigInt::from_int(0))
  }
  if bits64 == 0L {
    return BigInt(@bigint.BigInt::from_int(0))
  }
  let bits = Int64::to_int(bits64)
  let modulus = @bigint.BigInt::from_int(1) << bits
  let mut result = value.mod(modulus)
  if result.compare_int(0) < 0 {
    result = result.add(modulus)
  }
  if as_int {
    let half = modulus >> 1
    if result.compare(half) >= 0 {
      result = result.sub(modulus)
    }
  }
  BigInt(result)
}

///|
fn this_to_bigint(this_value : Value?) -> @bigint.BigInt raise {
  match this_value {
    Some(BigInt(value)) => value
    Some(Object(obj)) =>
      match obj.bigint_data {
        Some(value) => value
        None => {
          let _ = throw_type_error("not a BigInt")
          @bigint.BigInt::from_int(0)
        }
      }
    Some(_) => {
      let _ = throw_type_error("not a BigInt")
      @bigint.BigInt::from_int(0)
    }
    None => {
      let _ = throw_type_error("not a BigInt")
      @bigint.BigInt::from_int(0)
    }
  }
}

///|
fn this_to_symbol(this_value : Value?) -> SymbolValue raise {
  match this_value {
    Some(Symbol(symbol)) => symbol
    Some(Object(obj)) =>
      match obj.symbol_data {
        Some(symbol) => symbol
        None => {
          let _ = throw_type_error("not a symbol")
          SymbolValue::{ id: 0, description: None, key: None }
        }
      }
    Some(_) => {
      let _ = throw_type_error("not a symbol")
      SymbolValue::{ id: 0, description: None, key: None }
    }
    None => {
      let _ = throw_type_error("not a symbol")
      SymbolValue::{ id: 0, description: None, key: None }
    }
  }
}

///|
fn bigint_to_string_radix(value : @bigint.BigInt, radix : Int) -> String {
  if value.is_zero() {
    return "0"
  }
  let negative = value.compare_int(0) < 0
  let abs_value = if negative { value.neg() } else { value }
  let digits = bigint_to_radix(abs_value, radix)
  if negative {
    "-" + digits
  } else {
    digits
  }
}

///|
fn strip_bigint_separators(
  lexeme : String,
  start : Int,
  end : Int,
  radix : Int,
) -> String raise {
  let mut index = start
  let mut any = false
  let mut prev_digit = false
  let underscore = Char::to_int('_')
  let sb = StringBuilder::new()
  while index < end {
    let unit = lexeme.code_unit_at(index)
    let code = UInt16::to_int(unit)
    if code == underscore {
      if !prev_digit || index + 1 >= end {
        fail("invalid bigint literal")
      }
      let next_unit = lexeme.code_unit_at(index + 1)
      let next_digit = digit_value(UInt16::to_int(next_unit))
      if next_digit < 0 || next_digit >= radix {
        fail("invalid bigint literal")
      }
      prev_digit = false
      index = index + 1
      continue
    }
    let digit = digit_value(code)
    if digit < 0 || digit >= radix {
      fail("invalid bigint literal")
    }
    sb.write_char(UInt16::unsafe_to_char(unit))
    any = true
    prev_digit = true
    index = index + 1
  }
  if !any || !prev_digit {
    fail("invalid bigint literal")
  }
  sb.to_string()
}

///|
fn parse_bigint_literal(lexeme : String) -> @bigint.BigInt raise {
  let mut index = 0
  let len = lexeme.length()
  let mut radix = 10
  if lexeme.has_prefix("0x") || lexeme.has_prefix("0X") {
    radix = 16
    index = 2
  } else if lexeme.has_prefix("0o") || lexeme.has_prefix("0O") {
    radix = 8
    index = 2
  } else if lexeme.has_prefix("0b") || lexeme.has_prefix("0B") {
    radix = 2
    index = 2
  }
  let digits = strip_bigint_separators(lexeme, index, len, radix)
  let view = digits.view(start_offset=0, end_offset=digits.length())
  let (value, ok) = parse_bigint_digits(view, radix)
  if !ok {
    fail("invalid bigint literal")
  }
  value
}

///|
fn parse_bigint_string(text : String) -> @bigint.BigInt raise {
  match parse_bigint_string_inner(text) {
    Some(value) => value
    None => {
      let _ = throw_syntax_error("invalid BigInt literal")
      @bigint.BigInt::from_int(0)
    }
  }
}

///|
fn parse_bigint_string_inner(text : String) -> @bigint.BigInt? {
  let trimmed = text.trim()
  if trimmed.is_empty() {
    return Some(@bigint.BigInt::from_int(0))
  }
  let len = trimmed.length()
  let mut index = 0
  let mut negative = false
  let mut has_sign = false
  let first = UInt16::to_int(trimmed.code_unit_at(0))
  if first == Char::to_int('+') || first == Char::to_int('-') {
    has_sign = true
    if first == Char::to_int('-') {
      negative = true
    }
    index = 1
  }
  if index >= len {
    return None
  }
  let mut radix = 10
  if index + 1 < len {
    let c0 = UInt16::to_int(trimmed.code_unit_at(index))
    let c1 = UInt16::to_int(trimmed.code_unit_at(index + 1))
    if c0 == Char::to_int('0') &&
      (c1 == Char::to_int('x') || c1 == Char::to_int('X')) {
      if has_sign {
        return None
      }
      radix = 16
      index = index + 2
    } else if c0 == Char::to_int('0') &&
      (c1 == Char::to_int('o') || c1 == Char::to_int('O')) {
      if has_sign {
        return None
      }
      radix = 8
      index = index + 2
    } else if c0 == Char::to_int('0') &&
      (c1 == Char::to_int('b') || c1 == Char::to_int('B')) {
      if has_sign {
        return None
      }
      radix = 2
      index = index + 2
    }
  }
  if index >= len {
    return None
  }
  let view = trimmed.view(start_offset=index, end_offset=len)
  let (value, ok) = parse_bigint_digits(view, radix)
  if !ok {
    return None
  }
  if negative && !value.is_zero() {
    Some(value.neg())
  } else {
    Some(value)
  }
}

///|
fn parse_bigint_digits(
  view : StringView,
  radix : Int,
) -> (@bigint.BigInt, Bool) {
  let mut value = @bigint.BigInt::from_int(0)
  let base = @bigint.BigInt::from_int(radix)
  let mut any = false
  for ch in view {
    let digit = digit_value(Char::to_int(ch))
    if digit < 0 || digit >= radix {
      return (value, false)
    }
    value = value.mul(base).add(@bigint.BigInt::from_int(digit))
    any = true
  }
  (value, any)
}

///|
fn call_primitive_method(value : Value, name : String) -> Value? raise {
  let method_value = property_get(value, name)
  if is_callable(method_value) {
    let result = call_value_with_this(method_value, [], value)
    if !is_object_like(result) {
      return Some(result)
    }
  }
  None
}

///|
fn to_primitive(value : Value, prefer_string : Bool) -> Value raise {
  if !is_object_like(value) {
    return value
  }
  match symbol_to_primitive_key() {
    Some(key) =>
      match property_get(value, key) {
        Undefined | Null => ()
        method_value => {
          let hint = if prefer_string { "string" } else { "number" }
          let result = call_value_with_this(method_value, [String(hint)], value)
          if !is_object_like(result) {
            return result
          }
          let _ = throw_type_error("toPrimitive")
          return Undefined
        }
      }
    None => ()
  }
  let first = if prefer_string { "toString" } else { "valueOf" }
  let second = if prefer_string { "valueOf" } else { "toString" }
  match call_primitive_method(value, first) {
    Some(result) => return result
    None => ()
  }
  match call_primitive_method(value, second) {
    Some(result) => return result
    None => ()
  }
  let _ = throw_type_error("cannot convert object to primitive")
  Undefined
}

///|
fn to_primitive_default(value : Value) -> Value raise {
  if !is_object_like(value) {
    return value
  }
  match symbol_to_primitive_key() {
    Some(key) =>
      match property_get(value, key) {
        Undefined | Null => ()
        method_value => {
          let result = call_value_with_this(
            method_value,
            [String("default")],
            value,
          )
          if !is_object_like(result) {
            return result
          }
          let _ = throw_type_error("toPrimitive")
          return Undefined
        }
      }
    None => ()
  }
  match call_primitive_method(value, "valueOf") {
    Some(result) => return result
    None => ()
  }
  match call_primitive_method(value, "toString") {
    Some(result) => return result
    None => ()
  }
  let _ = throw_type_error("cannot convert object to primitive")
  Undefined
}

///|
fn to_number(value : Value) -> Double raise {
  match value {
    Number(v) => v
    Bool(v) => if v { 1.0 } else { 0.0 }
    Null => 0.0
    Undefined => nan()
    String(s) => string_to_number(s)
    BigInt(_) => {
      let _ = throw_type_error("cannot convert bigint to number")
      nan()
    }
    Symbol(_) => {
      let _ = throw_type_error("cannot convert symbol to number")
      nan()
    }
    Object(_)
    | Array(_)
    | Builtin(_)
    | Function(_)
    | BoundFunction(_)
    | Arguments(_) => {
      let prim = to_primitive(value, false)
      to_number(prim)
    }
  }
}

///|
fn to_numeric(value : Value) -> Value raise {
  let prim = if is_object_like(value) {
    to_primitive(value, false)
  } else {
    value
  }
  match prim {
    BigInt(_) => prim
    _ => Number(to_number(prim))
  }
}

///|
fn to_string_value(value : Value) -> String {
  match value {
    String(s) => s
    Bool(v) => if v { "true" } else { "false" }
    Null => "null"
    Undefined => "undefined"
    Number(v) => Double::to_string(v)
    BigInt(v) => v.to_string()
    Symbol(symbol) => symbol_to_string(symbol)
    Builtin(builtin) => "function \{builtin_name(builtin.kind)}"
    Function(func) =>
      match func.name {
        Some(name) => "function \{name}"
        None => "function"
      }
    BoundFunction(bound) =>
      match bound.props.get("name") {
        Some(prop) =>
          match prop.value {
            String(name) =>
              if name.is_empty() {
                "function"
              } else {
                "function \{name}"
              }
            _ => "function"
          }
        None => "function"
      }
    Arguments(_) | Object(_) =>
      try {
        let prim = to_primitive(value, true)
        to_string_value(prim)
      } catch {
        _ => "[object Object]"
      }
    Array(arr) => array_to_string(arr)
  }
}

///|
fn to_string_strict(value : Value) -> String raise {
  if is_object_like(value) {
    let prim = to_primitive(value, true)
    return to_string_strict(prim)
  }
  match value {
    Symbol(_) => {
      let _ = throw_type_error("cannot convert symbol to string")
      ""
    }
    _ => to_string_value(value)
  }
}

///|
pub fn value_to_string(value : Value) -> String {
  to_string_value(value)
}

///|
pub fn format_error(value : Value) -> String {
  let stack_value = property_get(value, "stack") catch { _ => Undefined }
  match stack_value {
    String(stack) =>
      if stack.is_empty() {
        to_string_value(value)
      } else {
        stack
      }
    _ => {
      let mut message = to_string_value(value)
      let line_value = property_get(value, "lineNumber") catch {
        _ => Undefined
      }
      let column_value = property_get(value, "columnNumber") catch {
        _ => Undefined
      }
      match line_value {
        Number(line) => {
          message = message + " (line " + Double::to_string(line)
          match column_value {
            Number(column) =>
              message = message + ", column " + Double::to_string(column)
            _ => ()
          }
          message = message + ")"
          message
        }
        _ => message
      }
    }
  }
}

///|
pub fn error_name(value : Value) -> String? {
  match value {
    Object(obj) => {
      fn name_from_props(value : Value) -> String? {
        let name_value = property_get(value, "name") catch { _ => Undefined }
        match name_value {
          String(name) => return Some(name)
          _ => ()
        }
        let ctor_value = property_get(value, "constructor") catch {
          _ => Undefined
        }
        if is_object_like(ctor_value) {
          let ctor_name = property_get(ctor_value, "name") catch {
            _ => Undefined
          }
          match ctor_name {
            String(name) => return Some(name)
            _ => ()
          }
        }
        None
      }

      if !obj.is_error {
        name_from_props(value)
      } else {
        match obj.proto {
          Some(proto) =>
            match value_id(proto) {
              Some(proto_id) => {
                fn proto_matches(proto_opt : ObjectValue?) -> Bool {
                  match proto_opt {
                    Some(proto_obj) => proto_id == proto_obj.id
                    None => false
                  }
                }

                if proto_matches(syntax_error_proto()) {
                  Some("SyntaxError")
                } else if proto_matches(type_error_proto()) {
                  Some("TypeError")
                } else if proto_matches(reference_error_proto()) {
                  Some("ReferenceError")
                } else if proto_matches(range_error_proto()) {
                  Some("RangeError")
                } else if proto_matches(eval_error_proto()) {
                  Some("EvalError")
                } else if proto_matches(uri_error_proto()) {
                  Some("URIError")
                } else if proto_matches(aggregate_error_proto()) {
                  Some("AggregateError")
                } else if proto_matches(error_proto()) {
                  Some("Error")
                } else {
                  name_from_props(value)
                }
              }
              None => name_from_props(value)
            }
          None => name_from_props(value)
        }
      }
    }
    _ => None
  }
}

///|
fn this_to_string(this_value : Value?) -> String raise {
  match this_value {
    Some(String(value)) => value
    Some(Object(obj)) =>
      match obj.string_data {
        Some(value) => value
        None => {
          let _ = throw_type_error("not a string")
          ""
        }
      }
    Some(Null) => {
      let _ = throw_type_error("not a string")
      ""
    }
    Some(Undefined) => {
      let _ = throw_type_error("not a string")
      ""
    }
    Some(_) => {
      let _ = throw_type_error("not a string")
      ""
    }
    None => {
      let _ = throw_type_error("not a string")
      ""
    }
  }
}

///|
fn this_to_string_coerce(this_value : Value?) -> String raise {
  let value = match this_value {
    Some(inner) => inner
    None => Undefined
  }
  match value {
    Null => {
      let _ = throw_type_error("cannot convert to object")
      ""
    }
    Undefined => {
      let _ = throw_type_error("cannot convert to object")
      ""
    }
    _ => to_string_strict(value)
  }
}

///|
fn this_to_number(this_value : Value?) -> Double raise {
  match this_value {
    Some(Number(value)) => value
    Some(Object(obj)) =>
      match obj.number_data {
        Some(value) => value
        None => {
          let _ = throw_type_error("not a number")
          0.0
        }
      }
    Some(_) => {
      let _ = throw_type_error("not a number")
      0.0
    }
    None => {
      let _ = throw_type_error("not a number")
      0.0
    }
  }
}

///|
fn this_to_bool(this_value : Value?) -> Bool raise {
  match this_value {
    Some(Bool(value)) => value
    Some(Object(obj)) =>
      match obj.bool_data {
        Some(value) => value
        None => {
          let _ = throw_type_error("not a boolean")
          false
        }
      }
    Some(_) => {
      let _ = throw_type_error("not a boolean")
      false
    }
    None => {
      let _ = throw_type_error("not a boolean")
      false
    }
  }
}

///|
fn clamp_index(num : Double, len : Int) -> Int {
  if Double::is_nan(num) || num <= 0.0 {
    return 0
  }
  let max = Double::from_int(len)
  if num >= max {
    return len
  }
  Int64::to_int(Double::to_int64(Double::trunc(num)))
}

///|
fn slice_index(num : Double, len : Int) -> Int {
  if Double::is_nan(num) {
    return 0
  }
  if Double::is_inf(num) {
    return if num < 0.0 { 0 } else { len }
  }
  let value = Int64::to_int(Double::to_int64(Double::trunc(num)))
  if value < 0 {
    let adjusted = len + value
    if adjusted < 0 {
      0
    } else {
      adjusted
    }
  } else if value > len {
    len
  } else {
    value
  }
}

///|
fn clamp_last_index(num : Double, len : Int) -> Int {
  if Double::is_nan(num) {
    return len
  }
  if num < 0.0 {
    return 0
  }
  let max = Double::from_int(len)
  if num >= max {
    return len
  }
  Int64::to_int(Double::to_int64(Double::trunc(num)))
}

///|
fn to_int32_sat(num : Double) -> Int {
  if Double::is_nan(num) {
    return 0
  }
  if Double::is_inf(num) {
    return if num < 0.0 { -2147483648 } else { 2147483647 }
  }
  Int64::to_int(Double::to_int64(Double::trunc(num)))
}

///|
fn object_builtin_tag(value : Value) -> String raise {
  match value {
    Undefined => "Undefined"
    Null => "Null"
    Bool(_) => "Boolean"
    Number(_) => "Number"
    String(_) => "String"
    BigInt(_) => "BigInt"
    Symbol(_) => "Symbol"
    Function(_) => "Function"
    Builtin(_) => "Function"
    BoundFunction(_) => "Function"
    Array(_) => "Array"
    Arguments(_) => "Arguments"
    Object(obj) =>
      match obj.proxy_data {
        Some(data) => {
          proxy_check_revoked(data)
          match data.target {
            Function(_) => "Function"
            _ =>
              if is_array_value(data.target) {
                "Array"
              } else if is_callable(data.target) {
                "Function"
              } else {
                "Object"
              }
          }
        }
        None =>
          if is_array_proto_object(obj) {
            "Array"
          } else if obj.string_data is Some(_) {
            "String"
          } else if obj.number_data is Some(_) {
            "Number"
          } else if obj.bool_data is Some(_) {
            "Boolean"
          } else if obj.regexp_data is Some(_) {
            "RegExp"
          } else if obj.date_data is Some(_) {
            "Date"
          } else if obj.is_error {
            "Error"
          } else {
            "Object"
          }
      }
  }
}

///|
fn function_to_string_value(value : Value) -> String raise {
  if !is_callable(value) {
    let _ = throw_type_error("not a function")
    return ""
  }
  match value {
    Function(func) =>
      match func.source {
        Some(source) => return source
        None => ()
      }
    _ => ()
  }
  let mut prefix = "function "
  match value {
    Function(func) =>
      if func.is_async && func.is_generator {
        prefix = "async function *"
      } else if func.is_async {
        prefix = "async function "
      } else if func.is_generator {
        prefix = "function *"
      }
    _ => ()
  }
  let name_value = property_get(value, "name")
  let name = match name_value {
    String(value) => value
    _ => ""
  }
  prefix + name + "() {\n    [native code]\n}"
}

///|
fn object_to_string(value : Value) -> String raise {
  match value {
    Undefined => "[object Undefined]"
    Null => "[object Null]"
    _ => {
      let obj = to_object(value)
      let mut tag = object_builtin_tag(obj)
      match symbol_to_string_tag_key() {
        Some(key) =>
          match property_get(obj, key) {
            String(value) => tag = value
            _ => ()
          }
        None => ()
      }
      "[object " + tag + "]"
    }
  }
}

///|
fn to_int32(value : Double) -> Int {
  if Double::is_nan(value) || Double::is_inf(value) {
    return 0
  }
  let trunc = Double::trunc(value)
  let two32 = 4294967296.0
  let mut n = Double::mod(trunc, two32)
  if n < 0.0 {
    n = n + two32
  }
  if n >= 2147483648.0 {
    n = n - two32
  }
  Double::to_int(n)
}

///|
fn to_uint32(value : Double) -> UInt {
  if Double::is_nan(value) || Double::is_inf(value) {
    return UInt::default()
  }
  let trunc = Double::trunc(value)
  let two32 = 4294967296.0
  let mut n = Double::mod(trunc, two32)
  if n < 0.0 {
    n = n + two32
  }
  UInt::trunc_double(n)
}

///|
fn shift_count(value : Value) -> Int raise {
  let count = to_int32(to_number(value))
  Int::land(count, 0x1f)
}

///|
fn bigint_shift_count(value : @bigint.BigInt) -> Int {
  let max_shift = 2147483647
  if value.compare_int(max_shift) > 0 {
    return max_shift
  }
  if value.compare_int(-max_shift) < 0 {
    return -max_shift
  }
  value.to_int()
}

///|
fn bigint_shift_right_floor(
  value : @bigint.BigInt,
  shift : Int,
) -> @bigint.BigInt {
  if shift <= 0 {
    return value
  }
  if value.compare_int(0) >= 0 {
    return value >> shift
  }
  let abs = value.neg()
  let trunc = abs >> shift
  let restored = trunc << shift
  if restored.equal(abs) {
    trunc.neg()
  } else {
    trunc.neg().sub(@bigint.BigInt::from_int(1))
  }
}

///|
fn strict_eq(a : Value, b : Value) -> Bool {
  match (a, b) {
    (Undefined, Undefined) => true
    (Null, Null) => true
    (Bool(x), Bool(y)) => x == y
    (Number(x), Number(y)) => Double::equal(x, y)
    (String(x), String(y)) => x == y
    (BigInt(x), BigInt(y)) => x.equal(y)
    (Symbol(x), Symbol(y)) => x.id == y.id
    (Function(x), Function(y)) => x.id == y.id
    (BoundFunction(x), BoundFunction(y)) => x.id == y.id
    (Object(x), Object(y)) => x.id == y.id
    (Builtin(x), Builtin(y)) => x.id == y.id
    (Array(x), Array(y)) => x.id == y.id
    (Arguments(x), Arguments(y)) => x.id == y.id
    _ => false
  }
}

///|
fn loose_eq(a : Value, b : Value) -> Bool raise {
  if strict_eq(a, b) {
    return true
  }
  if is_html_dda_value(a) {
    match b {
      Null | Undefined => return true
      _ => ()
    }
  }
  if is_html_dda_value(b) {
    match a {
      Null | Undefined => return true
      _ => ()
    }
  }
  match (a, b) {
    (Null, Undefined) => true
    (Undefined, Null) => true
    (BigInt(x), Number(y)) => bigint_equal_number(x, y)
    (Number(x), BigInt(y)) => bigint_equal_number(y, x)
    (BigInt(x), String(y)) => bigint_equal_string(x, y)
    (String(x), BigInt(y)) => bigint_equal_string(y, x)
    (BigInt(x), BigInt(y)) => x.equal(y)
    (Bool(_), _) => loose_eq(Number(to_number(a)), b)
    (_, Bool(_)) => loose_eq(a, Number(to_number(b)))
    (Number(_), String(_)) =>
      strict_eq(Number(to_number(a)), Number(to_number(b)))
    (String(_), Number(_)) =>
      strict_eq(Number(to_number(a)), Number(to_number(b)))
    _ =>
      if is_object_like(a) && is_object_like(b) {
        false
      } else if is_object_like(a) {
        let prim = to_primitive_default(a)
        loose_eq(prim, b)
      } else if is_object_like(b) {
        let prim = to_primitive_default(b)
        loose_eq(a, prim)
      } else {
        false
      }
  }
}

///|
fn bigint_equal_number(value : @bigint.BigInt, num : Double) -> Bool {
  match bigint_from_double(num) {
    Some(other) => value.equal(other)
    None => false
  }
}

///|
fn bigint_equal_string(value : @bigint.BigInt, text : String) -> Bool {
  match parse_bigint_string_inner(text) {
    Some(other) => value.equal(other)
    None => false
  }
}

///|
enum CompareOp {
  CmpLt
  CmpLte
  CmpGt
  CmpGte
} derive(Show)

///|
fn compare_values(left : Value, right : Value, op : CompareOp) -> Bool raise {
  let mut l = left
  let mut r = right
  if is_object_like(l) {
    l = to_primitive(l, false)
  }
  if is_object_like(r) {
    r = to_primitive(r, false)
  }
  match (l, r) {
    (String(a), String(b)) => compare_string(a, b, op)
    (BigInt(a), String(text)) =>
      match parse_bigint_string_inner(text) {
        Some(b) => compare_bigint(a, b, op)
        None => false
      }
    (String(text), BigInt(b)) =>
      match parse_bigint_string_inner(text) {
        Some(a) => compare_bigint(a, b, op)
        None => false
      }
    (BigInt(a), BigInt(b)) => compare_bigint(a, b, op)
    (BigInt(a), _) => compare_bigint_number(a, to_number(r), op)
    (_, BigInt(b)) =>
      compare_bigint_number(b, to_number(l), reverse_compare_op(op))
    _ => {
      let l_num = to_number(l)
      let r_num = to_number(r)
      compare_number(l_num, r_num, op)
    }
  }
}

///|
fn compare_string(left : String, right : String, op : CompareOp) -> Bool {
  let cmp = string_lex_compare(left, right)
  match op {
    CmpLt => cmp < 0
    CmpLte => cmp <= 0
    CmpGt => cmp > 0
    CmpGte => cmp >= 0
  }
}

///|
fn string_lex_compare(left : String, right : String) -> Int {
  left.view().lexical_compare(right.view())
}

///|
fn compare_number(left : Double, right : Double, op : CompareOp) -> Bool {
  match op {
    CmpLt => left < right
    CmpLte => left <= right
    CmpGt => left > right
    CmpGte => left >= right
  }
}

///|
fn reverse_compare_op(op : CompareOp) -> CompareOp {
  match op {
    CmpLt => CmpGt
    CmpLte => CmpGte
    CmpGt => CmpLt
    CmpGte => CmpLte
  }
}

///|
fn compare_bigint(
  left : @bigint.BigInt,
  right : @bigint.BigInt,
  op : CompareOp,
) -> Bool {
  let cmp = left.compare(right)
  match op {
    CmpLt => cmp < 0
    CmpLte => cmp <= 0
    CmpGt => cmp > 0
    CmpGte => cmp >= 0
  }
}

///|
fn compare_bigint_number(
  left : @bigint.BigInt,
  right : Double,
  op : CompareOp,
) -> Bool {
  match bigint_number_cmp(left, right) {
    Some(cmp) =>
      match op {
        CmpLt => cmp < 0
        CmpLte => cmp <= 0
        CmpGt => cmp > 0
        CmpGte => cmp >= 0
      }
    None => false
  }
}

///|
fn bigint_number_cmp(left : @bigint.BigInt, right : Double) -> Int? {
  if Double::is_nan(right) {
    return None
  }
  if Double::is_inf(right) {
    return if right > 0.0 { Some(-1) } else { Some(1) }
  }
  let negative = right < 0.0
  let abs_value = Double::abs(right)
  let (mantissa, exp2) = double_to_parts(abs_value)
  let (num, den) = parts_to_fraction(mantissa, exp2)
  let signed_num = if negative { num.neg() } else { num }
  let left_scaled = left.mul(den)
  let cmp = left_scaled.compare(signed_num)
  if cmp < 0 {
    Some(-1)
  } else if cmp > 0 {
    Some(1)
  } else {
    Some(0)
  }
}

///|
fn nan() -> Double {
  0.0 / 0.0
}

///|
fn inf() -> Double {
  1.0 / 0.0
}

///|
fn negative_zero() -> Double {
  UInt64::reinterpret_as_double(0x8000000000000000UL)
}

///|
fn is_js_whitespace(code : Int) -> Bool {
  code == 0x0009 ||
  code == 0x000A ||
  code == 0x000B ||
  code == 0x000C ||
  code == 0x000D ||
  code == 0x0020 ||
  code == 0x00A0 ||
  code == 0x1680 ||
  (code >= 0x2000 && code <= 0x200A) ||
  code == 0x2028 ||
  code == 0x2029 ||
  code == 0x202F ||
  code == 0x205F ||
  code == 0x3000 ||
  code == 0xFEFF
}

///|
fn trim_js_whitespace(value : String) -> String {
  let len = value.length()
  let mut start = 0
  while start < len {
    let unit = UInt16::to_int(value.code_unit_at(start))
    if !is_js_whitespace(unit) {
      break
    }
    start = start + 1
  }
  let mut end = len
  while end > start {
    let unit = UInt16::to_int(value.code_unit_at(end - 1))
    if !is_js_whitespace(unit) {
      break
    }
    end = end - 1
  }
  if start == 0 && end == len {
    value
  } else {
    value.unsafe_substring(start~, end~)
  }
}

///|
fn trim_js_whitespace_start(value : String) -> String {
  let len = value.length()
  let mut start = 0
  while start < len {
    let unit = UInt16::to_int(value.code_unit_at(start))
    if !is_js_whitespace(unit) {
      break
    }
    start = start + 1
  }
  if start == 0 {
    value
  } else {
    value.unsafe_substring(start~, end=len)
  }
}

///|
fn trim_js_whitespace_end(value : String) -> String {
  let mut end = value.length()
  while end > 0 {
    let unit = UInt16::to_int(value.code_unit_at(end - 1))
    if !is_js_whitespace(unit) {
      break
    }
    end = end - 1
  }
  if end == value.length() {
    value
  } else {
    value.unsafe_substring(start=0, end~)
  }
}

///|
fn string_normalize_form(value : String, form : String) -> String raise {
  let valid = form == "NFC" || form == "NFD" || form == "NFKC" || form == "NFKD"
  if !valid {
    let _ = throw_range_error("invalid normalization form")

  }
  match form {
    "NFC" => unicode_normalize_string(value, UNICODE_NFC)
    "NFD" => unicode_normalize_string(value, UNICODE_NFD)
    "NFKC" => unicode_normalize_string(value, UNICODE_NFKC)
    _ => unicode_normalize_string(value, UNICODE_NFKD)
  }
}

///|
fn find_exponent_index(text : String, start : Int) -> Int? {
  let len = text.length()
  let mut index = start
  let lower_e = Char::to_int('e')
  let upper_e = Char::to_int('E')
  while index < len {
    let unit = UInt16::to_int(text.code_unit_at(index))
    if unit == lower_e || unit == upper_e {
      return Some(index)
    }
    index = index + 1
  }
  None
}

///|
fn scan_mantissa_digits(text : String, start : Int, end : Int) -> (Bool, Bool) {
  let mut has_digit = false
  let mut has_non_zero = false
  let mut index = start
  let zero = Char::to_int('0')
  let nine = Char::to_int('9')
  while index < end {
    let unit = UInt16::to_int(text.code_unit_at(index))
    if unit >= zero && unit <= nine {
      has_digit = true
      if unit != zero {
        has_non_zero = true
        break
      }
    }
    index = index + 1
  }
  (has_digit, has_non_zero)
}

///|
fn decimal_overflow_value(text : String) -> Double? {
  let len = text.length()
  if len == 0 {
    return None
  }
  let mut index = 0
  let mut negative = false
  let first = UInt16::to_int(text.code_unit_at(0))
  if first == Char::to_int('+') {
    index = 1
  } else if first == Char::to_int('-') {
    negative = true
    index = 1
  }
  let exp_index = match find_exponent_index(text, index) {
    Some(pos) => pos
    None => return None
  }
  let (has_digit, has_non_zero) = scan_mantissa_digits(text, index, exp_index)
  if !has_digit {
    return None
  }
  if !has_non_zero {
    return Some(if negative { negative_zero() } else { 0.0 })
  }
  let mut exp_start = exp_index + 1
  if exp_start >= len {
    return None
  }
  let mut exp_negative = false
  let exp_sign = UInt16::to_int(text.code_unit_at(exp_start))
  if exp_sign == Char::to_int('+') || exp_sign == Char::to_int('-') {
    exp_negative = exp_sign == Char::to_int('-')
    exp_start = exp_start + 1
  }
  if exp_start >= len {
    return None
  }
  let mut exp_value = 0
  let mut idx = exp_start
  let zero = Char::to_int('0')
  let nine = Char::to_int('9')
  while idx < len {
    let unit = UInt16::to_int(text.code_unit_at(idx))
    if unit < zero || unit > nine {
      return None
    }
    exp_value = exp_value * 10 + (unit - zero)
    idx = idx + 1
  }
  let exp = if exp_negative { -exp_value } else { exp_value }
  if exp > 308 {
    return Some(if negative { Double::neg(inf()) } else { inf() })
  }
  if exp < -324 {
    return Some(if negative { negative_zero() } else { 0.0 })
  }
  None
}

///|
fn string_to_number(value : String) -> Double {
  let trimmed = trim_js_whitespace(value)
  if trimmed.is_empty() {
    return 0.0
  }
  if trimmed.contains("_") {
    return nan()
  }
  if trimmed == "Infinity" || trimmed == "+Infinity" {
    return inf()
  }
  if trimmed == "-Infinity" {
    return 0.0 - inf()
  }
  let trimmed_lower = trimmed.to_lower()
  if trimmed_lower == "infinity" ||
    trimmed_lower == "+infinity" ||
    trimmed_lower == "-infinity" {
    return nan()
  }
  if trimmed.has_prefix("0x") || trimmed.has_prefix("0X") {
    let digits = trimmed
      .unsafe_substring(start=2, end=trimmed.length())
      .to_string_view()
    try Double::convert_uint64(@strconv.parse_uint64(digits, base=16)) catch {
      _ => nan()
    } noraise {
      value => value
    }
  } else if trimmed.has_prefix("0o") || trimmed.has_prefix("0O") {
    let digits = trimmed
      .unsafe_substring(start=2, end=trimmed.length())
      .to_string_view()
    try Double::convert_uint64(@strconv.parse_uint64(digits, base=8)) catch {
      _ => nan()
    } noraise {
      value => value
    }
  } else if trimmed.has_prefix("0b") || trimmed.has_prefix("0B") {
    let digits = trimmed
      .unsafe_substring(start=2, end=trimmed.length())
      .to_string_view()
    try Double::convert_uint64(@strconv.parse_uint64(digits, base=2)) catch {
      _ => nan()
    } noraise {
      value => value
    }
  } else {
    let mut sign = 1.0
    let mut start = 0
    if trimmed.has_prefix("+") {
      start = 1
    } else if trimmed.has_prefix("-") {
      sign = -1.0
      start = 1
    }
    if start == 1 {
      let body = trimmed.unsafe_substring(start=1, end=trimmed.length())
      if body.has_prefix("0x") ||
        body.has_prefix("0X") ||
        body.has_prefix("0o") ||
        body.has_prefix("0O") ||
        body.has_prefix("0b") ||
        body.has_prefix("0B") {
        return nan()
      }
    }
    try @strconv.parse_double(trimmed) catch {
      _ =>
        match decimal_overflow_value(trimmed) {
          Some(value) => value
          None => nan()
        }
    } noraise {
      value =>
        if value == 0.0 {
          let (has_digit, has_non_zero) = match
            find_exponent_index(trimmed, start) {
            Some(exp_index) => scan_mantissa_digits(trimmed, start, exp_index)
            None => scan_mantissa_digits(trimmed, start, trimmed.length())
          }
          if has_digit && !has_non_zero && sign < 0.0 {
            negative_zero()
          } else {
            value
          }
        } else {
          value
        }
    }
  }
}

///|
fn string_from_char_codes(args : Array[Value]) -> String raise {
  let units : Array[Int] = []
  for arg in args {
    let unit = to_uint16_from_double(to_number(arg))
    units.push(unit)
  }
  string_from_code_units(units)
}

///|
fn string_from_code_points(args : Array[Value]) -> String raise {
  let units : Array[Int] = []
  for arg in args {
    let num = to_number(arg)
    if Double::is_nan(num) || num < 0.0 || num > 0x10ffff.0 {
      let _ = throw_range_error("invalid code point")
      return ""
    }
    let int_val = Double::trunc(num)
    if int_val != num {
      let _ = throw_range_error("invalid code point")
      return ""
    }
    let code_point = Double::to_int(int_val)
    if code_point <= 0xffff {
      units.push(code_point)
    } else {
      let cp = code_point - 0x10000
      let high = 0xD800 + (cp >> 10)
      let low = 0xDC00 + (cp & 0x3ff)
      units.push(high)
      units.push(low)
    }
  }
  string_from_code_units(units)
}

///|
fn test262_code_point_range(start : UInt, end : UInt) -> String {
  let max_end = 0x10ffff + 1
  let max_end_u = UInt::trunc_double(Double::from_int(max_end))
  let end_value = if end > max_end_u { max_end_u } else { end }
  let mut start_value = start
  if start_value > end_value {
    start_value = end_value
  }
  let units : Array[Int] = []
  let mut current = start_value
  while current < end_value {
    let code_point = UInt::reinterpret_as_int(current)
    if code_point <= 0xffff {
      units.push(code_point)
    } else {
      let cp = code_point - 0x10000
      let high = 0xD800 + (cp >> 10)
      let low = 0xDC00 + (cp & 0x3ff)
      units.push(high)
      units.push(low)
    }
    current = current + 1
  }
  string_from_code_units(units)
}

///|
fn string_from_code_units(units : Array[Int]) -> String {
  if units.is_empty() {
    return ""
  }
  let bytes : Array[Byte] = []
  for unit in units {
    let value = unit & 0xffff
    let low = Int::to_byte(value & 0xff)
    let high = Int::to_byte((value >> 8) & 0xff)
    bytes.push(low)
    bytes.push(high)
  }
  let data = Bytes::from_array(bytes)
  data.to_unchecked_string()
}

///|
fn hex_digit_upper(value : Int) -> Int {
  if value < 10 {
    48 + value
  } else {
    55 + value
  }
}

///|
fn uri_hex_value(code : Int) -> Int? {
  let zero = Char::to_int('0')
  let nine = Char::to_int('9')
  let upper_a = Char::to_int('A')
  let upper_f = Char::to_int('F')
  let lower_a = Char::to_int('a')
  let lower_f = Char::to_int('f')
  if code >= zero && code <= nine {
    Some(code - zero)
  } else if code >= upper_a && code <= upper_f {
    Some(code - upper_a + 10)
  } else if code >= lower_a && code <= lower_f {
    Some(code - lower_a + 10)
  } else {
    None
  }
}

///|
fn uri_encode_hex(units : Array[Int], byte : Int) -> Unit {
  let percent = Char::to_int('%')
  units.push(percent)
  units.push(hex_digit_upper((byte >> 4) & 0x0f))
  units.push(hex_digit_upper(byte & 0x0f))
}

///|
fn uri_escape_hex(units : Array[Int], code : Int) -> Unit {
  let percent = Char::to_int('%')
  units.push(percent)
  if code >= 256 {
    units.push(Char::to_int('u'))
    units.push(hex_digit_upper((code >> 12) & 0x0f))
    units.push(hex_digit_upper((code >> 8) & 0x0f))
  }
  units.push(hex_digit_upper((code >> 4) & 0x0f))
  units.push(hex_digit_upper(code & 0x0f))
}

///|
fn is_uri_reserved(code : Int) -> Bool {
  if code < 0 || code >= 0x100 {
    return false
  }
  code == Char::to_int(';') ||
  code == Char::to_int('/') ||
  code == Char::to_int('?') ||
  code == Char::to_int(':') ||
  code == Char::to_int('@') ||
  code == Char::to_int('&') ||
  code == Char::to_int('=') ||
  code == Char::to_int('+') ||
  code == Char::to_int('$') ||
  code == Char::to_int(',') ||
  code == Char::to_int('#')
}

///|
fn is_uri_unescaped(code : Int, is_component : Bool) -> Bool {
  if code < 0 || code >= 0x100 {
    return false
  }
  let is_alpha = (code >= Char::to_int('a') && code <= Char::to_int('z')) ||
    (code >= Char::to_int('A') && code <= Char::to_int('Z'))
  if is_alpha {
    return true
  }
  if code >= Char::to_int('0') && code <= Char::to_int('9') {
    return true
  }
  if code == 45 ||
    code == 95 ||
    code == 46 ||
    code == 33 ||
    code == 126 ||
    code == 42 ||
    code == 39 ||
    code == 40 ||
    code == 41 {
    return true
  }
  !is_component && is_uri_reserved(code)
}

///|
fn is_unescaped(code : Int) -> Bool {
  if code < 0 || code >= 0x100 {
    return false
  }
  let is_alpha = (code >= Char::to_int('a') && code <= Char::to_int('z')) ||
    (code >= Char::to_int('A') && code <= Char::to_int('Z'))
  if is_alpha {
    return true
  }
  if code >= Char::to_int('0') && code <= Char::to_int('9') {
    return true
  }
  code == 64 ||
  code == 42 ||
  code == 95 ||
  code == 43 ||
  code == 45 ||
  code == 46 ||
  code == 47
}

///|
fn is_surrogate_code_point(code : Int) -> Bool {
  code >= 0xD800 && code <= 0xDFFF
}

///|
fn append_code_point_units(units : Array[Int], code_point : Int) -> Unit {
  if code_point <= 0xffff {
    units.push(code_point)
  } else {
    let cp = code_point - 0x10000
    let high = 0xD800 + (cp >> 10)
    let low = 0xDC00 + (cp & 0x3ff)
    units.push(high)
    units.push(low)
  }
}

///|
fn uri_hex_decode(text : String, index : Int) -> Int raise {
  let len = text.length()
  let percent = Char::to_int('%')
  if index >= len || UInt16::to_int(text.code_unit_at(index)) != percent {
    let _ = throw_uri_error("expecting %")
    return 0
  }
  if index + 2 >= len {
    let _ = throw_uri_error("expecting hex digit")
    return 0
  }
  let hi = UInt16::to_int(text.code_unit_at(index + 1))
  let lo = UInt16::to_int(text.code_unit_at(index + 2))
  let high = match uri_hex_value(hi) {
    Some(value) => value
    None => {
      let _ = throw_uri_error("expecting hex digit")
      return 0
    }
  }
  let low = match uri_hex_value(lo) {
    Some(value) => value
    None => {
      let _ = throw_uri_error("expecting hex digit")
      return 0
    }
  }
  (high << 4) | low
}

///|
fn uri_decode(text : String, is_component : Bool) -> String raise {
  let len = text.length()
  let mut index = 0
  let units : Array[Int] = []
  let percent = Char::to_int('%')
  while index < len {
    let unit = UInt16::to_int(text.code_unit_at(index))
    if unit != percent {
      units.push(unit)
      index = index + 1
      continue
    }
    let byte = uri_hex_decode(text, index)
    index = index + 3
    if byte < 0x80 {
      if !is_component && is_uri_reserved(byte) {
        units.push(percent)
        units.push(UInt16::to_int(text.code_unit_at(index - 2)))
        units.push(UInt16::to_int(text.code_unit_at(index - 1)))
      } else {
        units.push(byte)
      }
      continue
    }
    let mut count = 0
    let mut min = 0
    let mut code = byte
    if byte >= 0xc0 && byte <= 0xdf {
      count = 1
      min = 0x80
      code = byte & 0x1f
    } else if byte >= 0xe0 && byte <= 0xef {
      count = 2
      min = 0x800
      code = byte & 0x0f
    } else if byte >= 0xf0 && byte <= 0xf7 {
      count = 3
      min = 0x10000
      code = byte & 0x07
    } else {
      count = 0
      min = 1
      code = 0
    }
    let mut invalid = false
    while count > 0 {
      let next = uri_hex_decode(text, index)
      index = index + 3
      if (next & 0xc0) != 0x80 {
        invalid = true
        break
      }
      code = (code << 6) | (next & 0x3f)
      count = count - 1
    }
    if invalid || code < min || code > 0x10ffff || is_surrogate_code_point(code) {
      let _ = throw_uri_error("malformed UTF-8")
      return ""
    }
    append_code_point_units(units, code)
  }
  string_from_code_units(units)
}

///|
fn uri_encode(text : String, is_component : Bool) -> String raise {
  let len = text.length()
  let mut index = 0
  let units : Array[Int] = []
  while index < len {
    let unit = UInt16::to_int(text.code_unit_at(index))
    if is_uri_unescaped(unit, is_component) {
      units.push(unit)
      index = index + 1
      continue
    }
    if is_trail_surrogate(unit) {
      let _ = throw_uri_error("invalid character")
      return ""
    }
    let mut code_point = unit
    if is_lead_surrogate(unit) {
      if index + 1 >= len {
        let _ = throw_uri_error("expecting surrogate pair")
        return ""
      }
      let next = UInt16::to_int(text.code_unit_at(index + 1))
      if !is_trail_surrogate(next) {
        let _ = throw_uri_error("expecting surrogate pair")
        return ""
      }
      code_point = 0x10000 + ((unit - 0xD800) << 10) + (next - 0xDC00)
      index = index + 2
    } else {
      index = index + 1
    }
    if code_point < 0x80 {
      uri_encode_hex(units, code_point)
    } else if code_point < 0x800 {
      uri_encode_hex(units, (code_point >> 6) | 0xc0)
      uri_encode_hex(units, (code_point & 0x3f) | 0x80)
    } else if code_point < 0x10000 {
      uri_encode_hex(units, (code_point >> 12) | 0xe0)
      uri_encode_hex(units, ((code_point >> 6) & 0x3f) | 0x80)
      uri_encode_hex(units, (code_point & 0x3f) | 0x80)
    } else {
      uri_encode_hex(units, (code_point >> 18) | 0xf0)
      uri_encode_hex(units, ((code_point >> 12) & 0x3f) | 0x80)
      uri_encode_hex(units, ((code_point >> 6) & 0x3f) | 0x80)
      uri_encode_hex(units, (code_point & 0x3f) | 0x80)
    }
  }
  string_from_code_units(units)
}

///|
fn uri_escape(text : String) -> String {
  let len = text.length()
  let units : Array[Int] = []
  let mut index = 0
  while index < len {
    let unit = UInt16::to_int(text.code_unit_at(index))
    if is_unescaped(unit) {
      units.push(unit)
    } else {
      uri_escape_hex(units, unit)
    }
    index = index + 1
  }
  string_from_code_units(units)
}

///|
fn parse_hex_digits(text : String, start : Int, count : Int) -> Int? {
  if count <= 0 {
    return Some(0)
  }
  let len = text.length()
  if start < 0 || start + count > len {
    return None
  }
  let mut value = 0
  let mut index = start
  let end = start + count
  while index < end {
    let unit = UInt16::to_int(text.code_unit_at(index))
    match uri_hex_value(unit) {
      Some(digit) => value = (value << 4) | digit
      None => return None
    }
    index = index + 1
  }
  Some(value)
}

///|
fn uri_unescape(text : String) -> String {
  let len = text.length()
  let units : Array[Int] = []
  let mut index = 0
  let percent = Char::to_int('%')
  let letter_u = Char::to_int('u')
  while index < len {
    let mut unit = UInt16::to_int(text.code_unit_at(index))
    if unit == percent {
      if index + 6 <= len &&
        UInt16::to_int(text.code_unit_at(index + 1)) == letter_u {
        match parse_hex_digits(text, index + 2, 4) {
          Some(value) => {
            unit = value
            index = index + 5
          }
          None => ()
        }
      } else if index + 3 <= len {
        match parse_hex_digits(text, index + 1, 2) {
          Some(value) => {
            unit = value
            index = index + 2
          }
          None => ()
        }
      }
    }
    units.push(unit)
    index = index + 1
  }
  string_from_code_units(units)
}

///|
fn to_uint16_from_double(num : Double) -> Int {
  let masked = UInt::reinterpret_as_int(to_uint32(num)) & 0xffff
  masked
}

///|
fn string_index_of(value : String, search : String, from : Int) -> Int {
  let len = value.length()
  let search_len = search.length()
  if search_len == 0 {
    return if from > len { len } else { from }
  }
  if search_len > len {
    return -1
  }
  let mut i = from
  let last = len - search_len
  while i <= last {
    let slice = value.unsafe_substring(start=i, end=i + search_len)
    if slice == search {
      return i
    }
    i = i + 1
  }
  -1
}

///|
fn string_last_index_of(value : String, search : String, from : Int) -> Int {
  let len = value.length()
  let search_len = search.length()
  if search_len == 0 {
    return if from > len { len } else { from }
  }
  if search_len > len {
    return -1
  }
  let mut i = from
  if i > len - search_len {
    i = len - search_len
  }
  while i >= 0 {
    let slice = value.unsafe_substring(start=i, end=i + search_len)
    if slice == search {
      return i
    }
    if i == 0 {
      break
    }
    i = i - 1
  }
  -1
}

///|
fn string_split_value(
  value : String,
  args : Array[Value],
  limit : UInt,
) -> Value raise {
  let result : Array[Value?] = []
  let mut count : UInt = 0U
  if args.is_empty() || args[0] is Undefined {
    if limit == 0U {
      return new_array_value([])
    }
    if count < limit {
      result.push(Some(String(value)))
      count = count + 1U
    }
    return new_array_value(result)
  }
  let sep = to_string_strict(args[0])
  if limit == 0U {
    return new_array_value([])
  }
  if sep.is_empty() {
    let len = value.length()
    let mut i = 0
    while i < len {
      if count >= limit {
        break
      }
      result.push(Some(String(value.unsafe_substring(start=i, end=i + 1))))
      count = count + 1U
      i = i + 1
    }
    return new_array_value(result)
  }
  let sep_len = sep.length()
  let mut start = 0
  let len = value.length()
  while start <= len {
    if count >= limit {
      break
    }
    let index = string_index_of(value, sep, start)
    if index < 0 {
      if count < limit {
        result.push(Some(String(value.unsafe_substring(start~, end=len))))
        count = count + 1U
      }
      break
    }
    if count < limit {
      result.push(Some(String(value.unsafe_substring(start~, end=index))))
      count = count + 1U
    } else {
      break
    }
    start = index + sep_len
    if start == len {
      if count < limit {
        result.push(Some(String("")))
        count = count + 1U
      }
      break
    }
  }
  new_array_value(result)
}

///|
fn string_pad_start(value : String, target_len : Int, fill : String) -> String {
  let len = value.length()
  if target_len <= len || fill.is_empty() {
    return value
  }
  let fill_len = fill.length()
  if fill_len == 0 {
    return value
  }
  let needed = target_len - len
  let repeat_count = needed / fill_len
  let extra = needed % fill_len
  let mut padding = fill.repeat(repeat_count)
  if extra > 0 {
    padding = padding + fill.unsafe_substring(start=0, end=extra)
  }
  padding + value
}

///|
fn string_pad_end(value : String, target_len : Int, fill : String) -> String {
  let len = value.length()
  if target_len <= len || fill.is_empty() {
    return value
  }
  let fill_len = fill.length()
  if fill_len == 0 {
    return value
  }
  let needed = target_len - len
  let repeat_count = needed / fill_len
  let extra = needed % fill_len
  let mut padding = fill.repeat(repeat_count)
  if extra > 0 {
    padding = padding + fill.unsafe_substring(start=0, end=extra)
  }
  value + padding
}

///|
fn string_create_html(
  this_value : Value?,
  args : Array[Value],
  tag : String,
  attr : String?,
) -> Value raise {
  let text = this_to_string_coerce(this_value)
  let result = StringBuilder::new()
  result.write_string("<")
  result.write_string(tag)
  match attr {
    Some(name) => {
      result.write_string(" ")
      result.write_string(name)
      result.write_string("=\"")
      let attr_value = if args.is_empty() { Undefined } else { args[0] }
      let attr_text = this_to_string_coerce(Some(attr_value))
      for ch in attr_text {
        if ch == '"' {
          result.write_string("&quot;")
        } else {
          result.write_char(ch)
        }
      }
      result.write_string("\"")
    }
    None => ()
  }
  result.write_string(">")
  result.write_string(text)
  result.write_string("</")
  result.write_string(tag)
  result.write_string(">")
  String(result.to_string())
}

///|
fn parse_regexp_flags(flags : String) -> RegexpFlags raise {
  let mut global = false
  let mut sticky = false
  let mut unicode = false
  let mut dot_all = false
  let mut ignore_case = false
  let mut multiline = false
  let mut has_indices = false
  let mut unicode_sets = false
  for ch in flags {
    match ch {
      'g' =>
        if global {
          let _ = throw_syntax_error("invalid regexp flags")

        } else {
          global = true
        }
      'y' =>
        if sticky {
          let _ = throw_syntax_error("invalid regexp flags")

        } else {
          sticky = true
        }
      'u' =>
        if unicode || unicode_sets {
          let _ = throw_syntax_error("invalid regexp flags")

        } else {
          unicode = true
        }
      'v' =>
        if unicode || unicode_sets {
          let _ = throw_syntax_error("invalid regexp flags")

        } else {
          unicode_sets = true
          unicode = true
        }
      's' =>
        if dot_all {
          let _ = throw_syntax_error("invalid regexp flags")

        } else {
          dot_all = true
        }
      'i' =>
        if ignore_case {
          let _ = throw_syntax_error("invalid regexp flags")

        } else {
          ignore_case = true
        }
      'm' =>
        if multiline {
          let _ = throw_syntax_error("invalid regexp flags")

        } else {
          multiline = true
        }
      'd' =>
        if has_indices {
          let _ = throw_syntax_error("invalid regexp flags")

        } else {
          has_indices = true
        }
      _ => {
        let _ = throw_syntax_error("invalid regexp flags")

      }
    }
  }
  let mut compile = ""
  if ignore_case {
    compile = compile + "i"
  }
  if multiline {
    compile = compile + "m"
  }
  if dot_all {
    compile = compile + "s"
  }
  if unicode_sets {
    compile = compile + "v"
  } else if unicode {
    compile = compile + "u"
  }
  RegexpFlags::{
    compile,
    global,
    sticky,
    unicode,
    dot_all,
    ignore_case,
    multiline,
    has_indices,
    unicode_sets,
  }
}

///|
fn regexp_data_from_pattern(
  pattern : String,
  flags : String,
) -> RegexpData raise {
  let parsed = parse_regexp_flags(flags)
  let regex = try regexp_compile(pattern, parsed) catch {
    _ => {
      let _ = throw_syntax_error("invalid regular expression")
      fail("unreachable")
    }
  } noraise {
    value => value
  }
  RegexpData::{
    source: pattern,
    flags,
    regex,
    global: parsed.global,
    sticky: parsed.sticky,
    unicode: parsed.unicode,
    dot_all: parsed.dot_all,
    ignore_case: parsed.ignore_case,
    multiline: parsed.multiline,
    has_indices: parsed.has_indices,
    unicode_sets: parsed.unicode_sets,
  }
}

///|
fn is_regexp_value(value : Value) -> Bool raise {
  if !is_object_like(value) {
    return false
  }
  match symbol_match_key() {
    Some(key) =>
      match property_get(value, key) {
        Undefined =>
          match regexp_object_from_value(value) {
            Some(_) => true
            None => false
          }
        matcher => is_truthy(matcher)
      }
    None =>
      match regexp_object_from_value(value) {
        Some(_) => true
        None => false
      }
  }
}

///|
fn check_regexp_g_flag(value : Value) -> Unit raise {
  if !is_regexp_value(value) {
    return
  }
  let flags = property_get(value, "flags")
  match flags {
    Undefined | Null => {
      let _ = throw_type_error("cannot convert to object")
      return
    }
    _ => ()
  }
  let flag_text = to_string_strict(flags)
  if string_index_of(flag_text, "g", 0) < 0 {
    let _ = throw_type_error("regexp must have the 'g' flag")

  }
}

///|
fn regexp_object_from_value(value : Value) -> (ObjectValue, RegexpData)? {
  match value {
    Object(obj) =>
      match obj.regexp_data {
        Some(data) => Some((obj, data))
        None => None
      }
    _ => None
  }
}

///|
fn require_regexp(this_value : Value?) -> (ObjectValue, RegexpData) raise {
  match this_value {
    Some(Object(obj)) =>
      match obj.regexp_data {
        Some(data) => (obj, data)
        None => {
          let _ = throw_type_error("not a regexp")
          fail("unreachable")
        }
      }
    Some(_) => {
      let _ = throw_type_error("not a regexp")
      fail("unreachable")
    }
    None => {
      let _ = throw_type_error("not a regexp")
      fail("unreachable")
    }
  }
}

///|
fn regexp_compile_value(
  this_value : Value?,
  args : Array[Value],
) -> Value raise {
  let (obj, _) = require_regexp(this_value)
  let pattern_value = if args.is_empty() { Undefined } else { args[0] }
  let flags_value = if args.length() > 1 { args[1] } else { Undefined }
  let data = match regexp_object_from_value(pattern_value) {
    Some((_, pattern_data)) => {
      if !(flags_value is Undefined) {
        let _ = throw_type_error("flags must be undefined")

      }
      pattern_data
    }
    None => {
      let pattern = if pattern_value is Undefined {
        ""
      } else {
        to_string_strict(pattern_value)
      }
      let flags = if flags_value is Undefined {
        ""
      } else {
        to_string_strict(flags_value)
      }
      regexp_data_from_pattern(pattern, flags)
    }
  }
  obj.regexp_data = Some(data)
  let value = Object(obj)
  let _ = property_set(value, "lastIndex", Number(0.0), true)
  value
}

///|
fn regexp_from_args(
  args : Array[Value],
  force_new : Bool,
  new_target? : Value = Undefined,
) -> Value raise {
  let pattern_value = if args.is_empty() { Undefined } else { args[0] }
  let flags_value = if args.length() > 1 { args[1] } else { Undefined }
  let pattern_is_regexp = is_regexp_value(pattern_value)
  if pattern_is_regexp {
    if flags_value is Undefined && !force_new {
      let ctor = property_get(pattern_value, "constructor")
      if same_value(ctor, new_target) {
        return pattern_value
      }
    }
  }
  let mut pattern = ""
  let mut flags_str : String? = None
  let mut flags_raw : Value? = None
  if pattern_is_regexp {
    match regexp_object_from_value(pattern_value) {
      Some((_, data)) => {
        pattern = data.source
        if flags_value is Undefined {
          flags_str = Some(data.flags)
        } else {
          flags_raw = Some(flags_value)
        }
      }
      None => {
        let source_value = property_get(pattern_value, "source")
        pattern = to_string_strict(source_value)
        if flags_value is Undefined {
          flags_raw = Some(property_get(pattern_value, "flags"))
        } else {
          flags_raw = Some(flags_value)
        }
      }
    }
  } else {
    if pattern_value is Undefined {
      pattern = ""
    } else {
      pattern = to_string_strict(pattern_value)
    }
    if flags_value is Undefined {
      flags_str = Some("")
    } else {
      flags_raw = Some(flags_value)
    }
  }
  let proto = if new_target is Undefined {
    value_from_object(regexp_proto())
  } else {
    let default_proto = match function_realm_env(new_target) {
      Some(env) =>
        match value_from_object(regexp_proto_for_env(env)) {
          Some(value) => Some(value)
          None => value_from_object(regexp_proto())
        }
      None => value_from_object(regexp_proto())
    }
    constructor_proto_from_target(new_target, default_proto)
  }
  let flags = match flags_str {
    Some(value) => value
    None =>
      match flags_raw {
        Some(value) =>
          if value is Undefined {
            ""
          } else {
            to_string_strict(value)
          }
        None => ""
      }
  }
  new_regexp_value(pattern, flags, proto)
}

///|
fn regexp_exec_method(rx : Value, input : Value) -> Value raise {
  let exec_method = property_get(rx, "exec")
  if is_callable(exec_method) {
    let result = call_value_with_this(exec_method, [input], rx)
    if is_object_like(result) || result is Null {
      return result
    }
    return throw_type_error("RegExp exec method must return an object or null")
  }
  match regexp_object_from_value(rx) {
    Some((obj, data)) => {
      let text = to_string_strict(input)
      regexp_exec_value(obj, data, text)
    }
    None => throw_type_error("not a regexp")
  }
}

///|
fn string_get_substitution(
  matched : String,
  input : String,
  position : Int,
  captures : Array[String?],
  named_captures : Value,
  replacement : String,
) -> String raise {
  let _ = string_get_substitution_len(
    matched, input, position, captures, named_captures, replacement,
  )
  let result = StringBuilder::new()
  let mut result_len = 0
  let len = replacement.length()
  let captures_len = captures.length()
  let mut i = 0
  while true {
    let j = string_index_of(replacement, "$", i)
    if j < 0 || j + 1 >= len {
      break
    }
    let prefix = replacement.unsafe_substring(start=i, end=j)
    result_len = add_string_length(result_len, prefix.length())
    result.write_string(prefix)
    let j0 = j
    let mut k = j + 1
    let code = UInt16::to_int(replacement.code_unit_at(k))
    k = k + 1
    if code == Char::to_int('$') {
      result_len = add_string_length(result_len, 1)
      result.write_string("$")
    } else if code == Char::to_int('&') {
      result_len = add_string_length(result_len, matched.length())
      result.write_string(matched)
    } else if code == Char::to_int('`') {
      let end_pos = if position > input.length() {
        input.length()
      } else {
        position
      }
      result_len = add_string_length(result_len, end_pos)
      result.write_string(input.unsafe_substring(start=0, end=end_pos))
    } else if code == Char::to_int('\'') {
      let mut tail_pos = position + matched.length()
      if tail_pos > input.length() {
        tail_pos = input.length()
      }
      result_len = add_string_length(result_len, input.length() - tail_pos)
      result.write_string(
        input.unsafe_substring(start=tail_pos, end=input.length()),
      )
    } else if code >= Char::to_int('0') && code <= Char::to_int('9') {
      let mut index = code - Char::to_int('0')
      if k < len {
        let next = UInt16::to_int(replacement.code_unit_at(k))
        if next >= Char::to_int('0') && next <= Char::to_int('9') {
          let next_index = index * 10 + (next - Char::to_int('0'))
          if next_index >= 1 && next_index < captures_len {
            index = next_index
            k = k + 1
          }
        }
      }
      if index >= 1 && index < captures_len {
        match captures[index] {
          Some(text) => {
            result_len = add_string_length(result_len, text.length())
            result.write_string(text)
          }
          None => ()
        }
      } else {
        let literal = replacement.unsafe_substring(start=j0, end=k)
        result_len = add_string_length(result_len, literal.length())
        result.write_string(literal)
      }
    } else if code == Char::to_int('<') && !(named_captures is Undefined) {
      let close = string_index_of(replacement, ">", k)
      if close < 0 {
        let literal = replacement.unsafe_substring(start=j0, end=k)
        result_len = add_string_length(result_len, literal.length())
        result.write_string(literal)
      } else {
        let name = replacement.unsafe_substring(start=k, end=close)
        let target = to_object(named_captures)
        let capture = property_get(target, name)
        if !(capture is Undefined) {
          let text = to_string_strict(capture)
          result_len = add_string_length(result_len, text.length())
          result.write_string(text)
        }
        k = close + 1
      }
    } else {
      let literal = replacement.unsafe_substring(start=j0, end=k)
      result_len = add_string_length(result_len, literal.length())
      result.write_string(literal)
    }
    i = k
  }
  let tail = replacement.unsafe_substring(start=i, end=len)
  result_len = add_string_length(result_len, tail.length())
  result.write_string(tail)
  result.to_string()
}

///|
fn string_get_substitution_len(
  matched : String,
  input : String,
  position : Int,
  captures : Array[String?],
  named_captures : Value,
  replacement : String,
) -> Int raise {
  let len = replacement.length()
  let input_len = input.length()
  let captures_len = captures.length()
  let mut total = 0
  let mut i = 0
  while true {
    let j = string_index_of(replacement, "$", i)
    if j < 0 || j + 1 >= len {
      break
    }
    total = add_string_length(total, j - i)
    let j0 = j
    let mut k = j + 1
    let code = UInt16::to_int(replacement.code_unit_at(k))
    k = k + 1
    if code == Char::to_int('$') {
      total = add_string_length(total, 1)
    } else if code == Char::to_int('&') {
      total = add_string_length(total, matched.length())
    } else if code == Char::to_int('`') {
      let end_pos = if position > input_len { input_len } else { position }
      total = add_string_length(total, end_pos)
    } else if code == Char::to_int('\'') {
      let mut tail_pos = position + matched.length()
      if tail_pos > input_len {
        tail_pos = input_len
      }
      total = add_string_length(total, input_len - tail_pos)
    } else if code >= Char::to_int('0') && code <= Char::to_int('9') {
      let mut index = code - Char::to_int('0')
      if k < len {
        let next = UInt16::to_int(replacement.code_unit_at(k))
        if next >= Char::to_int('0') && next <= Char::to_int('9') {
          let next_index = index * 10 + (next - Char::to_int('0'))
          if next_index >= 1 && next_index < captures_len {
            index = next_index
            k = k + 1
          }
        }
      }
      if index >= 1 && index < captures_len {
        match captures[index] {
          Some(text) => total = add_string_length(total, text.length())
          None => ()
        }
      } else {
        total = add_string_length(total, k - j0)
      }
    } else if code == Char::to_int('<') && !(named_captures is Undefined) {
      let close = string_index_of(replacement, ">", k)
      if close < 0 {
        total = add_string_length(total, k - j0)
      } else {
        let name = replacement.unsafe_substring(start=k, end=close)
        let target = to_object(named_captures)
        let capture = property_get(target, name)
        if !(capture is Undefined) {
          let text = to_string_strict(capture)
          total = add_string_length(total, text.length())
        }
        k = close + 1
      }
    } else {
      total = add_string_length(total, k - j0)
    }
    i = k
  }
  total = add_string_length(total, len - i)
  total
}

///|
fn string_replace_internal(
  this_value : Value,
  args : Array[Value],
  replace_all : Bool,
) -> Value raise {
  match this_value {
    Null | Undefined => {
      let _ = throw_type_error("cannot convert to object")
      return String("")
    }
    _ => ()
  }
  if args.is_empty() {
    return String(to_string_strict(this_value))
  }
  let search = args[0]
  let replace_value = if args.length() < 2 { Undefined } else { args[1] }
  if is_object_like(search) {
    if replace_all {
      check_regexp_g_flag(search)
    }
    match symbol_replace_key() {
      Some(key) =>
        match property_get(search, key) {
          Undefined | Null => ()
          replacer =>
            return call_value_with_this(
              replacer,
              [this_value, replace_value],
              search,
            )
        }
      None => ()
    }
  }
  let value = to_string_strict(this_value)
  let search_str = to_string_strict(search)
  let functional_replace = is_callable(replace_value)
  let replace_str = if functional_replace {
    ""
  } else {
    to_string_strict(replace_value)
  }
  let len = value.length()
  let result = StringBuilder::new()
  let mut end_of_last_match = 0
  let mut is_first = true
  while true {
    let pos = if search_str.is_empty() {
      if is_first {
        0
      } else if end_of_last_match >= len {
        -1
      } else {
        end_of_last_match + 1
      }
    } else {
      string_index_of(value, search_str, end_of_last_match)
    }
    if pos < 0 {
      if is_first {
        return String(value)
      }
      break
    }
    result.write_string(
      value.unsafe_substring(start=end_of_last_match, end=pos),
    )
    let replacement = if functional_replace {
      let res = call_value_with_this(
        replace_value,
        [String(search_str), Number(Double::from_int(pos)), String(value)],
        Undefined,
      )
      to_string_strict(res)
    } else {
      string_get_substitution(
        search_str,
        value,
        pos,
        [Some(search_str)],
        Undefined,
        replace_str,
      )
    }
    result.write_string(replacement)
    end_of_last_match = pos + search_str.length()
    is_first = false
    if !replace_all {
      break
    }
  }
  result.write_string(value.unsafe_substring(start=end_of_last_match, end=len))
  String(result.to_string())
}

///|
fn string_replace_value(this_value : Value, args : Array[Value]) -> Value raise {
  string_replace_internal(this_value, args, false)
}

///|
fn string_replace_all_value(
  this_value : Value,
  args : Array[Value],
) -> Value raise {
  string_replace_internal(this_value, args, true)
}

///|
fn string_match_symbol(
  this_value : Value,
  value : String,
  search : Value,
  symbol_key : String?,
  match_all : Bool,
) -> Value raise {
  if is_object_like(search) {
    if match_all {
      check_regexp_g_flag(search)
    }
    match symbol_key {
      Some(key) =>
        match property_get(search, key) {
          Undefined | Null => ()
          matcher => return call_value_with_this(matcher, [this_value], search)
        }
      None => ()
    }
  }
  let args : Array[Value] = [search]
  if match_all {
    args.push(String("g"))
  }
  let rx = regexp_from_args(args, true)
  match symbol_key {
    Some(key) => {
      let method_value = property_get(rx, key)
      call_value_with_this(method_value, [String(value)], rx)
    }
    None => {
      let input = String(value)
      regexp_exec_method(rx, input)
    }
  }
}

///|
fn string_match_value(
  this_value : Value,
  value : String,
  search : Value,
) -> Value raise {
  string_match_symbol(this_value, value, search, symbol_match_key(), false)
}

///|
fn string_match_all_value(
  this_value : Value,
  value : String,
  search : Value,
) -> Value raise {
  string_match_symbol(this_value, value, search, symbol_match_all_key(), true)
}

///|
fn string_search_value(
  this_value : Value,
  value : String,
  search : Value,
) -> Value raise {
  string_match_symbol(this_value, value, search, symbol_search_key(), false)
}

///|
fn regexp_exec_value(
  obj : ObjectValue,
  data : RegexpData,
  input : String,
) -> Value raise {
  let len = input.length()
  let last_index_value = regexp_last_index(obj)
  let mut exec_data = data
  match obj.regexp_data {
    Some(current) => exec_data = current
    None => ()
  }
  let use_last_index = exec_data.global || exec_data.sticky
  let mut last_index = if use_last_index { last_index_value } else { 0L }
  if use_last_index {
    let len64 = Int64::from_int(len)
    if last_index > len64 {
      set_regexp_last_index(obj, 0)
      return Null
    }
    if (exec_data.unicode || exec_data.unicode_sets) &&
      !is_valid_unicode_index(input, Int64::to_int(last_index)) {
      set_regexp_last_index(obj, 0)
      last_index = 0L
    }
  }
  let start_index = if use_last_index { Int64::to_int(last_index) } else { 0 }
  match regexp_match_from(exec_data, input, start_index, exec_data.sticky) {
    None => {
      if use_last_index {
        set_regexp_last_index(obj, 0)
      }
      Null
    }
    Some(match_value) => {
      let start = match_value.start
      let end = match_value.end
      let groups = match_value.groups
      let groups_value = build_regexp_groups(
        exec_data.regex.capture_names,
        groups,
      )
      if use_last_index {
        set_regexp_last_index(obj, end)
      }
      let elements : Array[Value?] = []
      for entry in groups {
        match entry {
          Some(text) => elements.push(Some(String(text)))
          None => elements.push(None)
        }
      }
      let result = new_array_value(elements)
      match result {
        Array(arr) => {
          arr.props.set("index", property_data(Number(Double::from_int(start))))
          arr.props.set("input", property_data(String(input)))
          arr.props.set("groups", property_data(groups_value))
          if exec_data.has_indices {
            let indices = build_regexp_indices(
              start,
              end,
              match_value.indices,
              exec_data.regex.capture_names,
            )
            arr.props.set("indices", property_data(indices))
          }
        }
        _ => ()
      }
      result
    }
  }
}

///|
fn regexp_match_from(
  data : RegexpData,
  input : String,
  start : Int,
  sticky : Bool,
) -> RegexpMatch? {
  regexp_match_from_program(data.regex, input, start, sticky)
}

///|
fn has_named_captures(capture_names : Array[String?]) -> Bool {
  for name in capture_names {
    if name is Some(_) {
      return true
    }
  }
  false
}

///|
fn build_regexp_groups(
  capture_names : Array[String?],
  groups : Array[String?],
) -> Value {
  if !has_named_captures(capture_names) {
    return Undefined
  }
  let groups_value = new_object_value_with_proto(None)
  let groups_obj = match groups_value {
    Object(obj) => obj
    _ => new_object_struct(None)
  }
  let mut i = 0
  while i < capture_names.length() {
    match capture_names[i] {
      Some(name) => {
        let value = match groups.get(i + 1) {
          Some(Some(text)) => String(text)
          _ => Undefined
        }
        if !(value is Undefined) || !groups_obj.props.contains(name) {
          groups_obj.props.set(name, property_data(value))
        }
      }
      None => ()
    }
    i = i + 1
  }
  Object(groups_obj)
}

///|
fn build_regexp_indices(
  start : Int,
  end : Int,
  group_indices : Array[CaptureSpan?],
  capture_names : Array[String?],
) -> Value {
  let values : Array[Value?] = []
  let use_groups = has_named_captures(capture_names)
  let mut groups_value = Undefined
  let mut groups_obj : ObjectValue? = None
  if use_groups {
    groups_value = new_object_value_with_proto(None)
    groups_obj = match groups_value {
      Object(obj) => Some(obj)
      _ => None
    }
  }
  let pair : Array[Value?] = [
    Some(Number(Double::from_int(start))),
    Some(Number(Double::from_int(end))),
  ]
  values.push(Some(new_array_value(pair)))
  let mut i = 0
  for entry in group_indices {
    let val = match entry {
      Some(span) =>
        new_array_value([
          Some(Number(Double::from_int(span.start))),
          Some(Number(Double::from_int(span.end))),
        ])
      None => Undefined
    }
    if val is Undefined {
      values.push(None)
    } else {
      values.push(Some(val))
    }
    match (groups_obj, capture_names.get(i)) {
      (Some(obj), Some(Some(name))) =>
        if !(val is Undefined) || !obj.props.contains(name) {
          obj.props.set(name, property_data(val))
        }
      _ => ()
    }
    i = i + 1
  }
  let indices_value = new_array_value(values)
  match indices_value {
    Array(arr) => arr.props.set("groups", property_data(groups_value))
    _ => ()
  }
  indices_value
}

///|
fn regexp_last_index(obj : ObjectValue) -> Int64 raise {
  let value = property_get(Value::Object(obj), "lastIndex")
  to_length_int64(to_number(value))
}

///|
fn set_regexp_last_index(obj : ObjectValue, index : Int) -> Unit raise {
  let _ = property_set(
    Value::Object(obj),
    "lastIndex",
    Number(Double::from_int(index)),
    true,
  )

}

///|
fn to_length_index(num : Double, len : Int) -> Int {
  if Double::is_nan(num) || num <= 0.0 {
    return 0
  }
  if Double::is_inf(num) {
    return len
  }
  let trunc = Double::trunc(num)
  let max = Double::from_int(len)
  if trunc >= max {
    return len
  }
  Int64::to_int(Double::to_int64(trunc))
}

///|
fn to_length_int64(num : Double) -> Int64 {
  if Double::is_nan(num) || num <= 0.0 {
    return 0L
  }
  let max_safe = 9007199254740991.0
  if Double::is_inf(num) || num >= max_safe {
    return 9007199254740991L
  }
  let trunc = Double::trunc(num)
  if trunc >= max_safe {
    return 9007199254740991L
  }
  Double::to_int64(trunc)
}

///|
fn to_index_int64(value : Value) -> Int64 raise {
  let num = to_number(value)
  if Double::is_nan(num) || num == 0.0 {
    return 0L
  }
  if Double::is_inf(num) {
    let _ = throw_range_error("invalid array buffer length")
    return 0L
  }
  let trunc = Double::trunc(num)
  if trunc < 0.0 || trunc > 9007199254740991.0 {
    let _ = throw_range_error("invalid array buffer length")
    return 0L
  }
  Double::to_int64(trunc)
}

///|
fn to_int64_clamp(
  value : Value,
  min : Int,
  max : Int,
  neg_offset : Int,
) -> Int raise {
  let num = to_number(value)
  if Double::is_inf(num) {
    return if num < 0.0 { min } else { max }
  }
  let mut int_val = if Double::is_nan(num) {
    0L
  } else {
    Double::to_int64(Double::trunc(num))
  }
  if int_val < 0L {
    int_val = int_val + Int64::from_int(neg_offset)
  }
  let min_val = Int64::from_int(min)
  let max_val = Int64::from_int(max)
  if int_val < min_val {
    return min
  }
  if int_val > max_val {
    return max
  }
  Int64::to_int(int_val)
}

///|
fn to_int64_clamp64(
  value : Value,
  min : Int64,
  max : Int64,
  neg_offset : Int64,
) -> Int64 raise {
  let num = to_number(value)
  if Double::is_inf(num) {
    return if num < 0.0 { min } else { max }
  }
  let mut int_val = if Double::is_nan(num) {
    0L
  } else {
    Double::to_int64(Double::trunc(num))
  }
  if int_val < 0L {
    int_val = int_val + neg_offset
  }
  if int_val < min {
    return min
  }
  if int_val > max {
    return max
  }
  int_val
}

///|
fn is_valid_unicode_index(value : String, index : Int) -> Bool {
  if index <= 0 {
    return true
  }
  let len = value.length()
  if index >= len {
    return true
  }
  let prev = UInt16::to_int(value.code_unit_at(index - 1))
  let curr = UInt16::to_int(value.code_unit_at(index))
  !(is_lead_surrogate(prev) && is_trail_surrogate(curr))
}

///|
fn advance_string_index(value : String, index : Int, unicode : Bool) -> Int {
  if !unicode {
    return index + 1
  }
  let len = value.length()
  if index + 1 >= len {
    return index + 1
  }
  let first = UInt16::to_int(value.code_unit_at(index))
  let second = UInt16::to_int(value.code_unit_at(index + 1))
  if is_lead_surrogate(first) && is_trail_surrogate(second) {
    index + 2
  } else {
    index + 1
  }
}

///|
fn advance_string_index_int64(
  value : String,
  index : Int64,
  unicode : Bool,
) -> Int64 {
  if !unicode {
    return index + 1L
  }
  let len = Int64::from_int(value.length())
  if index + 1L >= len {
    return index + 1L
  }
  let idx = Int64::to_int(index)
  let first = UInt16::to_int(value.code_unit_at(idx))
  let second = UInt16::to_int(value.code_unit_at(idx + 1))
  if is_lead_surrogate(first) && is_trail_surrogate(second) {
    index + 2L
  } else {
    index + 1L
  }
}

///|
fn is_lead_surrogate(code : Int) -> Bool {
  code >= 0xD800 && code <= 0xDBFF
}

///|
fn is_trail_surrogate(code : Int) -> Bool {
  code >= 0xDC00 && code <= 0xDFFF
}

///|
fn is_surrogate(code : Int) -> Bool {
  code >= 0xD800 && code <= 0xDFFF
}

///|
fn string_find_invalid_codepoint(value : String) -> Int {
  let len = value.length()
  let mut i = 0
  while i < len {
    let unit = UInt16::to_int(value.code_unit_at(i))
    if is_lead_surrogate(unit) {
      if i + 1 < len {
        let next = UInt16::to_int(value.code_unit_at(i + 1))
        if is_trail_surrogate(next) {
          i = i + 2
          continue
        }
      }
      return i
    } else if is_trail_surrogate(unit) {
      return i
    }
    i = i + 1
  }
  -1
}

///|
fn string_to_well_formed(value : String) -> String {
  let len = value.length()
  let mut i = 0
  let result = StringBuilder::new()
  while i < len {
    let unit = UInt16::to_int(value.code_unit_at(i))
    if is_lead_surrogate(unit) {
      if i + 1 < len {
        let next = UInt16::to_int(value.code_unit_at(i + 1))
        if is_trail_surrogate(next) {
          result.write_string(value.unsafe_substring(start=i, end=i + 2))
          i = i + 2
          continue
        }
      }
      result.write_string("\uFFFD")
      i = i + 1
      continue
    }
    if is_trail_surrogate(unit) {
      result.write_string("\uFFFD")
      i = i + 1
      continue
    }
    result.write_string(value.unsafe_substring(start=i, end=i + 1))
    i = i + 1
  }
  result.to_string()
}

///|
fn regexp_source_escape(pattern : String) -> String {
  if pattern.is_empty() {
    return "(?:)"
  }
  let result = StringBuilder::new()
  let len = pattern.length()
  let mut i = 0
  let mut in_class = false
  while i < len {
    let start = i
    let code = UInt16::to_int(pattern.code_unit_at(i))
    i = i + 1
    if code == Char::to_int('\\') {
      if i < len {
        i = i + 1
      }
      result.write_string(pattern.unsafe_substring(start~, end=i))
      continue
    }
    if code == Char::to_int(']') {
      in_class = false
      result.write_string(pattern.unsafe_substring(start~, end=i))
      continue
    }
    if code == Char::to_int('[') && !in_class {
      if i < len && UInt16::to_int(pattern.code_unit_at(i)) == Char::to_int(']') {
        i = i + 1
      }
      in_class = true
      result.write_string(pattern.unsafe_substring(start~, end=i))
      continue
    }
    if code == Char::to_int('\n') {
      result.write_string("\\n")
      continue
    }
    if code == Char::to_int('\r') {
      result.write_string("\\r")
      continue
    }
    if code == Char::to_int('/') && !in_class {
      result.write_string("\\/")
      continue
    }
    result.write_string(pattern.unsafe_substring(start~, end=i))
  }
  result.to_string()
}

///|
fn append_hex2(sb : StringBuilder, code : Int) -> Unit {
  sb.write_string("\\x")
  sb.write_char(hex_digit(Int::land(code >> 4, 0xf)))
  sb.write_char(hex_digit(Int::land(code, 0xf)))
}

///|
fn append_hex4(sb : StringBuilder, code : Int) -> Unit {
  sb.write_string("\\u")
  sb.write_char(hex_digit(Int::land(code >> 12, 0xf)))
  sb.write_char(hex_digit(Int::land(code >> 8, 0xf)))
  sb.write_char(hex_digit(Int::land(code >> 4, 0xf)))
  sb.write_char(hex_digit(Int::land(code, 0xf)))
}

///|
fn regexp_escape_string(value : String) -> String {
  let result = StringBuilder::new()
  let len = value.length()
  let mut i = 0
  while i < len {
    let code = UInt16::to_int(value.code_unit_at(i))
    if code < 33 {
      if code >= 9 && code <= 13 {
        result.write_char('\\')
        let map = "tnvfr"
        let index = code - 9
        result.write_string(map.unsafe_substring(start=index, end=index + 1))
      } else {
        append_hex2(result, code)
      }
    } else if code < 128 {
      if (code >= Char::to_int('0') && code <= Char::to_int('9')) ||
        (code >= Char::to_int('A') && code <= Char::to_int('Z')) ||
        (code >= Char::to_int('a') && code <= Char::to_int('z')) {
        if i == 0 {
          append_hex2(result, code)
        } else {
          result.write_string(value.unsafe_substring(start=i, end=i + 1))
        }
      } else if ",-=<>#&!%:;@~'`\"".contains(
          value.unsafe_substring(start=i, end=i + 1),
        ) {
        append_hex2(result, code)
      } else {
        if code != Char::to_int('_') {
          result.write_char('\\')
        }
        result.write_string(value.unsafe_substring(start=i, end=i + 1))
      }
    } else if code < 256 {
      append_hex2(result, code)
    } else if is_surrogate(code) || is_js_whitespace(code) {
      append_hex4(result, code)
    } else {
      result.write_string(value.unsafe_substring(start=i, end=i + 1))
    }
    i = i + 1
  }
  result.to_string()
}

///|
fn regexp_proto_for_env(env : Env) -> ObjectValue? {
  match global_object(env) {
    Some(global_obj) =>
      match global_obj.props.get("RegExp") {
        Some(prop) =>
          match prop.value {
            Builtin(builtin) =>
              match builtin.props.get("prototype") {
                Some(proto_prop) =>
                  match proto_prop.value {
                    Object(proto_obj) => Some(proto_obj)
                    _ => None
                  }
                None => None
              }
            _ => None
          }
        None => None
      }
    None => None
  }
}

///|
fn is_regexp_proto_obj(obj : ObjectValue, env : Env?) -> Bool {
  match env {
    Some(value) =>
      match regexp_proto_for_env(value) {
        Some(proto) => proto.id == obj.id
        None => false
      }
    None =>
      match regexp_proto() {
        Some(proto) => proto.id == obj.id
        None => false
      }
  }
}

///|
fn regexp_get_source_value(this_value : Value?) -> Value raise {
  match this_value {
    Some(Object(obj)) =>
      if is_regexp_proto_obj(obj, current_env()) {
        String("(?:)")
      } else {
        match obj.regexp_data {
          Some(data) => String(regexp_source_escape(data.source))
          None => throw_type_error("not a regexp")
        }
      }
    Some(_) => throw_type_error("not an object")
    None => throw_type_error("not an object")
  }
}

///|
fn regexp_get_flag_value(this_value : Value?, flag : String) -> Value raise {
  match this_value {
    Some(Object(obj)) =>
      if is_regexp_proto_obj(obj, current_env()) {
        Undefined
      } else {
        match obj.regexp_data {
          Some(data) => {
            let enabled = match flag {
              "global" => data.global
              "ignoreCase" => data.ignore_case
              "multiline" => data.multiline
              "dotAll" => data.dot_all
              "unicode" => data.unicode && !data.unicode_sets
              "unicodeSets" => data.unicode_sets
              "sticky" => data.sticky
              "hasIndices" => data.has_indices
              _ => false
            }
            Bool(enabled)
          }
          None => throw_type_error("not a regexp")
        }
      }
    Some(_) => throw_type_error("not an object")
    None => throw_type_error("not an object")
  }
}

///|
fn regexp_get_flags_value(this_value : Value?) -> Value raise {
  let target = match this_value {
    Some(value) => value
    None => Undefined
  }
  if !is_object_like(target) {
    return throw_type_error("not an object")
  }
  let flags = StringBuilder::new()
  let entries : Array[(String, String)] = [
    ("hasIndices", "d"),
    ("global", "g"),
    ("ignoreCase", "i"),
    ("multiline", "m"),
    ("dotAll", "s"),
    ("unicode", "u"),
    ("unicodeSets", "v"),
    ("sticky", "y"),
  ]
  for entry in entries {
    let (name, flag) = entry
    if is_truthy(property_get(target, name)) {
      flags.write_string(flag)
    }
  }
  String(flags.to_string())
}

///|
fn regexp_to_string_value(this_value : Value?) -> Value raise {
  let target = match this_value {
    Some(value) => value
    None => Undefined
  }
  if !is_object_like(target) {
    return throw_type_error("not an object")
  }
  let source = to_string_strict(property_get(target, "source"))
  let flags = to_string_strict(property_get(target, "flags"))
  String("/" + source + "/" + flags)
}

///|
fn regexp_species_constructor(rx : Value) -> Value raise {
  let default_ctor = match global_property_value("RegExp") {
    Some(value) => value
    None => new_builtin_value(BuiltinFunction::RegExpConstructor)
  }
  let ctor = property_get(rx, "constructor")
  match ctor {
    Undefined => default_ctor
    _ =>
      if !is_object_like(ctor) {
        throw_type_error("constructor is not an object")
      } else {
        match symbol_species_key() {
          Some(key) =>
            match property_get(ctor, key) {
              Undefined | Null => default_ctor
              species =>
                if !is_constructor_value(species) {
                  throw_type_error("not a constructor")
                } else {
                  species
                }
            }
          None => default_ctor
        }
      }
  }
}

///|
fn regexp_symbol_match_value(rx : Value, input : String) -> Value raise {
  if !is_object_like(rx) {
    return throw_type_error("not an object")
  }
  let flags = to_string_strict(property_get(rx, "flags"))
  let global = string_index_of(flags, "g", 0) >= 0
  if !global {
    return regexp_exec_method(rx, String(input))
  }
  let full_unicode = string_index_of(flags, "u", 0) >= 0 ||
    string_index_of(flags, "v", 0) >= 0
  let _ = property_set(rx, "lastIndex", Number(0.0), true)
  let matches : Array[Value?] = []
  while true {
    let result = regexp_exec_method(rx, String(input))
    match result {
      Null => break
      _ => {
        let matched = to_string_strict(property_get(result, "0"))
        matches.push(Some(String(matched)))
        if matched.is_empty() {
          let last_index_value = property_get(rx, "lastIndex")
          let last_index = to_length_int64(to_number(last_index_value))
          let next_index = advance_string_index_int64(
            input, last_index, full_unicode,
          )
          let _ = property_set(
            rx,
            "lastIndex",
            Number(Int64::to_double(next_index)),
            true,
          )

        }
      }
    }
  }
  if matches.is_empty() {
    Null
  } else {
    new_array_value(matches)
  }
}

///|
fn regexp_symbol_match_all_value(rx : Value, input : String) -> Value raise {
  if !is_object_like(rx) {
    return throw_type_error("not an object")
  }
  let ctor = regexp_species_constructor(rx)
  let flags = to_string_strict(property_get(rx, "flags"))
  let matcher = call_constructor(ctor, [rx, String(flags)])
  let last_index_value = property_get(rx, "lastIndex")
  let last_index = to_length_int64(to_number(last_index_value))
  let _ = property_set(
    matcher,
    "lastIndex",
    Number(Int64::to_double(last_index)),
    true,
  )
  let global = string_index_of(flags, "g", 0) >= 0
  let unicode = string_index_of(flags, "u", 0) >= 0 ||
    string_index_of(flags, "v", 0) >= 0
  new_regexp_string_iterator(matcher, input, global, unicode)
}

///|
fn regexp_symbol_search_value(rx : Value, input : String) -> Value raise {
  if !is_object_like(rx) {
    return throw_type_error("not an object")
  }
  let previous_last_index = property_get(rx, "lastIndex")
  if !same_value(previous_last_index, Number(0.0)) {
    let _ = property_set(rx, "lastIndex", Number(0.0), true)

  }
  let result = regexp_exec_method(rx, String(input))
  let current_last_index = property_get(rx, "lastIndex")
  if !same_value(current_last_index, previous_last_index) {
    let _ = property_set(rx, "lastIndex", previous_last_index, true)

  }
  match result {
    Null => Number(-1.0)
    _ => property_get(result, "index")
  }
}

///|
fn regexp_symbol_replace_value(
  rx : Value,
  input : String,
  replace_value : Value,
) -> Value raise {
  if !is_object_like(rx) {
    return throw_type_error("not an object")
  }
  let functional_replace = is_callable(replace_value)
  let replace_str = if functional_replace {
    ""
  } else {
    to_string_strict(replace_value)
  }
  let flags = to_string_strict(property_get(rx, "flags"))
  let is_global = string_index_of(flags, "g", 0) >= 0
  let full_unicode = string_index_of(flags, "u", 0) >= 0 ||
    string_index_of(flags, "v", 0) >= 0
  if is_global {
    let _ = property_set(rx, "lastIndex", Number(0.0), true)

  }
  let results : Array[Value] = []
  while true {
    let result = regexp_exec_method(rx, String(input))
    match result {
      Null => break
      _ => results.push(result)
    }
    if !is_global {
      break
    }
    let matched = to_string_strict(property_get(result, "0"))
    if matched.is_empty() {
      let last_index_value = property_get(rx, "lastIndex")
      let last_index = to_length_int64(to_number(last_index_value))
      let next_index = advance_string_index_int64(
        input, last_index, full_unicode,
      )
      let _ = property_set(
        rx,
        "lastIndex",
        Number(Int64::to_double(next_index)),
        true,
      )

    }
  }
  if results.is_empty() {
    return String(input)
  }
  let mut next_source_position = 0
  let output = StringBuilder::new()
  for result in results {
    let captures_len = array_like_length(result)
    let matched = to_string_strict(property_get(result, "0"))
    let position_value = property_get(result, "index")
    let mut position = to_length_index(
      to_number(position_value),
      input.length(),
    )
    if position < 0 {
      position = 0
    } else if position > input.length() {
      position = input.length()
    }
    let captures : Array[String?] = []
    captures.push(Some(matched))
    let mut i = 1
    while i < captures_len {
      let cap = property_get(result, Int::to_string(i))
      match cap {
        Undefined => captures.push(None)
        _ => captures.push(Some(to_string_strict(cap)))
      }
      i = i + 1
    }
    let named = property_get(result, "groups")
    let replacement = if functional_replace {
      let args : Array[Value] = []
      for capture in captures {
        match capture {
          Some(text) => args.push(String(text))
          None => args.push(Undefined)
        }
      }
      args.push(Number(Double::from_int(position)))
      args.push(String(input))
      if !(named is Undefined) {
        args.push(named)
      }
      let res = call_value_with_this(replace_value, args, Undefined)
      to_string_strict(res)
    } else {
      let named_captures = if named is Undefined {
        Undefined
      } else {
        to_object(named)
      }
      string_get_substitution(
        matched, input, position, captures, named_captures, replace_str,
      )
    }
    if position >= next_source_position {
      output.write_string(
        input.unsafe_substring(start=next_source_position, end=position),
      )
      output.write_string(replacement)
      next_source_position = position + matched.length()
    }
  }
  output.write_string(
    if next_source_position < input.length() {
      input.unsafe_substring(start=next_source_position, end=input.length())
    } else {
      ""
    },
  )
  String(output.to_string())
}

///|
fn regexp_symbol_split_value(
  rx : Value,
  input : String,
  limit_value : Value,
) -> Value raise {
  if !is_object_like(rx) {
    return throw_type_error("not an object")
  }
  let ctor = regexp_species_constructor(rx)
  let mut flags = to_string_strict(property_get(rx, "flags"))
  let unicode = string_index_of(flags, "u", 0) >= 0 ||
    string_index_of(flags, "v", 0) >= 0
  if string_index_of(flags, "y", 0) < 0 {
    flags = flags + "y"
  }
  let splitter = call_constructor(ctor, [rx, String(flags)])
  let results : Array[Value?] = []
  let lim = if limit_value is Undefined {
    0xffffffffU
  } else {
    to_uint32(to_number(limit_value))
  }
  if lim == 0U {
    return new_array_value(results)
  }
  let size = input.length()
  let mut lengthA : UInt = 0U
  if size == 0 {
    let z = regexp_exec_method(splitter, String(input))
    match z {
      Null => {
        results.push(Some(String(input)))
        lengthA = lengthA + 1U
      }
      _ => ()
    }
    return new_array_value(results)
  }
  let mut p = 0
  let mut q = 0
  while q < size {
    let _ = property_set(
      splitter,
      "lastIndex",
      Number(Double::from_int(q)),
      true,
    )
    let z = regexp_exec_method(splitter, String(input))
    match z {
      Null => q = advance_string_index(input, q, unicode)
      _ => {
        let end_value = property_get(splitter, "lastIndex")
        let mut e = to_length_index(to_number(end_value), input.length())
        if e > size {
          e = size
        }
        if e == p {
          q = advance_string_index(input, q, unicode)
        } else {
          let part = input.unsafe_substring(start=p, end=q)
          results.push(Some(String(part)))
          lengthA = lengthA + 1U
          if lengthA == lim {
            return new_array_value(results)
          }
          p = e
          let captures_len = array_like_length(z)
          let mut i = 1
          while i < captures_len {
            let cap = property_get(z, Int::to_string(i))
            results.push(Some(cap))
            lengthA = lengthA + 1U
            if lengthA == lim {
              return new_array_value(results)
            }
            i = i + 1
          }
          q = p
        }
      }
    }
  }
  if p > size {
    p = size
  }
  if lengthA < lim {
    let tail = input.unsafe_substring(start=p, end=size)
    results.push(Some(String(tail)))
  }
  new_array_value(results)
}

///|
fn parse_int_value(args : Array[Value]) -> Value raise {
  if args.is_empty() {
    return Number(nan())
  }
  let text = to_string_strict(args[0])
  let radix = if args.length() < 2 { 0 } else { to_int32(to_number(args[1])) }
  Number(parse_int_string(text, radix))
}

///|
fn parse_int_string(text : String, radix_arg : Int) -> Double {
  let view = trim_js_whitespace_start(text)
  if view.is_empty() {
    return nan()
  }
  let len = view.length()
  let mut index = 0
  let mut sign = 1.0
  let first = UInt16::to_int(view.code_unit_at(index))
  if first == Char::to_int('+') || first == Char::to_int('-') {
    if first == Char::to_int('-') {
      sign = -1.0
    }
    index = index + 1
  }
  let mut radix = radix_arg
  if radix != 0 && (radix < 2 || radix > 36) {
    return nan()
  }
  if radix == 0 {
    radix = 10
    if index + 1 < len {
      let c0 = UInt16::to_int(view.code_unit_at(index))
      let c1 = UInt16::to_int(view.code_unit_at(index + 1))
      if c0 == Char::to_int('0') &&
        (c1 == Char::to_int('x') || c1 == Char::to_int('X')) {
        radix = 16
        index = index + 2
      }
    }
  } else if radix == 16 {
    if index + 1 < len {
      let c0 = UInt16::to_int(view.code_unit_at(index))
      let c1 = UInt16::to_int(view.code_unit_at(index + 1))
      if c0 == Char::to_int('0') &&
        (c1 == Char::to_int('x') || c1 == Char::to_int('X')) {
        index = index + 2
      }
    }
  }
  let base = Double::from_int(radix)
  let mut value = 0.0
  let mut any = false
  while index < len {
    let code = UInt16::to_int(view.code_unit_at(index))
    let digit = digit_value(code)
    if digit < 0 || digit >= radix {
      break
    }
    value = value * base + Double::from_int(digit)
    any = true
    index = index + 1
  }
  if !any {
    nan()
  } else {
    sign * value
  }
}

///|
fn parse_float_value(args : Array[Value]) -> Value raise {
  if args.is_empty() {
    return Number(nan())
  }
  let text = to_string_strict(args[0])
  Number(parse_float_string(text))
}

///|
fn parse_float_string(text : String) -> Double {
  let view = trim_js_whitespace_start(text)
  if view.is_empty() {
    return nan()
  }
  let len = view.length()
  let mut index = 0
  if len == 0 {
    return nan()
  }
  let first = UInt16::to_int(view.code_unit_at(index))
  if first == Char::to_int('+') || first == Char::to_int('-') {
    index = index + 1
  }
  let tail = view.view(start_offset=index, end_offset=len)
  if tail.has_prefix("Infinity") {
    if first == Char::to_int('-') {
      return 0.0 - inf()
    }
    return inf()
  }
  let mut pos = index
  let mut saw_digit = false
  while pos < len && is_digit_code(UInt16::to_int(view.code_unit_at(pos))) {
    saw_digit = true
    pos = pos + 1
  }
  if pos < len && UInt16::to_int(view.code_unit_at(pos)) == Char::to_int('.') {
    pos = pos + 1
    while pos < len && is_digit_code(UInt16::to_int(view.code_unit_at(pos))) {
      saw_digit = true
      pos = pos + 1
    }
  }
  if !saw_digit {
    return nan()
  }
  let mut end = pos
  if end < len {
    let c = UInt16::to_int(view.code_unit_at(end))
    if c == Char::to_int('e') || c == Char::to_int('E') {
      let mut exp_pos = end + 1
      if exp_pos < len {
        let sign_code = UInt16::to_int(view.code_unit_at(exp_pos))
        if sign_code == Char::to_int('+') || sign_code == Char::to_int('-') {
          exp_pos = exp_pos + 1
        }
      }
      let exp_start = exp_pos
      while exp_pos < len &&
            is_digit_code(UInt16::to_int(view.code_unit_at(exp_pos))) {
        exp_pos = exp_pos + 1
      }
      if exp_pos > exp_start {
        end = exp_pos
      }
    }
  }
  let slice = view.view(start_offset=0, end_offset=end)
  try @strconv.parse_double(slice) catch {
    _ => nan()
  } noraise {
    value => value
  }
}

///|
fn digit_value(code : Int) -> Int {
  if code >= Char::to_int('0') && code <= Char::to_int('9') {
    return code - Char::to_int('0')
  }
  if code >= Char::to_int('a') && code <= Char::to_int('z') {
    return code - Char::to_int('a') + 10
  }
  if code >= Char::to_int('A') && code <= Char::to_int('Z') {
    return code - Char::to_int('A') + 10
  }
  -1
}

///|
fn is_digit_code(code : Int) -> Bool {
  code >= Char::to_int('0') && code <= Char::to_int('9')
}

///|
fn imul(left : Double, right : Double) -> Int {
  let a = to_int32(left)
  let b = to_int32(right)
  let product = Int64::from_int(a) * Int64::from_int(b)
  let two32 = 1L << 32
  let mut n = Int64::mod(product, two32)
  if n < 0L {
    n = n + two32
  }
  if n >= 1L << 31 {
    n = n - two32
  }
  Int64::to_int(n)
}

///|
fn math_hypot(args : Array[Value]) -> Double raise {
  if args.is_empty() {
    return 0.0
  }
  let mut r = 0.0
  let mut has_value = false
  let mut saw_nan = false
  let mut saw_inf = false
  let mut index = 0
  while index < args.length() {
    let value = to_number(args[index])
    if Double::is_inf(value) {
      saw_inf = true
    } else if Double::is_nan(value) {
      saw_nan = true
    } else if !has_value {
      r = Double::abs(value)
      has_value = true
    } else {
      r = @math.hypot(r, value)
    }
    index = index + 1
  }
  if saw_inf {
    inf()
  } else if saw_nan {
    nan()
  } else {
    r
  }
}

///|
fn math_cosh_value(value : Double) -> Double {
  if Double::is_nan(value) {
    return value
  }
  let abs_value = Double::abs(value)
  if Double::is_inf(abs_value) {
    return inf()
  }
  // Use libm-style thresholds to match QuickJS behavior.
  if abs_value < 0.34657359027997264 {
    let t = @math.expm1(abs_value)
    let w = 1.0 + t
    return 1.0 + t * t / (2.0 * w)
  }
  if abs_value < 22.0 {
    let t = @math.exp(abs_value)
    return 0.5 * t + 0.5 / t
  }
  if abs_value < 709.78271289338397 {
    return 0.5 * @math.exp(abs_value)
  }
  if abs_value < 710.4758600739439 {
    let w = @math.exp(0.5 * abs_value)
    return 0.5 * w * w
  }
  inf()
}

///|
fn math_max(args : Array[Value]) -> Double raise {
  if args.is_empty() {
    return 0.0 - inf()
  }
  let mut result = to_number(args[0])
  let mut index = 1
  while index < args.length() {
    let value = to_number(args[index])
    if !Double::is_nan(result) {
      if Double::is_nan(value) {
        result = value
      } else if value > result {
        result = value
      } else if value == 0.0 && result == 0.0 {
        if is_negative_zero(result) && !is_negative_zero(value) {
          result = value
        }
      }
    }
    index = index + 1
  }
  result
}

///|
fn math_min(args : Array[Value]) -> Double raise {
  if args.is_empty() {
    return inf()
  }
  let mut result = to_number(args[0])
  let mut index = 1
  while index < args.length() {
    let value = to_number(args[index])
    if !Double::is_nan(result) {
      if Double::is_nan(value) {
        result = value
      } else if value < result {
        result = value
      } else if value == 0.0 && result == 0.0 {
        if !is_negative_zero(result) && is_negative_zero(value) {
          result = value
        }
      }
    }
    index = index + 1
  }
  result
}

///|
fn math_round_value(num : Double) -> Double {
  let mut bits = Double::reinterpret_as_uint64(num)
  let e = UInt64::to_int((bits >> 52) & 0x7ffUL)
  if e < 1023 {
    if e == 1022 && bits != 0xbfe0000000000000UL {
      bits = (bits & (1UL << 63)) | (1023UL << 52)
    } else {
      bits = bits & (1UL << 63)
    }
    return UInt64::reinterpret_as_double(bits)
  }
  if e < 1023 + 52 {
    let s = bits >> 63
    let shift = 52 - (e - 1023)
    let one = 1UL << shift
    let frac_mask = one - 1UL
    bits = bits + (one >> 1) - s
    bits = bits & UInt64::lnot(frac_mask)
  }
  UInt64::reinterpret_as_double(bits)
}

///|
fn math_trunc_value(num : Double) -> Double {
  if Double::is_nan(num) || Double::is_inf(num) || num == 0.0 {
    return num
  }
  let truncated = Double::trunc(num)
  if truncated == 0.0 && (num < 0.0 || is_negative_zero(num)) {
    negative_zero()
  } else {
    truncated
  }
}

///|
fn math_sign_value(num : Double) -> Double {
  if Double::is_nan(num) {
    return nan()
  }
  if num == 0.0 {
    return if is_negative_zero(num) { negative_zero() } else { 0.0 }
  }
  if num > 0.0 {
    1.0
  } else {
    -1.0
  }
}

///|
fn math_clz32_value(num : Double) -> Int {
  let value = UInt::land(to_uint32(num), 0xffffffffU)
  if value == 0U {
    return 32
  }
  let mut count = 0
  let mut mask = 0x80000000U
  while UInt::land(value, mask) == 0U {
    count = count + 1
    mask = mask >> 1
  }
  count
}

///|
fn math_random_value() -> Double {
  let mut value = 0.0
  let mask = (1UL << 53) - 1UL
  let denom = Double::convert_uint64(1UL << 53)
  math_rand_state_ref.update(fn(state) {
    let next = state * 6364136223846793005UL + 1UL
    let mantissa = (next >> 11) & mask
    value = Double::convert_uint64(mantissa) / denom
    next
  })
  value
}

///|
fn math_f16round_value(num : Double) -> Double {
  let bits = double_to_float16_bits(num)
  float16_bits_to_double(bits)
}

///|
priv enum SumPreciseStateEnum {
  Finite
  Infinity
  MinusInfinity
  Nan
} derive(Eq)

///|
priv struct SumPreciseState {
  mut state : SumPreciseStateEnum
  mut counter : Int
  mut n_limbs : Int
  acc : Array[Int64]
}

///|
let sp_limb_bits : Int = 56

///|
let sp_rnd_bits : Int = sp_limb_bits - 53

///|
let sum_precise_acc_len : Int = 39

///|
let sum_precise_counter_init : Int = 250

///|
let sp_limb_mask_u64 : UInt64 = (1UL << sp_limb_bits) - 1UL

///|
let sp_limb_mask_i64 : Int64 = (1L << sp_limb_bits) - 1L

///|
fn sum_precise_init() -> SumPreciseState {
  SumPreciseState::{
    state: SumPreciseStateEnum::Finite,
    counter: sum_precise_counter_init,
    n_limbs: 0,
    acc: Array::make(sum_precise_acc_len, 0L),
  }
}

///|
fn sum_precise_renorm(state : SumPreciseState) -> Unit {
  let mut carry : Int64 = 0L
  let mut i = 0
  while i < state.n_limbs {
    let v = state.acc[i] + carry
    state.acc[i] = Int64::land(v, sp_limb_mask_i64)
    carry = v >> sp_limb_bits
    i = i + 1
  }
  if carry != 0L && state.n_limbs < sum_precise_acc_len {
    state.acc[state.n_limbs] = carry
    state.n_limbs = state.n_limbs + 1
  }
}

///|
fn sum_precise_add(state : SumPreciseState, value : Double) -> Unit {
  let bits = Double::reinterpret_as_uint64(value)
  let sgn = bits >> 63 != 0UL
  let e = UInt64::to_int((bits >> 52) & 0x7ffUL)
  let mut m = bits & ((1UL << 52) - 1UL)
  if e == 2047 {
    if m == 0UL {
      if state.state == SumPreciseStateEnum::Nan ||
        (state.state == SumPreciseStateEnum::MinusInfinity && !sgn) ||
        (state.state == SumPreciseStateEnum::Infinity && sgn) {
        state.state = SumPreciseStateEnum::Nan
      } else {
        state.state = if sgn {
          SumPreciseStateEnum::MinusInfinity
        } else {
          SumPreciseStateEnum::Infinity
        }
      }
    } else {
      state.state = SumPreciseStateEnum::Nan
    }
    return
  }
  let mut shift : Int = 0
  let mut p : Int = 0
  if e == 0 {
    if m == 0UL {
      if state.n_limbs == 0 && !sgn {
        state.n_limbs = 1
      }
      return
    }
  } else {
    m = m | (1UL << 52)
    shift = e - 1
    p = shift / sp_limb_bits
    shift = shift % sp_limb_bits
  }
  let a0 = (m << shift) & sp_limb_mask_u64
  let a1 = m >> (sp_limb_bits - shift)
  let a0_i = a0.reinterpret_as_int64()
  let a1_i = a1.reinterpret_as_int64()
  if !sgn {
    state.acc[p] = state.acc[p] + a0_i
    state.acc[p + 1] = state.acc[p + 1] + a1_i
  } else {
    state.acc[p] = state.acc[p] - a0_i
    state.acc[p + 1] = state.acc[p + 1] - a1_i
  }
  state.n_limbs = Int::max(state.n_limbs, p + 2)
  state.counter = state.counter - 1
  if state.counter == 0 {
    state.counter = sum_precise_counter_init
    sum_precise_renorm(state)
  }
}

///|
fn sum_precise_get_result(state : SumPreciseState) -> Double {
  match state.state {
    SumPreciseStateEnum::Finite => ()
    SumPreciseStateEnum::Infinity => return inf()
    SumPreciseStateEnum::MinusInfinity => return -inf()
    SumPreciseStateEnum::Nan => return nan()
  }
  sum_precise_renorm(state)
  let mut n = state.n_limbs
  if n == 0 {
    return -0.0
  }
  while n > 0 && state.acc[n - 1] == 0L {
    n = n - 1
  }
  if n == 0 {
    return 0.0
  }
  let is_neg = state.acc[n - 1] < 0L
  if is_neg {
    let mut carry : Int64 = 1L
    let mut i = 0
    while i < n - 1 {
      let v = sp_limb_mask_i64 - state.acc[i] + carry
      state.acc[i] = Int64::land(v, sp_limb_mask_i64)
      carry = v >> sp_limb_bits
      i = i + 1
    }
    state.acc[n - 1] = -state.acc[n - 1] + carry - 1L
    while n > 1 && state.acc[n - 1] == 0L {
      n = n - 1
    }
  }
  if n == 1 && state.acc[0] < 1L << 52 {
    let sign_bit = if is_neg { 1UL << 63 } else { 0UL }
    let mantissa = state.acc[0].reinterpret_as_uint64()
    return UInt64::reinterpret_as_double(sign_bit | mantissa)
  }
  let mut e = n * sp_limb_bits
  let mut p = n - 1
  let mut m = state.acc[p].reinterpret_as_uint64()
  let shift = m.clz() - (64 - sp_limb_bits)
  e = e - shift - 52
  if shift != 0 {
    m = m << shift
    if p > 0 {
      p = p - 1
      let shift1 = sp_limb_bits - shift
      let prev = state.acc[p].reinterpret_as_uint64()
      let nz = prev & ((1UL << shift1) - 1UL)
      let sticky = if nz != 0UL { 1UL } else { 0UL }
      m = m | (prev >> shift1) | sticky
    }
  }
  if (m & ((1UL << sp_rnd_bits) - 1UL)) == 1UL << (sp_rnd_bits - 1) {
    while p > 0 {
      p = p - 1
      if state.acc[p] != 0L {
        m = m | 1UL
        break
      }
    }
  }
  let addend = (1UL << (sp_rnd_bits - 1)) - 1UL + ((m >> sp_rnd_bits) & 1UL)
  m = (m + addend) >> sp_rnd_bits
  if m == 1UL << 53 {
    e = e + 1
  }
  let sign_bit = if is_neg { 1UL << 63 } else { 0UL }
  if e >= 2047 {
    return UInt64::reinterpret_as_double(sign_bit | (2047UL << 52))
  }
  let exp_bits = Int::to_uint64(e) << 52
  let mantissa = m & ((1UL << 52) - 1UL)
  UInt64::reinterpret_as_double(sign_bit | exp_bits | mantissa)
}

///|
fn math_sum_precise(args : Array[Value]) -> Value raise {
  let value = if args.is_empty() { Undefined } else { args[0] }
  let (iterator, next_method) = get_iterator_from_value(value)
  let state = sum_precise_init()
  while true {
    let (done, item) = iterator_step_value(iterator, next_method)
    if done {
      break
    }
    match item {
      Number(value) => sum_precise_add(state, value)
      _ => {
        let _ = iterator_close_on_error(iterator)
        return throw_type_error("not a number")
      }
    }
  }
  Number(sum_precise_get_result(state))
}
